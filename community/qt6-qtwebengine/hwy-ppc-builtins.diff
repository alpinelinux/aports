These builtins were renamed in GCC in commit
https://github.com/gcc-mirror/gcc/commit/b620845fff7d38bca3b79ca9f5a5d049eba9e7f8

--

diff --git a/src/3rdparty/chromium/third_party/highway/src/hwy/ops/ppc_vsx-inl.h b/src/3rdparty/chromium/third_party/highway/src/hwy/ops/ppc_vsx-inl.h
index d216c54..10fb624 100644
--- a/src/3rdparty/chromium/third_party/highway/src/hwy/ops/ppc_vsx-inl.h
+++ b/src/3rdparty/chromium/third_party/highway/src/hwy/ops/ppc_vsx-inl.h
@@ -3707,10 +3707,10 @@ static HWY_INLINE V VsxF2INormalizeSrcVals(V v) {
 template <class D, HWY_IF_I64_D(D)>
 HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspsxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsignede_v4sf))
   const __vector float raw_v =
       detail::VsxF2INormalizeSrcVals(InterleaveLower(v, v)).raw;
-  return VFromD<decltype(di64)>{__builtin_vsx_xvcvspsxds(raw_v)};
+  return VFromD<decltype(di64)>{__builtin_vsignede_v4sf(raw_v)};
 #else
   const RebindToFloat<decltype(di64)> df64;
   return ConvertTo(di64, PromoteTo(df64, v));
@@ -3720,11 +3720,11 @@ HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {
 template <class D, HWY_IF_U64_D(D)>
 HWY_API VFromD<D> PromoteTo(D du64, VFromD<Rebind<float, D>> v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspuxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vunsignede_v4sf))
   const __vector float raw_v =
       detail::VsxF2INormalizeSrcVals(InterleaveLower(v, v)).raw;
   return VFromD<decltype(du64)>{reinterpret_cast<__vector unsigned long long>(
-      __builtin_vsx_xvcvspuxds(raw_v))};
+      __builtin_vunsignede_v4sf(raw_v))};
 #else
   const RebindToFloat<decltype(du64)> df64;
   return ConvertTo(du64, PromoteTo(df64, v));
@@ -3830,11 +3830,11 @@ HWY_API VFromD<D> PromoteUpperTo(D df64, Vec128<uint32_t> v) {
 template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_I64_D(D)>
 HWY_API VFromD<D> PromoteUpperTo(D di64, Vec128<float> v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspsxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsignede_v4sf))
   const __vector float raw_v =
       detail::VsxF2INormalizeSrcVals(InterleaveUpper(Full128<float>(), v, v))
           .raw;
-  return VFromD<decltype(di64)>{__builtin_vsx_xvcvspsxds(raw_v)};
+  return VFromD<decltype(di64)>{__builtin_vsignede_v4sf(raw_v)};
 #else
   const RebindToFloat<decltype(di64)> df64;
   return ConvertTo(di64, PromoteUpperTo(df64, v));
@@ -3844,12 +3844,12 @@ HWY_API VFromD<D> PromoteUpperTo(D di64, Vec128<float> v) {
 template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_U64_D(D)>
 HWY_API VFromD<D> PromoteUpperTo(D du64, Vec128<float> v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspuxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vunsignede_v4sf))
   const __vector float raw_v =
       detail::VsxF2INormalizeSrcVals(InterleaveUpper(Full128<float>(), v, v))
           .raw;
   return VFromD<decltype(du64)>{reinterpret_cast<__vector unsigned long long>(
-      __builtin_vsx_xvcvspuxds(raw_v))};
+      __builtin_vunsignede_v4sf(raw_v))};
 #else
   const RebindToFloat<decltype(du64)> df64;
   return ConvertTo(du64, PromoteUpperTo(df64, v));
@@ -3938,19 +3938,19 @@ HWY_INLINE VFromD<D> PromoteEvenTo(hwy::SignedTag /*to_type_tag*/,
                                    hwy::FloatTag /*from_type_tag*/, D d_to,
                                    V v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspsxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsignede_v4sf))
   (void)d_to;
   const auto normalized_v = detail::VsxF2INormalizeSrcVals(v);
 #if HWY_IS_LITTLE_ENDIAN
-  // __builtin_vsx_xvcvspsxds expects the source values to be in the odd lanes
+  // __builtin_vsignede_v4sf expects the source values to be in the odd lanes
   // on little-endian PPC, and the vec_sld operation below will shift the even
   // lanes of normalized_v into the odd lanes.
   return VFromD<D>{
-      __builtin_vsx_xvcvspsxds(vec_sld(normalized_v.raw, normalized_v.raw, 4))};
+      __builtin_vsignede_v4sf(vec_sld(normalized_v.raw, normalized_v.raw, 4))};
 #else
-  // __builtin_vsx_xvcvspsxds expects the source values to be in the even lanes
+  // __builtin_vsignede_v4sf expects the source values to be in the even lanes
   // on big-endian PPC.
-  return VFromD<D>{__builtin_vsx_xvcvspsxds(normalized_v.raw)};
+  return VFromD<D>{__builtin_vsignede_v4sf(normalized_v.raw)};
 #endif
 #else
   const RebindToFloat<decltype(d_to)> df64;
@@ -3966,21 +3966,21 @@ HWY_INLINE VFromD<D> PromoteEvenTo(hwy::UnsignedTag /*to_type_tag*/,
                                    hwy::FloatTag /*from_type_tag*/, D d_to,
                                    V v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspuxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vunsignede_v4sf))
   (void)d_to;
   const auto normalized_v = detail::VsxF2INormalizeSrcVals(v);
 #if HWY_IS_LITTLE_ENDIAN
-  // __builtin_vsx_xvcvspuxds expects the source values to be in the odd lanes
+  // __builtin_vunsignede_v4sf expects the source values to be in the odd lanes
   // on little-endian PPC, and the vec_sld operation below will shift the even
   // lanes of normalized_v into the odd lanes.
   return VFromD<D>{
-      reinterpret_cast<__vector unsigned long long>(__builtin_vsx_xvcvspuxds(
+      reinterpret_cast<__vector unsigned long long>(__builtin_vunsignede_v4sf(
           vec_sld(normalized_v.raw, normalized_v.raw, 4)))};
 #else
-  // __builtin_vsx_xvcvspuxds expects the source values to be in the even lanes
+  // __builtin_vunsignede_v4sf expects the source values to be in the even lanes
   // on big-endian PPC.
   return VFromD<D>{reinterpret_cast<__vector unsigned long long>(
-      __builtin_vsx_xvcvspuxds(normalized_v.raw))};
+      __builtin_vunsignede_v4sf(normalized_v.raw))};
 #endif
 #else
   const RebindToFloat<decltype(d_to)> df64;
@@ -4023,19 +4023,19 @@ HWY_INLINE VFromD<D> PromoteOddTo(hwy::SignedTag /*to_type_tag*/,
                                   hwy::FloatTag /*from_type_tag*/, D d_to,
                                   V v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspsxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsignede_v4sf))
   (void)d_to;
   const auto normalized_v = detail::VsxF2INormalizeSrcVals(v);
 #if HWY_IS_LITTLE_ENDIAN
-  // __builtin_vsx_xvcvspsxds expects the source values to be in the odd lanes
+  // __builtin_vsignede_v4sf expects the source values to be in the odd lanes
   // on little-endian PPC
-  return VFromD<D>{__builtin_vsx_xvcvspsxds(normalized_v.raw)};
+  return VFromD<D>{__builtin_vsignede_v4sf(normalized_v.raw)};
 #else
-  // __builtin_vsx_xvcvspsxds expects the source values to be in the even lanes
+  // __builtin_vsignede_v4sf expects the source values to be in the even lanes
   // on big-endian PPC, and the vec_sld operation below will shift the odd lanes
   // of normalized_v into the even lanes.
   return VFromD<D>{
-      __builtin_vsx_xvcvspsxds(vec_sld(normalized_v.raw, normalized_v.raw, 4))};
+      __builtin_vsignede_v4sf(vec_sld(normalized_v.raw, normalized_v.raw, 4))};
 #endif
 #else
   const RebindToFloat<decltype(d_to)> df64;
@@ -4051,20 +4051,20 @@ HWY_INLINE VFromD<D> PromoteOddTo(hwy::UnsignedTag /*to_type_tag*/,
                                   hwy::FloatTag /*from_type_tag*/, D d_to,
                                   V v) {
 #if !HWY_S390X_HAVE_Z14 && \
-    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vsx_xvcvspuxds))
+    (HWY_COMPILER_GCC_ACTUAL || HWY_HAS_BUILTIN(__builtin_vunsignede_v4sf))
   (void)d_to;
   const auto normalized_v = detail::VsxF2INormalizeSrcVals(v);
 #if HWY_IS_LITTLE_ENDIAN
-  // __builtin_vsx_xvcvspuxds expects the source values to be in the odd lanes
+  // __builtin_vunsignede_v4sf expects the source values to be in the odd lanes
   // on little-endian PPC
   return VFromD<D>{reinterpret_cast<__vector unsigned long long>(
-      __builtin_vsx_xvcvspuxds(normalized_v.raw))};
+      __builtin_vunsignede_v4sf(normalized_v.raw))};
 #else
-  // __builtin_vsx_xvcvspuxds expects the source values to be in the even lanes
+  // __builtin_vunsignede_v4sf expects the source values to be in the even lanes
   // on big-endian PPC, and the vec_sld operation below will shift the odd lanes
   // of normalized_v into the even lanes.
   return VFromD<D>{
-      reinterpret_cast<__vector unsigned long long>(__builtin_vsx_xvcvspuxds(
+      reinterpret_cast<__vector unsigned long long>(__builtin_vunsignede_v4sf(
           vec_sld(normalized_v.raw, normalized_v.raw, 4)))};
 #endif
 #else
-- 
2.52.0

