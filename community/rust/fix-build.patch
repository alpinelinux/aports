diff --git a/src/bootstrap/flags.rs b/src/bootstrap/flags.rs
index 56cbb4cecf2a..dc9dac736278 100644
--- a/src/bootstrap/flags.rs
+++ b/src/bootstrap/flags.rs
@@ -242,11 +242,18 @@ Arguments:
         let cwd = t!(env::current_dir());
         let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();
 
+        let cfg_file = matches.opt_str("config").map(PathBuf::from).or_else(|| {
+            if fs::metadata("config.toml").is_ok() {
+                Some(PathBuf::from("config.toml"))
+            } else {
+                None
+            }
+        });
 
         // All subcommands can have an optional "Available paths" section
         if matches.opt_present("verbose") {
             let flags = Flags::parse(&["build".to_string()]);
-            let mut config = Config::default();
+            let mut config = Config::parse(&flags.build, cfg_file.clone());
             config.build = flags.build.clone();
             let mut build = Build::new(flags, config);
             metadata::build(&mut build);
@@ -307,14 +314,6 @@ Arguments:
         };
 
 
-        let cfg_file = matches.opt_str("config").map(PathBuf::from).or_else(|| {
-            if fs::metadata("config.toml").is_ok() {
-                Some(PathBuf::from("config.toml"))
-            } else {
-                None
-            }
-        });
-
         let mut stage = matches.opt_str("stage").map(|j| j.parse().unwrap());
 
         if matches.opt_present("incremental") {
diff --git a/src/bootstrap/bin/main.rs b/src/bootstrap/bin/main.rs
index 5ca5ce1648f2..5ef18b89841f 100644
--- a/src/bootstrap/bin/main.rs
+++ b/src/bootstrap/bin/main.rs
@@ -26,12 +26,6 @@ use bootstrap::{Flags, Config, Build};
 fn main() {
     let args = env::args().skip(1).collect::<Vec<_>>();
     let flags = Flags::parse(&args);
-    let mut config = Config::parse(&flags.build, flags.config.clone());
-
-    // compat with `./configure` while we're still using that
-    if std::fs::metadata("config.mk").is_ok() {
-        config.update_with_config_mk();
-    }
-
+    let config = Config::parse(&flags.build, flags.config.clone());
     Build::new(flags, config).build();
 }
diff --git a/src/bootstrap/config.rs b/src/bootstrap/config.rs
index fd8aa320fb3d..902cd0997a8e 100644
--- a/src/bootstrap/config.rs
+++ b/src/bootstrap/config.rs
@@ -15,7 +15,7 @@
 
 use std::collections::HashMap;
 use std::env;
-use std::fs::File;
+use std::fs::{self, File};
 use std::io::prelude::*;
 use std::path::PathBuf;
 use std::process;
@@ -410,6 +410,12 @@ impl Config {
             set(&mut config.rust_dist_src, t.src_tarball);
         }
 
+
+        // compat with `./configure` while we're still using that
+        if fs::metadata("config.mk").is_ok() {
+            config.update_with_config_mk();
+        }
+
         return config
     }
 
@@ -418,7 +424,7 @@ impl Config {
     /// While we still have `./configure` this implements the ability to decode
     /// that configuration into this. This isn't exactly a full-blown makefile
     /// parser, but hey it gets the job done!
-    pub fn update_with_config_mk(&mut self) {
+    fn update_with_config_mk(&mut self) {
         let mut config = String::new();
         File::open("config.mk").unwrap().read_to_string(&mut config).unwrap();
         for line in config.lines() {
