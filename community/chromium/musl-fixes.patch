--- ./third_party/lss/linux_syscall_support.h.orig
+++ ./third_party/lss/linux_syscall_support.h
@@ -1127,6 +1127,12 @@
 #ifndef __NR_fallocate
 #define __NR_fallocate          285
 #endif
+
+#undef __NR_pread
+#define __NR_pread __NR_pread64
+#undef __NR_pwrite
+#define __NR_pwrite __NR_pwrite64
+
 /* End of x86-64 definitions                                                 */
 #elif defined(__mips__)
 #if _MIPS_SIM == _MIPS_SIM_ABI32
--- ./sandbox/linux/suid/process_util.h.orig
+++ ./sandbox/linux/suid/process_util.h
@@ -11,6 +11,14 @@
 #include <stdbool.h>
 #include <sys/types.h>
 
+// Some additional functions
+# define TEMP_FAILURE_RETRY(expression) \
+	(__extension__			\
+	 ({ long int __result;		\
+	  do __result = (long int) (expression); \
+	  while (__result == -1L && errno == EINTR); \
+	  __result; }))
+
 // This adjusts /proc/process/oom_score_adj so the Linux OOM killer
 // will prefer certain process types over others. The range for the
 // adjustment is [-1000, 1000], with [0, 1000] being user accessible.
--- ./sandbox/linux/seccomp-bpf/trap.cc.orig
+++ ./sandbox/linux/seccomp-bpf/trap.cc
@@ -156,7 +156,7 @@
   // most versions of glibc don't include this information in siginfo_t. So,
   // we need to explicitly copy it into a arch_sigsys structure.
   struct arch_sigsys sigsys;
-  memcpy(&sigsys, &info->_sifields, sizeof(sigsys));
+  memcpy(&sigsys, &info->__si_fields, sizeof(sigsys));
 
 #if defined(__mips__)
   // When indirect syscall (syscall(__NR_foo, ...)) is made on Mips, the
--- ./third_party/ffmpeg/libavutil/cpu.c.orig
+++ ./third_party/ffmpeg/libavutil/cpu.c
@@ -38,7 +38,6 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
-#include <sys/sysctl.h>
 #endif
 #if HAVE_UNISTD_H
 #include <unistd.h>
diff --git a/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc b/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
index 9067e84..1c47b2a 100644
--- chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
+++ chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
@@ -39,7 +39,9 @@
 #endif  // defined(OS_ANDROID) && defined(__arm__)
 
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(__GLIBC__)
 #include <gnu/libc-version.h>
+#endif
 
 #include "base/linux_util.h"
 #include "base/strings/string_split.h"
@@ -295,7 +297,7 @@ void RecordLinuxDistro() {
 #endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
 
 void RecordLinuxGlibcVersion() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(__GLIBC__) && !defined(OS_CHROMEOS)
   base::Version version(gnu_get_libc_version());
 
   UMALinuxGlibcVersion glibc_version_result = UMA_LINUX_GLIBC_NOT_PARSEABLE;
--- ./device/serial/serial_io_handler_posix.cc.orig
+++ ./device/serial/serial_io_handler_posix.cc
@@ -6,6 +6,7 @@
 
 #include <sys/ioctl.h>
 #include <termios.h>
+#include <asm-generic/ioctls.h>
 
 #include "base/posix/eintr_wrapper.h"
 
diff --git a/third_party/ots/include/opentype-sanitiser.h b/third_party/ots/include/opentype-sanitiser.h
index a80ea16..55a2abf 100644
--- third_party/ots/include/opentype-sanitiser.h
+++ third_party/ots/include/opentype-sanitiser.h
@@ -20,6 +20,7 @@ typedef unsigned __int64 uint64_t;
 #define htonl(x) _byteswap_ulong (x)
 #define htons(x) _byteswap_ushort (x)
 #else
+#include <sys/types.h>
 #include <arpa/inet.h>
 #include <stdint.h>
 #endif
--- ./base/logging.cc.orig
+++ ./base/logging.cc
@@ -545,8 +545,7 @@
 
 LogMessage::~LogMessage() {
   size_t stack_start = stream_.tellp();
-#if !defined(OFFICIAL_BUILD) && !defined(OS_NACL) && !defined(__UCLIBC__) && \
-    !defined(OS_AIX)
+#if !defined(OFFICIAL_BUILD) && !defined(OS_NACL) && defined(__GLIBC__)
   if (severity_ == LOG_FATAL && !base::debug::BeingDebugged()) {
     // Include a stack trace on a fatal, unless a debugger is attached.
     base::debug::StackTrace trace;
--- ./net/dns/dns_config_service_posix.cc.orig
+++ ./net/dns/dns_config_service_posix.cc
@@ -122,7 +122,7 @@
   ConfigParsePosixResult result;
   config->unhandled_options = false;
 // TODO(fuchsia): Use res_ninit() when it's implemented on Fuchsia.
-#if defined(OS_OPENBSD) || defined(OS_FUCHSIA)
+#if defined(OS_OPENBSD) || defined(OS_FUCHSIA) || defined(_GNU_SOURCE)
   // Note: res_ninit in glibc always returns 0 and sets RES_INIT.
   // res_init behaves the same way.
   memset(&_res, 0, sizeof(_res));
--- base/native_library_posix.cc.orig  2016-11-17 01:45:50.032002326 +0100
+++ base/native_library_posix.cc       2016-11-17 01:46:23.729001549 +0100
@@ -12,6 +12,10 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/thread_restrictions.h"

+#ifndef RTLD_DEEPBIND
+#define RTLD_DEEPBIND 0
+#endif
+
 namespace base {

 std::string NativeLibraryLoadError::ToString() const {
diff --git ./third_party/blink/renderer/platform/wtf/stack_util.cc b/third_party/blink/renderer/platform/wtf/stack_util.cc
index 10f1c0d..8e86a2e 100644
--- ./third_party/blink/renderer/platform/wtf/stack_util.cc
+++ ./third_party/blink/renderer/platform/wtf/stack_util.cc
@@ -28,7 +28,7 @@ size_t GetUnderestimatedStackSize() {
 // FIXME: On Mac OSX and Linux, this method cannot estimate stack size
 // correctly for the main thread.
 
-#if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
     defined(OS_FUCHSIA)
   // pthread_getattr_np() can fail if the thread is not invoked by
   // pthread_create() (e.g., the main thread of webkit_unit_tests).
@@ -96,7 +96,7 @@ size_t GetUnderestimatedStackSize() {
 }
 
 void* GetStackStart() {
-#if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
     defined(OS_FUCHSIA)
   pthread_attr_t attr;
   int error;
--- third_party/lss/linux_syscall_support.h.orig
+++ third_party/lss/linux_syscall_support.h
@@ -132,15 +132,18 @@
 
 /* The Android NDK's <sys/stat.h> #defines these macros as aliases
  * to their non-64 counterparts. To avoid naming conflict, remove them. */
-#ifdef __ANDROID__
+#if defined(fstat64)
   /* These are restored by the corresponding #pragma pop_macro near
    * the end of this file. */
 # pragma push_macro("stat64")
 # pragma push_macro("fstat64")
+# pragma push_macro("fstatat64")
 # pragma push_macro("lstat64")
 # undef stat64
 # undef fstat64
+# undef fstatat64
 # undef lstat64
+# define __RESTORE_MACRO 1
 #endif
 
 #if defined(__ANDROID__) && defined(__x86_64__)
@@ -4545,12 +4548,14 @@
 # endif
 #endif
 
-#ifdef __ANDROID__
+#ifdef __RESTORE_MACRO
   /* These restore the original values of these macros saved by the
    * corresponding #pragma push_macro near the top of this file. */
 # pragma pop_macro("stat64")
 # pragma pop_macro("fstat64")
+# pragma pop_macro("fstatat64")
 # pragma pop_macro("lstat64")
+#undef __RESTORE_MACRO
 #endif
 
 #if defined(__cplusplus) && !defined(SYS_CPLUSPLUS)
--- third_party/crashpad/crashpad/util/linux/ptracer.cc.orig
+++ third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -28,6 +28,9 @@
 #include <asm/ldt.h>
 #include <asm/ptrace-abi.h>
 #endif
+#if defined(ARCH_CPU_ARM_FAMILY)
+#include <asm/ptrace.h>
+#endif
 
 namespace crashpad {
 
--- third_party/crashpad/crashpad/util/linux/thread_info.h.orig
+++ third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -232,7 +232,7 @@
                 "Size mismatch");
 #elif defined(ARCH_CPU_ARMEL)
   static_assert(sizeof(f32_t::fpregs) == sizeof(user_fpregs), "Size mismatch");
-#if !defined(__GLIBC__)
+#if !defined(__linux__)
   static_assert(sizeof(f32_t::vfp) == sizeof(user_vfp), "Size mismatch");
 #endif
 #elif defined(ARCH_CPU_ARM64)
