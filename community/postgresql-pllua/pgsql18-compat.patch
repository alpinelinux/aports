Patch-Source: https://github.com/pllua/pllua/pull/16
--
From bb2f44b542e650ddd250e4e27c73e86aadb09dde Mon Sep 17 00:00:00 2001
From: Christoph Berg <myon@debian.org>
Date: Mon, 28 Apr 2025 12:17:44 +0200
Subject: [PATCH] Support PG18's pg_noreturn

PG18 renames pg_attribute_noreturn() to pg_noreturn. To support both, mark
definitions with both, and #define the other one away.
---
 src/pllua.h | 24 +++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/src/pllua.h b/src/pllua.h
index c684d7d..7735a23 100644
--- a/src/pllua.h
+++ b/src/pllua.h
@@ -54,10 +54,16 @@
 #define FALLTHROUGH /* FALLTHROUGH */
 #endif
 
-LUA_API int   (lua_error) (lua_State *L) pg_attribute_noreturn();
-LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg) pg_attribute_noreturn();
-LUALIB_API int (luaL_typeerror) (lua_State *L, int arg, const char *tname) pg_attribute_noreturn();
-LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...) pg_attribute_noreturn();
+#if PG_VERSION_NUM >= 180000
+#define pg_attribute_noreturn()
+#else
+#define pg_noreturn
+#endif
+
+pg_noreturn LUA_API int   (lua_error) (lua_State *L) pg_attribute_noreturn();
+pg_noreturn LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg) pg_attribute_noreturn();
+pg_noreturn LUALIB_API int (luaL_typeerror) (lua_State *L, int arg, const char *tname) pg_attribute_noreturn();
+pg_noreturn LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...) pg_attribute_noreturn();
 
 /*
  * Define how we want to handle int8 values.
@@ -115,7 +121,7 @@ extern bool pllua_pending_error;
 #define ASSERT_PG_CONTEXT Assert(pllua_context == PLLUA_CONTEXT_PG)
 #define ASSERT_LUA_CONTEXT Assert(pllua_context == PLLUA_CONTEXT_LUA)
 
-void pllua_pending_error_violation(lua_State *L) pg_attribute_noreturn();
+pg_noreturn void pllua_pending_error_violation(lua_State *L) pg_attribute_noreturn();
 
 static inline pllua_context_type
 pllua_setcontext(lua_State *L, pllua_context_type newctx)
@@ -621,7 +627,7 @@ int pllua_open_print(lua_State *L);
 
 int pllua_p_print (lua_State *L);
 void pllua_debug_lua(lua_State *L, const char *msg, ...) pg_attribute_printf(2, 3);
-void pllua_error(lua_State *L, const char *msg, ...) pg_attribute_noreturn();
+pg_noreturn void pllua_error(lua_State *L, const char *msg, ...) pg_attribute_noreturn();
 void pllua_warning(lua_State *L, const char *msg, ...) pg_attribute_printf(2, 3);
 void pllua_error_callback(void *arg);
 int pllua_error_callback_location(lua_State *L);
@@ -638,10 +644,10 @@ int pllua_panic(lua_State *L);
 int pllua_newerror(lua_State *L);
 int pllua_register_error(lua_State *L);
 void pllua_poperror(lua_State *L);
-void pllua_rethrow_from_lua(lua_State *L, int rc) pg_attribute_noreturn();
+pg_noreturn void pllua_rethrow_from_lua(lua_State *L, int rc) pg_attribute_noreturn();
 
 /* These are DLLEXPORT so that transform modules can get at them */
-PGDLLEXPORT void pllua_rethrow_from_pg(lua_State *L, MemoryContext mcxt) pg_attribute_noreturn();
+pg_noreturn PGDLLEXPORT void pllua_rethrow_from_pg(lua_State *L, MemoryContext mcxt) pg_attribute_noreturn();
 PGDLLEXPORT int pllua_pcall_nothrow(lua_State *L, int nargs, int nresults, int msgh);
 PGDLLEXPORT int pllua_cpcall(lua_State *L, lua_CFunction func, void* arg);
 PGDLLEXPORT void pllua_pcall(lua_State *L, int nargs, int nresults, int msgh);
@@ -688,7 +694,7 @@ void **pllua_newrefobject(lua_State *L, char *objtype, void *value, bool userval
 void **pllua_torefobject(lua_State *L, int nd, char *objtype);
 void *pllua_newobject(lua_State *L, char *objtype, size_t sz, bool uservalue);
 void *pllua_toobject(lua_State *L, int nd, char *objtype);
-void pllua_type_error(lua_State *L, char *expected) pg_attribute_noreturn();
+pg_noreturn void pllua_type_error(lua_State *L, char *expected) pg_attribute_noreturn();
 void **pllua_checkrefobject(lua_State *L, int nd, char *objtype);
 void *pllua_checkobject(lua_State *L, int nd, char *objtype);
 
