From 6bb87ff30e4bf00bb3086ee0657af0145810f2de Mon Sep 17 00:00:00 2001
From: John Zimmermann <me@johnnynator.dev>
Date: Sun, 9 Nov 2025 22:33:13 +0100
Subject: [PATCH] bitap: allocate patternMask on heap instead of stack

the current code results in a stackoverflow on systems
with smaller default stack size than glibc (e.g. musl)

BUG: 511233
---
 runners/services/bitap.h | 16 +++++++++-------
 1 file changed, 9 insertions(+), 7 deletions(-)

diff --git a/runners/services/bitap.h b/runners/services/bitap.h
index 1981878361d..be697a1316b 100644
--- a/runners/services/bitap.h
+++ b/runners/services/bitap.h
@@ -4,6 +4,7 @@
 #pragma once
 
 #include <bitset>
+#include <memory>
 #include <optional>
 
 #include <QDebug>
@@ -62,25 +63,26 @@ inline std::optional<Match> bitap(const QStringView &name, const QStringView &pa
     // With hammingDistance >= pattern.length(), it would always match by changing the entire pattern, so clamp it.
     hammingDistance = std::min(hammingDistance, int(pattern.length() - 1));
 
-    const PatternMask patternMask = [&pattern, &name] {
-        PatternMask patternMask;
+    // allocate on heap to prevent stackoverflow on musl libc (patternMask ~512k size, musl stack 128k)
+    std::unique_ptr<const PatternMask> patternMask = [&pattern, &name] {
+        auto patternMask = std::make_unique<PatternMask>();
         // The following is an optimized version of patternMask.fill(Mask().set()); to set all **necessary** bits to 1.
         for (const auto &qchar : pattern) {
-            patternMask.at(qchar.unicode()).set();
+            patternMask->at(qchar.unicode()).set();
         }
         for (const auto &qchar : name) {
-            patternMask.at(qchar.unicode()).set();
+            patternMask->at(qchar.unicode()).set();
         }
 
         for (int i = 0; i < pattern.size(); ++i) {
             const auto char_ = pattern.at(i).unicode();
-            patternMask.at(char_).reset(i); // unset the relevant index bits
+            patternMask->at(char_).reset(i); // unset the relevant index bits
         }
 
         if (BITAP().isDebugEnabled()) {
             for (const auto &i : pattern) {
                 const auto char_ = i.unicode();
-                qCDebug(BITAP) << "Pattern mask for" << char_ << "is" << patternMask.at(char_).to_string();
+                qCDebug(BITAP) << "Pattern mask for" << char_ << "is" << patternMask->at(char_).to_string();
             }
         }
 
@@ -97,7 +99,7 @@ inline std::optional<Match> bitap(const QStringView &name, const QStringView &pa
     for (int i = 0; i < name.size(); ++i) {
         const auto &char_ = name.at(i);
         auto previousBit = bits[0];
-        const auto mask = patternMask.at(char_.unicode());
+        const auto mask = patternMask->at(char_.unicode());
         bits[0] |= mask;
         bits[0] <<= 1;
 
-- 
GitLab

