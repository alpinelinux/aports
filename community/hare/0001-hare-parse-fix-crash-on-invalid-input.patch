From f2449260531373e7bea52353a15a1bab978ff00a Mon Sep 17 00:00:00 2001
From: Hugo Osvaldo Barrera <hugo@whynothugo.nl>
Date: Sat, 14 Feb 2026 12:33:31 +0100
Subject: [PATCH] hare::parse: fix crash on invalid input
Patch-Source: https://git.sr.ht/~sircmpwn/hare/commit/f2449260531373e7bea52353a15a1bab978ff00a

When an unexpected token is parsed, want() calls mkloc to determine its
location. mkloc lexes and unlexes the next token, and want() then
unlexes the parsed token, aborting the process due to the dual unlex.

Prevent the double-unlex by unlexing the token before the call to mkloc,
leaving the unlex slot unoccupied before mkloc lexes and unlexes the
token.

In theory this also corrects the token for whom the position is
returned, although this position seems to be entirely unused right now.
---
 hare/parse/+test/unit_test.ha | 13 +++++++++++++
 hare/parse/parse.ha           |  2 +-
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/hare/parse/+test/unit_test.ha b/hare/parse/+test/unit_test.ha
index 6a89a35af4697c246ba7425a6e4af2ade7a98246..70b87dec38a5400fba0b6be3caa3bc4578b9c8ed 100644
--- a/hare/parse/+test/unit_test.ha
+++ b/hare/parse/+test/unit_test.ha
@@ -137,3 +137,16 @@ fn tup_to_import(tup: import_tuple) ast::import = ast::import {
 		"// humans think is impossible.\n"
 		"export fn main() void = void;\n");
 };
+
+@test fn want() void = {
+	// Hint: missing semicolon.
+	let in = "fn f() void = { const x = 1\ny(); };";
+	let stream = memio::fixed(strings::toutf8(in));
+	let scanner = bufio::newscanner(&stream);
+	defer bufio::finish(&scanner);
+
+	let lexer = lex::init(&scanner, "<test>");
+	let got = subunit(&lexer);
+
+	assert(got is lex::error);
+};
diff --git a/hare/parse/parse.ha b/hare/parse/parse.ha
index 6893f929641fd02729c0b1bec1d0602cf646bc4e..86da154d7324786e888aaaeb61ac1cfa343bcab5 100644
--- a/hare/parse/parse.ha
+++ b/hare/parse/parse.ha
@@ -40,6 +40,7 @@ export fn want(lexer: *lex::lexer, want: lex::ltok...) (lex::token | error) = {
 
 	let buf = memio::dynamic();
 	defer io::close(&buf)!;
+	lex::unlex(lexer, tok);
 	for (let i = 0z; i < len(want); i += 1) {
 		const tstr = if (want[i] == ltok::NAME) "name"
 			else lex::tokstr((want[i], void, mkloc(lexer)));
@@ -48,7 +49,6 @@ export fn want(lexer: *lex::lexer, want: lex::ltok...) (lex::token | error) = {
 			fmt::fprint(&buf, ", ")!;
 		};
 	};
-	lex::unlex(lexer, tok);
 	return syntaxerr(mkloc(lexer), "Unexpected '{}', was expecting {}",
 		lex::tokstr(tok), memio::string(&buf)!);
 };
