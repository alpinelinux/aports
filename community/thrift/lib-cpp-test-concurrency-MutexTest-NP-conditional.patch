diff --git a/lib/cpp/test/concurrency/MutexTest.cpp b/lib/cpp/test/concurrency/MutexTest.cpp
index 781ec1a4..880d0b11 100644
--- a/lib/cpp/test/concurrency/MutexTest.cpp
+++ b/lib/cpp/test/concurrency/MutexTest.cpp
@@ -32,7 +32,9 @@ using namespace apache::thrift::concurrency;
 struct LFAT
 {
   LFAT()
+#ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
     : uut(Mutex::ERRORCHECK_INITIALIZER)
+#endif
   {
     BOOST_CHECK_EQUAL(0, pthread_mutex_init(&mx, 0));
     BOOST_CHECK_EQUAL(0, pthread_cond_init(&cv, 0));
@@ -59,15 +61,18 @@ BOOST_AUTO_TEST_SUITE(MutexTest)
 
 BOOST_AUTO_TEST_CASE(happy_path)
 {
+#ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
   Mutex uut(Mutex::ERRORCHECK_INITIALIZER);                         // needed to test unlocking twice without undefined behavior
 
   BOOST_CHECK_NO_THROW( uut.lock());
   BOOST_CHECK_THROW   ( uut.lock(), SystemResourceException);       // EDEADLK (this thread owns it)
   BOOST_CHECK_NO_THROW( uut.unlock());
+#endif
 }
 
 BOOST_AUTO_TEST_CASE(recursive_happy_path)
 {
+#ifdef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
   Mutex uut(Mutex::RECURSIVE_INITIALIZER);
 
   BOOST_CHECK_NO_THROW( uut.lock());
@@ -80,15 +85,18 @@ BOOST_AUTO_TEST_CASE(recursive_happy_path)
   BOOST_CHECK_NO_THROW( uut.unlock());
   BOOST_CHECK_NO_THROW( uut.unlock());
   BOOST_CHECK_NO_THROW( uut.unlock());
+#endif
 }
 
 BOOST_AUTO_TEST_CASE(trylock)
 {
+#ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
   Mutex uut(Mutex::ADAPTIVE_INITIALIZER);   // just using another initializer for coverage
 
   BOOST_CHECK         ( uut.trylock());
   BOOST_CHECK         (!uut.trylock());
   BOOST_CHECK_NO_THROW( uut.unlock());
+#endif
 }
 
 BOOST_AUTO_TEST_CASE(timedlock)


