From 2a36c4c1ef8ba620e7b69608e3f599c422453250 Mon Sep 17 00:00:00 2001
From: Jens Reidel <adrian@travitia.xyz>
Date: Thu, 11 Dec 2025 05:50:17 +0100
Subject: [PATCH] Use Mutex from std

Asynchronous Mutex types are only useful when a lock must be held across
an await point, see also https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html#which-kind-of-mutex-should-you-use

Signed-off-by: Jens Reidel <adrian@travitia.xyz>
---
 Cargo.lock                      | 88 ---------------------------------
 cli/src/main.rs                 |  2 +-
 lib/Cargo.toml                  |  2 -
 lib/src/channel.rs              | 18 +++----
 lib/src/context.rs              |  4 +-
 lib/src/output_configuration.rs | 30 ++++++-----
 lib/src/output_manager.rs       | 12 ++---
 lib/src/wl_registry.rs          |  4 +-
 8 files changed, 30 insertions(+), 130 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index d659c18..2b7a28b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -64,15 +64,6 @@ version = "2.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"
 
-[[package]]
-name = "branches"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f11502672c5570f77f6bdf573332483f8475bab6a7fda00f1fae8ddb5a6245c0"
-dependencies = [
- "rustc_version",
-]
-
 [[package]]
 name = "bytes"
 version = "1.11.0"
@@ -160,14 +151,12 @@ name = "cosmic-randr"
 version = "0.1.0"
 dependencies = [
  "cosmic-protocols",
- "futures-lite",
  "indexmap",
  "thiserror",
  "tokio",
  "tracing",
  "wayland-client",
  "wayland-protocols-wlr",
- "xutex",
 ]
 
 [[package]]
@@ -193,21 +182,6 @@ dependencies = [
  "thiserror",
 ]
 
-[[package]]
-name = "crossbeam-queue"
-version = "0.3.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
-dependencies = [
- "crossbeam-utils",
-]
-
-[[package]]
-name = "crossbeam-utils"
-version = "0.8.21"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
-
 [[package]]
 name = "downcast-rs"
 version = "1.2.1"
@@ -230,12 +204,6 @@ dependencies = [
  "windows-sys 0.61.2",
 ]
 
-[[package]]
-name = "fastrand"
-version = "2.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
-
 [[package]]
 name = "find-msvc-tools"
 version = "0.1.5"
@@ -248,31 +216,6 @@ version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3f722aa875298d34a0ebb6004699f6f4ea830d36dec8ac2effdbbc840248a096"
 
-[[package]]
-name = "futures-core"
-version = "0.3.31"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
-
-[[package]]
-name = "futures-io"
-version = "0.3.31"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"
-
-[[package]]
-name = "futures-lite"
-version = "2.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f78e10609fe0e0b3f4157ffab1876319b5b0db102a2c60dc4626306dc46b44ad"
-dependencies = [
- "fastrand",
- "futures-core",
- "futures-io",
- "parking",
- "pin-project-lite",
-]
-
 [[package]]
 name = "hashbrown"
 version = "0.16.1"
@@ -445,12 +388,6 @@ version = "1.70.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"
 
-[[package]]
-name = "parking"
-version = "2.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"
-
 [[package]]
 name = "pin-project-lite"
 version = "0.2.16"
@@ -490,15 +427,6 @@ dependencies = [
  "proc-macro2",
 ]
 
-[[package]]
-name = "rustc_version"
-version = "0.4.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
-dependencies = [
- "semver",
-]
-
 [[package]]
 name = "rustix"
 version = "1.1.2"
@@ -512,12 +440,6 @@ dependencies = [
  "windows-sys 0.61.2",
 ]
 
-[[package]]
-name = "semver"
-version = "1.0.27"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"
-
 [[package]]
 name = "shlex"
 version = "1.3.0"
@@ -855,13 +777,3 @@ checksum = "c8d71a593cc5c42ad7876e2c1fda56f314f3754c084128833e64f1345ff8a03a"
 dependencies = [
  "memchr",
 ]
-
-[[package]]
-name = "xutex"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f7b2794adabee656fae931dc27d457c4e8a83cfe96ad1e1c73de770b8401b57"
-dependencies = [
- "branches",
- "crossbeam-queue",
-]
diff --git a/cli/src/main.rs b/cli/src/main.rs
index d908f7f..a9673e5 100644
--- a/cli/src/main.rs
+++ b/cli/src/main.rs
@@ -315,7 +315,7 @@ impl App {
     /// Returns error if the message receiver fails, dispach fails, or a configuration failed.
     async fn receive_config_messages(&mut self) -> Result<(), Box<dyn std::error::Error>> {
         loop {
-            while let Some(message) = self.message_rx.try_recv().await {
+            while let Some(message) = self.message_rx.try_recv() {
                 if config_message(Some(message))? {
                     return Ok(());
                 }
diff --git a/lib/Cargo.toml b/lib/Cargo.toml
index 77d25c3..1e978ea 100644
--- a/lib/Cargo.toml
+++ b/lib/Cargo.toml
@@ -7,14 +7,12 @@ edition = "2024"
 
 [dependencies]
 cosmic-protocols = { git = "https://github.com/pop-os/cosmic-protocols.git" }
-futures-lite = "2.6.1"
 indexmap = "2.12.1"
 thiserror = "2.0.17"
 tokio = { version = "1.48.0", default-features = false, features = ["net", "sync"] }
 tracing = "0.1.43"
 wayland-client = "0.31.11"
 wayland-protocols-wlr = { version = "0.3.9", features = [ "client", "wayland-client" ] }
-xutex = "0.1.3"
 
 [dev-dependencies]
 tokio = { version = "1.48.0", features = ["macros", "rt",] }
diff --git a/lib/src/channel.rs b/lib/src/channel.rs
index 47b1818..8e57978 100644
--- a/lib/src/channel.rs
+++ b/lib/src/channel.rs
@@ -4,7 +4,7 @@
 use std::{
     collections::VecDeque,
     sync::{
-        Arc,
+        Arc, Mutex,
         atomic::{AtomicBool, Ordering},
     },
 };
@@ -14,7 +14,7 @@ use super::Message;
 /// Create a channel for receiving messages from cosmic-randr.
 pub fn channel() -> (Sender, Receiver) {
     let channel = Arc::new(Channel {
-        queue: xutex::AsyncMutex::new(VecDeque::default()),
+        queue: Mutex::new(VecDeque::default()),
         notify: tokio::sync::Notify::const_new(),
         closed: AtomicBool::new(false),
     });
@@ -24,7 +24,7 @@ pub fn channel() -> (Sender, Receiver) {
 
 /// A channel specifically for handling cosmic-randr messages.
 struct Channel {
-    pub(self) queue: xutex::AsyncMutex<VecDeque<Message>>,
+    pub(self) queue: Mutex<VecDeque<Message>>,
     pub(self) notify: tokio::sync::Notify,
     pub(self) closed: AtomicBool,
 }
@@ -32,8 +32,8 @@ struct Channel {
 pub struct Sender(Arc<Channel>);
 
 impl Sender {
-    pub async fn send(&self, message: Message) {
-        self.0.queue.lock().await.push_back(message);
+    pub fn send(&self, message: Message) {
+        self.0.queue.lock().unwrap().push_back(message);
         self.0.notify.notify_one();
     }
 }
@@ -49,9 +49,9 @@ pub struct Receiver(Arc<Channel>);
 
 impl Receiver {
     /// Returns a value until the sender is dropped.
-    pub async fn recv(&mut self) -> Option<Message> {
+    pub async fn recv(&self) -> Option<Message> {
         loop {
-            if let Some(value) = self.0.queue.lock().await.pop_front() {
+            if let Some(value) = self.0.queue.lock().unwrap().pop_front() {
                 return Some(value);
             }
 
@@ -63,7 +63,7 @@ impl Receiver {
         }
     }
 
-    pub async fn try_recv(&mut self) -> Option<Message> {
-        self.0.queue.lock().await.pop_front()
+    pub fn try_recv(&self) -> Option<Message> {
+        self.0.queue.lock().unwrap().pop_front()
     }
 }
diff --git a/lib/src/context.rs b/lib/src/context.rs
index 7813ae2..fae7c52 100644
--- a/lib/src/context.rs
+++ b/lib/src/context.rs
@@ -324,8 +324,8 @@ impl Context {
             .map_err(Error::from)
     }
 
-    pub async fn send(&mut self, event: Message) {
-        self.sender.send(event).await
+    pub fn send(&mut self, event: Message) {
+        self.sender.send(event)
     }
 
     pub fn create_output_config(&mut self) -> Configuration {
diff --git a/lib/src/output_configuration.rs b/lib/src/output_configuration.rs
index f3f1312..3c7436c 100644
--- a/lib/src/output_configuration.rs
+++ b/lib/src/output_configuration.rs
@@ -16,23 +16,21 @@ impl Dispatch<ZwlrOutputConfigurationV1, ()> for Context {
         _conn: &Connection,
         _handle: &QueueHandle<Self>,
     ) {
-        futures_lite::future::block_on(async {
-            match event {
-                Event::Succeeded => {
-                    let _res = state.send(Message::ConfigurationSucceeded).await;
-                    proxy.destroy();
-                }
-                Event::Failed => {
-                    let _res = state.send(Message::ConfigurationFailed).await;
-                    proxy.destroy();
-                }
-                Event::Cancelled => {
-                    let _res = state.send(Message::ConfigurationCancelled).await;
-                    proxy.destroy();
-                }
-                _ => unreachable!(),
+        match event {
+            Event::Succeeded => {
+                let _res = state.send(Message::ConfigurationSucceeded);
+                proxy.destroy();
             }
-        });
+            Event::Failed => {
+                let _res = state.send(Message::ConfigurationFailed);
+                proxy.destroy();
+            }
+            Event::Cancelled => {
+                let _res = state.send(Message::ConfigurationCancelled);
+                proxy.destroy();
+            }
+            _ => unreachable!(),
+        }
     }
 }
 
diff --git a/lib/src/output_manager.rs b/lib/src/output_manager.rs
index af9f209..aca4e38 100644
--- a/lib/src/output_manager.rs
+++ b/lib/src/output_manager.rs
@@ -47,18 +47,14 @@ impl Dispatch<ZwlrOutputManagerV1, ()> for Context {
                     // `get_head`. Queue sending `ManagerDone` until sync callback.
                     state.done_queued = true;
                 } else {
-                    futures_lite::future::block_on(async {
-                        let _res = state.send(Message::ManagerDone).await;
-                    });
+                    let _res = state.send(Message::ManagerDone);
                 }
             }
 
             ZwlrOutputManagerEvent::Finished => {
                 state.output_manager = None;
                 state.output_manager_serial = 0;
-                futures_lite::future::block_on(async {
-                    let _res = state.send(Message::ManagerFinished).await;
-                });
+                let _res = state.send(Message::ManagerFinished);
             }
 
             _ => tracing::debug!(?event, "unknown event"),
@@ -98,9 +94,7 @@ impl Dispatch<WlCallback, ()> for Context {
                 if state.cosmic_manager_sync_callback.as_ref() == Some(proxy) {
                     state.cosmic_manager_sync_callback = None;
                     if state.done_queued {
-                        futures_lite::future::block_on(async {
-                            let _res = state.send(Message::ManagerDone).await;
-                        });
+                        let _res = state.send(Message::ManagerDone);
                         state.done_queued = false;
                     }
                 }
diff --git a/lib/src/wl_registry.rs b/lib/src/wl_registry.rs
index cf09712..939f826 100644
--- a/lib/src/wl_registry.rs
+++ b/lib/src/wl_registry.rs
@@ -27,9 +27,7 @@ impl Dispatch<wl_registry::WlRegistry, ()> for Context {
                         "wlr-output-management protocol version {version} < 2 is not supported"
                     );
 
-                    futures_lite::future::block_on(async {
-                        let _ = state.send(Message::Unsupported).await;
-                    });
+                    let _ = state.send(Message::Unsupported);
 
                     return;
                 }
-- 
2.52.0

