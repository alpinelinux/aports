From d593e92526bf1aa6914bada92494d9a21aa2e966 Mon Sep 17 00:00:00 2001
From: Hugo Osvaldo Barrera <hugo@whynothugo.nl>
Date: Mon, 2 Feb 2026 22:16:11 +0100
Subject: [PATCH] Implement socket activation without libsystemd

Socket activation uses sd_listen_fds from libsystemd, and can only be
compiled on systems with systemd.

This is an issue for Alpine / postmarketOS, where upstream has no
systemd package, but downstream depends on upstream's pipewire package
and wants to rely on socket activation. This also prevents using
socket-activation on other non-systemd distributions, including
non-Linux.

Implement equivalent functionality without a dependency on libsystemd.
---
 src/modules/module-protocol-native.c       | 13 ++--
 src/modules/module-protocol-pulse/server.c | 18 ++---
 src/pipewire/private.h                     | 77 ++++++++++++++++++++++
 3 files changed, 86 insertions(+), 22 deletions(-)

diff --git a/src/modules/module-protocol-native.c b/src/modules/module-protocol-native.c
index 96e99f35e..71d43ad36 100644
--- a/src/modules/module-protocol-native.c
+++ b/src/modules/module-protocol-native.c
@@ -34,9 +34,6 @@
 #include <spa/utils/json.h>
 #include <spa/debug/log.h>
 
-#ifdef HAVE_SYSTEMD
-#include <systemd/sd-daemon.h>
-#endif
 
 #ifdef HAVE_SELINUX
 #include <selinux/selinux.h>
@@ -909,13 +906,12 @@ static int add_socket(struct pw_protocol *protocol, struct server *s, struct soc
 	int fd = -1, res;
 	bool activated = false;
 
-#ifdef HAVE_SYSTEMD
 	{
-		int i, n = sd_listen_fds(0);
+		int i, n = listen_fd();
 		for (i = 0; i < n; ++i) {
-			if (sd_is_socket_unix(SD_LISTEN_FDS_START + i, SOCK_STREAM,
-						1, s->addr.sun_path, 0) > 0) {
-				fd = SD_LISTEN_FDS_START + i;
+			if (is_socket_unix(LISTEN_FDS_START + i, SOCK_STREAM,
+						s->addr.sun_path) > 0) {
+				fd = LISTEN_FDS_START + i;
 				activated = true;
 				pw_log_info("server %p: Found socket activation socket for '%s'",
 						s, s->addr.sun_path);
@@ -923,7 +919,6 @@ static int add_socket(struct pw_protocol *protocol, struct server *s, struct soc
 			}
 		}
 	}
-#endif
 
 	if (fd < 0) {
 		struct stat socket_stat;
diff --git a/src/modules/module-protocol-pulse/server.c b/src/modules/module-protocol-pulse/server.c
index 4e744e33f..ec3cb3a21 100644
--- a/src/modules/module-protocol-pulse/server.c
+++ b/src/modules/module-protocol-pulse/server.c
@@ -21,9 +21,6 @@
 #include <netinet/ip.h>
 #include <unistd.h>
 
-#ifdef HAVE_SYSTEMD
-#include <systemd/sd-daemon.h>
-#endif
 
 #include <spa/utils/cleanup.h>
 #include <spa/utils/defs.h>
@@ -47,6 +44,8 @@
 #include "snap-policy.h"
 #endif
 
+#include "pipewire/private.h"
+
 #define LISTEN_BACKLOG 32
 #define MAX_CLIENTS 64
 
@@ -577,26 +576,19 @@ static bool is_stale_socket(int fd, const struct sockaddr_un *addr_un)
 	return false;
 }
 
-#ifdef HAVE_SYSTEMD
 static int check_systemd_activation(const char *path)
 {
-	const int n = sd_listen_fds(0);
+	const int n = listen_fd();
 
 	for (int i = 0; i < n; i++) {
-		const int fd = SD_LISTEN_FDS_START + i;
+		const int fd = LISTEN_FDS_START + i;
 
-		if (sd_is_socket_unix(fd, SOCK_STREAM, 1, path, 0) > 0)
+		if (is_socket_unix(fd, SOCK_STREAM, path) > 0)
 			return fd;
 	}
 
 	return -1;
 }
-#else
-static inline int check_systemd_activation(SPA_UNUSED const char *path)
-{
-	return -1;
-}
-#endif
 
 static int start_unix_server(struct server *server, const struct sockaddr_storage *addr)
 {
diff --git a/src/pipewire/private.h b/src/pipewire/private.h
index 5582709ad..8990e044f 100644
--- a/src/pipewire/private.h
+++ b/src/pipewire/private.h
@@ -7,8 +7,12 @@
 
 /** \privatesection */
 
+#include <fcntl.h>
+#include <stdlib.h>
+#include <limits.h>
 #include <sys/socket.h>
 #include <sys/types.h> /* for pthread_t */
+#include <sys/un.h>
 
 #include "pipewire/impl.h"
 
@@ -1416,4 +1420,77 @@ void pw_log_topic_unregister_enum(const struct spa_log_topic_enum *e);
 }
 #endif
 
+#ifndef LISTEN_FDS_START
+#define LISTEN_FDS_START 3
+#endif
+
+/* Returns the number of file descriptors passed for socket activation.
+ * Returns 0 if none, -1 on error. */
+static inline int listen_fd(void)
+{
+	const char *listen_fds;
+	char *endptr;
+	long n;
+	int i, flags;
+
+	listen_fds = getenv("LISTEN_FDS");
+	if (!listen_fds)
+		return 0;
+
+	n = strtol(listen_fds, &endptr, 10);
+	if (endptr == listen_fds || *endptr != '\0' || n < 0 || n > INT_MAX - LISTEN_FDS_START) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	for (i = 0; i < (int)n; i++) {
+		flags = fcntl(LISTEN_FDS_START + i, F_GETFD);
+		if (flags == -1)
+			return -1;
+		if (fcntl(LISTEN_FDS_START + i, F_SETFD, flags | FD_CLOEXEC) == -1)
+			return -1;
+	}
+
+	unsetenv("LISTEN_FDS");
+
+	return (int)n;
+}
+
+/* Check if the fd is a listening unix socket of the given type,
+ * optionally bound to the given path. */
+static inline int is_socket_unix(int fd, int type, const char *path)
+{
+	struct sockaddr_un addr;
+	int val;
+	socklen_t len = sizeof(val);
+
+	if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &val, &len) < 0)
+		return -errno;
+	if (val != type)
+		return 0;
+
+	if (getsockopt(fd, SOL_SOCKET, SO_ACCEPTCONN, &val, &len) < 0)
+		return -errno;
+	if (!val)
+		return 0;
+
+	if (path) {
+		len = sizeof(addr);
+		memset(&addr, 0, sizeof(addr));
+		if (getsockname(fd, (struct sockaddr *)&addr, &len) < 0)
+			return -errno;
+		if (addr.sun_family != AF_UNIX)
+			return 0;
+		size_t length = strlen(path);
+		if (length > 0) {
+			if (len < offsetof(struct sockaddr_un, sun_path) + length)
+				return 0;
+			if (memcmp(addr.sun_path, path, length) != 0)
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
 #endif /* PIPEWIRE_PRIVATE_H */
-- 
2.52.0

