From cff110ac98012042c58694169d5722eb55f60635 Mon Sep 17 00:00:00 2001
From: Mike Sharov <msharov@users.sourceforge.net>
Date: Wed, 25 Apr 2018 11:17:06 -0400
Subject: [PATCH] Make it compile cleanly 	Fix openssl MD5 hash
 calculations; context struct is private 		and must be created
 with helper functions. 	Add -Wextra to compile flags and fix all
 warnings.

---
 about.c          | 125 +++++++++++++-------------
 configure        |   2 +-
 conversions.c    | 222 ++++++++++++++++++++++-------------------------
 conversions.h    |   4 +-
 digcalc.c        | 189 ++++++++++++++--------------------------
 digcalc.h        |  39 +++------
 interface.c      |   2 +-
 main.c           |  10 +--
 netio.c          |   2 +-
 os-support.c     |  26 ++----
 os-support.h     |   6 +-
 ui-support.c     |   2 +-
 updatecheck.c    |   2 -
 xmlparse.c       |   8 +-
 zlib_interface.c |  41 ++++-----
 zlib_interface.h |   2 -
 16 files changed, 284 insertions(+), 398 deletions(-)

diff --git a/about.c b/about.c
index 2bff040..753e7db 100644
--- a/about.c
+++ b/about.c
@@ -117,15 +117,15 @@ void Snowfall (int christmastree) {
 	int wind = 1;			/* 1: wind active, 0: inactive 
 							   set to 1 here so the first loop run clears it. */
 	int newflake = 0;		/* Time until a new flake appears. */
-	
+
 	/* Set ncurses halfdelay mode. */
 	halfdelay (3);
-	
+
 	/* White snowflakes! */
 	/* Doesn't work on white terminal background... obviously.
 	attron (COLOR_PAIR(16));
 	attron (WA_BOLD); */
-	
+
 	while (1) {
 		/* Set up the storm. */
 		if (windtimer == 0) {
@@ -161,7 +161,7 @@ void Snowfall (int christmastree) {
 			new->oldchar = new->oldchar2 = ' ';
 			new->vspeed = 1+(float)rand() / (float)RAND_MAX * 2;
 			new->hspeed = (1+(float)rand() / (float)RAND_MAX * 7)-4;
-			
+
 			/* Add our new snowflake to the pointer chain. */
 			new->next = NULL;
 			if (first == NULL) {
@@ -173,7 +173,7 @@ void Snowfall (int christmastree) {
 					new->prev = new->prev->next;
 				new->prev->next = new;
 			}
-			
+
 			/* Set new counter until next snowflake. */
 			newflake = 1+(float)rand() / (float)RAND_MAX * 2;
 			/*
@@ -181,7 +181,7 @@ void Snowfall (int christmastree) {
 			mvprintw (1,1,"New flake in %d rounds.", newflake);
 			*/
 		}
-		
+
 		for (cur = first; cur != NULL; cur = curnext) {
 			curnext = cur->next;
 			/* Draw every snowflake at its coordinates to the screen. */
@@ -204,7 +204,7 @@ void Snowfall (int christmastree) {
 					if ((cur->oldx < 14) && (cur->oldx > 9) && (cur->oldy < 24) && (cur->oldy > 20)) {
 						attroff (COLOR_PAIR(12));
 					}
-					
+
 					if (christmastree)
 						ChristmasTree();
 				}
@@ -214,7 +214,7 @@ void Snowfall (int christmastree) {
 			}
 			/* Set new hspeed for flake */
 			cur->hspeed = (1+(float)rand() / (float)RAND_MAX * 7)-4;
-			
+
 			/* Advance every flake downwards by a random amount and to
 			   the left or right.
 			   Check if the next position would obscure a character on the screen
@@ -223,7 +223,7 @@ void Snowfall (int christmastree) {
 			if (wind)
 				cur->hspeed += windspeed;
 			cur->x += cur->hspeed;
-			
+
 			if (cur->y > LINES) {
 				if (cur == first) {
 					first = first->next;
@@ -237,7 +237,7 @@ void Snowfall (int christmastree) {
 				free (cur);
 				continue;
 			}
-			
+
 			/* Only draw if we're still inside the window. */
 			if (cur->y <= LINES) {
 				/*
@@ -254,12 +254,12 @@ void Snowfall (int christmastree) {
 					cur->oldchar = ' ';
 			}
 		}
-	
+
 		windtimer--;
 		newflake--;
-		
+
 		refresh();
-		
+
 		/* Leave loop if anykey(tm) was pressed. */
 		if (getch() != ERR)
 			break;
@@ -319,7 +319,7 @@ void xmasAbout (void) {
 	mvaddstr (19, 29, "Fernando J. Pereda, Marco Cova");
 	mvaddstr (20, 29, "Cheng-Lung Sung, Dmitry Petukhov");
 	mvaddstr (21, 29, "Douglas Campos");
-	
+
 	Snowfall(1);
 }
 
@@ -331,7 +331,7 @@ void SHDrawGun (int gun_pos) {
 	clrtoeol();
 	move (LINES-2, 0);
 	clrtoeol();
-	
+
 	attron (WA_BOLD);
 	mvaddstr (LINES-3, gun_pos-3, "___/\\___");
 	mvaddstr (LINES-2, gun_pos-3, "|######|");
@@ -350,27 +350,27 @@ void SHDrawScore (int score, int level) {
 	int i, len;
 	char scorestr[16];
 	char levelstr[16];
-	
+
 	attron (WA_REVERSE);
 	for (i = 0; i < COLS; i++) {
 		mvaddch (0, i, ' ');
 	}
 	mvaddstr (0, 1, "Santa Hunta!");
-	
+
 	snprintf (scorestr, sizeof(scorestr), _("Score: %d"), score);
 	len = strlen (scorestr);
 	mvaddstr (0, COLS-1-len, scorestr);
-	
+
 	snprintf (levelstr, sizeof(levelstr), _("Level: %d"), level);
 	len = strlen (levelstr);
 	mvaddstr (0, COLS/2-len/2, levelstr);
-	
+
 	attroff (WA_REVERSE);
 }
 
 void SHClearScreen (void) {
 	int i;
-	
+
 	for (i = 0; i < LINES; i++) {
 		move (i, 0);
 		clrtoeol();
@@ -386,9 +386,9 @@ void SHDrawProjectile (shot shot) {
 void SHDrawSanta (santa santa) {
 	int len;
 	char *draw_string;
-	
+
 	len = COLS - santa.x;
-	
+
 	if (santa.anim == 0) {
 		if (santa.x < 0) {
 			draw_string = santa.gfx+abs(santa.x);
@@ -412,7 +412,7 @@ void SHDrawSanta (santa santa) {
 		} else
 			mvaddnstr (santa.y+1, santa.x, santa.altgfx_line2, len);
 	}
-	
+
 	attron (COLOR_PAIR(10));
 	mvaddch (santa.y, santa.x + santa.length - 1, '*');
 	attroff (COLOR_PAIR(10));
@@ -445,9 +445,9 @@ int SHAddScore (santa santa) {
 
 void SHDrawHitScore (scoreDisplay score) {
 	int rand_color;
-	
+
 	rand_color = 10 + ((float)rand() / (float)RAND_MAX * 6);
-	
+
 	attron (WA_BOLD);
 	attron (COLOR_PAIR(rand_color));
 	mvprintw (score.y, score.x, "%d", score.score);
@@ -472,15 +472,15 @@ void printFinalScore (int score) {
 	int y;
 	int divisor;
 	int digit;
-	
+
 	if (score == 0)
 		number_count = 1;
 	else
 		number_count = log10(score) + 1;
-	
-	
+
+
 	pos = COLS/2 - ((number_count * 8) / 2);
-	
+
 	for (i = 0; i < number_count; i++) {
 		y = 12;
 		divisor = pow (10, number_count-1-i);
@@ -491,30 +491,30 @@ void printFinalScore (int score) {
 			mvaddstr (y, pos + (i * 8), numbers[digit][j]);
 			y++;
 		}
-	}	
+	}
 	refresh();
 }
 
 void SHFinalScore (int score) {
 	int rand_color;
 
-	attron (WA_BOLD);	
+	attron (WA_BOLD);
 	mvaddstr (9, COLS/2-6, "Final score:");
 	refresh();
 	sleep(1);
-	
-	
+
+
 	for (;;) {
 		if (getch() == 'q')
 			break;
-		
+
 		rand_color = 10 + ((float)rand() / (float)RAND_MAX * 6);
 		attron (WA_BOLD);
 		attron (COLOR_PAIR(rand_color));
 		printFinalScore(score);
 		attroff (COLOR_PAIR(rand_color));
 		attroff (WA_BOLD);
-		
+
 		move (LINES-1, COLS-1);
 		refresh();
 	}
@@ -530,7 +530,6 @@ void santaHunta (void) {
 	int level = 1;
 	struct timeval before;
 	struct timeval after;
-	struct timeval delay;
 	int draw_loop = 0;
 	long draw_delay = 0;
 	shot shot;
@@ -538,31 +537,27 @@ void santaHunta (void) {
 	int targets = 0;
 	int hitcount = 0;
 	scoreDisplay scoreDisplay;
-	
+
 	shot.fired = 0;
 	shot.x = 0;
 	shot.y = 0;
-	
+
 	scoreDisplay.rounds = 0;
-	
+
 	/* Set ncurses halfdelay mode.
 	 * Max resolution is 1/10sec */
 	halfdelay (1);
-	
-	for (;;) {	
+
+	for (;;) {
 		gettimeofday (&before, NULL);
 		input = getch();
 		gettimeofday (&after, NULL);
 
 		if (after.tv_sec > before.tv_sec)
 			after.tv_usec += 1000000;
-		
-		delay.tv_sec = 0;
-		delay.tv_usec = abs(100000 - (after.tv_usec - before.tv_usec));
 
 		if (!targets) {
 			newSanta(&santa, level);
-			
 			targets = 1;
 		}
 
@@ -576,41 +571,41 @@ void santaHunta (void) {
 
 			if (targets)
 				SHDrawSanta(santa);
-			
+
 			if (santa.anim == 0)
 				santa.anim = 1;
 			else
 				santa.anim = 0;
-				
+
 			if (santa.x >= COLS)
 				targets = 0;
-			
+
 			if (shot.fired)
 				SHDrawProjectile(shot);
-				
+
 			if (scoreDisplay.rounds > 0)
 				SHDrawHitScore(scoreDisplay);
-			
+
 			if (SHHit(shot, santa)) {
 				targets = 0;
 				hitcount++;
 				last_score = SHAddScore(santa);
 				score += last_score;
-				
+
 				scoreDisplay.x = shot.x;
 				scoreDisplay.y = shot.y;
 				scoreDisplay.score = last_score;
 				scoreDisplay.rounds = 20;
 			}
-			
+
 			santa.x += santa.speed;
-			
+
 			scoreDisplay.rounds--;
-			
+
 			shot.y--;
 			if (shot.y == 0)
 				shot.fired = 0;
-			
+
 			if (hitcount == 10) {
 				hitcount = 0;
 				level++;
@@ -618,7 +613,7 @@ void santaHunta (void) {
 		}
 
 		count++;
-		
+
 		if ((input == KEY_RIGHT) || (input == keybindings.next)) {
 			if (gun_pos < COLS-5)
 				gun_pos++;
@@ -632,7 +627,7 @@ void santaHunta (void) {
 				mvaddstr (LINES-4, gun_pos-2, "\\***/");
 				attroff (COLOR_PAIR(12));
 				attroff (WA_BOLD);
-				
+
 				shot.x = gun_pos;
 				shot.y = LINES-4;
 				shot.fired = 1;
@@ -641,33 +636,33 @@ void santaHunta (void) {
 			SHFinalScore(score);
 			break;
 		}
-			
+
 		SHDrawGun(gun_pos);
 		SHDrawScore(score, level);
 		SHDrawStatus();
-		
+
 		refresh();
 	}
-	
+
 	/* Leave halfdelay mode. */
 	cbreak();
 }
 
 void UIAbout (void) {
 	int xpos;
-	
+
 	clear();				/* Get the crap off the screen to make room
 							   for our wonderful ASCII logo. :) */
 
 	xpos = COLS/2 - 40;
-	
+
 	if (COLS < 80) {
 		mvprintw (0, 0, _("Need at least 80 COLS terminal, sorry!"));
 		refresh();
 		getch();
 		return;
 	}
-	
+
 	if (easterEgg()) {
 		santaHunta();
 	} else {
@@ -679,7 +674,7 @@ void UIAbout (void) {
 		mvaddstr (6, xpos, "/______  / / ___|___/ \\____/  /__|__/  / ___|___/ \\____ \\   /__|__/  /______  /");
 		mvaddstr (7, xpos, "       \\/  \\/                          \\/              \\/                   \\/");
 		mvprintw (9, COLS/2-(strlen("Version")+strlen(VERSION)+1)/2, "Version %s", VERSION);
-		
+
 		mvaddstr (11, COLS/2-(strlen(_("Brought to you by:")))/2, _("Brought to you by:"));
 		mvaddstr (13, COLS/2-(strlen(_("Main code")))/2, _("Main code"));
 		mvaddstr (14, COLS/2-6, "Oliver Feiler");
@@ -690,7 +685,7 @@ void UIAbout (void) {
 		mvaddstr (21, COLS/2-32, "Fernando J. Pereda, Marco Cova, Cheng-Lung Sung, Dmitry Petukhov");
 		mvaddstr (22, COLS/2-26, "Douglas Campos, Ray Iwata, Piotr Ozarowski, Yang Huan");
 		mvaddstr (23, COLS/2-15, "Ihar Hrachyshka, Mats Berglund");
-		
+
 		refresh();
 		getch();
 	}
diff --git a/conversions.c b/conversions.c
index a6155a1..b17348a 100644
--- a/conversions.c
+++ b/conversions.c
@@ -1,6 +1,6 @@
 /* Snownews - A lightweight console RSS newsreader
  * $Id: conversions.c 1173 2006-10-14 21:41:42Z kiza $
- * 
+ *
  * Copyright 2003-2009 Oliver Feiler <kiza@kcore.de> and
  *                     Rene Puls <rpuls@gmx.net>
  *
@@ -20,8 +20,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  */
- 
-#include <sys/types.h> 
+
+#define _GNU_SOURCE
+#include <sys/types.h>
 #include <string.h>
 #include <iconv.h>
 #include <stdio.h>
@@ -29,22 +30,12 @@
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
+#include <time.h>
 #include <libxml/HTMLparser.h>
 #include <langinfo.h>
 #include <openssl/evp.h>
-
+#include <openssl/md5.h>
 #include "os-support.h"
-
-/* I have no idea what needs to be defined to get strptime() on glibc.
- * This is stolen from somewhere else and it works for me(tm).
- * If you know how it's supposed to work, tell me. Manpage says
- * define _XOPEN_SOURCE for glibc2, but that doesn't work. */
-#define _XOPEN_SOURCE 500		/* Needed for glibc2 strptime(). What's the 500 for? */
-#define __USE_XOPEN
-#include <time.h>
-#undef __USE_XOPEN
-#undef _XOPEN_SOURCE
-
 #include "conversions.h"
 #include "config.h"
 #include "interface.h"
@@ -57,7 +48,7 @@ extern struct entity *first_entity;
 
 extern char *forced_target_charset;
 
-int calcAgeInDays (struct tm * t);
+static int calcAgeInDays (const struct tm* t);
 
 #ifdef STATIC_CONST_ICONV
 char * iconvert (const char * inbuf) {
@@ -72,11 +63,11 @@ char * iconvert (char * inbuf) {
 
 	/*(void)strlcpy(target_charset, nl_langinfo(CODESET), sizeof(target_charset));*/
 	strncpy(target_charset, nl_langinfo(CODESET), sizeof(target_charset));
-		
+
 	/* Take a shortcut. */
 	if (strcasecmp (target_charset, "UTF-8") == 0)
 		return strdup(inbuf);
-	
+
 	inbytesleft = strlen(inbuf);
 	outbytesleft = strlen(inbuf);
 
@@ -92,20 +83,20 @@ char * iconvert (char * inbuf) {
 	if (cd == (iconv_t) -1) {
 		return NULL;
 	}
-	
+
 	outbuf = malloc (outbytesleft+1);
 	outbuf_first = outbuf;
 
-	if (iconv (cd, &inbuf, &inbytesleft, &outbuf, &outbytesleft) == -1) {
+	if (iconv (cd, &inbuf, &inbytesleft, &outbuf, &outbytesleft) == (size_t)-1) {
 		free(outbuf_first);
 		iconv_close(cd);
 		return NULL;
 	}
 
 	*outbuf = 0;
-	
+
 	iconv_close (cd);
-	
+
 	return outbuf_first;
 }
 
@@ -135,18 +126,18 @@ char * UIDejunk (char * feed_description) {
 	unsigned long ch;			/* Decoded numeric entity */
 #endif
 	const htmlEntityDesc *ep;	/* For looking up HTML entities */
-	
+
 	/* Gracefully handle passed NULL ptr. */
 	if (feed_description == NULL) {
 		newtext = strdup("(null)");
 		return newtext;
 	}
-	
+
 	/* Make a copy and point *start to it so we can free the stuff again! */
 	text = strdup (feed_description);
 	start = text;
-	
-	
+
+
 	/* If text begins with a tag, discard all of them. */
 	while (1) {
 		if (text[0] == '<') {
@@ -162,14 +153,14 @@ char * UIDejunk (char * feed_description) {
 	}
 	newtext = malloc (1);
 	newtext[0] = '\0';
-	
+
 	while (1) {
 		/* Strip tags... tagsoup mode. */
 		/* strsep puts everything before "<" into detagged. */
 		detagged = strsep (&text, "<");
 		if (detagged == NULL)
 			break;
-		
+
 		/* Replace <p> and <br> (in all incarnations) with newlines, but only
 		   if there isn't already a following newline. */
 		if (text != NULL) {
@@ -188,12 +179,12 @@ char * UIDejunk (char * feed_description) {
 
 		/* Now append detagged to newtext. */
 		strcat (newtext, detagged);
-		
+
 		/* Advance *text to next position after the closed tag. */
 		htmltag = strsep (&text, ">");
 		if (htmltag == NULL)
 			break;
-		
+
 		if (s_strcasestr(htmltag, "img src") != NULL) {
 /*			attribute = s_strcasestr(htmltag, "alt=");
 			if (attribute == NULL)
@@ -216,25 +207,25 @@ char * UIDejunk (char * feed_description) {
 		}*/
 	}
 	free (start);
-	
+
 	CleanupString (newtext, 0);
-	
+
 	/* See if there are any entities in the string at all. */
 	if (strchr(newtext, '&') != NULL) {
 		text = strdup (newtext);
 		start = text;
 		free (newtext);
-	
+
 		newtext = malloc (1);
 		newtext[0] = '\0';
-		
+
 		while (1) {
 			/* Strip HTML entities. */
 			detagged = strsep (&text, "&");
 			if (detagged == NULL)
 				break;
-			
-			if (detagged != '\0') {
+
+			if (*detagged) {
 				newtext = realloc (newtext, strlen(newtext)+strlen(detagged)+1);
 				strcat (newtext, detagged);
 			}
@@ -260,29 +251,29 @@ char * UIDejunk (char * feed_description) {
 					strcat (newtext, "'");
 					continue;
 				}
-				
+
 				/* Decode user defined entities. */
 				found = 0;
 				for (cur_entity = first_entity; cur_entity != NULL; cur_entity = cur_entity->next_ptr) {
 					if (strcmp (entity, cur_entity->entity) == 0) {
 						/* We have found a matching entity. */
-						
+
 						/* If entity_length is more than 1 char we need to realloc
 						   more space in newtext. */
 						if (cur_entity->entity_length > 1)
 							newtext = realloc (newtext,  strlen(newtext)+cur_entity->entity_length+1);
-						
+
 						/* Append new entity. */
 						strcat (newtext, cur_entity->converted_entity);
-						
+
 						/* Set found flag. */
 						found = 1;
-						
+
 						/* We can now leave the for loop. */
 						break;
 					}
 				}
-								
+
 				/* Try to parse some standard entities. */
 				if (!found) {
 					/* See if it was a numeric entity. */
@@ -330,7 +321,7 @@ char * UIDejunk (char * feed_description) {
 				break;
 		}
 		free (start);
-	}	
+	}
 	return newtext;
 }
 
@@ -340,7 +331,7 @@ char * UIDejunk (char * feed_description) {
  * the 4th version which corrupted some random memory unfortunately...
  * but this one works. Heureka!
  */
-char * WrapText (char * text, int width) {
+char* WrapText (const char* text, unsigned width) {
 	char *newtext;
 	char *textblob;			/* Working copy of text. */
 	char *chapter;
@@ -352,14 +343,14 @@ char * WrapText (char * text, int width) {
 	char *p;
 	int lena, lenb;
 	*/
-	
+
 	textblob = strdup (text);
 	start = textblob;
-	
+
 
 	line = malloc (1);
 	line[0] = '\0';
-	
+
 	newtext = malloc(1);
 	memset (newtext, 0, 1);
 
@@ -371,14 +362,14 @@ char * WrapText (char * text, int width) {
 		while (1) {
 			savepos = chapter;
 			chunk = strsep (&chapter, " ");
-			
+
 			/* Last chunk. */
 			if (chunk == NULL) {
 				if (line != NULL) {
 					newtext = realloc (newtext, strlen(newtext)+strlen(line)+2);
 					strcat (newtext, line);
 					strcat (newtext, "\n");
-					
+
 					/* Faster replacement with memcpy.
 					 * Overkill, overcomplicated and smelling of bugs all over.
 					 */
@@ -393,22 +384,22 @@ char * WrapText (char * text, int width) {
 					p++;
 					*p=0;
 					*/
-					
+
 					line[0] = '\0';
 				}
 				break;
 			}
-			
+
 			if (strlen(chunk) > width) {
 				/* First copy remaining stuff in line to newtext. */
 				newtext = realloc (newtext, strlen(newtext)+strlen(line)+2);
 				strcat (newtext, line);
 				strcat (newtext, "\n");
-				
+
 				free (line);
 				line = malloc (1);
 				line[0] = '\0';
-				
+
 				/* Then copy chunk with max length of line to newtext. */
 				line = realloc (line, width+1);
 				strncat (line, chunk, width-5);
@@ -442,10 +433,10 @@ char * WrapText (char * text, int width) {
 			}
 		}
 	}
-	
-	free (line);	
-	free (start);	
-	
+
+	free (line);
+	free (start);
+
 	return newtext;
 }
 
@@ -458,14 +449,14 @@ char *base64encode(char const *inbuf, unsigned int inbuf_size) {
 	unsigned int outbuf_size = 0;
 	int bits = 0;
 	int char_count = 0;
-	
+
 	outbuf = malloc(1);
-	
+
 	while (inbuf_pos < inbuf_size) {
-	
+
 		bits |= *inbuf;
 		char_count++;
-		
+
 		if (char_count == 3) {
 			outbuf = realloc(outbuf, outbuf_size+4);
 			outbuf_size += 4;
@@ -477,12 +468,12 @@ char *base64encode(char const *inbuf, unsigned int inbuf_size) {
 			bits = 0;
 			char_count = 0;
 		}
-		
+
 		inbuf++;
 		inbuf_pos++;
 		bits <<= 8;
 	}
-	
+
 	if (char_count > 0) {
 		bits <<= 16 - (8 * char_count);
 		outbuf = realloc(outbuf, outbuf_size+4);
@@ -498,10 +489,10 @@ char *base64encode(char const *inbuf, unsigned int inbuf_size) {
 		}
 		outbuf_pos += 4;
 	}
-	
+
 	outbuf = realloc(outbuf, outbuf_size+1);
 	outbuf[outbuf_pos] = 0;
-	
+
 	return outbuf;
 }
 
@@ -531,7 +522,7 @@ char* decodechunked(char * chunked, unsigned int *inputlen) {
 	}
 	*dest = '\0';
 	*inputlen = dest - chunked;
-	
+
 	return chunked;
 }
 #endif
@@ -543,13 +534,13 @@ char* decodechunked(char * chunked, unsigned int *inputlen) {
  */
 void CleanupString (char * string, int tidyness) {
 	int len, i;
-	
+
 	/* If we are passed a NULL pointer, leave it alone and return. */
 	if (string == NULL)
 		return;
-	
+
 	len = strlen(string);
-	
+
 	while ((string[0] == '\n' || string [0] == ' ' || string [0] == '\t') &&
 			(len > 0)) {
 		/* len=strlen(string) does not include \0 of string.
@@ -558,13 +549,13 @@ void CleanupString (char * string, int tidyness) {
 		memmove (string, string+1, len);
 		len--;
 	}
-	
+
 	/* Remove trailing spaces. */
 	while ((len > 1) && (string[len-1] == ' ')) {
 		string[len-1] = 0;
 		len--;
 	}
-	
+
 	len = strlen(string);
 	/* Eat newlines and tabs along the whole string. */
 	for (i = 0; i < len; i++) {
@@ -574,18 +565,18 @@ void CleanupString (char * string, int tidyness) {
 		if (tidyness == 1 && string[i] == '\n') {
 			string[i] = ' ';
 		}
-	}	
+	}
 }
 
 /* http://foo.bar/address.rdf -> http:__foo.bar_address.rdf */
 char * Hashify (const char * url) {
 	int i, len;
 	char *hashed_url;
-	
+
 	hashed_url = strdup(url);
-	
+
 	len = strlen(hashed_url);
-	
+
 	/* Don't allow filenames > 128 chars for teeny weeny
 	 * operating systems.
 	 */
@@ -593,7 +584,7 @@ char * Hashify (const char * url) {
 		len = 128;
 		hashed_url[128] = '\0';
 	}
-	
+
 	for (i = 0; i < len; i++) {
 		if (((hashed_url[i] < 32) || (hashed_url[i] > 38)) &&
 			((hashed_url[i] < 43) || (hashed_url[i] > 46)) &&
@@ -601,7 +592,7 @@ char * Hashify (const char * url) {
 			((hashed_url[i] < 97) || (hashed_url[i] > 122)) &&
 			(hashed_url[i] != 0))
 			hashed_url[i] = '_';
-		
+
 		/* Cygwin doesn't seem to like anything besides a-z0-9 in filenames.
 		   Zap'em! */
 #ifdef __CYGWIN__
@@ -612,31 +603,26 @@ char * Hashify (const char * url) {
 			hashed_url[i] = '_';
 #endif
 	}
-	
+
 	return hashed_url;
 }
 
-char * genItemHash (char ** hashitems, int items) {
-	int i;
-	EVP_MD_CTX mdctx;
-	unsigned char md_value[EVP_MAX_MD_SIZE];
-	unsigned int md_len;
-	char md5_hex[33];
-
-	EVP_DigestInit(&mdctx, EVP_md5());
-	
-	for (i = 0; i < items; i++) {
-		if (hashitems[i] != NULL)
-			EVP_DigestUpdate(&mdctx, hashitems[i], (size_t) strlen(hashitems[i]));
-	}
-	
-	EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
-	EVP_MD_CTX_cleanup(&mdctx);
-	
-	for (i = 0; i < md_len; i++) {
-		sprintf(&md5_hex[2*i], "%02x", md_value[i]);
-	}
-	
+char * genItemHash (const char* const* hashitems, int items) {
+	EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
+	EVP_DigestInit(mdctx, EVP_md5());
+
+	for (int i = 0; i < items; ++i)
+		if (hashitems[i])
+			EVP_DigestUpdate (mdctx, hashitems[i], strlen(hashitems[i]));
+
+	unsigned char md_value [EVP_MAX_MD_SIZE];
+	unsigned md_len = 0;
+	EVP_DigestFinal_ex (mdctx, md_value, &md_len);
+	EVP_MD_CTX_free (mdctx);
+
+	char md5_hex [MD5_DIGEST_LENGTH*2+1];
+	for (unsigned i = 0; i < md_len; ++i)
+		sprintf (&md5_hex[2*i], "%02x", md_value[i]);
 	return strdup(md5_hex);
 }
 
@@ -646,14 +632,14 @@ int ISODateToUnix (char const * const ISODate) {
 	struct tm *t;
 	time_t tt = 0;
 	int time_unix = 0;
-	
+
 	/* Do not crash with an empty tag */
 	if (ISODate == NULL)
 		return 0;
-	
+
 	t = malloc(sizeof(struct tm));
 	gmtime_r(&tt, t);
-	
+
 	/* OpenBSD does not know %F == %Y-%m-%d
 	 * <insert inflamatory comment here> */
 	if (strptime(ISODate, "%Y-%m-%dT%T", t)) {
@@ -669,7 +655,7 @@ int ISODateToUnix (char const * const ISODate) {
 		time_unix = timegm(t);
 #endif
 	}
-	
+
 	free (t);
 	return time_unix;
 }
@@ -680,17 +666,17 @@ int pubDateToUnix (char const * const pubDate) {
 	time_t tt = 0;
 	int time_unix = 0;
 	char *oldlocale;
-	
+
 	/* Do not crash with an empty Tag */
 	if (pubDate == NULL)
 		return 0;
-	
+
 	start_here = pubDate;
 	start_here += 5;
-	
+
 	t = malloc(sizeof(struct tm));
 	gmtime_r(&tt, t);
-	
+
 #ifdef LOCALEPATH
 	/* Cruft!
 	 * Save old locale so we can parse the stupid pubDate format.
@@ -708,7 +694,7 @@ int pubDateToUnix (char const * const pubDate) {
 		setlocale(LC_TIME, "C");
 	}
 #endif
-	
+
 	if (strptime(start_here, "%d %b %Y %T", t)) {
 #ifdef __CYGWIN__
 		time_unix = mktime(t);
@@ -723,7 +709,7 @@ int pubDateToUnix (char const * const pubDate) {
 		free (oldlocale);
 	}
 #endif
-	
+
 	free (t);
 	return time_unix;
 }
@@ -736,21 +722,21 @@ char * unixToPostDateString (int unixDate) {
 	int strfstr_len = 32;
 	char tmpstr[32];
 	int age;
-	
+
 	time_str = malloc(len);
 	time_strfstr = malloc(strfstr_len);
-	
+
 	unix_t = unixDate;
 	gmtime_r(&unix_t, &t);
-	
+
 	age = calcAgeInDays(&t);
-	
+
 	strftime(time_strfstr, strfstr_len, _(", %H:%M"), &t);
 	strcpy(time_str, _("Posted "));
 	len -= strlen(_("Posted "));
 	if (len <= 0)
 		return NULL;
-	
+
 	if (age == 0) {
 		strncat(time_str, _("today"), len-1);
 		len -= strlen(_("today"));
@@ -796,15 +782,13 @@ char * unixToPostDateString (int unixDate) {
 		strncat(time_str, time_strfstr, len-1);
 	}
 	free (time_strfstr);
-	
+
 	return time_str;
 }
 
-int calcAgeInDays (struct tm * t) {
-	time_t unix_t;
+static int calcAgeInDays (const struct tm* t) {
+	time_t unix_t = time(NULL);
 	struct tm current_t;
-	
-	unix_t = time(NULL);
 	gmtime_r(&unix_t, &current_t);
 
 	/* (((current year - passed year) * 365) + current year day) - passed year day */
diff --git a/conversions.h b/conversions.h
index 6816df4..148becc 100644
--- a/conversions.h
+++ b/conversions.h
@@ -30,11 +30,11 @@ char * iconvert (const char * inbuf);
 char * iconvert (char * inbuf);
 #endif
 char * UIDejunk (char * feed_description);
-char * WrapText (char * text, int width);
+char* WrapText (const char* text, unsigned width);
 char *base64encode(char const *inbuf, unsigned int inbuf_size);
 void CleanupString (char * string, int tidyness);
 char * Hashify (const char * url);
-char * genItemHash (char ** hashitems, int items);
+char* genItemHash (const char* const* hashitems, int items);
 int ISODateToUnix (char const * const ISODate);
 int pubDateToUnix (char const * const pubDate);
 char * unixToPostDateString (int unixDate);
diff --git a/digcalc.c b/digcalc.c
index fef39a2..7a99b26 100644
--- a/digcalc.c
+++ b/digcalc.c
@@ -15,144 +15,87 @@
 #include "digcalc.h"
 #include <openssl/evp.h>
 
-
 /* calculate H(A1) as per spec */
-void DigestCalcHA1(
-    IN char * pszAlg,
-    IN char * pszUserName,
-    IN char * pszRealm,
-    IN char * pszPassword,
-    IN char * pszNonce,
-    IN char * pszCNonce,
-    OUT HASHHEX SessionKey
-    )
+void DigestCalcHA1 (const char* pszAlg, const char* pszUserName, const char* pszRealm,
+	const char* pszPassword, const char* pszNonce, const char* pszCNonce,
+	HASHHEX SessionKey)
 {
-	EVP_MD_CTX mdctx;
-	unsigned char md_value[EVP_MAX_MD_SIZE];
-	unsigned int md_len;
-	int i;
-	HASH HA1;
-	
-	EVP_DigestInit(&mdctx, EVP_md5());
-	EVP_DigestUpdate(&mdctx, pszUserName, strlen(pszUserName));
-	EVP_DigestUpdate(&mdctx, ":", 1);
-	EVP_DigestUpdate(&mdctx, pszRealm, strlen(pszRealm));
-	EVP_DigestUpdate(&mdctx, ":", 1);
-	EVP_DigestUpdate(&mdctx, pszPassword, strlen(pszPassword));
-	EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
-	EVP_MD_CTX_cleanup(&mdctx);
-	
+	EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
+	EVP_DigestInit (mdctx, EVP_md5());
+	EVP_DigestUpdate (mdctx, pszUserName, strlen(pszUserName));
+	EVP_DigestUpdate (mdctx, ":", 1);
+	EVP_DigestUpdate (mdctx, pszRealm, strlen(pszRealm));
+	EVP_DigestUpdate (mdctx, ":", 1);
+	EVP_DigestUpdate (mdctx, pszPassword, strlen(pszPassword));
+	unsigned char md_value [EVP_MAX_MD_SIZE];
+	unsigned md_len;
+	EVP_DigestFinal_ex (mdctx, md_value, &md_len);
+
 	if (strcmp(pszAlg, "md5-sess") == 0) {
-		EVP_DigestInit(&mdctx, EVP_md5());
-		EVP_DigestUpdate(&mdctx, HA1, HASHLEN);
-		EVP_DigestUpdate(&mdctx, ":", 1);
-		EVP_DigestUpdate(&mdctx, pszNonce, strlen(pszNonce));
-		EVP_DigestUpdate(&mdctx, ":", 1);
-		EVP_DigestUpdate(&mdctx, pszCNonce, strlen(pszCNonce));
-		EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
-		EVP_MD_CTX_cleanup(&mdctx);
-	};
-	
-	for (i = 0; i < md_len; i++) {
-		sprintf(&SessionKey[2*i], "%02x", md_value[i]);
+		EVP_DigestInit (mdctx, EVP_md5());
+		HASH HA1;
+		EVP_DigestUpdate (mdctx, HA1, HASHLEN);
+		EVP_DigestUpdate (mdctx, ":", 1);
+		EVP_DigestUpdate (mdctx, pszNonce, strlen(pszNonce));
+		EVP_DigestUpdate (mdctx, ":", 1);
+		EVP_DigestUpdate (mdctx, pszCNonce, strlen(pszCNonce));
+		EVP_DigestFinal_ex (mdctx, md_value, &md_len);
 	}
+	EVP_MD_CTX_free (mdctx);
+
+	for (unsigned i = 0; i < md_len; ++i)
+		sprintf (&SessionKey[2*i], "%02x", md_value[i]);
 };
 
 /* calculate request-digest/response-digest as per HTTP Digest spec */
 void DigestCalcResponse(
-    IN HASHHEX HA1,           /* H(A1) */
-    IN char * pszNonce,       /* nonce from server */
-    IN char * pszNonceCount,  /* 8 hex digits */
-    IN char * pszCNonce,      /* client nonce */
-    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
-    IN char * pszMethod,      /* method from the request */
-    IN char * pszDigestUri,   /* requested URL */
-    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
-    OUT HASHHEX Response      /* request-digest or response-digest */
+    const HASHHEX HA1,		/* H(A1) */
+    const char* pszNonce,	/* nonce from server */
+    const char* pszNonceCount,	/* 8 hex digits */
+    const char* pszCNonce,	/* client nonce */
+    const char* pszQop,		/* qop-value: "", "auth", "auth-int" */
+    const char* pszMethod,	/* method from the request */
+    const char* pszDigestUri,	/* requested URL */
+    const HASHHEX HEntity,	/* H(entity body) if qop="auth-int" */
+    HASHHEX Response		/* request-digest or response-digest */
     )
 {
-	EVP_MD_CTX mdctx;
-	HASHHEX HA2Hex;
-	unsigned char md_value[EVP_MAX_MD_SIZE];
-	unsigned int md_len;
-	int i;
-	
 	/* calculate H(A2) */
-	EVP_DigestInit(&mdctx, EVP_md5());
-	EVP_DigestUpdate(&mdctx, pszMethod, strlen(pszMethod));
-	EVP_DigestUpdate(&mdctx, ":", 1);
-	EVP_DigestUpdate(&mdctx, pszDigestUri, strlen(pszDigestUri));
+	EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
+	EVP_DigestInit (mdctx, EVP_md5());
+	EVP_DigestUpdate (mdctx, pszMethod, strlen(pszMethod));
+	EVP_DigestUpdate (mdctx, ":", 1);
+	EVP_DigestUpdate (mdctx, pszDigestUri, strlen(pszDigestUri));
 	if (strcmp(pszQop, "auth-int") == 0) {
-		EVP_DigestUpdate(&mdctx, ":", 1);
-		EVP_DigestUpdate(&mdctx, HEntity, HASHHEXLEN);
-	};
-	EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
-	EVP_MD_CTX_cleanup(&mdctx);
-	
-	for (i = 0; i < md_len; i++) {
-		sprintf(&HA2Hex[2*i], "%02x", md_value[i]);
+		EVP_DigestUpdate (mdctx, ":", 1);
+		EVP_DigestUpdate (mdctx, HEntity, HASHHEXLEN);
 	}
-	
+	unsigned char md_value [EVP_MAX_MD_SIZE];
+	unsigned md_len = 0;
+	EVP_DigestFinal_ex (mdctx, md_value, &md_len);
+
+	HASHHEX HA2Hex;
+	for (unsigned i = 0; i < md_len; ++i)
+		sprintf (&HA2Hex[2*i], "%02x", md_value[i]);
+
 	/* calculate response */
-	EVP_DigestInit(&mdctx, EVP_md5());
-	EVP_DigestUpdate(&mdctx, HA1, HASHHEXLEN);
-	EVP_DigestUpdate(&mdctx, ":", 1);
-	EVP_DigestUpdate(&mdctx, pszNonce, strlen(pszNonce));
-	EVP_DigestUpdate(&mdctx, ":", 1);
+	EVP_DigestInit (mdctx, EVP_md5());
+	EVP_DigestUpdate (mdctx, HA1, HASHHEXLEN);
+	EVP_DigestUpdate (mdctx, ":", 1);
+	EVP_DigestUpdate (mdctx, pszNonce, strlen(pszNonce));
+	EVP_DigestUpdate (mdctx, ":", 1);
 	if (*pszQop) {
-		EVP_DigestUpdate(&mdctx, pszNonceCount, strlen(pszNonceCount));
-		EVP_DigestUpdate(&mdctx, ":", 1);
-		EVP_DigestUpdate(&mdctx, pszCNonce, strlen(pszCNonce));
-		EVP_DigestUpdate(&mdctx, ":", 1);
-		EVP_DigestUpdate(&mdctx, pszQop, strlen(pszQop));
-		EVP_DigestUpdate(&mdctx, ":", 1);
+		EVP_DigestUpdate (mdctx, pszNonceCount, strlen(pszNonceCount));
+		EVP_DigestUpdate (mdctx, ":", 1);
+		EVP_DigestUpdate (mdctx, pszCNonce, strlen(pszCNonce));
+		EVP_DigestUpdate (mdctx, ":", 1);
+		EVP_DigestUpdate (mdctx, pszQop, strlen(pszQop));
+		EVP_DigestUpdate (mdctx, ":", 1);
 	};
-	EVP_DigestUpdate(&mdctx, HA2Hex, HASHHEXLEN);
-	EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
-	EVP_MD_CTX_cleanup(&mdctx);
-	
-	for (i = 0; i < md_len; i++) {
-		sprintf(&Response[2*i], "%02x", md_value[i]);
-	}
-	
-#if 0
-	/* This is the old MD5 digest calculator for a reference until I am sure
-	 * the new code works for sure */
-	/* *************************** */
-      struct MD5Context Md5Ctx;
-      HASH HA2;
-      HASH RespHash;
-      HASHHEX HA2Hex;
-
-      /* calculate H(A2) */
-      MD5Init(&Md5Ctx);
-      MD5Update(&Md5Ctx, pszMethod, strlen(pszMethod));
-      MD5Update(&Md5Ctx, ":", 1);
-      MD5Update(&Md5Ctx, pszDigestUri, strlen(pszDigestUri));
-      if (strcmp(pszQop, "auth-int") == 0) {
-            MD5Update(&Md5Ctx, ":", 1);
-            MD5Update(&Md5Ctx, HEntity, HASHHEXLEN);
-      };
-      MD5Final(HA2, &Md5Ctx);
-       CvtHex(HA2, HA2Hex);
-
-      /* calculate response */
-      MD5Init(&Md5Ctx);
-      MD5Update(&Md5Ctx, HA1, HASHHEXLEN);
-      MD5Update(&Md5Ctx, ":", 1);
-      MD5Update(&Md5Ctx, pszNonce, strlen(pszNonce));
-      MD5Update(&Md5Ctx, ":", 1);
-      if (*pszQop) {
+	EVP_DigestUpdate (mdctx, HA2Hex, HASHHEXLEN);
+	EVP_DigestFinal_ex (mdctx, md_value, &md_len);
+	EVP_MD_CTX_free (mdctx);
 
-          MD5Update(&Md5Ctx, pszNonceCount, strlen(pszNonceCount));
-          MD5Update(&Md5Ctx, ":", 1);
-          MD5Update(&Md5Ctx, pszCNonce, strlen(pszCNonce));
-          MD5Update(&Md5Ctx, ":", 1);
-          MD5Update(&Md5Ctx, pszQop, strlen(pszQop));
-          MD5Update(&Md5Ctx, ":", 1);
-      };
-      MD5Update(&Md5Ctx, HA2Hex, HASHHEXLEN);
-      MD5Final(RespHash, &Md5Ctx);
-      CvtHex(RespHash, Response);
-#endif
+	for (unsigned i = 0; i < md_len; ++i)
+		sprintf (&Response[2*i], "%02x", md_value[i]);
 };
diff --git a/digcalc.h b/digcalc.h
index e17cdde..86d1cb2 100644
--- a/digcalc.h
+++ b/digcalc.h
@@ -18,36 +18,23 @@
 typedef char HASH[HASHLEN];
 #define HASHHEXLEN 32
 typedef char HASHHEX[HASHHEXLEN+1];
-#define IN
-#define OUT
 
 /* calculate H(A1) as per HTTP Digest spec */
-void DigestCalcHA1(
-    IN char * pszAlg,
-    IN char * pszUserName,
-    IN char * pszRealm,
-    IN char * pszPassword,
-    IN char * pszNonce,
-    IN char * pszCNonce,
-    OUT HASHHEX SessionKey
-    );
+void DigestCalcHA1 (const char* pszAlg, const char* pszUserName, const char* pszRealm,
+			const char* pszPassword, const char* pszNonce, const char* pszCNonce,
+			HASHHEX SessionKey);
 
 /* calculate request-digest/response-digest as per HTTP Digest spec */
-void DigestCalcResponse(
-    IN HASHHEX HA1,           /* H(A1) */
-    IN char * pszNonce,       /* nonce from server */
-    IN char * pszNonceCount,  /* 8 hex digits */
-    IN char * pszCNonce,      /* client nonce */
-    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
-    IN char * pszMethod,      /* method from the request */
-    IN char * pszDigestUri,   /* requested URL */
-    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
-    OUT HASHHEX Response      /* request-digest or response-digest */
-    );
-
-void CvtHex(
-    IN HASH Bin,
-    OUT HASHHEX Hex
+void DigestCalcResponse (
+    const HASHHEX HA1,		/* H(A1) */
+    const char* pszNonce,	/* nonce from server */
+    const char* pszNonceCount,	/* 8 hex digits */
+    const char* pszCNonce,	/* client nonce */
+    const char* pszQop,		/* qop-value: "", "auth", "auth-int" */
+    const char* pszMethod,	/* method from the request */
+    const char* pszDigestUri,	/* requested URL */
+    const HASHHEX HEntity,	/* H(entity body) if qop="auth-int" */
+    HASHHEX Response		/* request-digest or response-digest */
     );
 
 #endif
diff --git a/interface.c b/interface.c
index 1fa7a1e..5e798d3 100644
--- a/interface.c
+++ b/interface.c
@@ -67,7 +67,7 @@ struct scrolltext {
 };
 
 #ifdef SIGWINCH
-void sig_winch(int p)
+void sig_winch (int p __attribute__((unused)))
 {
 	resize_dirty = 1;
 }
diff --git a/main.c b/main.c
index c031912..0318178 100644
--- a/main.c
+++ b/main.c
@@ -155,15 +155,9 @@ void MainSignalHandler (int sig) {
 }
 
 /* Automatic child reaper. */
-void sigChildHandler (int sig) {
-	int status, child_val;
-
+static void sigChildHandler (int sig __attribute__((unused))) {
 	/* Wait for any child without blocking */
-	if (waitpid(-1, &status, WNOHANG) < 0)
-			return;
-
-	if (WIFEXITED(status))
-		child_val = WEXITSTATUS(status);
+	waitpid (-1, NULL, WNOHANG);
 }
 
 void printHelp (void) {
diff --git a/netio.c b/netio.c
index 5d3bae0..4a08e1e 100644
--- a/netio.c
+++ b/netio.c
@@ -129,7 +129,7 @@ int NetPoll (struct feed * cur_ptr, int * my_socket, int rw) {
  *	0	Connected
  *	-1	Error occured (netio_error is set)
  */
-int NetConnect (int * my_socket, char * host, struct feed * cur_ptr, int httpproto, int suppressoutput) {
+int NetConnect (int * my_socket, char * host, struct feed * cur_ptr, int httpproto __attribute__((unused)), int suppressoutput) {
 	char tmp[512];
 	struct sockaddr_in address;	
 	struct hostent *remotehost;
diff --git a/os-support.c b/os-support.c
index a590a58..8b61f35 100644
--- a/os-support.c
+++ b/os-support.c
@@ -39,7 +39,7 @@
  * The following function was written by François Gouget.
  */
 #ifdef SUN
-char* strsep(char** str, const char* delims)
+char* strsep (char** str, const char* delims)
 {
     char* token;
 
@@ -93,29 +93,21 @@ time_t timegm(struct tm *t)
 #endif
 
 /* strcasestr stolen from: http://www.unixpapa.com/incnote/string.html */
-char *s_strcasestr(char *a, char *b) {
-	size_t l;
+const char* s_strcasestr (const char* a, const char* b) {
+	const size_t lena = strlen(a), lenb = strlen(b);
 	char f[3];
-	int lena = strlen(a);
-	int lenb = strlen(b);
-	
 	snprintf(f, sizeof(f), "%c%c", tolower(*b), toupper(*b));
-	for (l = strcspn(a, f); l != lena; l += strcspn(a + l + 1, f) + 1)
+	for (size_t l = strcspn(a, f); l != lena; l += strcspn(a + l + 1, f) + 1)
 		if (strncasecmp(a + l, b, lenb) == 0)
-			return(a + l);
-	return(NULL);
+			return a + l;
+	return NULL;
 }
 
 
 /* Private malloc wrapper. Aborts program execution if malloc fails. */
-void * s_malloc (size_t size) {
-	void *newmem;
-	
-	newmem = malloc (size);
-	
-	if (newmem == NULL) {
+void* s_malloc (size_t size) {
+	void* newmem = malloc (size);
+	if (!newmem)
 		MainQuit ("Allocating memory", strerror(errno));
-	}
-	
 	return newmem;
 }
diff --git a/os-support.h b/os-support.h
index 3eb1068..d5ef6a1 100644
--- a/os-support.h
+++ b/os-support.h
@@ -27,10 +27,10 @@
 #define OS_SUPPORT_H
 
 #ifdef SUN
-char* strsep(char** str, const char* delims);
+char* strsep (char** str, const char* delims);
 #endif
 
-char *s_strcasestr(char *a, char *b);
-void * s_malloc (size_t size);
+const char* s_strcasestr (const char* a, const char* b);
+void* s_malloc (size_t size);
 
 #endif
diff --git a/ui-support.c b/ui-support.c
index cc56c8e..c498833 100644
--- a/ui-support.c
+++ b/ui-support.c
@@ -223,7 +223,7 @@ void UISupportDrawHeader (const char * headerstring) {
 	
 	mvprintw (0, 1, "* Snownews %s", VERSION);
 	if (headerstring != NULL) {
-		if (strlen(headerstring) > COLS-18)
+		if (strlen(headerstring) > COLS-18u)
 			mvaddnstr (0, 19, headerstring, COLS-20);
 		else
 			mvaddstr (0, COLS-strlen(headerstring)-1, headerstring);
diff --git a/updatecheck.c b/updatecheck.c
index e7b55a7..cf328eb 100644
--- a/updatecheck.c
+++ b/updatecheck.c
@@ -45,7 +45,6 @@ void AutoVersionCheck (void) {
 	int oldtime;
 	char *versionstring = NULL;
 	char *url;
-	char *freeme;
 	
 	update = newFeedStruct();
 	
@@ -77,7 +76,6 @@ void AutoVersionCheck (void) {
 	
 	url = strdup ("http://kiza.kcore.de/software/snownews/version");
 	update->feedurl = strdup(url);
-	freeme = url;
 	versionstring = DownloadFeed (url, update, 1);
 	free (url);
 	
diff --git a/xmlparse.c b/xmlparse.c
index ef93745..11241fb 100644
--- a/xmlparse.c
+++ b/xmlparse.c
@@ -183,7 +183,6 @@ void parse_rdf10_item(struct feed *feed, xmlDocPtr doc, xmlNodePtr node)
 {
 	xmlNodePtr cur;
 	xmlChar *readstatusstring;
-	char **hashitems = NULL;
 	char *guid = NULL;
 	char *date_str = NULL;
 	struct newsitem *item;
@@ -277,14 +276,9 @@ void parse_rdf10_item(struct feed *feed, xmlDocPtr doc, xmlNodePtr node)
 	   <guid> is not saved in the cache, thus we would generate a different
 	   hash than the one from the live feed. */
 	if (item->data->hash == NULL) {
-		hashitems = malloc (sizeof(char *) * 4);
-		hashitems[0] = item->data->title;
-		hashitems[1] = item->data->link;
-		hashitems[2] = guid;
-		hashitems[3] = NULL;
+		const char* hashitems[] = { item->data->title, item->data->link, guid, NULL };
 		item->data->hash = genItemHash (hashitems, 3);
 		xmlFree (guid);
-		free (hashitems);
 	}
 	
 	/* If saverestore == 1, restore readstatus. */
diff --git a/zlib_interface.c b/zlib_interface.c
index 9a9b325..12cdf45 100644
--- a/zlib_interface.c
+++ b/zlib_interface.c
@@ -26,7 +26,7 @@
 #include <zlib.h>
 #include <string.h>
 
-int JG_ZLIB_DEBUG = 0;
+static const int JG_ZLIB_DEBUG = 0;
 
 struct gzip_header {
 	unsigned char magic[2];
@@ -50,33 +50,33 @@ int jg_zlib_uncompress(void const *in_buf, int in_size,
 	z_stream stream;
 	char *out_buf = NULL;
 	int out_buf_bytes = 0;
-	char tmp_buf[4096];
+	unsigned char tmp_buf[4096];
 	int result;
 	int new_bytes;
-	
+
 	/* Prepare the stream structure. */
 	stream.zalloc = NULL;
 	stream.zfree = NULL;
 	stream.opaque = NULL;
-	stream.next_in = (void *)in_buf;	
+	stream.next_in = (void*) in_buf;
 	stream.avail_in = in_size;
 	stream.next_out = tmp_buf;
 	stream.avail_out = sizeof tmp_buf;
-	
+
 	if (out_size != NULL)
 		*out_size = 0;
-	
+
 	if (gzip)
 		result = inflateInit2(&stream, MAX_WBITS + 32); /* UNTESTED */
 	else
 		result = inflateInit2(&stream, -MAX_WBITS);
-	
+
 	if (result != 0) {
 		if (JG_ZLIB_DEBUG)
 			fprintf(stderr, "inflateInit2 failed: %d\n", result);
 		return JG_ZLIB_ERROR_OLDVERSION;
 	}
-	
+
 	do {
 		/* Should be Z_FINISH? */
 		result = inflate(&stream, Z_NO_FLUSH);
@@ -84,6 +84,7 @@ int jg_zlib_uncompress(void const *in_buf, int in_size,
 			case Z_BUF_ERROR:
 				if (stream.avail_in == 0)
 					goto DONE; /* zlib bug */
+				/* fallthrough */
 			case Z_ERRNO:
 			case Z_NEED_DICT:
 			case Z_MEM_ERROR:
@@ -114,19 +115,19 @@ int jg_zlib_uncompress(void const *in_buf, int in_size,
 			return JG_ZLIB_ERROR_NODATA;
 		}
 	} while (result != Z_STREAM_END);
-	
+
 DONE:
-	
+
 	inflateEnd(&stream);
-	
+
 	/* Null-terminate the output buffer so it can be handled like a string. */
 	out_buf = realloc(out_buf, out_buf_bytes + 1);
 	out_buf[out_buf_bytes] = 0;
-	
+
 	/* The returned size does NOT include the additionall null byte! */
 	if (out_size != NULL)
 		*out_size = out_buf_bytes;
-	
+
 	*out_buf_ptr = out_buf;
 
 	return 0;
@@ -141,24 +142,24 @@ int jg_gzip_uncompress(void const *in_buf, int in_size,
 	struct gzip_header const *header;
 	char *data_start;
 	int offset = sizeof *header;
-	
+
 	header = in_buf;
-	
+
 	if (out_size != NULL)
 		*out_size = 0;
-	
+
 	if ((header->magic[0] != 0x1F) || (header->magic[1] != 0x8B)) {
 		if (JG_ZLIB_DEBUG)
 			fprintf(stderr, "ERROR: Invalid magic bytes for GZIP data\n");
 		return JG_ZLIB_ERROR_BAD_MAGIC;
 	}
-	
+
 	if (header->method != 8) {
 		if (JG_ZLIB_DEBUG)
 			fprintf(stderr, "ERROR: Compression method is not deflate\n");
 		return JG_ZLIB_ERROR_BAD_METHOD;
 	}
-	
+
 	if (header->flags != 0 && header->flags != 8) {
 		if (JG_ZLIB_DEBUG) {
 			snprintf (tmpstring, sizeof(tmpstring), "ERROR: Unsupported flags %d", header->flags);
@@ -166,7 +167,7 @@ int jg_gzip_uncompress(void const *in_buf, int in_size,
 		}
 		return JG_ZLIB_ERROR_BAD_FLAGS;
 	}
-	
+
 	if (header->flags & 8) {
 		/* skip the file name */
 		while (offset < in_size) {
@@ -177,7 +178,7 @@ int jg_gzip_uncompress(void const *in_buf, int in_size,
 			offset++;
 		}
 	}
-	
+
 	data_start = (char *)in_buf + offset;
 
 	return jg_zlib_uncompress(data_start, in_size - offset - 8, 
diff --git a/zlib_interface.h b/zlib_interface.h
index 4644284..cc6f62d 100644
--- a/zlib_interface.h
+++ b/zlib_interface.h
@@ -32,8 +32,6 @@ enum JG_ZLIB_ERROR {
 	JG_ZLIB_ERROR_BAD_FLAGS = -6
 };
 
-extern int JG_ZLIB_DEBUG;
-
 int jg_zlib_uncompress(void const *in_buf, int in_size, 
                        void **out_buf_ptr, int *out_size,
                        int gzip);   
--- ./configure.orig	2018-10-30 09:16:43.691589791 +0000
+++ ./configure	2018-10-30 10:02:13.380306557 +0000
@@ -12,7 +12,7 @@
 chomp($xmlldflags);
 
 my $prefix = "/usr/local";
-my $cflags = "-Wall -Wno-format-y2k -O2 -DLOCALEPATH=\"\\\"\$(LOCALEPATH)\\\"\" -DOS=\\\"$os\\\" $xmlcflags \$(EXTRA_CFLAGS) ";
+my $cflags = "-Wall -O2 -DLOCALEPATH=\"\\\"\$(LOCALEPATH)\\\"\" -DOS=\\\"$os\\\" $xmlcflags \$(EXTRA_CFLAGS) ";
 my $ldflags = "-lintl -lncursesw -lcrypto $xmlldflags \$(EXTRA_LDFLAGS) ";
 
 my $use_nls = 1;
