diff --git a/Makefile.defs b/Makefile.defs
index 480a3f8..327eeb9 100644
--- a/Makefile.defs
+++ b/Makefile.defs
@@ -273,6 +273,7 @@ CC_LONGVER:=$(shell if  $(CC) -v 2>/dev/null; then \
 					else \
 						$(CC) -V 2>&1 ; \
 					fi )
+CC_OPT ?= -O9
 MKTAGS=ctags
 
 #find-out the compiler's name
@@ -334,6 +335,7 @@ ifneq (, $(findstring clang, $(CC_LONGVER)))
 	CC_FULLVER:=$(shell echo "$(CC_LONGVER)" | head -n 1 |  sed -e 's/.*version \([0-9]\.[0-9]\).*/\1/g' )
 	CC_SHORTVER:=$(shell echo "$(CC_FULLVER)" | cut -d. -f1,2 )
 	CC_VER=$(CC) $(CC_FULLVER)
+	CC_OPT=-O3
 	MKDEP=$(CC) -MM 
 endif
 
@@ -887,7 +889,7 @@ ifeq	($(ARCH), i386)
 ifeq		($(CC_NAME), gcc) 
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS=-g -O9 -funroll-loops  -Wcast-align $(PROFILE)
+				CFLAGS=-g $(CC_OPT) -funroll-loops  -Wcast-align $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 $(call				set_if_empty,CPU,athlon64)
@@ -945,8 +947,8 @@ ifeq		($(CC_NAME), clang)
 $(call                          set_if_empty,CPU,athlon64)
 					C_DEFS+=-DCC_GCC_LIKE_ASM
                                         CFLAGS+=-m32
-                                                -O9      \
-                                                         \
+                                                $(CC_OPT) \
+                                                          \
                                                 -mtune=$(CPU)
                                         LDFLAGS+=-m32
 else			# CC_NAME, clang
@@ -972,7 +974,7 @@ ifeq	($(ARCH), x86_64)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS=-g -O9 -funroll-loops  -Wcast-align $(PROFILE)
+				CFLAGS=-g $(CC_OPT) -funroll-loops  -Wcast-align $(PROFILE)
 			#if gcc 4.5+
 			# don't add '-mtune=$(CPU)' - gcc failure
 ifeq			($(CC_SHORTVER), 4.5+)
@@ -1041,7 +1043,7 @@ ifeq            ($(CC_NAME), clang)
 $(call                          set_if_empty,CPU,opteron)
 					C_DEFS+=-DCC_GCC_LIKE_ASM
                                         CFLAGS+=-m64 \
-                                                -O9        
+                                                $(CC_OPT)        
                                         LDFLAGS+=-m64
 else      	# CC_NAME, clang
 ifeq		($(CC_NAME), icc)
@@ -1066,7 +1068,7 @@ ifeq	($(ARCH), sparc64)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM -DSPARC64_MODE
 				#common stuff
-				CFLAGS=-g -O9 -funroll-loops  $(PROFILE) \
+				CFLAGS=-g $(CC_OPT) -funroll-loops  $(PROFILE) \
 					#-Wcast-align \
 					#-Wmissing-prototypes 
 				#if gcc 4.5+ or 4.2+
@@ -1157,7 +1159,7 @@ ifeq	($(ARCH), sparc)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS=-g -O9 -funroll-loops  $(PROFILE) \
+				CFLAGS=-g $(CC_OPT) -funroll-loops  $(PROFILE) \
 					#-Wcast-align \
 					#-Wmissing-prototypes 
 				#if gcc 4.5+ or 4.2+
@@ -1222,7 +1224,7 @@ ifeq	($(ARCH), arm)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS=-marm -march=armv5t -O9 -funroll-loops -fsigned-char $(PROFILE)
+				CFLAGS=-marm -march=armv5t $(CC_OPT) -funroll-loops -fsigned-char $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 					CFLAGS+= -ftree-vectorize -fno-strict-overflow
@@ -1270,7 +1272,7 @@ ifeq	($(ARCH), arm6)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS=-march=armv6 -O9 -funroll-loops -fsigned-char \
+				CFLAGS=-march=armv6 $(CC_OPT) -funroll-loops -fsigned-char \
 						$(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
@@ -1317,7 +1319,7 @@ ifeq	($(ARCH), mips)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS=-O9 -funroll-loops  $(PROFILE)
+				CFLAGS=$(CC_OPT) -funroll-loops  $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 					CFLAGS+=-march=r3000 -minline-all-stringops \
@@ -1364,7 +1366,7 @@ ifeq	($(ARCH), mips2)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS= -mips2 -O9 -funroll-loops $(PROFILE)
+				CFLAGS= -mips2 $(CC_OPT) -funroll-loops $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 					CFLAGS+=-minline-all-stringops -ftree-vectorize \
@@ -1409,7 +1411,7 @@ ifeq	($(ARCH), mips64)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS= -mips64 -O9 -funroll-loops $(PROFILE)
+				CFLAGS= -mips64 $(CC_OPT) -funroll-loops $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 					CFLAGS+=-minline-all-stringops -ftree-vectorize \
@@ -1454,7 +1456,7 @@ ifeq	($(ARCH), alpha)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS= -O9 -funroll-loops $(PROFILE)
+				CFLAGS= $(CC_OPT) -funroll-loops $(PROFILE)
 			#if gcc 4.5 or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 					CFLAGS+= -fno-strict-overflow
@@ -1500,7 +1502,7 @@ ifeq	($(ARCH), ppc)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS= -O9 -funroll-loops -fsigned-char $(PROFILE)
+				CFLAGS= $(CC_OPT) -funroll-loops -fsigned-char $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 $(call				set_if_empty,CPU,powerpc)
@@ -1549,7 +1551,7 @@ ifeq	($(ARCH), ppc64)
 ifeq		($(CC_NAME), gcc)
 				C_DEFS+=-DCC_GCC_LIKE_ASM
 				#common stuff
-				CFLAGS= -O9 -funroll-loops -fsigned-char $(PROFILE)
+				CFLAGS= $(CC_OPT) -funroll-loops -fsigned-char $(PROFILE)
 			#if gcc 4.5+ or 4.2+
 ifeq (,$(strip $(filter-out 4.2+ 4.5+,$(CC_SHORTVER))))
 $(call				set_if_empty,CPU,powerpc64)
diff --git a/Makefile.groups b/Makefile.groups
index d1cad86..30f2f17 100644
--- a/Makefile.groups
+++ b/Makefile.groups
@@ -13,7 +13,7 @@ mod_list_basic=async auth benchmark blst cfg_rpc cfgutils corex counters \
 				   mediaproxy mi_datagram mi_fifo mi_rpc mqueue \
 				   nat_traversal nathelper path pike pv ratelimit rr rtimer \
 				   rtpproxy sanity sdpops siputils sl statistics textops \
-				   textopsx tm tmx topoh xlog rtpproxy-ng stun
+				   textopsx tm tmx topoh xlog rtpproxy-ng stun sipt
 
 # - extra used modules, with no extra dependency
 mod_list_extra=avp auth_diameter call_control cnxcc dmq domainpolicy msrp pdb \
@@ -23,7 +23,7 @@ mod_list_extra=avp auth_diameter call_control cnxcc dmq domainpolicy msrp pdb \
 # - common modules depending on database
 mod_list_db=acc alias_db auth_db avpops cfg_db db_text db_flatstore \
 			  db_cluster dialog dispatcher domain drouting group \
-			  htable imc matrix msilo mtree p_usrloc pdt permissions \
+			  htable imc matrix mohqueue msilo mtree p_usrloc pdt permissions \
 			  pipelimit prefix_route registrar sipcapture siptrace speeddial \
 			  sqlops uac uri_db userblacklist usrloc
 
@@ -154,6 +154,9 @@ mod_list_java=app_java
 # - modules depending on iptables library
 mod_list_iptrtpproxy=iptrtpproxy
 
+# - modules depending on gzip library
+mod_list_gzcompress=gzcompress
+
 # - all modules
 mod_list_all=$(sort $(mod_list_basic) $(mod_list_extra) \
 			   $(mod_list_db) $(mod_list_dbuid) \
@@ -175,7 +178,8 @@ mod_list_all=$(sort $(mod_list_basic) $(mod_list_extra) \
 			   $(mod_list_iptrtpproxy) $(mod_list_mi_xmlrpc) \
 			   $(mod_list_outbound) $(mod_list_osp) \
 			   $(mod_list_java) $(mod_list_dnssec) \
-			   $(mod_list_sctp) $(mod_list_autheph))
+			   $(mod_list_sctp) $(mod_list_autheph) \
+			   $(mod_list_gzcompress))
 
 
 
@@ -333,6 +337,9 @@ module_group_ksctp=$(mod_list_sctp)
 # pkg auth_ephemeral module
 module_group_kautheph=$(mod_list_autheph)
 
+# pkg gzcompress module
+module_group_kgzcompress=$(mod_list_gzcompress)
+
 # list of static modules
 #
 static_modules:=
diff --git a/dset.c b/dset.c
index 13b000b..4b886bd 100644
--- a/dset.c
+++ b/dset.c
@@ -90,7 +90,7 @@ branch_t *get_sip_branch(int idx)
 		return NULL;
 	if(idx<0)
 	{
-		if(nr_branches + idx >= 0)
+		if((int)nr_branches + idx >= 0)
 			return &branches[nr_branches+idx];
 		return NULL;
 	}
@@ -109,7 +109,7 @@ int drop_sip_branch(int idx)
 {
 	if(nr_branches==0 || idx>=nr_branches)
 		return 0;
-	if(idx<0 && nr_branches+idx<0)
+	if(idx<0 && (int)nr_branches+idx<0)
 		return 0;
 	/* last branch */
 	if(idx==nr_branches-1)
diff --git a/flags.c b/flags.c
index 1523d0b..becb569 100644
--- a/flags.c
+++ b/flags.c
@@ -74,7 +74,7 @@ int flag_in_range( flag_t flag ) {
 			flag, MAX_FLAG );
 		return 0;
 	}
-	if (flag<0) {
+	if ((int)flag<0) {
 		LOG(L_ERR, "ERROR: message flag (%d) must be in range %d..%d\n",
 			flag, 0, MAX_FLAG );
 		return 0;
diff --git a/mem/q_malloc.c b/mem/q_malloc.c
index 50acab9..8c36d03 100644
--- a/mem/q_malloc.c
+++ b/mem/q_malloc.c
@@ -473,6 +473,12 @@ void qm_free(struct qm_block* qm, void* p)
 	MDBG("qm_free: freeing frag. %p alloc'ed from %s: %s(%ld)\n",
 			f, f->file, f->func, f->line);
 #endif
+	if (unlikely(f->u.is_free)){
+		LM_INFO("freeing a free fragment (%p/%p) - ignore\n",
+				f, p);
+		return;
+	}
+
 	size=f->size;
 	qm->used-=size;
 	qm->real_used-=size;
diff --git a/modules/avpops/avpops_parse.c b/modules/avpops/avpops_parse.c
index 3a16f18..3a6c5ec 100644
--- a/modules/avpops/avpops_parse.c
+++ b/modules/avpops/avpops_parse.c
@@ -129,6 +129,14 @@ int parse_avp_db(char *s, struct db_param *dbp, int allow_scheme)
 				goto error;
 			}
 		}
+		/* no pv to lookup, create one to store flags details */
+		dbp->a.u.sval = (pv_spec_t*)pkg_malloc(sizeof(pv_spec_t));
+		if(dbp->a.u.sval==NULL)
+		{
+			LM_ERR("no more pkg\n");
+			goto error;
+		}
+		memset(dbp->a.u.sval, 0, sizeof(pv_spec_t));
 		dbp->a.u.sval->pvp.pvn.u.isname.type |= (flags<<8)&0xff00;
 		dbp->a.type = AVPOPS_VAL_NONE;
 	} else {
diff --git a/modules/dialog_ng/dlg_handlers.c b/modules/dialog_ng/dlg_handlers.c
index 262e923..93a00c7 100644
--- a/modules/dialog_ng/dlg_handlers.c
+++ b/modules/dialog_ng/dlg_handlers.c
@@ -905,9 +905,9 @@ int dlg_new_dialog(struct sip_msg *req, struct cell *t, const int run_initial_cb
     if (populate_leg_info(dlg, req, t, DLG_CALLER_LEG,
             &(get_from(req)->tag_value)) != 0) {
         LM_ERR("could not add further info to the dialog\n");
-        shm_free(dlg);
         lock_destroy(dlg->dlg_out_entries_lock);
         lock_dealloc(dlg->dlg_out_entries_lock);
+        shm_free(dlg);
         return -1;
     }
 
diff --git a/modules/registrar/save.c b/modules/registrar/save.c
index fc5d564..caa81df 100644
--- a/modules/registrar/save.c
+++ b/modules/registrar/save.c
@@ -95,7 +95,7 @@ static inline int star(sip_msg_t *_m, udomain_t* _d, str* _a, str *_h)
 {
 	urecord_t* r;
 	ucontact_t* c;
-	
+
 	ul.lock_udomain(_d, _a);
 
 	if (!ul.get_urecord(_d, _a, &r)) {
@@ -114,11 +114,11 @@ static inline int star(sip_msg_t *_m, udomain_t* _d, str* _a, str *_h)
 
 	if (ul.delete_urecord(_d, _a, r) < 0) {
 		LM_ERR("failed to remove record from usrloc\n");
-		
-		     /* Delete failed, try to get corresponding
-		      * record structure and send back all existing
-		      * contacts
-		      */
+
+		/* Delete failed, try to get corresponding
+		 * record structure and send back all existing
+		 * contacts
+		 */
 		rerrno = R_UL_DEL_R;
 		if (!ul.get_urecord(_d, _a, &r)) {
 			build_contact(_m, r->contacts, _h);
@@ -133,7 +133,7 @@ static inline int star(sip_msg_t *_m, udomain_t* _d, str* _a, str *_h)
 
 
 /*! \brief
- */
+*/
 static struct socket_info *get_sock_val(struct sip_msg *msg)
 {
 	struct socket_info *sock;
@@ -179,10 +179,10 @@ static struct socket_info *get_sock_val(struct sip_msg *msg)
 		socks = vavp->val.v.s;
 	}
 	if (parse_phostport( socks.s, &hosts.s, &hosts.len,
-	&port, &proto)!=0) {
+				&port, &proto)!=0) {
 		socks.s[socks.len] = c;
 		LM_ERR("bad socket <%.*s> in \n",
-			socks.len, socks.s);
+				socks.len, socks.s);
 		return 0;
 	}
 	if(sock_hdr_name.len>0 && c!=0) {
@@ -211,7 +211,7 @@ static inline int no_contacts(sip_msg_t *_m, udomain_t* _d, str* _a, str* _h)
 {
 	urecord_t* r;
 	int res;
-	
+
 	ul.lock_udomain(_d, _a);
 	res = ul.get_urecord(_d, _a, &r);
 	if (res < 0) {
@@ -220,7 +220,7 @@ static inline int no_contacts(sip_msg_t *_m, udomain_t* _d, str* _a, str* _h)
 		ul.unlock_udomain(_d, _a);
 		return -1;
 	}
-	
+
 	if (res == 0) {  /* Contacts found */
 		build_contact(_m, r->contacts, _h);
 		ul.release_urecord(r);
@@ -280,7 +280,7 @@ static inline ucontact_info_t* pack_ci( struct sip_msg* _m, contact_t* _c, unsig
 
 		/* set tcp connection id */
 		if (_m->rcv.proto==PROTO_TCP || _m->rcv.proto==PROTO_TLS
-		        || _m->rcv.proto==PROTO_WS  || _m->rcv.proto==PROTO_WSS) {
+				|| _m->rcv.proto==PROTO_WS  || _m->rcv.proto==PROTO_WSS) {
 			ci.tcpconn_id = _m->rcv.proto_reserved1;
 		} else {
 			ci.tcpconn_id = -1;
@@ -288,7 +288,7 @@ static inline ucontact_info_t* pack_ci( struct sip_msg* _m, contact_t* _c, unsig
 
 		/* additional info from message */
 		if (parse_headers(_m, HDR_USERAGENT_F, 0) != -1 && _m->user_agent &&
-		_m->user_agent->body.len>0 && _m->user_agent->body.len<MAX_UA_SIZE) {
+				_m->user_agent->body.len>0 && _m->user_agent->body.len<MAX_UA_SIZE) {
 			ci.user_agent = &_m->user_agent->body;
 		} else {
 			ci.user_agent = &no_ua;
@@ -379,8 +379,8 @@ static inline ucontact_info_t* pack_ci( struct sip_msg* _m, contact_t* _c, unsig
 				if (received_found==0) {
 					memset(&val, 0, sizeof(int_str));
 					if (rcv_avp_name.n!=0
-								&& search_first_avp(rcv_avp_type, rcv_avp_name, &val, 0)
-								&& val.s.len > 0) {
+							&& search_first_avp(rcv_avp_type, rcv_avp_name, &val, 0)
+							&& val.s.len > 0) {
 						if (val.s.len>RECEIVED_MAX_SIZE) {
 							rerrno = R_CONTACT_LEN;
 							LM_ERR("received too long\n");
@@ -574,13 +574,13 @@ error:
 
 
 static int test_max_contacts(struct sip_msg* _m, urecord_t* _r, contact_t* _c,
-										ucontact_info_t *ci, int mc)
+		ucontact_info_t *ci, int mc)
 {
 	int num;
 	int e;
 	ucontact_t* ptr, *cont;
 	int ret;
-	
+
 	num = 0;
 	ptr = _r->contacts;
 	while(ptr) {
@@ -590,7 +590,7 @@ static int test_max_contacts(struct sip_msg* _m, urecord_t* _r, contact_t* _c,
 		ptr = ptr->next;
 	}
 	LM_DBG("%d valid contacts\n", num);
-	
+
 	for( ; _c ; _c = get_next_contact(_c) ) {
 		/* calculate expires */
 		calc_contact_expires(_m, _c->expires, &e);
@@ -610,7 +610,7 @@ static int test_max_contacts(struct sip_msg* _m, urecord_t* _r, contact_t* _c,
 			if (e == 0) num--;
 		}
 	}
-	
+
 	LM_DBG("%d contacts after commit\n", num);
 	if (num > mc) {
 		LM_INFO("too many contacts for AOR <%.*s>\n", _r->aor.len, _r->aor.s);
@@ -668,7 +668,7 @@ static inline int update_contacts(struct sip_msg* _m, urecord_t* _r, int _mode,
 
 #ifdef USE_TCP
 	if ( (_m->flags&tcp_persistent_flag) &&
-	(_m->rcv.proto==PROTO_TCP||_m->rcv.proto==PROTO_TLS||_m->rcv.proto==PROTO_WS||_m->rcv.proto==PROTO_WSS)) {
+			(_m->rcv.proto==PROTO_TCP||_m->rcv.proto==PROTO_TLS||_m->rcv.proto==PROTO_WS||_m->rcv.proto==PROTO_WSS)) {
 		e_max = -1;
 		tcp_check = 1;
 	} else {
@@ -756,15 +756,15 @@ static inline int update_contacts(struct sip_msg* _m, urecord_t* _r, int _mode,
 				/* If call-id has changed then delete all records with this sip.instance
 				   then insert new record */
 				if (ci->instance.s != NULL &&
-					(ci->callid->len != c->callid.len ||
-						strncmp(ci->callid->s, c->callid.s, ci->callid->len) != 0))
+						(ci->callid->len != c->callid.len ||
+						 strncmp(ci->callid->s, c->callid.s, ci->callid->len) != 0))
 				{
 					ptr = _r->contacts;
 					while (ptr)
 					{
 						ptr0 = ptr->next;
 						if ((ptr != c) && ptr->instance.len == c->instance.len &&
-							strncmp(ptr->instance.s, c->instance.s, ptr->instance.len) == 0)
+								strncmp(ptr->instance.s, c->instance.s, ptr->instance.len) == 0)
 						{
 							ul.delete_ucontact(_r, ptr);
 						}
@@ -912,12 +912,12 @@ int save(struct sip_msg* _m, udomain_t* _d, int _cflags, str *_uri)
 	}
 
 	if (reg_outbound_mode != REG_OUTBOUND_NONE
-		&& !(parse_headers(_m, HDR_VIA2_F, 0) == -1 || _m->via2 == 0
-			|| _m->via2->error != PARSE_OK)) {
+			&& !(parse_headers(_m, HDR_VIA2_F, 0) == -1 || _m->via2 == 0
+				|| _m->via2->error != PARSE_OK)) {
 		/* Outbound supported on server, and more than one Via: - not the first hop */
 
 		if (!(parse_headers(_m, HDR_PATH_F, 0) == -1 || _m->path == 0)) {
-		        route = (rr_t *)0;
+			route = (rr_t *)0;
 			if (parse_rr_body(_m->path->body.s, _m->path->body.len, &route) < 0) {
 				LM_ERR("Failed to parse Path: header body\n");
 				goto error;
@@ -949,7 +949,7 @@ int save(struct sip_msg* _m, udomain_t* _d, int _cflags, str *_uri)
 
 		if ((use_ob == 0) && (reg_regid_mode == REG_REGID_OUTBOUND)) {
 			if ((get_supported(_m) & F_OPTION_TAG_OUTBOUND)
-			    && contact->reg_id) {
+					&& contact->reg_id) {
 				LM_WARN("Outbound used by UAC but not supported by edge proxy\n");
 				rerrno = R_OB_UNSUP_EDGE;
 				goto error;
@@ -959,7 +959,7 @@ int save(struct sip_msg* _m, udomain_t* _d, int _cflags, str *_uri)
 			}
 		}
 	}
-	
+
 	get_act_time();
 	c = get_first_contact(_m);
 
@@ -1012,9 +1012,9 @@ int unregister(struct sip_msg* _m, udomain_t* _d, str* _uri, str *_ruid)
 	if (_ruid == NULL) {
 		/* No ruid provided - remove all contacts for aor */
 
-	        if (extract_aor(_uri, &aor, NULL) < 0) {
-		        LM_ERR("failed to extract Address Of Record\n");
-		        return -1;
+		if (extract_aor(_uri, &aor, NULL) < 0) {
+			LM_ERR("failed to extract Address Of Record\n");
+			return -1;
 		}
 
 		u = parse_to_uri(_m);
@@ -1029,36 +1029,37 @@ int unregister(struct sip_msg* _m, udomain_t* _d, str* _uri, str *_ruid)
 	} else {
 		/* ruid provided - remove a specific contact */
 
-	        if (_uri->len > 0) {
+		if (_uri->len > 0) {
 
-		        if (extract_aor(_uri, &aor, NULL) < 0) {
-		                LM_ERR("failed to extract Address Of Record\n");
-		                return -1;
-		        }
+			if (extract_aor(_uri, &aor, NULL) < 0) {
+				LM_ERR("failed to extract Address Of Record\n");
+				return -1;
+			}
 
-		        if (ul.get_urecord_by_ruid(_d, ul.get_aorhash(&aor),
-						   _ruid, &r, &c) != 0) {
-			        LM_WARN("AOR/Contact not found\n");
-			        return -1;
+			if (ul.get_urecord_by_ruid(_d, ul.get_aorhash(&aor),
+						_ruid, &r, &c) != 0) {
+				LM_WARN("AOR/Contact not found\n");
+				return -1;
 			}
 			if (ul.delete_ucontact(r, c) != 0) {
-			        LM_WARN("could not delete contact\n");
-			        return -1;
+				ul.unlock_udomain(_d, &aor);
+				LM_WARN("could not delete contact\n");
+				return -1;
 			}
 			ul.unlock_udomain(_d, &aor);
 
 		} else {
 
-   		        res = ul.delete_urecord_by_ruid(_d, _ruid);
+			res = ul.delete_urecord_by_ruid(_d, _ruid);
 			switch (res) {
-			case -1:
-			        LM_ERR("could not delete contact\n");
-			        return -1;
-			case -2:
-			        LM_WARN("contact not found\n");
-			        return -1;
-			default:
-			        return 1;
+				case -1:
+					LM_ERR("could not delete contact\n");
+					return -1;
+				case -2:
+					LM_WARN("contact not found\n");
+					return -1;
+				default:
+					return 1;
 			}
 
 		}
diff --git a/modules/sdpops/sdpops_mod.c b/modules/sdpops/sdpops_mod.c
index a506fc6..16f2278 100644
--- a/modules/sdpops/sdpops_mod.c
+++ b/modules/sdpops/sdpops_mod.c
@@ -168,8 +168,8 @@ int sdp_remove_str_codec_id_attrs(sip_msg_t* msg,
 	payload = sdp_stream->payload_attr;
 	while (payload) {
 		LM_DBG("a= ... for codec %.*s/%.*s\n",
-			payload->rtp_payload.len, payload->rtp_payload.s,
-			payload->rtp_enc.len, payload->rtp_enc.s);
+				payload->rtp_payload.len, payload->rtp_payload.s,
+				payload->rtp_enc.len, payload->rtp_enc.s);
 		if(rm_codec->len==payload->rtp_payload.len
 				&& strncmp(payload->rtp_payload.s, rm_codec->s,
 					rm_codec->len)==0) {
@@ -181,8 +181,8 @@ int sdp_remove_str_codec_id_attrs(sip_msg_t* msg,
 							aline.len, 0);
 					if (anchor == NULL) {
 						LM_ERR("failed to remove [%.*s] inside [%.*s]\n",
-							rm_codec->len, rm_codec->s,
-							aline.len, aline.s);
+								rm_codec->len, rm_codec->s,
+								aline.len, aline.s);
 						return -1;
 					}
 				}
@@ -195,8 +195,8 @@ int sdp_remove_str_codec_id_attrs(sip_msg_t* msg,
 							aline.len, 0);
 					if (anchor == NULL) {
 						LM_ERR("failed to remove [%.*s] inside [%.*s]\n",
-							rm_codec->len, rm_codec->s,
-							aline.len, aline.s);
+								rm_codec->len, rm_codec->s,
+								aline.len, aline.s);
 						return -1;
 					}
 				}
@@ -226,7 +226,7 @@ int sdp_codec_in_str(str *allcodecs, str* codec, char delim)
 			if(codec->len <= allcodecs->len-i) {
 				if(strncmp(&allcodecs->s[i], codec->s, codec->len)==0) {
 					if(&allcodecs->s[i+codec->len]
-									== &allcodecs->s[allcodecs->len]
+							== &allcodecs->s[allcodecs->len]
 							|| allcodecs->s[i+codec->len] == delim) {
 						/* match */
 						return 1;
@@ -263,12 +263,12 @@ int sdp_remove_str_codec_id(sip_msg_t* msg, str *allcodecs, str* rmcodec)
 			if(rmcodec->len <= allcodecs->len-i) {
 				if(strncmp(&allcodecs->s[i], rmcodec->s, rmcodec->len)==0) {
 					if(&allcodecs->s[i+rmcodec->len]
-									== &allcodecs->s[allcodecs->len]
+							== &allcodecs->s[allcodecs->len]
 							|| allcodecs->s[i+rmcodec->len] == ' ') {
 						/* match - remove also the space before codec id */
 						LM_DBG("found codec [%.*s] inside [%.*s]\n",
-									rmcodec->len, rmcodec->s,
-									allcodecs->len, allcodecs->s);
+								rmcodec->len, rmcodec->s,
+								allcodecs->len, allcodecs->s);
 						anchor = del_lump(msg, &allcodecs->s[i-1] - msg->buf,
 								rmcodec->len+1, 0);
 						if (anchor == NULL) {
@@ -332,8 +332,8 @@ int sdp_remove_codecs_by_id(sip_msg_t* msg, str* codecs)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - payloads [%.*s]\n",
-				sdp_stream_num, sdp_session_num, 
-				sdp_stream->payloads.len, sdp_stream->payloads.s);
+					sdp_stream_num, sdp_session_num, 
+					sdp_stream->payloads.len, sdp_stream->payloads.s);
 			sdp_codecs = sdp_stream->payloads;
 			tmp_codecs = *codecs;
 			while(str_find_token(&tmp_codecs, &rm_codec, ',')==0
@@ -598,8 +598,8 @@ int sdp_keep_codecs_by_id(sip_msg_t* msg, str* codecs, str *media)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - payloads [%.*s]\n",
-				sdp_stream_num, sdp_session_num,
-				sdp_stream->payloads.len, sdp_stream->payloads.s);
+					sdp_stream_num, sdp_session_num,
+					sdp_stream->payloads.len, sdp_stream->payloads.s);
 			if((media==NULL)
 					|| (media->len==sdp_stream->media.len
 						&& strncasecmp(sdp_stream->media.s, media->s,
@@ -615,8 +615,8 @@ int sdp_keep_codecs_by_id(sip_msg_t* msg, str* codecs, str *media)
 
 					if(sdp_codec_in_str(codecs, &rm_codec, ',')==0) {
 						LM_DBG("codecs [%.*s] - remove [%.*s]\n",
-							sdp_codecs.len, sdp_codecs.s,
-							rm_codec.len, rm_codec.s);
+								sdp_codecs.len, sdp_codecs.s,
+								rm_codec.len, rm_codec.s);
 						sdp_remove_str_codec_id(msg, &sdp_codecs, &rm_codec);
 						sdp_remove_str_codec_id_attrs(msg, sdp_stream, &rm_codec);
 					}
@@ -761,11 +761,11 @@ static int sdp_with_media(sip_msg_t *msg, str *media)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - media [%.*s]\n",
-				sdp_stream_num, sdp_session_num,
-				sdp_stream->media.len, sdp_stream->media.s);
+					sdp_stream_num, sdp_session_num,
+					sdp_stream->media.len, sdp_stream->media.s);
 			if(media->len==sdp_stream->media.len
 					&& strncasecmp(sdp_stream->media.s, media->s,
-							media->len)==0)
+						media->len)==0)
 				return 1;
 			sdp_stream_num++;
 		}
@@ -838,16 +838,16 @@ static int sdp_remove_media(sip_msg_t *msg, str *media)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - media [%.*s]\n",
-				sdp_stream_num, sdp_session_num,
-				sdp_stream->media.len, sdp_stream->media.s);
+					sdp_stream_num, sdp_session_num,
+					sdp_stream->media.len, sdp_stream->media.s);
 			if(media->len==sdp_stream->media.len
 					&& strncasecmp(sdp_stream->media.s, media->s,
-							media->len)==0)
+						media->len)==0)
 			{
 				/* found - remove */
 				LM_DBG("removing media stream: %.*s", media->len, media->s);
 				nxt_stream = get_sdp_stream(msg, sdp_session_num,
-								sdp_stream_num+1);
+						sdp_stream_num+1);
 				/* skip back 'm=' */
 				dstart = sdp_stream->media.s - 2;
 				if(!nxt_stream) {
@@ -860,7 +860,7 @@ static int sdp_remove_media(sip_msg_t *msg, str *media)
 				anchor = del_lump(msg, dstart - msg->buf, dlen, 0);
 				if (anchor == NULL) {
 					LM_ERR("failed to remove media type [%.*s]\n",
-						 media->len, media->s);
+							media->len, media->s);
 					return -1;
 				}
 
@@ -930,11 +930,11 @@ static int sdp_with_transport(sip_msg_t *msg, str *transport)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - transport [%.*s]\n",
-				sdp_stream_num, sdp_session_num,
-				sdp_stream->transport.len, sdp_stream->transport.s);
+					sdp_stream_num, sdp_session_num,
+					sdp_stream->transport.len, sdp_stream->transport.s);
 			if(transport->len==sdp_stream->transport.len
 					&& strncasecmp(sdp_stream->transport.s, transport->s,
-							transport->len)==0)
+						transport->len)==0)
 				return 1;
 			sdp_stream_num++;
 		}
@@ -1007,16 +1007,16 @@ static int sdp_remove_transport(sip_msg_t *msg, str *transport)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - transport [%.*s]\n",
-				sdp_stream_num, sdp_session_num,
-				sdp_stream->transport.len, sdp_stream->transport.s);
+					sdp_stream_num, sdp_session_num,
+					sdp_stream->transport.len, sdp_stream->transport.s);
 			if(transport->len==sdp_stream->transport.len
 					&& strncasecmp(sdp_stream->transport.s, transport->s,
-							transport->len)==0)
+						transport->len)==0)
 			{
 				/* found - remove */
 				LM_DBG("removing transport stream: %.*s", transport->len, transport->s);
 				nxt_stream = get_sdp_stream(msg, sdp_session_num,
-								sdp_stream_num+1);
+						sdp_stream_num+1);
 				/* skip back 'm=' */
 				dstart = sdp_stream->media.s - 2;
 				if(!nxt_stream) {
@@ -1029,7 +1029,7 @@ static int sdp_remove_transport(sip_msg_t *msg, str *transport)
 				anchor = del_lump(msg, dstart - msg->buf, dlen, 0);
 				if (anchor == NULL) {
 					LM_ERR("failed to remove transport type [%.*s]\n",
-						 transport->len, transport->s);
+							transport->len, transport->s);
 					return -1;
 				}
 
@@ -1111,8 +1111,8 @@ int sdp_with_codecs_by_id(sip_msg_t* msg, str* codecs)
 			if(!sdp_stream) break;
 
 			LM_DBG("stream %d of %d - payloads [%.*s]\n",
-				sdp_stream_num, sdp_session_num,
-				sdp_stream->payloads.len, sdp_stream->payloads.s);
+					sdp_stream_num, sdp_session_num,
+					sdp_stream->payloads.len, sdp_stream->payloads.s);
 			sdp_codecs = sdp_stream->payloads;
 			tmp_codecs = *codecs;
 			while(str_find_token(&tmp_codecs, &fnd_codec, ',')==0
@@ -1123,13 +1123,13 @@ int sdp_with_codecs_by_id(sip_msg_t* msg, str* codecs)
 
 				if(sdp_codec_in_str(&sdp_codecs, &fnd_codec, ' ')==0) {
 					LM_DBG("codecs [%.*s] - not found [%.*s]\n",
-						sdp_codecs.len, sdp_codecs.s,
-						fnd_codec.len, fnd_codec.s);
+							sdp_codecs.len, sdp_codecs.s,
+							fnd_codec.len, fnd_codec.s);
 					notfound = 1;
 				} else {
 					LM_DBG("codecs [%.*s] - found [%.*s]\n",
-						sdp_codecs.len, sdp_codecs.s,
-						fnd_codec.len, fnd_codec.s);
+							sdp_codecs.len, sdp_codecs.s,
+							fnd_codec.len, fnd_codec.s);
 					foundone = 1;
 				}
 			}
@@ -1250,7 +1250,7 @@ static int w_sdp_get(sip_msg_t* msg, char *avp)
 	str s;
 	pv_spec_t *avp_spec = NULL;
 	int sdp_missing=1;
-	
+
 	s.s = avp; s.len = strlen(s.s);
 	if (pv_locate_name(&s) != s.len)
 	{
@@ -1275,7 +1275,7 @@ static int w_sdp_get(sip_msg_t* msg, char *avp)
 		return -1;
 	}
 	sdp = (sdp_info_t*)msg->body;
-	
+
 	if (sdp_missing) {
 		LM_DBG("No SDP\n");
 		return -2;
@@ -1286,10 +1286,10 @@ static int w_sdp_get(sip_msg_t* msg, char *avp)
 	}
 	if (add_avp(AVP_VAL_STR | avp_type, avp_name, avp_val) != 0)
 	{
-	  LM_ERR("Failed to add SDP avp");
-	  return -1;
+		LM_ERR("Failed to add SDP avp");
+		return -1;
 	}
-	
+
 	return 1;
 }
 
@@ -1314,16 +1314,16 @@ static int w_sdp_get_line_startswith(sip_msg_t *msg, char *avp, char *s_line)
 	char* p = NULL;
 	str s;
 	str sline;
-        int_str avp_val;
-        int_str avp_name;
-        pv_spec_t *avp_spec = NULL;
-        static unsigned short avp_type = 0;
+	int_str avp_val;
+	int_str avp_name;
+	pv_spec_t *avp_spec = NULL;
+	static unsigned short avp_type = 0;
 	int sdp_missing=1;
 
 	if (s_line == NULL || strlen(s_line) <= 0)
 	{
 		LM_ERR("Search string is null or empty\n");
-		    return -1;
+		return -1;
 	}
 	sline.s = s_line;
 	sline.len = strlen(s_line);
@@ -1337,10 +1337,10 @@ static int w_sdp_get_line_startswith(sip_msg_t *msg, char *avp, char *s_line)
 
 	sdp = (sdp_info_t *)msg->body;
 
-        if (sdp_missing || sdp == NULL)
+	if (sdp_missing || sdp == NULL)
 	{
-                LM_DBG("No SDP\n");
-                return -2;
+		LM_DBG("No SDP\n");
+		return -2;
 	}
 
 	body.s = sdp->raw_sdp.s;
@@ -1360,29 +1360,29 @@ static int w_sdp_get_line_startswith(sip_msg_t *msg, char *avp, char *s_line)
 	if (avp == NULL || strlen(avp) <= 0)
 	{
 		LM_ERR("avp variable is null or empty\n");
-		    return -1;
+		return -1;
 	}
 
 	s.s = avp;
 	s.len = strlen(s.s);
 
 	if (pv_locate_name(&s) != s.len)
-        {
-                LM_ERR("invalid parameter\n");
-                return -1;
-        }
-
-        if (((avp_spec = pv_cache_get(&s)) == NULL)
-                        || avp_spec->type!=PVT_AVP) {
-                LM_ERR("malformed or non AVP %s AVP definition\n", avp);
-                return -1;
-        }
-
-        if(pv_get_avp_name(0, &avp_spec->pvp, &avp_name, &avp_type)!=0)
-        {
-                LM_ERR("[%s]- invalid AVP definition\n", avp);
-                return -1;
-        }
+	{
+		LM_ERR("invalid parameter\n");
+		return -1;
+	}
+
+	if (((avp_spec = pv_cache_get(&s)) == NULL)
+			|| avp_spec->type!=PVT_AVP) {
+		LM_ERR("malformed or non AVP %s AVP definition\n", avp);
+		return -1;
+	}
+
+	if(pv_get_avp_name(0, &avp_spec->pvp, &avp_name, &avp_type)!=0)
+	{
+		LM_ERR("[%s]- invalid AVP definition\n", avp);
+		return -1;
+	}
 
 	p = find_sdp_line(body.s, body.s+body.len, sline.s[0]);
 	while (p != NULL)
@@ -1395,21 +1395,21 @@ static int w_sdp_get_line_startswith(sip_msg_t *msg, char *avp, char *s_line)
 
 		if (strncmp(line.s, sline.s, sline.len) == 0)
 		{
-            		avp_val.s.s = line.s;
-            		avp_val.s.len = line.len;
+			avp_val.s.s = line.s;
+			avp_val.s.len = line.len;
 
-			// remove ending \r\n if exists
+			/* skip ending \r\n if exists */
 			if (avp_val.s.s[line.len-2] == '\r' && avp_val.s.s[line.len-1] == '\n')
 			{
-			    avp_val.s.s[line.len-2] = '\0';
-			    avp_val.s.len -= 2;
+				/* add_avp() clones to shm and adds 0-terminating char */
+				avp_val.s.len -= 2;
 			}
 
-    			if (add_avp(AVP_VAL_STR | avp_type, avp_name, avp_val) != 0)
-    			{
-        		    LM_ERR("Failed to add SDP line avp");
-        		    return -1;
-    			}
+			if (add_avp(AVP_VAL_STR | avp_type, avp_name, avp_val) != 0)
+			{
+				LM_ERR("Failed to add SDP line avp");
+				return -1;
+			}
 
 			return 1;
 		}
diff --git a/modules/snmpstats/mibs/KAMAILIO-TC b/modules/snmpstats/mibs/KAMAILIO-TC
index 81d1459..171c491 100644
--- a/modules/snmpstats/mibs/KAMAILIO-TC
+++ b/modules/snmpstats/mibs/KAMAILIO-TC
@@ -62,7 +62,7 @@ KamailioSIPTransportProtocol ::= TEXTUAL-CONVENTION
                             tcp(2),
                             sctp(3),
                             tls(4),
-                            sctp_tls(5),
+                            sctptls(5),
 			    ws(6),
 			    wss(7)
            }
@@ -79,14 +79,13 @@ KamailioSIPEntityRole ::= TEXTUAL-CONVENTION
 		operation of a SIP outbound edge proxy node.
 		Kamailio adds the role 'sipcaptureServer' for
 		operation of a Homer SIPcapture node."
-		"
            SYNTAX BITS {
                             other(0),
                             userAgent(1),
                             proxyServer(2),
                             redirectServer(3),
-                            registrarServer(4)
-                            edgeproxyServer(5)
+                            registrarServer(4),
+                            edgeproxyServer(5),
                             sipcaptureServer(6)
            }
 
diff --git a/modules/tm/t_reply.c b/modules/tm/t_reply.c
index 562b583..4d9901d 100644
--- a/modules/tm/t_reply.c
+++ b/modules/tm/t_reply.c
@@ -1093,7 +1093,7 @@ int run_branch_failure_handlers(struct cell *t, struct sip_msg *rpl,
 
 	/* failure_route for a local UAC? */
 	if (!shmem_msg) {
-		LOG(L_WARN,"Warning: run_branch_failure_handlers: no UAC support (%d, %d) \n",
+		LOG(L_WARN,"no UAC support (%d, %d) \n",
 			on_branch_failure, t->tmcb_hl.reg_types);
 		return 0;
 	}
@@ -1101,13 +1101,13 @@ int run_branch_failure_handlers(struct cell *t, struct sip_msg *rpl,
 	/* don't start faking anything if we don't have to */
 	if (unlikely((on_branch_failure < 0) && !has_tran_tmcbs( t, TMCB_ON_BRANCH_FAILURE))) {
 		LOG(L_WARN,
-			"Warning: run_failure_handlers: no branch_failure handler (%d, %d)\n",
+			"no branch_failure handler (%d, %d)\n",
 			on_branch_failure, t->tmcb_hl.reg_types);
 		return 1;
 	}
 
 	if (!fake_req(&faked_req, shmem_msg, extra_flags, &t->uac[picked_branch])) {
-		LOG(L_ERR, "ERROR: run_branch_failure_handlers: fake_req failed\n");
+		LOG(L_ERR, "fake_req failed\n");
 		return 0;
 	}
 	/* fake also the env. conforming to the fake msg */
@@ -1124,7 +1124,7 @@ int run_branch_failure_handlers(struct cell *t, struct sip_msg *rpl,
 		if (exec_pre_script_cb(&faked_req, BRANCH_FAILURE_CB_TYPE)>0) {
 			/* run a branch_failure_route action if some was marked */
 			if (run_top_route(event_rt.rlist[on_branch_failure], &faked_req, 0)<0)
-				LOG(L_ERR, "ERROR: run_branch_failure_handlers: Error in run_top_route\n");
+				LOG(L_ERR, "error in run_top_route\n");
 			exec_post_script_cb(&faked_req, BRANCH_FAILURE_CB_TYPE);
 		}
 		/* update message flags, if changed in branch_failure route */
@@ -1357,9 +1357,9 @@ static enum rps t_should_relay_response( struct cell *Trans , int new_code,
 		/* also append the current reply to the transaction to
 		 * make it available in failure routes - a kind of "fake"
 		 * save of the final reply per branch */
-		Trans->uac[branch].reply = reply;
 		if (unlikely(has_tran_tmcbs( Trans, TMCB_ON_BRANCH_FAILURE_RO|TMCB_ON_BRANCH_FAILURE)
-						|| (Trans->uac[picked_branch].on_branch_failure) )) {
+						|| (Trans->uac[branch].on_branch_failure) )) {
+			Trans->uac[branch].reply = reply;
 			extra_flags=
 				((Trans->uac[branch].request.flags & F_RB_TIMEOUT)?
 							FL_TIMEOUT:0) | 
@@ -1369,6 +1369,7 @@ static enum rps t_should_relay_response( struct cell *Trans , int new_code,
 			picked_branch = branch;
 			run_branch_failure_handlers( Trans, Trans->uac[branch].reply,
 									new_code, extra_flags);
+			Trans->uac[branch].reply = 0;
 		}
 
 
diff --git a/modules/tm/t_serial.c b/modules/tm/t_serial.c
index 93c7480..62200ad 100644
--- a/modules/tm/t_serial.c
+++ b/modules/tm/t_serial.c
@@ -488,14 +488,24 @@ int t_next_contacts(struct sip_msg* msg, char* key, char* value)
 		il->next = (struct instance_list *)0;
 		set_instance(msg, &instance);
 	} else {
+		instance.s = 0;
 		instance.len = 0;
 	}
 
 	vavp = xavp_get(&ruid_name, xavp->val.v.xavp);
-	ruid = vavp->val.v.s;
-
+	if (vavp != NULL) {
+		ruid = vavp->val.v.s;
+	} else {
+		ruid.s = 0;
+		ruid.len = 0;
+	}
 	vavp = xavp_get(&ua_name, xavp->val.v.xavp);
-	location_ua = vavp->val.v.s;
+	if (vavp != NULL) {
+		location_ua = vavp->val.v.s;
+	} else {
+		location_ua.s = 0;
+		location_ua.len = 0;
+	}
 
 	/* Rewrite Request-URI */
 	rewrite_uri(msg, &uri);
@@ -582,10 +592,20 @@ int t_next_contacts(struct sip_msg* msg, char* key, char* value)
 		flags = vavp->val.v.i;
 
 		vavp = xavp_get(&ruid_name, xavp->val.v.xavp);
-		ruid = vavp->val.v.s;
+		if (vavp != NULL) {
+			ruid = vavp->val.v.s;
+		} else {
+			ruid.s = 0;
+			ruid.len = 0;
+		}
 
 		vavp = xavp_get(&ua_name, xavp->val.v.xavp);
-		location_ua = vavp->val.v.s;
+		if (vavp != NULL) {
+			location_ua = vavp->val.v.s;
+		} else {
+			location_ua.s = 0;
+			location_ua.len = 0;
+		}
 
 		vavp = xavp_get(&instance_name, xavp->val.v.xavp);
 		if (vavp != NULL) {
@@ -623,6 +643,7 @@ int t_next_contacts(struct sip_msg* msg, char* key, char* value)
 				il = ilp;
 			}
 		} else {
+			instance.s = 0;
 			instance.len = 0;
 		}
 
@@ -632,7 +653,8 @@ int t_next_contacts(struct sip_msg* msg, char* key, char* value)
 				dst_uri.len, (dst_uri.len > 0)?dst_uri.s:"",
 				path.len, (path.len>0)?path.s:"",
 				instance.len, (instance.len>0)?instance.s:"",
-				ruid.len, ruid.s, location_ua.len, location_ua.s);
+				ruid.len, (ruid.len>0)?ruid.s:"",
+				location_ua.len, (location_ua.len>0)?location_ua.s:"");
 		if (append_branch(msg, &uri, &dst_uri, &path, 0, flags, sock, &instance, 0,
 					&ruid, &location_ua) != 1) {
 			LM_ERR("appending branch failed\n");
diff --git a/modules/usrloc/udomain.c b/modules/usrloc/udomain.c
index 244f8e7..88fc7e4 100644
--- a/modules/usrloc/udomain.c
+++ b/modules/usrloc/udomain.c
@@ -1250,8 +1250,8 @@ int uldb_preload_attrs(udomain_t *_d)
 			}
 
 			if (use_domain) {
-				domain.s = (char*)VAL_STRING(ROW_VALUES(row) + 6);
-				if (VAL_NULL(ROW_VALUES(row)+6) || domain.s==0 || domain.s[0]==0){
+				domain.s = (char*)VAL_STRING(ROW_VALUES(row) + 5);
+				if (VAL_NULL(ROW_VALUES(row)+5) || domain.s==0 || domain.s[0]==0){
 					LM_CRIT("empty domain record for user %.*s...skipping\n",
 							user.len, user.s);
 					continue;
@@ -1270,8 +1270,7 @@ int uldb_preload_attrs(udomain_t *_d)
 				suri = user;
 			}
 
-			lock_udomain(_d, &suri);
-			if (get_urecord_by_ruid(_d, ul_get_aorhash(&suri), &ruid, &r, &c) > 0) {
+			if (get_urecord_by_ruid(_d, ul_get_aorhash(&suri), &ruid, &r, &c) < 0) {
 				/* delete attrs records from db table */
 				LM_INFO("no contact record for this ruid\n");
 				uldb_delete_attrs(_d->name, &user, &domain, &ruid);
@@ -1287,8 +1286,9 @@ int uldb_preload_attrs(udomain_t *_d)
 							LM_INFO("cannot add values to contact xavp\n");
 					}
 				}
+				/* get_urecord_by_ruid() locks the slot */
+				unlock_udomain(_d, &suri);
 			}
-			unlock_udomain(_d, &user);
 		}
 
 		if (DB_CAPABILITY(ul_dbf, DB_CAP_FETCH)) {
diff --git a/msg_translator.c b/msg_translator.c
index b4581e7..13b0785 100644
--- a/msg_translator.c
+++ b/msg_translator.c
@@ -1575,7 +1575,7 @@ static inline int adjust_clen(struct sip_msg* msg, int body_delta, int proto)
 		 */
 		/* no need for Content-Length if it's and UDP packet and
 		 * it hasn't Content-Length already */
-		if ((msg->content_length==0)){
+		if (msg->content_length==0){
 		    /* content-length doesn't exist, append it */
 			/* msg->unparsed should point just before the final crlf
 			 * - whole message was parsed by the above parse_headers
diff --git a/parser/parse_fline.c b/parser/parse_fline.c
index 8dacfe5..b8fee65 100644
--- a/parser/parse_fline.c
+++ b/parser/parse_fline.c
@@ -233,7 +233,7 @@ error:
 	if (prn) {
 		for (t=0; t<offset; t++)
 			if (*(buffer+t)) *(prn+t)=*(buffer+t);
-			else *(prn+t)='°';
+			else *(prn+t)=176; /* '°' */
 		LOG(L_DBG, "parsed so far: %.*s\n", offset, ZSW(prn) );
 		pkg_free( prn );
 	};
diff --git a/select_buf.c b/select_buf.c
index b3463a8..7277d48 100644
--- a/select_buf.c
+++ b/select_buf.c
@@ -162,7 +162,7 @@ int int_to_static_buffer(str* res, int val)
 {
 	char *c;
 	c = int2str(abs(val), &res->len);
-	res->s = get_static_buffer(res->len+(val<0)?1:0);
+	res->s = get_static_buffer(res->len+((val<0)?1:0));
 	if (!res->s) return -1;
 	if (val < 0) {
 		res->s[0] = '-';	
