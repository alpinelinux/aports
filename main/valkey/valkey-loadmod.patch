Patch-Source: https://src.fedoraproject.org/rpms/valkey/blob/rawhide/f/valkey-loadmod.patch
--
From b40ab88996d0bbe9bdd366af9426f7400b21e19c Mon Sep 17 00:00:00 2001
From: Remi Collet <remi@remirepo.net>
Date: Sat, 4 Oct 2025 07:23:52 +0200
Subject: [PATCH] Fix #2678 don't add loadmodule when from config

only protect loadmodule from include files

Signed-off-by: Remi Collet <remi@remirepo.net>
---
 src/config.c |  8 ++++++--
 src/module.c | 17 ++++++++++++-----
 src/module.h |  4 ++--
 3 files changed, 20 insertions(+), 9 deletions(-)

diff --git a/src/config.c b/src/config.c
index d0158b2c4d..ab453056df 100644
--- a/src/config.c
+++ b/src/config.c
@@ -448,6 +448,8 @@ static int updateClientOutputBufferLimit(sds *args, int arg_len, const char **er
  * within conf file parsing. This is only needed to support the deprecated
  * abnormal aggregate `save T C` functionality. Remove in the future. */
 static int reading_config_file;
+/* support detecting include vs main config file */
+static int reading_include_file = 0;
 
 void loadServerConfigFromString(sds config) {
     deprecatedConfig deprecated_configs[] = {
@@ -539,7 +541,9 @@ void loadServerConfigFromString(sds config) {
 
         /* Execute config directives */
         if (!strcasecmp(argv[0], "include") && argc == 2) {
+            reading_include_file = 1;
             loadServerConfig(argv[1], 0, NULL);
+            reading_include_file = 0;
         } else if (!strcasecmp(argv[0], "rename-command") && argc == 3) {
             struct serverCommand *cmd = lookupCommandBySds(argv[1]);
 
@@ -572,7 +576,7 @@ void loadServerConfigFromString(sds config) {
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0], "loadmodule") && argc >= 2) {
-            moduleEnqueueLoadModule(argv[1], &argv[2], argc - 2);
+            moduleEnqueueLoadModule(argv[1], &argv[2], argc - 2, reading_include_file);
         } else if (strchr(argv[0], '.')) {
             if (argc < 2) {
                 err = "Module config specified without value";
@@ -1605,7 +1609,7 @@ void rewriteConfigLoadmoduleOption(struct rewriteConfigState *state) {
     while ((de = dictNext(di)) != NULL) {
         struct ValkeyModule *module = dictGetVal(de);
         line = moduleLoadQueueEntryToLoadmoduleOptionStr(module, "loadmodule");
-        rewriteConfigRewriteLine(state, "loadmodule", line, 1);
+        if (line) rewriteConfigRewriteLine(state, "loadmodule", line, 1);
     }
     dictReleaseIterator(di);
     /* Mark "loadmodule" as processed in case modules is empty. */
diff --git a/src/module.c b/src/module.c
index e5afa952fa..f18bc3c6bf 100644
--- a/src/module.c
+++ b/src/module.c
@@ -84,6 +84,7 @@
 
 struct moduleLoadQueueEntry {
     sds path;
+    int from_include;
     int argc;
     robj **argv;
 };
@@ -670,7 +671,7 @@ void freeClientModuleData(client *c) {
     c->module_data = NULL;
 }
 
-void moduleEnqueueLoadModule(sds path, sds *argv, int argc) {
+void moduleEnqueueLoadModule(sds path, sds *argv, int argc, int from_include) {
     int i;
     struct moduleLoadQueueEntry *loadmod;
 
@@ -678,6 +679,7 @@ void moduleEnqueueLoadModule(sds path, sds *argv, int argc) {
     loadmod->argv = argc ? zmalloc(sizeof(robj *) * argc) : NULL;
     loadmod->path = sdsnew(path);
     loadmod->argc = argc;
+    loadmod->from_include = from_include;
     for (i = 0; i < argc; i++) {
         loadmod->argv[i] = createRawStringObject(argv[i], sdslen(argv[i]));
     }
@@ -688,6 +690,10 @@ sds moduleLoadQueueEntryToLoadmoduleOptionStr(ValkeyModule *module,
                                               const char *config_option_str) {
     sds line;
 
+    if (module->loadmod->from_include) {
+        /* no need to add as already from config */
+        return NULL;
+    }
     line = sdsnew(config_option_str);
     line = sdscatlen(line, " ", 1);
     line = sdscatsds(line, module->loadmod->path);
@@ -12350,7 +12356,7 @@ void moduleLoadFromQueue(void) {
     listRewind(server.loadmodule_queue, &li);
     while ((ln = listNext(&li))) {
         struct moduleLoadQueueEntry *loadmod = ln->value;
-        if (moduleLoad(loadmod->path, (void **)loadmod->argv, loadmod->argc, 0) == C_ERR) {
+        if (moduleLoad(loadmod->path, (void **)loadmod->argv, loadmod->argc, 0, loadmod->from_include) == C_ERR) {
             serverLog(LL_WARNING, "Can't load module from %s: server aborting", loadmod->path);
             exit(1);
         }
@@ -12531,7 +12537,7 @@ void moduleUnregisterCleanup(ValkeyModule *module) {
 
 /* Load a module and initialize it. On success C_OK is returned, otherwise
  * C_ERR is returned. */
-int moduleLoad(const char *path, void **module_argv, int module_argc, int is_loadex) {
+int moduleLoad(const char *path, void **module_argv, int module_argc, int is_loadex, int from_include) {
     int (*onload)(void *, void **, int);
     void *handle;
 
@@ -12606,6 +12612,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc, int is_loa
     ctx.module->loadmod->path = sdsnew(path);
     ctx.module->loadmod->argv = module_argc ? zmalloc(sizeof(robj *) * module_argc) : NULL;
     ctx.module->loadmod->argc = module_argc;
+    ctx.module->loadmod->from_include = from_include;
     for (int i = 0; i < module_argc; i++) {
         ctx.module->loadmod->argv[i] = module_argv[i];
         incrRefCount(ctx.module->loadmod->argv[i]);
@@ -13529,7 +13536,7 @@ void moduleCommand(client *c) {
             argv = &c->argv[3];
         }
 
-        if (moduleLoad(c->argv[2]->ptr, (void **)argv, argc, 0) == C_OK)
+        if (moduleLoad(c->argv[2]->ptr, (void **)argv, argc, 0, 0) == C_OK)
             addReply(c, shared.ok);
         else
             addReplyError(c, "Error loading the extension. Please check the server logs.");
@@ -13544,7 +13551,7 @@ void moduleCommand(client *c) {
         /* If this is a loadex command we want to populate server.module_configs_queue with
          * sds NAME VALUE pairs. We also want to increment argv to just after ARGS, if supplied. */
         if (parseLoadexArguments((ValkeyModuleString ***)&argv, &argc) == VALKEYMODULE_OK &&
-            moduleLoad(c->argv[2]->ptr, (void **)argv, argc, 1) == C_OK)
+            moduleLoad(c->argv[2]->ptr, (void **)argv, argc, 1, 0) == C_OK)
             addReply(c, shared.ok);
         else {
             dictEmpty(server.module_configs_queue, NULL);
diff --git a/src/module.h b/src/module.h
index f6c266b592..1f9e729e56 100644
--- a/src/module.h
+++ b/src/module.h
@@ -169,7 +169,7 @@ static inline void moduleInitDigestContext(ValkeyModuleDigest *mdvar) {
     memset(mdvar->x, 0, sizeof(mdvar->x));
 }
 
-void moduleEnqueueLoadModule(sds path, sds *argv, int argc);
+void moduleEnqueueLoadModule(sds path, sds *argv, int argc, int from_include);
 sds moduleLoadQueueEntryToLoadmoduleOptionStr(ValkeyModule *module,
                                               const char *config_option_str);
 ValkeyModuleCtx *moduleAllocateContext(void);
@@ -180,7 +180,7 @@ void moduleFreeContext(ValkeyModuleCtx *ctx);
 void moduleInitModulesSystem(void);
 void moduleInitModulesSystemLast(void);
 void modulesCron(void);
-int moduleLoad(const char *path, void **argv, int argc, int is_loadex);
+int moduleLoad(const char *path, void **argv, int argc, int is_loadex, int from_include);
 int moduleUnload(sds name, const char **errmsg);
 void moduleLoadFromQueue(void);
 int moduleGetCommandKeysViaAPI(struct serverCommand *cmd, robj **argv, int argc, getKeysResult *result);
