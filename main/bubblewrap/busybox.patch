Use busybox for test suite

--- a/meson.build
+++ b/meson.build
@@ -57,7 +57,7 @@ if (
   ], language : 'c')
 endif
 
-bash = find_program('bash', required : false)
+bash = find_program('ash', required : false)
 
 if get_option('python') == ''
   python = find_program('python3')
--- a/tests/libtest.sh
+++ b/tests/libtest.sh
@@ -46,6 +46,7 @@ cleanup() {
     if test -n "${TEST_SKIP_CLEANUP:-}"; then
         echo "Skipping cleanup of ${tempdir}"
     elif test -f "${tempdir}/.testtmp"; then
+        chmod -R u+rw "${tempdir}"
         rm -rf "${tempdir}"
     fi
 }
--- a/tests/test-run.sh
+++ b/tests/test-run.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env ash
 
 set -xeuo pipefail
 
@@ -92,16 +92,16 @@ fi
 ok "--symlink doesn't overwrite a conflicting symlink"
 
 # Test devices
-$RUN --unshare-pid --dev /dev ls -al /dev/{stdin,stdout,stderr,null,random,urandom,fd,core} >/dev/null
+$RUN --unshare-pid --dev /dev ls -al /dev/stdin /dev/stdout /dev/stderr /dev/null /dev/random /dev/urandom /dev/fd /dev/core >/dev/null
 ok "all expected devices were created"
 
 # Test --as-pid-1
-$RUN --unshare-pid --as-pid-1 --bind / / bash -c 'echo $$' > as_pid_1.txt
+$RUN --unshare-pid --as-pid-1 --bind / / ash -c 'echo $$' > as_pid_1.txt
 assert_file_has_content as_pid_1.txt "1"
 ok "can run as pid 1"
 
 # Test --info-fd and --json-status-fd
-if $RUN --unshare-all --info-fd 42 --json-status-fd 43 -- bash -c 'exit 42' 42>info.json 43>json-status.json 2>err.txt; then
+if $RUN --unshare-all --info-fd 42 --json-status-fd 43 -- ash -c 'exit 42' 42>info.json 43>json-status.json 2>err.txt; then
     fatal "should have been exit 42"
 fi
 assert_file_has_content info.json '"child-pid": [0-9]'
@@ -109,7 +109,7 @@ assert_file_has_content json-status.json '"child-pid": [0-9]'
 assert_file_has_content_literal json-status.json '"exit-code": 42'
 ok "info and json-status fd"
 
-DATA=$($RUN --proc /proc --unshare-all --info-fd 42 --json-status-fd 43 -- bash -c 'stat -L -c "%n %i" /proc/self/ns/*' 42>info.json 43>json-status.json 2>err.txt)
+DATA=$($RUN --proc /proc --unshare-all --info-fd 42 --json-status-fd 43 -- ash -c 'stat -L -c "%n %i" /proc/self/ns/*' 42>info.json 43>json-status.json 2>err.txt)
 
 for NS in "ipc" "mnt" "net" "pid" "uts"; do
 
@@ -237,7 +237,7 @@ for die_with_parent_argv in "--die-with-parent" "--die-with-parent --unshare-pid
     # We have to loop here, because bwrap doesn't wait for the lock if
     # another process is holding it. If we're unlucky, lockf-n.py will
     # be holding it.
-    bash -c "while true; do $RUN ${die_with_parent_argv} --lock-file $(pwd)/lock sleep 1h; done" &
+    ash -c "while true; do $RUN ${die_with_parent_argv} --lock-file $(pwd)/lock sleep 1h; done" &
     childshellpid=$!
 
     # Wait for lock to be taken (yes hacky)
@@ -561,8 +561,8 @@ $RUN sh -c 'echo $0' > stdout
 assert_file_has_content stdout sh
 $RUN --argv0 sh sh -c 'echo $0' > stdout
 assert_file_has_content stdout sh
-$RUN --argv0 right sh -c 'echo $0' > stdout
-assert_file_has_content stdout right
+$RUN --argv0 ash sh -c 'echo $0' > stdout
+assert_file_has_content stdout ash
 ok "argv0 manipulation"
 
 echo "foobar" > file-data
--- a/tests/test-specifying-pidns.sh
+++ b/tests/test-specifying-pidns.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env ash
 
 set -xeuo pipefail
 
--- a/tests/test-specifying-userns.sh
+++ b/tests/test-specifying-userns.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env ash
 
 set -xeuo pipefail
 
