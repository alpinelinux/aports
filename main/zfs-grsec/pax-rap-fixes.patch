diff --git a/cmd/ztest/ztest.c b/cmd/ztest/ztest.c
index 40524ed..a83b559 100644
--- a/cmd/ztest/ztest.c
+++ b/cmd/ztest/ztest.c
@@ -5541,7 +5541,7 @@ ztest_resume(spa_t *spa)
 	(void) zio_resume(spa);
 }
 
-static void *
+static void
 ztest_resume_thread(void *arg)
 {
 	spa_t *spa = arg;
@@ -5553,8 +5553,6 @@ ztest_resume_thread(void *arg)
 	}
 
 	thread_exit();
-
-	return (NULL);
 }
 
 #define	GRACE	300
@@ -5588,7 +5586,7 @@ ztest_execute(int test, ztest_info_t *zi, uint64_t id)
 		    (double)functime / NANOSEC, zi->zi_funcname);
 }
 
-static void *
+static void
 ztest_thread(void *arg)
 {
 	int rand;
@@ -5628,8 +5626,6 @@ ztest_thread(void *arg)
 	}
 
 	thread_exit();
-
-	return (NULL);
 }
 
 static void
@@ -5818,7 +5814,7 @@ ztest_run(ztest_shared_t *zs)
 	 * Create a thread to periodically resume suspended I/O.
 	 */
 	VERIFY3P((resume_thread = zk_thread_create(NULL, 0,
-	    (thread_func_t)ztest_resume_thread, spa, TS_RUN, NULL, 0, 0,
+	    ztest_resume_thread, spa, TS_RUN, NULL, 0, 0,
 	    PTHREAD_CREATE_JOINABLE)), !=, NULL);
 
 #if 0
@@ -5870,7 +5866,7 @@ ztest_run(ztest_shared_t *zs)
 			return;
 
 		VERIFY3P(thread = zk_thread_create(NULL, 0,
-		    (thread_func_t)ztest_thread,
+		    ztest_thread,
 		    (void *)(uintptr_t)t, TS_RUN, NULL, 0, 0,
 		    PTHREAD_CREATE_JOINABLE), !=, NULL);
 		tid[t] = thread->t_tid;
diff --git a/include/sys/zfs_context.h b/include/sys/zfs_context.h
index 78e33e1..255b1a4 100644
--- a/include/sys/zfs_context.h
+++ b/include/sys/zfs_context.h
@@ -240,7 +240,7 @@ typedef struct kthread {
 #define	getcomm()			"unknown"
 #define	thread_exit			zk_thread_exit
 #define	thread_create(stk, stksize, func, arg, len, pp, state, pri)	\
-	zk_thread_create(stk, stksize, (thread_func_t)func, arg,	\
+	zk_thread_create(stk, stksize, func, arg,	\
 	    len, NULL, state, pri, PTHREAD_CREATE_DETACHED)
 #define	thread_join(t)			zk_thread_join(t)
 #define	newproc(f, a, cid, pri, ctp, pid)	(ENOSYS)
diff --git a/module/zfs/arc.c b/module/zfs/arc.c
index 04fde6c..a9652dd 100644
--- a/module/zfs/arc.c
+++ b/module/zfs/arc.c
@@ -3416,7 +3416,7 @@ arc_kmem_reap_now(void)
  * using mutex_tryenter() from arc_reclaim_thread().
  */
 static void
-arc_reclaim_thread(void)
+arc_reclaim_thread(void *_unused)
 {
 	fstrans_cookie_t	cookie = spl_fstrans_mark();
 	clock_t			growtime = 0;
@@ -3509,7 +3509,7 @@ arc_reclaim_thread(void)
 }
 
 static void
-arc_user_evicts_thread(void)
+arc_user_evicts_thread(void *_unused)
 {
 	fstrans_cookie_t	cookie = spl_fstrans_mark();
 	callb_cpr_t cpr;
@@ -6732,7 +6732,7 @@ l2arc_release_cdata_buf(arc_buf_hdr_t *hdr)
  * heart of the L2ARC.
  */
 static void
-l2arc_feed_thread(void)
+l2arc_feed_thread(void *_unused)
 {
 	callb_cpr_t cpr;
 	l2arc_dev_t *dev;
diff --git a/module/zfs/spa.c b/module/zfs/spa.c
index dde909e..34ff0dc 100644
--- a/module/zfs/spa.c
+++ b/module/zfs/spa.c
@@ -5646,8 +5646,9 @@ spa_async_autoexpand(spa_t *spa, vdev_t *vd)
 }
 
 static void
-spa_async_thread(spa_t *spa)
+spa_async_thread(void *_spa)
 {
+	spa_t *spa = _spa;
 	int tasks, i;
 
 	ASSERT(spa->spa_sync_on);
diff --git a/module/zfs/txg.c b/module/zfs/txg.c
index 1d5ee97..2d63a57 100644
--- a/module/zfs/txg.c
+++ b/module/zfs/txg.c
@@ -107,8 +107,8 @@
  * now transition to the syncing state.
  */
 
-static void txg_sync_thread(dsl_pool_t *dp);
-static void txg_quiesce_thread(dsl_pool_t *dp);
+static void txg_sync_thread(void *_dp);
+static void txg_quiesce_thread(void *_dp);
 
 int zfs_txg_timeout = 5;	/* max seconds worth of delta per txg */
 
@@ -475,8 +475,9 @@ txg_wait_callbacks(dsl_pool_t *dp)
 }
 
 static void
-txg_sync_thread(dsl_pool_t *dp)
+txg_sync_thread(void *_dp)
 {
+	dsl_pool_t *dp = _dp;
 	spa_t *spa = dp->dp_spa;
 	tx_state_t *tx = &dp->dp_tx;
 	callb_cpr_t cpr;
@@ -584,8 +585,9 @@ txg_sync_thread(dsl_pool_t *dp)
 }
 
 static void
-txg_quiesce_thread(dsl_pool_t *dp)
+txg_quiesce_thread(void *_dp)
 {
+	dsl_pool_t *dp = _dp;
 	tx_state_t *tx = &dp->dp_tx;
 	callb_cpr_t cpr;
 
