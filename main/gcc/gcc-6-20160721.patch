diff -ru --unidirectional-new-file --exclude "po" gcc-6.1.0 gcc-6-20160721

Only in gcc-6.1.0/INSTALL: binaries.html
Only in gcc-6.1.0/INSTALL: build.html
Only in gcc-6.1.0/INSTALL: configure.html
Only in gcc-6.1.0/INSTALL: download.html
Only in gcc-6.1.0/INSTALL: finalinstall.html
Only in gcc-6.1.0/INSTALL: gfdl.html
Only in gcc-6.1.0/INSTALL: index.html
Only in gcc-6.1.0/INSTALL: old.html
Only in gcc-6.1.0/INSTALL: prerequisites.html
Only in gcc-6.1.0/INSTALL: specific.html
Only in gcc-6.1.0/INSTALL: test.html
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/LAST_UPDATED gcc-6-20160721/LAST_UPDATED
--- gcc-6.1.0/LAST_UPDATED	2016-04-27 08:22:13.000000000 +0000
+++ gcc-6-20160721/LAST_UPDATED	2016-07-21 22:33:07.000000000 +0000
@@ -1 +1 @@
-Obtained from SVN: tags/gcc_6_1_0_release revision 235474
+Obtained from SVN: branches/gcc-6-branch revision 238612
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/MD5SUMS gcc-6-20160721/MD5SUMS
--- gcc-6.1.0/MD5SUMS	2016-04-27 10:13:12.000000000 +0000
+++ gcc-6-20160721/MD5SUMS	2016-07-21 22:33:11.000000000 +0000
@@ -1,5 +1,5 @@
 # This file contains the MD5 checksums of the files in the 
-# gcc-6.1.0.tar.bz2 tarball.
+# gcc-6-20160721.tar.bz2 tarball.
 #
 # Besides verifying that all files in the tarball were correctly expanded,
 # it also can be used to determine if any files have changed since the
@@ -20,23 +20,11 @@
 fd4ecdf5d672efe2b0e409aca9cf9446  ChangeLog.jit
 09538b708302f1735f6fa05b622ecf5e  ChangeLog.tree-ssa
 24ab760126489e69436a43185dc3d202  INSTALL/README
-faeedc4aa0a33b139dba3e37dfcc32e9  INSTALL/binaries.html
-2ae07dc670badfddd880d0829f494717  INSTALL/build.html
-e2df733daff96626c742335bf4a3068f  INSTALL/configure.html
-ea288f7e1bc7954c3de3261254314248  INSTALL/download.html
-4ba2f0041409f363c2f2eb4f0dd77dff  INSTALL/finalinstall.html
-b19e611b013e13cf467d87dd2d5eba0d  INSTALL/gfdl.html
-f266c60ec900704e2125c1f55ef979fe  INSTALL/index.html
-d87c01263eb292cc6be0c98de9ba224f  INSTALL/old.html
-9fa79492a4fbc527f20e7c1d7f83880f  INSTALL/prerequisites.html
-897b84fa1251ef3d0db6d781c8bebe01  INSTALL/specific.html
-85828d67c1ef58065b4271ab44018590  INSTALL/test.html
-3ec6c77feebb68d73c98f35e6eecd408  LAST_UPDATED
+2019f60ae2fe0b2cc56e605eedd16555  LAST_UPDATED
 b101e24e658738320c6f7460345cd30e  MAINTAINERS
 ac51a3b92098155704bd0e6f3e27e70f  Makefile.def
 7fa740cb7ac3a6e647702770bb023340  Makefile.in
 5658e4a049df2f77bee1189b6603aa77  Makefile.tpl
-a4e0e310ef9f1d033f44a34667d1bc42  NEWS
 80d26bc3b1ad4f6969a96a24c9181bf5  README
 b510a5285eb05298b5f3d9f5ae920588  boehm-gc/AmigaOS.c
 2caafacabf758bb76a9dfce1fc544b97  boehm-gc/BCC_MAKEFILE
@@ -441,7 +429,7 @@
 d25174fd04b32bbeab5f3cc783277ec1  contrib/vimrc
 7cb42cbdf8becd280d1e16191416fb62  contrib/warn_summary
 8b59f0d0a2dcdced14765c514fbad719  depcomp
-7fa381dd5b3470740f26874e57453fc7  fixincludes/ChangeLog
+03b936340a4cbe370fe25452c5eefabd  fixincludes/ChangeLog
 c23ba4c4f4ca4dfcdd9b4155e4626da7  fixincludes/Makefile.in
 b6e3f4950abc6e254b467063381f6473  fixincludes/README
 455903ad4ff71fa5c5340ef7ae41a0e6  fixincludes/README-fixinc
@@ -454,13 +442,13 @@
 497da58c4b47627a33f754b61f6eb051  fixincludes/fixinc.in
 9662d8ad173553c438e3ad3fc9db8352  fixincludes/fixincl.c
 e1cd70e73f3c2d2319fd9d210ad6a5ff  fixincludes/fixincl.tpl
-2bc45da2368f2edd0afe13a68f13c8c6  fixincludes/fixincl.x
+189a30a5c8c04ee6145097e01dec36b9  fixincludes/fixincl.x
 47da6e634225e1667c26a71bcf234bfa  fixincludes/fixlib.c
 d8aac376a7311e465eb0a98d341103a1  fixincludes/fixlib.h
 5b2c1fd3ef9d44fb6beb1a0d45ddd533  fixincludes/fixopts.c
 ed1415e9dbc8f421fd9288bde0d90ad1  fixincludes/fixtests.c
 6df145c7cea1e2099cf97a0d83564aca  fixincludes/genfixes
-052121f87ed1928d7b0b7be1850ce33b  fixincludes/inclhack.def
+bafa3cf7b936fb735091aba9b601ed87  fixincludes/inclhack.def
 73354a5ccc669d3a585be10f1f7e7cb7  fixincludes/mkfixinc.sh
 5f9960cfe65b2e6bef658f770e52dfef  fixincludes/mkheaders.in
 3aa0563cd682ee61ecd9eb6eea0b0bce  fixincludes/procopen.c
@@ -541,7 +529,7 @@
 1ee4e2b61ae5781d35271f3181927037  fixincludes/tests/base/stdint.h
 bd72848710b6f098f5e44218bfe3202e  fixincludes/tests/base/stdio.h
 1887d8bc1711dae9922852cda6027877  fixincludes/tests/base/stdio_tag.h
-a35ebd909f0105b249e3af1c1b5826ab  fixincludes/tests/base/stdlib.h
+6b842aa18e09c73db745cbffa3cb34cf  fixincludes/tests/base/stdlib.h
 42a7de17fb8f2ac74bc30c7029199637  fixincludes/tests/base/string.h
 6931e261dc1cecb7983279cf909bd784  fixincludes/tests/base/strings.h
 127183621f8b29d6912c683be6102135  fixincludes/tests/base/sundev/vuid_event.h
@@ -572,12 +560,12 @@
 955462b555900ecd3934223c64e21fa7  fixincludes/tests/base/types/vxTypesBase.h
 c78e762f2c91f2af991feda7d3d7f4b2  fixincludes/tests/base/unistd.h
 a2fe1dc808019c9134bca8a4a9a8eec2  gcc/ABOUT-GCC-NLS
-06d0293a224884f2cc467d67f3b39573  gcc/BASE-VER
+401718b61199e799c9879210e445d03d  gcc/BASE-VER
 59530bdf33659b29e73d4adb9f9f6552  gcc/COPYING
 a916467b91076e631dd8edb7424769c7  gcc/COPYING.LIB
 d32239bcb673463ab874e80d47fae504  gcc/COPYING3
 6a6a8e020838b23406c81b19c1d46df6  gcc/COPYING3.LIB
-b3fff8c199e988a05ee713f0d584c272  gcc/ChangeLog
+47013cb6b7e3a068a8089357cc00568b  gcc/ChangeLog
 a3b63c675afa7a655cc2bfa8a907af79  gcc/ChangeLog-1997
 d9a88529352a010253c2e8fb1ed6023b  gcc/ChangeLog-1998
 240f08f81cb4699e8b49347db38233db  gcc/ChangeLog-1999
@@ -605,7 +593,7 @@
 3eb07e0b2e542409bf73d359f7f65609  gcc/ChangeLog.ptr
 e13638e26743ba41e6011b76cc00d9a9  gcc/ChangeLog.tree-ssa
 739ab47f6425bcea1d05e4fc0542de54  gcc/ChangeLog.tuples
-e8a6574a8534695f6f50d0345ddbcc52  gcc/DATESTAMP
+281e1cfb96402ae5f5610228d48687b7  gcc/DATESTAMP
 d41d8cd98f00b204e9800998ecf8427e  gcc/DEV-PHASE
 eb92e1ff5e982ca07e173e0eb286d243  gcc/FSFChangeLog
 30e1e33411566388b3164558482dc5e6  gcc/FSFChangeLog.10
@@ -617,7 +605,7 @@
 e71640635091e22ac2f09f2573aee53d  gcc/acinclude.m4
 9545fe83576dc99e441c64e268711730  gcc/aclocal.m4
 9063d23e571fcde20283b9f34d5e3422  gcc/ada/9drpc.adb
-790bd4173abc2b4c3a18bb0d780ecbd2  gcc/ada/ChangeLog
+4cdae618932d452c197dc7aa6ae96df1  gcc/ada/ChangeLog
 683be0b07dc4f64f118fd5e8ae9cb30d  gcc/ada/ChangeLog-2001
 7aff25efb203be4136b8776cdc812956  gcc/ada/ChangeLog-2002
 cd2379152000f40157d349018fb9364d  gcc/ada/ChangeLog-2003
@@ -1076,7 +1064,7 @@
 281fc9a014bf9c5a3677f1dd38cc9d5d  gcc/ada/a-taster.ads
 09e5467697bae79fd39e9e40a68afbab  gcc/ada/a-teioed.adb
 4eb0094120306451664ed73cdafe1d74  gcc/ada/a-teioed.ads
-2cf591e4878f55a978c94162e95e7267  gcc/ada/a-textio.adb
+7bbc8ad89fb1f29d8db561dc1e32fa14  gcc/ada/a-textio.adb
 8f8b52b35860a106600945520fa91ee6  gcc/ada/a-textio.ads
 c74a673b222c3d0037a22fb766c67488  gcc/ada/a-tgdico.ads
 e52f158e88867c99b27268762d9506b4  gcc/ada/a-tiboio.adb
@@ -1456,7 +1444,7 @@
 ffd0bc766345dd140e2b58fd781d013f  gcc/ada/g-cgicoo.ads
 8f1d7bbecdcc4526e6981f20b2c6aa3c  gcc/ada/g-cgideb.adb
 774b86530311360b01e1e5f5919cbbf2  gcc/ada/g-cgideb.ads
-755d5b83deaada0e6ba24a69420a9998  gcc/ada/g-comlin.adb
+bacfa2f3967417c2ef2a1a22e0e1191d  gcc/ada/g-comlin.adb
 5a463e3ab85c8c7a3123e5d216cfbd55  gcc/ada/g-comlin.ads
 810166883e82bd21c4358dc3983518f0  gcc/ada/g-comver.adb
 ca3c61abdfe3cd9da8902dc86e3f6ee5  gcc/ada/g-comver.ads
@@ -1632,22 +1620,22 @@
 b45654446bc74bb68ae4adef78906e9b  gcc/ada/g-zspche.ads
 c97edf7ce39a908dcaec55eb49d0abee  gcc/ada/g-zstspl.ads
 09160006db0a2d8dd0c3ce7884147582  gcc/ada/gcc-interface/Make-lang.in
-fd793f79cc63bedd8ab6318c59159b4a  gcc/ada/gcc-interface/Makefile.in
+c52ceda5eb7e9dea74d930a4ea1ea2a2  gcc/ada/gcc-interface/Makefile.in
 055be3d11fa6ccb53ffe7f8970a005ce  gcc/ada/gcc-interface/ada-tree.def
 71ae48a6622bd120e6be917ab8d64bf6  gcc/ada/gcc-interface/ada-tree.h
 51c95420b5900990141d2e5705582197  gcc/ada/gcc-interface/ada.h
 4cbfd794461da0feb1b8661ec623b6c6  gcc/ada/gcc-interface/config-lang.in
 9779c4debc13c6f1cfa1e4e6a6e6c638  gcc/ada/gcc-interface/cuintp.c
-b43bc9913a43c58f6b412f15b39d8b78  gcc/ada/gcc-interface/decl.c
+cb827270652e7128b12212e14a40dba0  gcc/ada/gcc-interface/decl.c
 c413d4d50e9563859f4d751a4404b705  gcc/ada/gcc-interface/gadaint.h
 610fd259aa8c7f70adaecc1a439ee311  gcc/ada/gcc-interface/gigi.h
 f2528ece7aa7e2ed8123de8fe434252a  gcc/ada/gcc-interface/lang-specs.h
 e3a177357a504878ee8863c5dddf3b44  gcc/ada/gcc-interface/lang.opt
-ef866c2969fb8b3f13f2d3688bc695fe  gcc/ada/gcc-interface/misc.c
+4c27c8d2e30202eac1e7d1e9bfffd989  gcc/ada/gcc-interface/misc.c
 7bd3630f35c5ac7b5c6cfaf8b16e5723  gcc/ada/gcc-interface/targtyps.c
-5d1a57ddd9d57b180b4cd4a4be8576a9  gcc/ada/gcc-interface/trans.c
-a02b6f4ab87fccca6fd7e17d5894186a  gcc/ada/gcc-interface/utils.c
-7a553c9da3a213884ffa3510657b2072  gcc/ada/gcc-interface/utils2.c
+c24acd0193cc38c43ad22911992a55b9  gcc/ada/gcc-interface/trans.c
+66f1fb7584990a73bddbcd0364e75218  gcc/ada/gcc-interface/utils.c
+453dbe7efe389a1246363b89d3072a77  gcc/ada/gcc-interface/utils2.c
 68b13816c95338a03ea3b161c2099ea1  gcc/ada/get_scos.adb
 baa8fdaf8d693eb6c5a7e42944887584  gcc/ada/get_scos.ads
 e867a4cc97f01b66441a6798d90d4453  gcc/ada/get_spark_xrefs.adb
@@ -2111,16 +2099,16 @@
 c444097cce82db9effcdd4c9c5a96b4a  gcc/ada/s-osinte-freebsd.adb
 e9bd5d8bc9bd1a613082cb3fdf78d0d4  gcc/ada/s-osinte-freebsd.ads
 94d967aaee13bf49e5e0e154e579871c  gcc/ada/s-osinte-gnu.adb
-7527080a292de10894550135dbed8017  gcc/ada/s-osinte-gnu.ads
+d92a6b091106c7dc15302b2da5f8f385  gcc/ada/s-osinte-gnu.ads
 7f1f83f2b78279e17d374e171c1da3b2  gcc/ada/s-osinte-hpux-dce.adb
 e0c8077ba5d78f82edb8990863741a5e  gcc/ada/s-osinte-hpux-dce.ads
 1b3ed31d0914d80bf259b7ee627bd948  gcc/ada/s-osinte-hpux.ads
-7db31ded89ea5e94817f0e46cdcc32d4  gcc/ada/s-osinte-kfreebsd-gnu.ads
+335bc179fd59062a542c5d745fe2a8b5  gcc/ada/s-osinte-kfreebsd-gnu.ads
 c42f30185875a0d4eb697a00df8d28d5  gcc/ada/s-osinte-linux.ads
 f147ed363aba7bfd5210a6c9bad98d22  gcc/ada/s-osinte-mingw.ads
 e0ccc12265d7031072307fee72e66441  gcc/ada/s-osinte-posix.adb
 95d33f38d09b64c6ddbdf6ca9013a19a  gcc/ada/s-osinte-rtems.adb
-fe47c19713c37f489761c788b554d4f0  gcc/ada/s-osinte-rtems.ads
+28b7f5c1fb0f8b5082fc0c24d6cd865e  gcc/ada/s-osinte-rtems.ads
 8e43cb0ee20789269fc8a03e909f1a98  gcc/ada/s-osinte-solaris-posix.ads
 4b79cc58a1b73b941681456c8abba9f5  gcc/ada/s-osinte-solaris.adb
 5d8bb4d19a51168c31b3c222912bdd69  gcc/ada/s-osinte-solaris.ads
@@ -2537,7 +2525,7 @@
 8e252740bca9edecd024787ce30f649d  gcc/ada/sem_ch4.ads
 624244945a590748325c5c5c0a41223e  gcc/ada/sem_ch5.adb
 701ea5362b9e04194e2db15e956540f0  gcc/ada/sem_ch5.ads
-9e8a2c2a55cc006edca1ce8c49e4245e  gcc/ada/sem_ch6.adb
+f4d25ba1c40eafec289a52f211f48aff  gcc/ada/sem_ch6.adb
 28a7dfff005e523e7d01745dc51c5883  gcc/ada/sem_ch6.ads
 037bdc170487cf7dc07b15149dcf7465  gcc/ada/sem_ch7.adb
 56d3e6547a0912dd936ec7f605b2d8d1  gcc/ada/sem_ch7.ads
@@ -2634,7 +2622,7 @@
 e140d98af57d16903584d7d0bef3a524  gcc/ada/system-aix.ads
 17f25a90ee740067374ebd1d1c5a4b0c  gcc/ada/system-aix64.ads
 30226a4fd428b16322030393cc04e28b  gcc/ada/system-darwin-ppc.ads
-e339f32e04ed66ca7791e54e5fe756c3  gcc/ada/system-darwin-ppc64.ads
+86a5b65c04f1712867b8fbdffa540f94  gcc/ada/system-darwin-ppc64.ads
 e88ee6c9ecd12a0d06a8c427ce611528  gcc/ada/system-darwin-x86.ads
 2485a3790c11c9b2750ffd1aaf26da7b  gcc/ada/system-darwin-x86_64.ads
 f3529cf7e308b1c2f88769fece799df1  gcc/ada/system-dragonfly-x86_64.ads
@@ -2643,25 +2631,25 @@
 25f3a3fee1b2a561ea63182dd634426c  gcc/ada/system-hpux-ia64.ads
 47f63cb03002da080bd48f7efbb405e9  gcc/ada/system-hpux.ads
 0bd33a30d9268cd6f90606e6ce520649  gcc/ada/system-linux-alpha.ads
-520bb2081f96d3ca2d165ecf2134b1e3  gcc/ada/system-linux-armeb.ads
+c6af2dc10c193c22c08348b38fa3b6ab  gcc/ada/system-linux-armeb.ads
 01b0500080a147f99972b2d982e4125e  gcc/ada/system-linux-armel.ads
 364fdafcdcb2a229ca3ca47224421c2a  gcc/ada/system-linux-hppa.ads
 0e122414da38ed660e3eaa9c9be8dafb  gcc/ada/system-linux-ia64.ads
-68ff02dae1328e9f398e3c73dd4802df  gcc/ada/system-linux-mips.ads
-bc023c717df920237fbef95edbd226d3  gcc/ada/system-linux-mips64el.ads
-d12178a6a0ba9ea4b121700cac935ad0  gcc/ada/system-linux-mipsel.ads
+ddf03d7b2a8cba5bab9193239c70e7b6  gcc/ada/system-linux-mips.ads
+fcc26e239c1a24371a4a78954ba317d3  gcc/ada/system-linux-mips64el.ads
+0b3bc0eb1bf2a000598beb1598f47fcb  gcc/ada/system-linux-mipsel.ads
 9ade05d741bb6b9f44a182816caee26a  gcc/ada/system-linux-ppc.ads
-b6eae833e6fe2137efe0aa740315727c  gcc/ada/system-linux-ppc64.ads
+7a62b37f000906c2a6a7443112ce3261  gcc/ada/system-linux-ppc64.ads
 5b5c779ee5bcde3977781e097b91c1a1  gcc/ada/system-linux-s390.ads
 8da865876fdebc15a9fab07fa62fd877  gcc/ada/system-linux-s390x.ads
 43432b26bef17aa65b2fd34e29a2f014  gcc/ada/system-linux-sh4.ads
 ab6d2ca73fb5888b79fe9901adfb8a98  gcc/ada/system-linux-sparc.ads
-746c66c11e22c3197cb994389e56e816  gcc/ada/system-linux-sparcv9.ads
+406a7e49e6e80be0426793c59092b568  gcc/ada/system-linux-sparcv9.ads
 a9e779541250ed8a6f4806893a2f2ee8  gcc/ada/system-linux-x86.ads
 53f0201149b3a77de1cd4a7748ba2ddb  gcc/ada/system-linux-x86_64.ads
 34b18e606f0f307a08fa56858c19d945  gcc/ada/system-mingw-x86_64.ads
 009f003dea0dd424ccad8aa6d022320c  gcc/ada/system-mingw.ads
-f88c313eaecc8e40a2484a6e48107810  gcc/ada/system-rtems.ads
+7f460166af9cc30048191b5fdb8d1f18  gcc/ada/system-rtems.ads
 82baebc8db3e7bfae7183b08fe31c2c3  gcc/ada/system-solaris-sparc.ads
 83f4ccb8086c6fee3b90a682436c1a6e  gcc/ada/system-solaris-sparcv9.ads
 056b449ee14d58e8119219b0720b9287  gcc/ada/system-solaris-x86.ads
@@ -2736,11 +2724,11 @@
 0493a7ed666c4b102be665a8e328be35  gcc/ada/xutil.adb
 2c8b2f1975e4e064d3803db6dbd516cb  gcc/ada/xutil.ads
 50ccfa68b3ffc2cea9079d312bab3902  gcc/addresses.h
-8b315dd0ca3dfd85ed4138a94f0226ba  gcc/alias.c
+1ea67a8bdfe6758c1407490f0a8686b6  gcc/alias.c
 3f435b1cc17bbef3b90835cfda49b4eb  gcc/alias.h
 2129a033ed56d38308ca40e1424337c0  gcc/alloc-pool.c
 f9d22e8738cd46b8cd0075ae0e4bd5e1  gcc/alloc-pool.h
-e6e8f06d2d315d03b3a5239d3f11d83c  gcc/asan.c
+71922db6042ca44d9217d21a73c6b0be  gcc/asan.c
 f24bb3e6f685b695e4763d26c6d5f82e  gcc/asan.h
 f015e12bb7fc520fda759e96f1a39311  gcc/attribs.c
 01d94dd275ab10965e144d0b9fa042f9  gcc/attribs.h
@@ -2759,7 +2747,7 @@
 998cc73d2ebc13688ba0738f7db6d87c  gcc/builtins.c
 d9b3f84012b6195bbd548885fa07798e  gcc/builtins.def
 70361ef7d2d5ef5ab078cc31686c0bde  gcc/builtins.h
-d7427e86dbf8fbabd4a42de303b749b0  gcc/c-family/ChangeLog
+732f68d952d2dcaa1881fe602dba3d64  gcc/c-family/ChangeLog
 ea3fa1f4d7390a105fa3caab4f79aaf7  gcc/c-family/ChangeLog.gimple-classes
 a2097d99f50de5a2a2e9b9f45acca9af  gcc/c-family/array-notation-common.c
 d268d78fdd0da46755bad2715380ca60  gcc/c-family/c-ada-spec.c
@@ -2767,17 +2755,17 @@
 d1049a363c1ecd0f98eee1aeb9ff6bd1  gcc/c-family/c-cilkplus.c
 307acace620255e11a0a4278376f80e5  gcc/c-family/c-common.c
 2ace27db32acd08f6b79a83ac2586e45  gcc/c-family/c-common.def
-61356ffa6a8522c2ff784912b59a3dfa  gcc/c-family/c-common.h
-285e5395a1948ee8a02d84a5c026bca0  gcc/c-family/c-cppbuiltin.c
+9f20703bcd296e28b53330fdacbaa6c4  gcc/c-family/c-common.h
+2726890948ddd8a7c99836847c4c465b  gcc/c-family/c-cppbuiltin.c
 3b48128f9d0659eb1ac831b7d0309053  gcc/c-family/c-dump.c
 dc79c0465bd1d84f8a2a1c8665086010  gcc/c-family/c-format.c
 a722f61259b29e7519af2ea01a4cfbde  gcc/c-family/c-format.h
-46424f0d93a4f1c2958225b7a9635981  gcc/c-family/c-gimplify.c
+889f2fce374ebce16f1c541fafc3b2e6  gcc/c-family/c-gimplify.c
 070d0560fe68e0d18e80f7ea464773ae  gcc/c-family/c-indentation.c
 c40da6434275aba5adccc92809e6e2d6  gcc/c-family/c-indentation.h
 969f5257abd1441eb2e44ec57beac8a3  gcc/c-family/c-lex.c
 f9fc887cc07ce21721909e6cc63fe030  gcc/c-family/c-objc.h
-a9f7cdede5781cfd42fb0bf6a0cc4cc2  gcc/c-family/c-omp.c
+f10a78fbf89addf947056a7351a1eaad  gcc/c-family/c-omp.c
 39020d7f69c32d241015c39dff40d502  gcc/c-family/c-opts.c
 b243e9180d094b7539387b07231deb33  gcc/c-family/c-pch.c
 25b59b2fa2b392ea34e1eafa54f0641a  gcc/c-family/c-ppoutput.c
@@ -2791,11 +2779,11 @@
 84c72ad7037868dfe6b3ea01496d2b74  gcc/c-family/c-target.h
 c332b723ec991da5fb10d4b3b450baf6  gcc/c-family/c-ubsan.c
 392b541b5038adb62676d41a74001649  gcc/c-family/c-ubsan.h
-a3b0076967d29252976ba4145fa1867c  gcc/c-family/c.opt
+cff22aa92cff7c3a722057eb507d5297  gcc/c-family/c.opt
 087e1ce4fd7400b0b286e3c2c7bd9aa4  gcc/c-family/cilk.c
 7deafa20602c6826937fab0a455cc8ed  gcc/c-family/cppspec.c
 dad64a3c28e8bbc124ca8c2f3a7a9f69  gcc/c-family/stub-objc.c
-a575bf8a7604ea59dc92a649577f9ea6  gcc/c/ChangeLog
+8e4f5b6a681941881b61133b3accf1c9  gcc/c/ChangeLog
 9cdf859ec7692fe84b67ba9109e3995e  gcc/c/Make-lang.in
 5bb4a410264b7f7ac0da9ddcffd92210  gcc/c/c-array-notation.c
 6d3e1a369a7f78b2f8b9d9f0f6f8aff7  gcc/c/c-aux-info.c
@@ -2807,13 +2795,13 @@
 88a01d3181a5b0369e3febd6acfe9520  gcc/c/c-lang.h
 8cac2a5e96973c846bd33bb75d3f651d  gcc/c/c-objc-common.c
 1092d3b7a8d0bc846e6d7f7433692208  gcc/c/c-objc-common.h
-658fd55e81e04dbb9fdb65e25d4d41ee  gcc/c/c-parser.c
-e68d1d94dab107ca752ec21c2fd10485  gcc/c/c-tree.h
-ebcf7804fa978c86de277f2cf45ac5b7  gcc/c/c-typeck.c
+99f360f887deb4bc4197d0ec6f6d6105  gcc/c/c-parser.c
+9b1855479c2c36717fefaba6896f2f8d  gcc/c/c-tree.h
+b5ac8b88fc750cd755936cc794748d3f  gcc/c/c-typeck.c
 3747bb41e8fd6a5de51dd6e7a7a47970  gcc/c/config-lang.in
 48ad75424472d7bdc1b734bf90e32a67  gcc/c/gccspec.c
 82c12673c34f23c306e289a9143864bc  gcc/caller-save.c
-ce68401b13ebe1bbabc9cea9313eaa28  gcc/calls.c
+9e1a94e39fbf3c650570aa64ccd735ad  gcc/calls.c
 f7110748a1375215f4469bde141b3432  gcc/calls.h
 0d087c05ff5dd25db84dedfbaf568d4b  gcc/ccmp.c
 d3d5b380ad6f749bd8db65a92d79e3ee  gcc/ccmp.h
@@ -2826,7 +2814,7 @@
 745b7c812796bf46765ebc99d5ad4566  gcc/cfgbuild.h
 a6ae55469bb1b6ad19931eb0ce91c962  gcc/cfgcleanup.c
 3bc167b2db649ed6cbd7ce505e48d35d  gcc/cfgcleanup.h
-a30d4252b545009dd4ec82aabefc6904  gcc/cfgexpand.c
+3d4be9fe9feb4248e7822dbf2561140c  gcc/cfgexpand.c
 020afc9cbf1b8f3e6768a0ce6a7e9b55  gcc/cfgexpand.h
 9d7a00e997730c1e512a0c8f318e1715  gcc/cfghooks.c
 86822fd705361191ce501823f4c84cf8  gcc/cfghooks.h
@@ -2835,9 +2823,9 @@
 e40d94d671641c4d2a68835c259d8098  gcc/cfgloopanal.c
 224984ea290493db3870a0ac1fcec23c  gcc/cfgloopmanip.c
 6b8000ec10e5f8d86a76268393bcb5a2  gcc/cfgloopmanip.h
-0b6b42e81311c9c0b90f384542f84a9b  gcc/cfgrtl.c
+0e5a7f5771e6f0aeb4ab18b86f9b38ee  gcc/cfgrtl.c
 c5f49aa0380336a2a865262bdb6edf72  gcc/cfgrtl.h
-71ded72dde0902e617fa2d55cbbb90e2  gcc/cgraph.c
+555e4220f0d3ea4b83dd17af16a2384d  gcc/cgraph.c
 7605193302a08a7aa5813a2007e874ef  gcc/cgraph.h
 6db406b55343fb518e9a72363f82202e  gcc/cgraphbuild.c
 0dd454c4df9ab62c991b406f6ab4bf4f  gcc/cgraphclones.c
@@ -2911,9 +2899,9 @@
 833a4f3b8d4bd41edd9548e426fd27b3  gcc/compare-elim.c
 5d296c1586f1d268a85c2aa0a3b4d64a  gcc/conditions.h
 9f336f22045efcaa67e235fba1bc08d6  gcc/config.build
-0e141afdcf55ff62734835a38532e63f  gcc/config.gcc
+ade5335c97576ae1c1ae6677f9cf4f6f  gcc/config.gcc
 75d9643d9dc2c2d16c12cdcb12dd361a  gcc/config.host
-f4624f449d40e68419ea99e171e6360d  gcc/config.in
+ab7e07d11b6403781c1f8e477b2a80ec  gcc/config.in
 8e697813dc96ca90f5d0f4c196efe2cc  gcc/config/README
 b94306d00c5458b99b6b45830bf1eae6  gcc/config/aarch64/aarch64-arches.def
 d70c159b70cc03592ac9fad295f8aff9  gcc/config/aarch64/aarch64-builtins.c
@@ -2930,8 +2918,8 @@
 3f9b7aaf2703c560457dadd6e0c9148b  gcc/config/aarch64/aarch64-opts.h
 5e44cc5092927352daf58d5d06792e96  gcc/config/aarch64/aarch64-protos.h
 34b37d5443fa4b7761945c006d214aff  gcc/config/aarch64/aarch64-simd-builtin-types.def
-52242be4568fcea119d6074ceb257d63  gcc/config/aarch64/aarch64-simd-builtins.def
-e1fadf5e5e4d054343fce675c7613146  gcc/config/aarch64/aarch64-simd.md
+2900ce100d2c396ab04379ddcaebb97d  gcc/config/aarch64/aarch64-simd-builtins.def
+d9316f824c3e2ed2fe92b3216a75a60f  gcc/config/aarch64/aarch64-simd.md
 e71203d59ad9d88352c651bf54967d4e  gcc/config/aarch64/aarch64-tune.md
 56e698ddd35d4d45d1b27f04173c27cc  gcc/config/aarch64/aarch64-tuning-flags.def
 28e8b35a70cddb3b2ecc24f45c6b1425  gcc/config/aarch64/aarch64.c
@@ -2939,7 +2927,7 @@
 3283c054473233f66729a33663aba76a  gcc/config/aarch64/aarch64.md
 8186400b6ebc5890fb03c1c392946923  gcc/config/aarch64/aarch64.opt
 ffcb2d86bab40fbb01226fcbac5f8afb  gcc/config/aarch64/arm_acle.h
-3fa2d68117b6c049d2f042ef47cfaec0  gcc/config/aarch64/arm_neon.h
+2307be37347862696a1710a987cb4f58  gcc/config/aarch64/arm_neon.h
 a775d873b993526c6094ca1b28d8e074  gcc/config/aarch64/atomics.md
 aab77a9141d7d8e0d399251a034b05ae  gcc/config/aarch64/biarchilp32.h
 f9fb82867abfae70f536c437cabbe0ec  gcc/config/aarch64/biarchlp64.h
@@ -2960,7 +2948,7 @@
 b0a8914a24f787dbee5e200ee917f621  gcc/config/alpha/alpha-protos.h
 07b69b4d54e4a57bf76dea6f05e45340  gcc/config/alpha/alpha.c
 0a25a7cfc4a2956d79c165776297f982  gcc/config/alpha/alpha.h
-38517a12f3265291c74853b269c5cf0b  gcc/config/alpha/alpha.md
+d248ba9c7788eb583ed7b179cc5029d8  gcc/config/alpha/alpha.md
 a26177734159dae5679e9276b982ace6  gcc/config/alpha/alpha.opt
 4061b6fbc59a1083452389c88c59dc42  gcc/config/alpha/constraints.md
 d6ffc31b378eda081971d2c468da4e2f  gcc/config/alpha/driver-alpha.c
@@ -3007,7 +2995,7 @@
 74de244fd60b2d76a3787960d782373f  gcc/config/arm/aarch-cost-tables.h
 f2b572d07746e403fd525bf9691ee2a5  gcc/config/arm/aout.h
 62fcdf218b75986907eca422e13aabd4  gcc/config/arm/arm-arches.def
-9a616434ff1b3cb0ebf9fa48bab40ce3  gcc/config/arm/arm-builtins.c
+e4a314e21e266db6c5d485e913a6885c  gcc/config/arm/arm-builtins.c
 1e0456dd3a7822f2fa3e26f77e2c2d26  gcc/config/arm/arm-c.c
 65b5dc7fa9360d10a9ca86119c20ba77  gcc/config/arm/arm-cores.def
 b63afb8e425edc52c016b6c15066845e  gcc/config/arm/arm-fixed.md
@@ -3020,7 +3008,7 @@
 b1cbf9ca4f296f2f39987d24e0af2530  gcc/config/arm/arm-simd-builtin-types.def
 c103dfefc6fcb9ebb20a29729bfecb69  gcc/config/arm/arm-tables.opt
 3f73ffc85b17a98310aef5b53adc5d98  gcc/config/arm/arm-tune.md
-cc2c987327ef9a3356a045e607ef2aec  gcc/config/arm/arm.c
+ea7cd77a1db03fa7b565ffbde84298d3  gcc/config/arm/arm.c
 23e54a7c9fe7e1c62983bdd39f19951d  gcc/config/arm/arm.h
 55f1f86069e992742e1b89abcc6ec7c4  gcc/config/arm/arm.md
 2d7e7f27748045f2d77a7377fda31d5e  gcc/config/arm/arm.opt
@@ -3060,7 +3048,7 @@
 3c4127440c24e5b23dce8d0f7cb8619b  gcc/config/arm/fa626te.md
 2e52ace39749711dc3787f62948b77ec  gcc/config/arm/fa726te.md
 197df6dea714a30f83e9b80aae52e81a  gcc/config/arm/fmp626.md
-4b74ce4cb188d764b7914f35639c2116  gcc/config/arm/freebsd.h
+0ecf27dc3b0558645025fe3aaa600593  gcc/config/arm/freebsd.h
 870d22c2f986f799ebc3522dace502f8  gcc/config/arm/genopt.sh
 c8550f4949927e5334c212129185e2bb  gcc/config/arm/gentune.sh
 05e346aff9b27762033d2fd03753ea06  gcc/config/arm/iterators.md
@@ -3116,16 +3104,16 @@
 4c3c46eb845e3505658b81b8eaa14288  gcc/config/avr/avr-modes.def
 0fffc0f61c26f4c9de873ad542b094ed  gcc/config/avr/avr-protos.h
 41b9882721bdec25585513f697848b5d  gcc/config/avr/avr-stdint.h
-88ca6ca8ed203bb11f9d74491a225841  gcc/config/avr/avr.c
+b38d57af8ead4be8ee87d298ed78c01e  gcc/config/avr/avr.c
 aea75b0a042f09c4610dfd149483ed2d  gcc/config/avr/avr.h
-66d5356d423c0d037897ef09cd81bc6d  gcc/config/avr/avr.md
+eff9328f7a8233598fb881c52e6518cd  gcc/config/avr/avr.md
 97ae0e97c66153cd01ba33e6dd23a191  gcc/config/avr/avr.opt
 6eea869c9b52b117753eab2b0bb544ab  gcc/config/avr/avrlibc.h
 272063927d64ca768006dc1e703a4a4c  gcc/config/avr/builtins.def
 fe325d127710d93f8c73b9ebfdd07ef4  gcc/config/avr/constraints.md
 04cce33bd7b1254e4ef5acfd097d1e55  gcc/config/avr/driver-avr.c
 7ad86a6961289da9a41d477a7d06632f  gcc/config/avr/elf.h
-ccb997e1a0a2c184e23e1d255ddbd5d8  gcc/config/avr/gen-avr-mmcu-specs.c
+ea6ae4085ca32c92536855c96966835b  gcc/config/avr/gen-avr-mmcu-specs.c
 ba3b75183e01f578520c7f5ad4822d65  gcc/config/avr/gen-avr-mmcu-texi.c
 a9056b0b6e3fde442dc545459462b61e  gcc/config/avr/genmultilib.awk
 5ee74356b8bc2a97c70d2b19e9547ad4  gcc/config/avr/predicates.md
@@ -3209,7 +3197,7 @@
 9a96119bd809f334545f28e92af4d7da  gcc/config/darwin-protos.h
 158992b1d82c85cd69b4d3a96fa964ba  gcc/config/darwin-sections.def
 56de9a396d23dd931c1f0dfd326f7fae  gcc/config/darwin.c
-1988031d70e01f816930f126da6a4f87  gcc/config/darwin.h
+217b6049deb67093ce6ace2e85e26144  gcc/config/darwin.h
 b463a7c4d27e349e9f2cd0e00a61487f  gcc/config/darwin.opt
 f2c8f6f89fa8ec74c30f6d9bc2d0d4e8  gcc/config/darwin10.h
 3544d912bd14b11ecd2f3a94d712c1b9  gcc/config/darwin12.h
@@ -3332,7 +3320,7 @@
 fe17ca5109af0e6e93b74bae231d1a55  gcc/config/i386/clflushoptintrin.h
 8db337d30ef627209263315869a56a98  gcc/config/i386/clwbintrin.h
 876790e99f6c0bb421e1492c7ea46ff0  gcc/config/i386/clzerointrin.h
-90532cc9b95026c43a798885aa570e2f  gcc/config/i386/constraints.md
+a6979d6ddcc5bb8ecf2a26f5ea34c71c  gcc/config/i386/constraints.md
 71baed36fc56f65d8c91aaefd5758aa1  gcc/config/i386/core2.md
 869e4b210e6f821bb16ac1e41fe7c5b7  gcc/config/i386/cpuid.h
 7fee26d8fedd334aa6fcd4bdc08cffb3  gcc/config/i386/cross-stdarg.h
@@ -3350,7 +3338,7 @@
 8f07bf469832ed4bd2cf349351a4be27  gcc/config/i386/djgpp.h
 c8e620657991f87382f5e2868a3a49e4  gcc/config/i386/djgpp.opt
 bf04c6bfb2855901059ede3c90d91a0e  gcc/config/i386/dragonfly.h
-1d476bca8c104bac65750c75940c3f2f  gcc/config/i386/driver-i386.c
+86578484e605e5669e9fa482de9ac349  gcc/config/i386/driver-i386.c
 0f5e3cbf6fc57e8c96539b55c3c5d03a  gcc/config/i386/emmintrin.h
 4d39e44657c94313f49309df7592ed83  gcc/config/i386/f16cintrin.h
 0123c9ade82b62efeff1e8b33c49a4a9  gcc/config/i386/fma4intrin.h
@@ -3371,15 +3359,15 @@
 7207180c0653cb9c7507f26a9a814675  gcc/config/i386/host-i386-darwin.c
 b80037f63f5fd458518208bbd7dbaa4f  gcc/config/i386/host-mingw32.c
 47ac29c21a60ee2ca29d54ea4a345deb  gcc/config/i386/i386-builtin-types.awk
-304099577fa33b6bf5bf012bfb1257d8  gcc/config/i386/i386-builtin-types.def
+b3837bf5c922be13974120be24db78c3  gcc/config/i386/i386-builtin-types.def
 bbfe1f7b817a5b3321bdc8c5ca0d6b32  gcc/config/i386/i386-c.c
 c29497fe4c1e5389895075d220252ca8  gcc/config/i386/i386-interix.h
 1c71860a666631f1a174dea14c52dbff  gcc/config/i386/i386-modes.def
 ac0b4653ef3d1e8200e8efbf73c5d8f0  gcc/config/i386/i386-opts.h
 d3f3a1198cf0be4e2a3b9b10e0f761cc  gcc/config/i386/i386-protos.h
-8558c1ec5c184c6d477b1b353e12f1cc  gcc/config/i386/i386.c
-8d0d0d6956f44b2dd70e2ccc5677fdc0  gcc/config/i386/i386.h
-ea9cb826551f214701f0ec1e3c12d742  gcc/config/i386/i386.md
+5dcd9d24f02d8cf92de3e00a69a09d94  gcc/config/i386/i386.c
+39295430120b7691bd2d787705eabfb1  gcc/config/i386/i386.h
+077d661cd9ce686cb9b40a9cb77c5c87  gcc/config/i386/i386.md
 e16f0e58cf07c96d0511136d7c28611a  gcc/config/i386/i386.opt
 be209c39783d5218055012112fe03242  gcc/config/i386/i386elf.h
 a56c5de1cde5aaa7a3753ce09e0be661  gcc/config/i386/ia32intrin.h
@@ -3425,7 +3413,7 @@
 5aa912e76dac257cfe5012440f7ad90a  gcc/config/i386/pmmintrin.h
 7810065fc76773a3b740126a476af54d  gcc/config/i386/popcntintrin.h
 4dcd1cf3c734c77f06e840e1fbd678f8  gcc/config/i386/ppro.md
-d0e6526febb471bb3acfeb59218f2847  gcc/config/i386/predicates.md
+50884030e7b9ddc82422cf705f6659d7  gcc/config/i386/predicates.md
 a0f562fc0aef289f6cdef5b931f5e39f  gcc/config/i386/prfchwintrin.h
 7feefb44b5c73254b20e5b7820e45ba1  gcc/config/i386/rdos.h
 d57b23dfe66e6405fed787f9047ce355  gcc/config/i386/rdos64.h
@@ -3437,7 +3425,7 @@
 6d7b4d52cdc2a6db01f9c20c45be0795  gcc/config/i386/slm.md
 d1a02c4509457e48895953880e756b4a  gcc/config/i386/smmintrin.h
 0a7e726af98f6a39952052f361cdfbee  gcc/config/i386/sol2.h
-9f55c5a60dd162d1ae5fb93d69b7a4a3  gcc/config/i386/sse.md
+30d0c0c8fd58d4ffee139d715d1e1b66  gcc/config/i386/sse.md
 91d7c7f7b9b34e3ae4e87882a355bf2b  gcc/config/i386/ssemath.h
 be9c2b7e2ff5d3a32ab3d902b56762ac  gcc/config/i386/stringop.def
 96f9e071c5c165d0cc21e51cfebe5b92  gcc/config/i386/stringop.opt
@@ -3662,7 +3650,7 @@
 f298ec31e1348e797caa9f7a1a7ea94d  gcc/config/microblaze/microblaze.md
 4dec1d8cba0ae9e95e0ae11ad82575dd  gcc/config/microblaze/microblaze.opt
 a16c7f39b0b2862c81dd0f0a4b232307  gcc/config/microblaze/predicates.md
-f986ab14af6b81f50248b55de266dfbb  gcc/config/microblaze/rtems.h
+c560707d4508d14056eaacb33c6b00bf  gcc/config/microblaze/rtems.h
 ca8367ac97d24747376a746a1a3806c2  gcc/config/microblaze/sync.md
 17818a25ae3112098cd91d698e37f0f7  gcc/config/microblaze/t-microblaze
 63ccba4e7f745d36609d7c129bac6288  gcc/config/microblaze/t-microblaze-linux
@@ -3851,7 +3839,7 @@
 d835d08884a2846e70bef505767bd3f1  gcc/config/nios2/t-rtems
 c2be83b7f197d233a6ce04c2245a312a  gcc/config/nvptx/mkoffload.c
 71182308acd7b24f983c5c3836f21e97  gcc/config/nvptx/nvptx-protos.h
-656dbc77c4631baba2d2fc786dbfd286  gcc/config/nvptx/nvptx.c
+d16914348f2acdb5a72c4e8cd5c348d9  gcc/config/nvptx/nvptx.c
 ee26c09dc69c862b8465425e61efb50d  gcc/config/nvptx/nvptx.h
 b6d00d17aa4debe5cbfb686a317af311  gcc/config/nvptx/nvptx.md
 f20baafe92ab83b58eced858f6668a59  gcc/config/nvptx/nvptx.opt
@@ -3881,9 +3869,9 @@
 e1c6685604f681faea2ce89975cb7fb0  gcc/config/pa/pa-openbsd.h
 7fe7a5966510922de22aeefc35c8e010  gcc/config/pa/pa-opts.h
 b1fa12eef4f2d69520c8e33ff00ea833  gcc/config/pa/pa-protos.h
-8db4f36dd448d091f4e3942edf612201  gcc/config/pa/pa.c
+9a436df6ba10cb315e4759c263bb20f7  gcc/config/pa/pa.c
 0cb5f8b8230c90bd6580010bb9088794  gcc/config/pa/pa.h
-85cf1e3de4bb1b1e4842fc2d8277c179  gcc/config/pa/pa.md
+870d0b3ff5e10512bbebb34482e95aa9  gcc/config/pa/pa.md
 2a55715c21637c72f4c2306798f28715  gcc/config/pa/pa.opt
 2c84ac4128fba0f0ec7a3a85f7724f7f  gcc/config/pa/pa32-linux.h
 3eb3ff97a411ccda47b603da5c8cc95f  gcc/config/pa/pa32-openbsd.h
@@ -3921,19 +3909,19 @@
 dbafb0fbae9820ebfe82de65a3b83f68  gcc/config/rl78/rl78.opt
 013aededeacbccea80fe3b6306066322  gcc/config/rl78/t-rl78
 ad241b2a8851ae9d5b6641c7b7b479cb  gcc/config/rpath.opt
-a3432c56bcb7fc05fd6b64099e48f679  gcc/config/rs6000/40x.md
-8fc4d37e67deb5fe12ee814274162f79  gcc/config/rs6000/440.md
+be34836d1ba31c631716d5010c1fe037  gcc/config/rs6000/40x.md
+e2c353cd79f9a4399a0dc40fe79e035c  gcc/config/rs6000/440.md
 cfc1fff1a1e39dd4fd2f1e047c1b010d  gcc/config/rs6000/476.h
-615d3d843859a69803593326d4b04616  gcc/config/rs6000/476.md
+76c22ba4be588931c8b58aff695d1d6f  gcc/config/rs6000/476.md
 1da0524d2d6d22f5cb7d53d9fe1c611b  gcc/config/rs6000/476.opt
-6c88c644d7df100d13787b316e121593  gcc/config/rs6000/601.md
-a6556ad3f85c0f4b0b1e84217fa9e114  gcc/config/rs6000/603.md
-d37c6f2ae8b08b04cff356c70860d541  gcc/config/rs6000/6xx.md
-fe7aaac8aa1b8059c3116b73e397f690  gcc/config/rs6000/7450.md
+7c0fa5cb3b835130227458f0f69f813b  gcc/config/rs6000/601.md
+ecbb83eea3d6a47a6af5584c6be12ca9  gcc/config/rs6000/603.md
+481cf4bf7f0be523a61462b9fb81de69  gcc/config/rs6000/6xx.md
+0fe53917723a9db222e730f098ace1fa  gcc/config/rs6000/7450.md
 03b5a697e67b56138a872018df4c3bab  gcc/config/rs6000/750cl.h
-010f2f4c822c612437243e649ec4c102  gcc/config/rs6000/7xx.md
-c8e123f1b622c43a3745ff2b5f799035  gcc/config/rs6000/8540.md
-cc8a63fb23e95bd165f77f99193198fc  gcc/config/rs6000/a2.md
+6eae8bf4ae5936dd0db712c9458f6901  gcc/config/rs6000/7xx.md
+02e47ab90dd56329510ee3801d6d700f  gcc/config/rs6000/8540.md
+f27e2df971a7f7e80091bf85b9be16dc  gcc/config/rs6000/a2.md
 215c8a4ac1298c2f899cb270f784122e  gcc/config/rs6000/aix-stdint.h
 d4d5391a097711b67df3082070de4c3a  gcc/config/rs6000/aix.h
 e580ffd868554681a147b5173478fb59  gcc/config/rs6000/aix43.h
@@ -3943,12 +3931,12 @@
 02a3d453ca7e43f4bf70187e1c3cf346  gcc/config/rs6000/aix61.h
 21c1c24d19668403ff77dc915a743342  gcc/config/rs6000/aix64.opt
 1088dba38de5967f615c2c010164ec48  gcc/config/rs6000/aix71.h
-4b64a4bbfc491cdb49ae51bf4dbdbbb8  gcc/config/rs6000/altivec.h
-890c898bb424f6b9a14e77361e11c737  gcc/config/rs6000/altivec.md
+72b7be964acfdeb0ca6642e9bb019ee4  gcc/config/rs6000/altivec.h
+1ae5cce9f95be1f33759897a0e901575  gcc/config/rs6000/altivec.md
 ebb5e6bcfc1093c0aff7c41cd9353433  gcc/config/rs6000/biarch64.h
-eb88cb402ce0ae76bea0e2669d29faf1  gcc/config/rs6000/cell.md
-ab77897337ed0bcc94d911de0a9b84d9  gcc/config/rs6000/constraints.md
-74ed46696e6d8336ffbaf386d75e54cf  gcc/config/rs6000/crypto.md
+936aede56563f66921091a90d3d1d56a  gcc/config/rs6000/cell.md
+2697e3b9700fedaea4ff0e78242d1382  gcc/config/rs6000/constraints.md
+3989f0e14500049f924ab6bf76471a93  gcc/config/rs6000/crypto.md
 c85b3bacf772d069c8a138ff0cf48400  gcc/config/rs6000/darwin.h
 cd92ef7ed3430ad83c27c94fc7c97de4  gcc/config/rs6000/darwin.md
 e8e5a87925f97e07063bc36de5dc3b22  gcc/config/rs6000/darwin.opt
@@ -3956,14 +3944,14 @@
 78939b2279a4d082aea92f53a289d711  gcc/config/rs6000/darwin7.h
 ac431f1a0b8ae0c72fc7cab9bc9e2f1d  gcc/config/rs6000/darwin8.h
 a77da74ccfb88c7b6bcd77d4a5f98c90  gcc/config/rs6000/default64.h
-522858d4ee17f4b8129dc2ff6eac0b08  gcc/config/rs6000/dfp.md
+1a96a05c3098cba8dcad9a84f4da9c74  gcc/config/rs6000/dfp.md
 b9490f963c3648aa2f0de7bc1cd5af58  gcc/config/rs6000/driver-rs6000.c
-d7a141c5235cb379dfa386c990ea731b  gcc/config/rs6000/e300c2c3.md
+d949390c82f3443dbfb82eef160fa0c7  gcc/config/rs6000/e300c2c3.md
 85e4c2a561d394919589b92fdf2a6da3  gcc/config/rs6000/e500.h
 8bb8b4dc450a6089b1cfca551026bfce  gcc/config/rs6000/e500mc.md
 3a8a9616dd1a37f5c41ea0eebe2b140b  gcc/config/rs6000/e500mc64.md
 0474b71c5e8814f8a2c2929068ebd209  gcc/config/rs6000/e5500.md
-91ac3cc581488d8d5149cbb4bfb5925d  gcc/config/rs6000/e6500.md
+fe4ae385f84f18458badf29e377e0771  gcc/config/rs6000/e6500.md
 a737c12b8f7510a91988a05012db3ccf  gcc/config/rs6000/eabi.h
 cbd3019152cc1036fd011d0059012250  gcc/config/rs6000/eabialtivec.h
 cb63806e3e70caa314033e967b7d4bb5  gcc/config/rs6000/eabisim.h
@@ -3973,7 +3961,7 @@
 8eabfc237f6f5d69a39b97c2a170287b  gcc/config/rs6000/genopt.sh
 386c32703bb134082430ae71c03664c9  gcc/config/rs6000/host-darwin.c
 ff786276df16ab764e024e79f389d1f0  gcc/config/rs6000/host-ppc64-darwin.c
-e8f836ba652ea98cf75c38a9a51571f2  gcc/config/rs6000/htm.md
+2299a6244b44c4fa0b0180101f4c9284  gcc/config/rs6000/htm.md
 4902896bbb0c8507f0cef5391b46f052  gcc/config/rs6000/htmintrin.h
 f8855608896ff92f191cd0ec0e8debce  gcc/config/rs6000/htmxlintrin.h
 c6a61039cfb5b76277bcccaa262e3ee0  gcc/config/rs6000/linux.h
@@ -3983,33 +3971,34 @@
 a0078bcc38f4ed35217a24ccfae5c528  gcc/config/rs6000/linuxspe.h
 27fed5a1c278b05b79d11ceb2b575b91  gcc/config/rs6000/lynx.h
 0cc3c5f9101501b8253ce3176c3ffce4  gcc/config/rs6000/milli.exp
-c624579cdc2079804105ce3d1189c52b  gcc/config/rs6000/mpc.md
+2fa8dcb8bc43d9ba7fffddb47770b257  gcc/config/rs6000/mpc.md
 c2fd14dbafe257185d6e8d9378100414  gcc/config/rs6000/netbsd.h
 dbc5748d385f0a366a69b70e5f4b5200  gcc/config/rs6000/option-defaults.h
 41f286ebbc56d4aa7ccf8cab2e90cfc5  gcc/config/rs6000/paired.h
 55af659a3619ef1966eece3320f3c9dd  gcc/config/rs6000/paired.md
-02aa07ccdebf9ed3f0df6f5d31a4dace  gcc/config/rs6000/power4.md
-3cb4b79927603a40dcc7f54b0a07948c  gcc/config/rs6000/power5.md
-253d89e0957e9e5492d8dcf15d208fc5  gcc/config/rs6000/power6.md
-83bc851e7693aeadfdf97ba3f11aec17  gcc/config/rs6000/power7.md
-9ad7a77314079c9e0cd64370c950c42b  gcc/config/rs6000/power8.md
+31242fa4ed8abafeba3b82a860474603  gcc/config/rs6000/power4.md
+44d38db73ba888118ad2e68d58f463c5  gcc/config/rs6000/power5.md
+9c803622bb5146608fe9539f2af34f36  gcc/config/rs6000/power6.md
+392d61b850052a84dca819f18d09ec44  gcc/config/rs6000/power7.md
+d8b143420c8e25c7b2a8df221ae27589  gcc/config/rs6000/power8.md
+4c6843f36ebb8e0c06de737adda165b0  gcc/config/rs6000/power9.md
 c335f4f65801de1318cd4db8b62934ba  gcc/config/rs6000/ppc-asm.h
 ea4871edf7de554404015404bafd83e6  gcc/config/rs6000/ppc-auxv.h
 30884ec5924e409646acd1aa99423fc5  gcc/config/rs6000/ppu_intrinsics.h
-6d9c1ca23d345218b3077b98e639e07b  gcc/config/rs6000/predicates.md
-a68302ec6a66487c8ecec6e28ef0e043  gcc/config/rs6000/rs6000-builtin.def
-596338f547ae69967d84ba7f4f847693  gcc/config/rs6000/rs6000-c.c
-7c301066108088876ee2e09362770be1  gcc/config/rs6000/rs6000-cpus.def
+195cd4f51261ae5a6bab57f4be102730  gcc/config/rs6000/predicates.md
+fed7519f3fb7d3f6e3b9e82dd640d7c0  gcc/config/rs6000/rs6000-builtin.def
+7baaf3b9a76f29c14d1e20e921eef7da  gcc/config/rs6000/rs6000-c.c
+3e5ef6c30730e4575563890ec3cfe76b  gcc/config/rs6000/rs6000-cpus.def
 2f0d36a3bf95d74249364237cf04e29c  gcc/config/rs6000/rs6000-linux.c
 192ddf2c1b6fd7fe7e53b1acadaee645  gcc/config/rs6000/rs6000-modes.def
 14f48bec5cd76d2a5aada931fb1fedf4  gcc/config/rs6000/rs6000-opts.h
-be801487c27166d61655a5ee6fb17163  gcc/config/rs6000/rs6000-protos.h
+7389795c236e28309f4187cce6e2dc55  gcc/config/rs6000/rs6000-protos.h
 b43d18bcb08f2293531b3302947868a2  gcc/config/rs6000/rs6000-tables.opt
-157543f273b999d4aa0589bd9ec62145  gcc/config/rs6000/rs6000.c
-b3d76f8a9e6c3f285875d109152cac89  gcc/config/rs6000/rs6000.h
-79d11c1b7f5b67bf5e7dc1b88beb3be9  gcc/config/rs6000/rs6000.md
-334e5a36e5ba56cf459f5d29dc275a86  gcc/config/rs6000/rs6000.opt
-bc7c7fd50f8133954bd162f41163a526  gcc/config/rs6000/rs64.md
+71c5cdb7a1b42c30338eb5001a658ae1  gcc/config/rs6000/rs6000.c
+219d2a37391d11dee8e606c70d31fa65  gcc/config/rs6000/rs6000.h
+b555f8e178f9b8bd13235a2c7ed5ac40  gcc/config/rs6000/rs6000.md
+ca447d624d64bde7352a3632cff4e012  gcc/config/rs6000/rs6000.opt
+23eae5c1992970cba9db6c157ab8c4f6  gcc/config/rs6000/rs64.md
 089f55bc6e1565ba82f6d496569d3280  gcc/config/rs6000/rtems.h
 510ae383bcc5df111af9d4407a82b6cb  gcc/config/rs6000/secureplt.h
 0377ddd2fcdd6253e75cfe7f6a9aee18  gcc/config/rs6000/si2vmx.h
@@ -4018,7 +4007,7 @@
 4916c7683b7e0a7036c40eb6d7ee92f0  gcc/config/rs6000/spe.md
 70e488f99d30586ce36bfe7b9dc08fec  gcc/config/rs6000/spu2vmx.h
 89082edb09e5818e9e5f9f05685cadcd  gcc/config/rs6000/sync.md
-975824c5c614d1480831eb06f3b18f10  gcc/config/rs6000/sysv4.h
+056da47aa9e7eb07f8dea417fb567401  gcc/config/rs6000/sysv4.h
 2913dacd00e26860f7ad46828646ca14  gcc/config/rs6000/sysv4.opt
 72d0179bc61a6d4aa963be895a0d6e5b  gcc/config/rs6000/sysv4le.h
 93056159fe947e9f851f95a932a97bfe  gcc/config/rs6000/t-aix43
@@ -4038,17 +4027,17 @@
 7116c0a8cdb50f6a880f3e39b38fbee9  gcc/config/rs6000/t-ppcendian
 7f0dbbdf1e014933add4051db875bfae  gcc/config/rs6000/t-ppcgas
 1b8aba690a39464c4ea9c647d73d6983  gcc/config/rs6000/t-ppcos
-7389d8d00e632c8845d538dc99e5c6b7  gcc/config/rs6000/t-rs6000
+98cf7ab5ad50cd5fa7d1d38921be79a1  gcc/config/rs6000/t-rs6000
 ae9fccfa6dbce7c4de5e57cb98ea316e  gcc/config/rs6000/t-rtems
 3139a8aaf8df8e678d1895cd6e6cdbc5  gcc/config/rs6000/t-spe
 0bd38a9da8637b9ca3a43b70bcd7f6ad  gcc/config/rs6000/t-vxworks
 f11925c88524d2fd457bf77944da1302  gcc/config/rs6000/t-vxworksae
 3f0601a68de7a0aee8264b538228d943  gcc/config/rs6000/t-vxworksmils
 bb61df2b42a69a90853a503710200de1  gcc/config/rs6000/t-xilinx
-90d8139c477dc9d8ff1374f594342cd1  gcc/config/rs6000/titan.md
+cc22792d76d22d8203dc7c3680c1dbc7  gcc/config/rs6000/titan.md
 7369115a6bfe8259388f41e912c060f2  gcc/config/rs6000/vec_types.h
-3895f5086b0451178d2cab3a8edc0df6  gcc/config/rs6000/vector.md
-64991c6a25d1e8270725d50368b8fb85  gcc/config/rs6000/vsx.md
+ed5c9b710457da108e718e8517f71c08  gcc/config/rs6000/vector.md
+444b4ec5dd2806e425c1e3138284f3d2  gcc/config/rs6000/vsx.md
 4d14358837cff46d3efb3a12dfa4fb39  gcc/config/rs6000/vxworks.h
 724f6bc5a165006b67c0526f1bd7477f  gcc/config/rs6000/vxworksae.h
 d0482b801e0a94640973282cfb41b1a4  gcc/config/rs6000/vxworksmils.h
@@ -4059,10 +4048,10 @@
 1aff8cb3714b63b6c3367f552dae743f  gcc/config/rs6000/x-rs6000
 e5e773649ecdb110972c35e49c42b3e5  gcc/config/rs6000/xcoff.h
 14b84186ff830f20eb02a0e254ead887  gcc/config/rs6000/xfpu.h
-36a1d4af1d8697adca6a1af98b7b0cf4  gcc/config/rs6000/xfpu.md
+1c69fd8a6a2d3aa89f111d94a29c74a8  gcc/config/rs6000/xfpu.md
 750508def567aebb2fcd9b027515ce60  gcc/config/rs6000/xilinx.h
 1701cee04ec5d0023ee2f2ceb0ff7490  gcc/config/rs6000/xilinx.opt
-3735d6fa9e1f7a056f86652bf630d59e  gcc/config/rtems.h
+c259e167d92ed9ea65d4529c9ac58029  gcc/config/rtems.h
 29973834f5994d1d1eb068d452b4912b  gcc/config/rtems.opt
 7ade2acf000a30e0e591946c40cc5802  gcc/config/rx/constraints.md
 e6126d96e89716a341e26fa279f84be1  gcc/config/rx/predicates.md
@@ -4093,9 +4082,9 @@
 df9ea5d53147f236d75784dfea931042  gcc/config/s390/s390-modes.def
 9fbc56cdaa1a0bfa0e8af1c738f747cb  gcc/config/s390/s390-opts.h
 ec6ce661c7b87984fbda470242973d68  gcc/config/s390/s390-protos.h
-286c274799f9c837c69299a3d92749cd  gcc/config/s390/s390.c
+cf2b018db73bc2242c43e8fd064460b9  gcc/config/s390/s390.c
 6128183534b6460c3504e49da918f124  gcc/config/s390/s390.h
-aef50f68871f4a43a28df1fa615b7353  gcc/config/s390/s390.md
+3d0ed16a636ca7198d07e174a4bb3ec1  gcc/config/s390/s390.md
 93ff0c316888e0ae1e6e5fcbb89614ea  gcc/config/s390/s390.opt
 b92144af9dcab9d6a6bd0a619e8bd90a  gcc/config/s390/s390intrin.h
 7182f5655f81cbe30f04b3209bb50a8c  gcc/config/s390/s390x.h
@@ -4166,32 +4155,33 @@
 cce52944785c3c1036a7380adda38c22  gcc/config/sparc/constraints.md
 4899a6b24fe9d952cbb0a117c5014933  gcc/config/sparc/cypress.md
 a6f5c02cb556d4484b510b1b080970f1  gcc/config/sparc/default-64.h
-8861dca695ebec27403ede9cba2e83aa  gcc/config/sparc/driver-sparc.c
+999b81b4a3d65c9f3913d9c5ac50116e  gcc/config/sparc/driver-sparc.c
 24b6ddb0c85a7d35c6bef23e162f238d  gcc/config/sparc/freebsd.h
 e3873b9f7262fe2e5e1c1ff303fd07f1  gcc/config/sparc/hypersparc.md
 ceb5379ddc5c41b514ec37a1902d2f2e  gcc/config/sparc/leon.md
 bce3eb1a406fa181a3518aeca8a5f851  gcc/config/sparc/linux.h
-4d0b279be0d03ade9a7a03dea9aab8c6  gcc/config/sparc/linux64.h
+e90fb5dab384ef61b70412869846e81a  gcc/config/sparc/linux64.h
 44524f5016f24f5db03ad91912a30fa7  gcc/config/sparc/long-double-switch.opt
 d14affc9d9a7c6d706ac72f92b369f54  gcc/config/sparc/netbsd-elf.h
 08f60d645b2128365c08c0f6c6e221ff  gcc/config/sparc/niagara.md
 16b7243175105a0d257eb4421bedc2ec  gcc/config/sparc/niagara2.md
-e597ae6bcd05bbe47a86aea7463c12ae  gcc/config/sparc/niagara4.md
+78dfd78b0f3609e0494bbaf344d70695  gcc/config/sparc/niagara4.md
+60463e86a2bfe089ae54632abf1cd938  gcc/config/sparc/niagara7.md
 3f126aec8253ea73daa2fbaafc3f7153  gcc/config/sparc/openbsd1-64.h
 df546d4092fe20ba80bd5a3954f0bd35  gcc/config/sparc/openbsd64.h
 fdf6ab88ad0b4e36a3b8ebf25cfdd547  gcc/config/sparc/predicates.md
 2042472acbe05e3e6c55253f1b308604  gcc/config/sparc/rtemself.h
-e105faae60a663602a2c212e0d82be55  gcc/config/sparc/sol2.h
+ea486cef33954ec2c7cd6b2bcd57b5c1  gcc/config/sparc/sol2.h
 027897262736bac521955a4e91403e9d  gcc/config/sparc/sp-elf.h
 16197cb93f1fda192e849bde60b989d3  gcc/config/sparc/sp64-elf.h
-b16df431afbd3ad37c03599441a6a068  gcc/config/sparc/sparc-c.c
+24821a14bcdbe2e146ed8e020c06d35c  gcc/config/sparc/sparc-c.c
 6e05fd82c65a1c0b69f52820e4e2c82a  gcc/config/sparc/sparc-modes.def
-e7e72eec1accf85bc1badbb0941af4f6  gcc/config/sparc/sparc-opts.h
+76ec8424fd03e5e3660223b5ca3cf59a  gcc/config/sparc/sparc-opts.h
 3b12f88afd2307417ea049e4a24a9bb8  gcc/config/sparc/sparc-protos.h
-9266b115b2f0af3232f05cf0c525c3e3  gcc/config/sparc/sparc.c
-28bbdfc6758c9c5ab027f2c08ef7a013  gcc/config/sparc/sparc.h
-1e404c290eca635c799aa01eb4d8d355  gcc/config/sparc/sparc.md
-48c9d42cb9fd0422c5cf112826aa7ffa  gcc/config/sparc/sparc.opt
+c45d5a341822603b1d2e3234df6c4200  gcc/config/sparc/sparc.c
+da3c18895492fa52031c534e5825b3fe  gcc/config/sparc/sparc.h
+1f89fb1ea3b02cbe8c12395bdcef59a6  gcc/config/sparc/sparc.md
+18fcbfcaaf4ebb852311426ae9f8571d  gcc/config/sparc/sparc.opt
 9cb87fbe1c20a8991a89a8c2215a7c07  gcc/config/sparc/sparclet.md
 8fa2a5576a24f640750e744d90353334  gcc/config/sparc/supersparc.md
 12aaadc74ad00986b0b584b5670f83a2  gcc/config/sparc/sync.md
@@ -4210,7 +4200,7 @@
 410423780343a1431e1c0dc5bf60dba8  gcc/config/sparc/tso.h
 b6612a314463771600938ccbd967e4c1  gcc/config/sparc/ultra1_2.md
 664dc34c9e8a2da763a8d607cdd40c28  gcc/config/sparc/ultra3.md
-172bd3dd1afbcc416192c4348f242e3b  gcc/config/sparc/visintrin.h
+6dd43af528bb6984a85f9b73d6cf430b  gcc/config/sparc/visintrin.h
 bf27cffd7002ed10c819216944e1fc8d  gcc/config/sparc/vxworks.h
 9b2ddc345afcea4f415dd0c8bc2d2ed3  gcc/config/sparc/x-sparc
 ec6f83b17b1625fed43638a36dc76ae5  gcc/config/spu/constraints.md
@@ -4327,10 +4317,10 @@
 905539c10b01b14270085b2ff8a8e401  gcc/config/visium/t-visium
 5970b7b34f57ccb9e61f7e6ca0b0990b  gcc/config/visium/visium-modes.def
 bcbe3f2a16b7c074ac5b3f63ddaa9fe2  gcc/config/visium/visium-opts.h
-8b4eaf75ea504e522ec4e6f7e5d0a800  gcc/config/visium/visium-protos.h
-4a68104ef84d725cd7c9b18678dc889a  gcc/config/visium/visium.c
+f179b316529c1e1aef8dd4a708a79edf  gcc/config/visium/visium-protos.h
+f211ad99efeaa709f4eed4515950528d  gcc/config/visium/visium.c
 13491427224304bc418ddad214bd2666  gcc/config/visium/visium.h
-5301760e9c5059d01ad49e4a4d27b512  gcc/config/visium/visium.md
+49f063ffb6ecc0eb5d9533b269661a66  gcc/config/visium/visium.md
 809a10680b60475e5abe66769cac59e5  gcc/config/visium/visium.opt
 883b3e153a9672ad32f1c8cb18cbea9d  gcc/config/vms/make-crtlmap.awk
 9b09f55f7820a1189c8b3dd933aca2ea  gcc/config/vms/t-vms
@@ -4374,8 +4364,8 @@
 bb1965ec2a1e0ce5e60d527c23ca610b  gcc/config/xtensa/xtensa.h
 d3ed3f2851a6ee9f647a0fe488ad1639  gcc/config/xtensa/xtensa.md
 6bc76a8cf807646d45ffd30b5ca7d2b2  gcc/config/xtensa/xtensa.opt
-a46aba5ea3ed52179bc15d322a73bab7  gcc/configure
-75eefe68ea80541c25dd77c91182eefa  gcc/configure.ac
+ebf9ee0b037a06c3e8bd155c4eedc1eb  gcc/configure
+19074c8f1663edb2fd70e9230c4b2bfd  gcc/configure.ac
 0ec5b41e50536d76b12ce8977926b0df  gcc/context.c
 26da2cb861339f31f80bd959e0d59598  gcc/context.h
 cccacb2ac29511a68f30d50c4f2a9655  gcc/convert.c
@@ -4383,7 +4373,7 @@
 d80857164629763d35964508054ddcda  gcc/coretypes.h
 c1d9055612e35b11f4c86de664f8e1a7  gcc/coverage.c
 653580fc0a70e3ade04c5b00362b0daa  gcc/coverage.h
-588dd1bd87a8445d4a2ce8e3c9bf6dc5  gcc/cp/ChangeLog
+07a267d95fe6b59a9cdf0b9c83620aa5  gcc/cp/ChangeLog
 d271e3663538ba1f3281cab3838e92cd  gcc/cp/ChangeLog-1993
 f5a44adbc05521162350ca409d1d95ce  gcc/cp/ChangeLog-1994
 ac55db48d964cb5469ff03c1cd3ee04d  gcc/cp/ChangeLog-1995
@@ -4411,57 +4401,57 @@
 9aa3cd9f75c785de9f51446e3f295515  gcc/cp/ChangeLog.tree-ssa
 40c026d4c25f7d1b05e9209c1db5fce9  gcc/cp/Make-lang.in
 9bc6241e715c32f1a0f6e1b8028cb853  gcc/cp/NEWS
-659647be28973c09cf89af9df4953b6d  gcc/cp/call.c
+bd82179542d443d90a79880b14342022  gcc/cp/call.c
 afb9bd2c59a27b9a4e01674e6ef4c2d2  gcc/cp/cfns.gperf
 4dc84f7aecf8adaa3133cffb6b7a9ca6  gcc/cp/cfns.h
 650800f32b775564604880eaff2b3561  gcc/cp/class.c
 739c569e48a7b41b606f425cbc9123d2  gcc/cp/config-lang.in
-fa7d60199ae182f298f4f68808ace2c0  gcc/cp/constexpr.c
-98f8a059d857e8d87b37bf2bfbdbd4cf  gcc/cp/constraint.cc
+fb0b6d2fe3954f87dc683f9bdc764d67  gcc/cp/constexpr.c
+c683759a418cb72958ad21fa84df0a0e  gcc/cp/constraint.cc
 3ba51b5d6be105c2076c7c57590c4ef3  gcc/cp/cp-array-notation.c
 186d27a5d5d478e09c882e0110153c3e  gcc/cp/cp-cilkplus.c
-3691807d913946b1b8f0532b509b32df  gcc/cp/cp-gimplify.c
+0baa9bffcd0cdbf12af9016cc861530a  gcc/cp/cp-gimplify.c
 bb99af59da6436bd29f57f3f050c526f  gcc/cp/cp-lang.c
 f3d5c0a13bc26cb7c946210741aa3848  gcc/cp/cp-objcp-common.c
 f21d1769c40e5fb7e0b4bb740c877732  gcc/cp/cp-objcp-common.h
-3c6dca654babce1444b010ecc13ce3a4  gcc/cp/cp-tree.def
-65470cc5483576513deae6ce5062ffac  gcc/cp/cp-tree.h
+d21831b373779814d66d82151827a70a  gcc/cp/cp-tree.def
+7bb799426f6eedb92c6eca4182368c66  gcc/cp/cp-tree.h
 1369f5ca78bd37e84d0985faff35f429  gcc/cp/cp-ubsan.c
 9f77a7a0c8d02ceef78c0f1cc355cca6  gcc/cp/cvt.c
-788228fb10c82f2c976b6a846bbabdb0  gcc/cp/cxx-pretty-print.c
+4fb925f8c277dfd445a3480f29c7ab2a  gcc/cp/cxx-pretty-print.c
 eb1c2da742513f6f21d3de7d3d531d78  gcc/cp/cxx-pretty-print.h
-f1c55a4f73e8b4520a611dcc1b78359e  gcc/cp/decl.c
+678407e0e9072d19a0290980484e5bdb  gcc/cp/decl.c
 f43394b8806c96193cee8cfd4a55336b  gcc/cp/decl.h
-212843cd9766a8b772323ee342b0a165  gcc/cp/decl2.c
+fdc369a0b616bd3345804d936c8247ec  gcc/cp/decl2.c
 7ae2c1642094de5138fbb999f0ba1dd7  gcc/cp/dump.c
-f0f9894e1405b5c87b3b4ce0cc7e52a0  gcc/cp/error.c
+aa416944f27c2d2b0973de74aa86cf45  gcc/cp/error.c
 55f92fe617bd4f1e45207eb0c41885fa  gcc/cp/except.c
 e68580c70d9bfd1c150485b9fca85280  gcc/cp/expr.c
 7fd276d735538ed700d62bbcceed734c  gcc/cp/friend.c
 953a6283c57f96c8e1146ea75f4e288b  gcc/cp/g++spec.c
-1442133c15bbf554bb5469f74b8e5f65  gcc/cp/init.c
-b9700c4afbc31914aa5aee27ae6f88c0  gcc/cp/lambda.c
+4bba39f4a689ecbc74bf127fd4263f02  gcc/cp/init.c
+3d2180f996851dedb628a5e874ec66a6  gcc/cp/lambda.c
 dd9fc96e1760180eadcc31d884bd5258  gcc/cp/lang-specs.h
 e978132617f114d81875d7e4a46eb0e9  gcc/cp/lex.c
-d87143518404a056fce1d858724c78d4  gcc/cp/logic.cc
-6334c1ba17789914f5b23f4a1a3f69d2  gcc/cp/mangle.c
-c5a1c61dd0126d95c56b54d9296a34e6  gcc/cp/method.c
-f81d03ee229696edc6da94e176422028  gcc/cp/name-lookup.c
-c30a346c475398a513900a6416b9a66f  gcc/cp/name-lookup.h
-deb968fc50478455c08d96ee047fe9dd  gcc/cp/operators.def
+bd372ca4699c268d003b88bba0920d87  gcc/cp/logic.cc
+baa9e5359a2757db5e2b361df4a146c5  gcc/cp/mangle.c
+326b441b0bc0067d256b4b72cd6b73a0  gcc/cp/method.c
+447088dbb1483cd82cfd32ddd03aaeb5  gcc/cp/name-lookup.c
+70b3b6f7199163918e5d2a0c1452b772  gcc/cp/name-lookup.h
+764366090f3163fb5ccd85cb19a94cff  gcc/cp/operators.def
 1cad434894b0845fc0a6f03de2d39180  gcc/cp/optimize.c
-511ff1c2f521689cce1705bdde1fdb9b  gcc/cp/parser.c
+d361550a9a144223bd187d146b434eeb  gcc/cp/parser.c
 b5da26fff61760a30cbda1f01a4c4808  gcc/cp/parser.h
-2efcaf76971f5ba20b51e40b1af73f3a  gcc/cp/pt.c
-d27b06455de42b40c3aa59809ce8e5d0  gcc/cp/ptree.c
+b90b86ba7f3a492099acfd67ab97cbff  gcc/cp/pt.c
+e61259963d803da8e625c96134d4f5a6  gcc/cp/ptree.c
 f06807decf6ff4b02873679e35ef5865  gcc/cp/repo.c
 fc320188ae1e308c62b750b92ce39885  gcc/cp/rtti.c
-9a7cb8e4675ba96266c69dde701fa938  gcc/cp/search.c
-166191d8843b08d730837b3af2dce517  gcc/cp/semantics.c
-2f7b6936624a3d96e86609871f84abc6  gcc/cp/tree.c
+f0b16ecd9783b80773d4b1b34c7cca79  gcc/cp/search.c
+63057d814cda7d68459be27649fd4772  gcc/cp/semantics.c
+79d814f96502c3b714d31e97796e9d17  gcc/cp/tree.c
 4ac4dcdc19063fd7ea7055b2064b4d37  gcc/cp/type-utils.h
-ff2ed2489e1b5c86c141aa685a39105f  gcc/cp/typeck.c
-1f202024e77b011bfd17bef5ce12de4e  gcc/cp/typeck2.c
+c8be854d952188928c591e6f91ccea64  gcc/cp/typeck.c
+0270a989f06efe3bd572525956fe0cb4  gcc/cp/typeck2.c
 8b2699a100775446f1d3379bfb10c109  gcc/cp/vtable-class-hierarchy.c
 bd835b9ee78a94f4ae3f8adee63f9a51  gcc/cppbuiltin.c
 a8b7256c689701d5c714e06099ce8503  gcc/cppbuiltin.h
@@ -4489,7 +4479,7 @@
 d91a67e4d82e6bdeaf9fffd22877f0c6  gcc/debug.h
 a2f5dd98d48b024b1d8e92d344a4b25c  gcc/defaults.h
 1668c0a4a49475062d63b5e7e79dc0bd  gcc/df-core.c
-d9d3dfc948e383e99d89b9bf94d0270d  gcc/df-problems.c
+b7719ad67f0aeddd22383a71f99829dc  gcc/df-problems.c
 8b863d46f0db1d704fb337492860e696  gcc/df-scan.c
 2c97a89f9d8933b777cbcc4c48cf4a89  gcc/df.h
 cbe294220fc2c2e1131c4aa645acf01e  gcc/dfp.c
@@ -4501,7 +4491,6 @@
 6bb8763d2cd82acf9315292a011edb6a  gcc/diagnostic.c
 cc2592797ca4befcbb1163c1a7a00f80  gcc/diagnostic.def
 b5b5c842e04bed80ee2680523e412d59  gcc/diagnostic.h
-5fc479a26716b39889254afe283c3601  gcc/doc/aot-compile.1
 4b0e646c5de4431c5d6bbfe40f0cd073  gcc/doc/avr-mmcu.texi
 67be61d4feeb4a05b9c19af733aa05ae  gcc/doc/bugreport.texi
 0615182a653a9840fd7ae8745219a5be  gcc/doc/cfg.texi
@@ -4511,40 +4500,20 @@
 240a91046efda88ae96dd3386f6e431c  gcc/doc/configterms.texi
 de72fb12d4dca40f7a8d5b4429df7991  gcc/doc/contrib.texi
 c498cc82ef6af94189c770012a2a18e9  gcc/doc/contribute.texi
-cef4aa06bdc96ae8433d4ef6eb0d9e17  gcc/doc/cpp.1
-e33796d8f10e03971c17c727c0ed98ac  gcc/doc/cpp.info
 0f2a72efa57326c8f726620c490228a1  gcc/doc/cpp.texi
 c558a3f6cb1b068e5bdc0406d2ed7217  gcc/doc/cppenv.texi
-ae059b34b3ba2259010d90020291b4f1  gcc/doc/cppinternals.info
 5e146b7ee23d2aecc854dcc8ab494552  gcc/doc/cppinternals.texi
 594e4c25acf69b6587158d05dd033b24  gcc/doc/cppopts.texi
-b932543840194c4e96437fd2ceecac4b  gcc/doc/extend.texi
+7dad3edc6db5ea68a12718e08cc14d81  gcc/doc/extend.texi
 95f852d1ef912c794a713c43da587f55  gcc/doc/fragments.texi
 6f0ea8cb29b8222c190965f0c877a2fa  gcc/doc/frontends.texi
-d9402bb24605de2195da4ff24876e5a4  gcc/doc/fsf-funding.7
-0991a56b1679183382c28bcbb676992f  gcc/doc/g++.1
-173801a593681cce80cead8f82d17bb5  gcc/doc/gc-analyze.1
-0991a56b1679183382c28bcbb676992f  gcc/doc/gcc.1
-a59de0b25ac96403053a8406e13e0413  gcc/doc/gcc.info
 88763fd4a2ca7b1f84637c92258f12c3  gcc/doc/gcc.texi
-6aeca8a702bc8b889395d5d5cff7e7ea  gcc/doc/gccinstall.info
-c57b5c8adcbc824265f2af1eac66db5f  gcc/doc/gccint.info
 a1072c7fe384b26d4053192ee158b54a  gcc/doc/gccint.texi
-2e55b10f3b9f54aea645919f7503c4d0  gcc/doc/gcj-dbtool.1
-c27b0341270205e4019a6ea6664bac87  gcc/doc/gcj.1
-61cc329dd6acc1b861a08867a5436ef9  gcc/doc/gcj.info
-50ffacc2debe4799d45cb09ad3f79cf4  gcc/doc/gcov-tool.1
 600e5ec8739c8b59da149866fceeb218  gcc/doc/gcov-tool.texi
-0078d98bb3433a8e24cba1b419527449  gcc/doc/gcov.1
 72bbc01b16e62773dff9dfa7a60f2e01  gcc/doc/gcov.texi
 ccdbce7ea9c6edf013744bebd58a7236  gcc/doc/generic.texi
-7f263eee8bc8903e68cc203013fa1f53  gcc/doc/gfdl.7
-32e298859d6afe21751a0a14eb789580  gcc/doc/gfortran.1
-5599bfd4bc2ba8a372d0ecbe55f61166  gcc/doc/gij.1
 5d1606771c73c06954506e0770209ad6  gcc/doc/gimple.texi
 290370669f02bef1502ada9273e5261f  gcc/doc/gnu.texi
-d61436fe79b7893fb9c4c4e4f3e30f87  gcc/doc/gpl.7
-cdd2c1f4af54045dde46712d1a27a02a  gcc/doc/grmic.1
 07064b30149463ca48cad1274d117022  gcc/doc/gty.texi
 ffbbf9909dbcbd3ce420b273106fe852  gcc/doc/headerdirs.texi
 5ddad8e0920359df62f566823c25331e  gcc/doc/hostconfig.texi
@@ -4556,26 +4525,23 @@
 5f5adc2c6c4ebdcf03cc0125250f5995  gcc/doc/include/gpl_v3.texi
 73819b3930a3d4be5d6234070d02386a  gcc/doc/include/texinfo.tex
 a57e0b900d0ae5846091a1e5f722fcf7  gcc/doc/install-old.texi
-908618ce1dc5bb94c6d123dd8d74971f  gcc/doc/install.texi
+b0727164f0afe4cdc4f1d83d19d4029d  gcc/doc/install.texi
 9e425a943a46a878a1f546f928d14b04  gcc/doc/install.texi2html
 a869466cbfcd212e8988279541bdda16  gcc/doc/interface.texi
-9370b86f1acf47dd44addb607f8a18fa  gcc/doc/invoke.texi
-157e4d0432e64fcdedb1c96345c820bb  gcc/doc/jcf-dump.1
-e63f6f4d2f72b8b7a2b1ec6bdf7db68d  gcc/doc/jv-convert.1
+8acd73b8868d165bb592a2448c7f9df7  gcc/doc/invoke.texi
 a0e7c077817653eddca3b287b2ec1499  gcc/doc/languages.texi
 ab4011897f2095293d3a4d9443678fb5  gcc/doc/libgcc.texi
 b0981441c4f9daaa09818d68a36bd67f  gcc/doc/loop.texi
 fc3fd4aafdd4ab47930dcb216ffe03cc  gcc/doc/lto.texi
 5c2acf2b3a4a6b50ab9b1544cc49e81f  gcc/doc/makefile.texi
 ab9503a1420248f03274f60100f0648a  gcc/doc/match-and-simplify.texi
-c94a6e10ecd4c7f73a44d5488d883968  gcc/doc/md.texi
+27523cb487a4388cb994819a94202ec0  gcc/doc/md.texi
 1f5569ca70207eb8ded92ebefd130c2e  gcc/doc/objc.texi
 83bbf74c59b8849c2b8d083a134672c7  gcc/doc/optinfo.texi
 e2a974acfc3260f2407c7fe05a990bce  gcc/doc/options.texi
 6cd361bc13e8ff0fd0523b24175f2317  gcc/doc/passes.texi
 a989acbeb85b23b1813e7e65a54c288f  gcc/doc/plugins.texi
 6f4f5f396ee46b12e48520f7305e57d9  gcc/doc/portability.texi
-03b5d223de456bb73f15d0b1a5a84f63  gcc/doc/rebuild-gcj-db.1
 bb856e2cc8413005478956f3edee2c25  gcc/doc/rtl.texi
 29e91cae40a54cd373834ec123131f3d  gcc/doc/service.texi
 43460cd9078a9e21d9ac0d9315448c43  gcc/doc/sourcebuild.texi
@@ -4598,7 +4564,7 @@
 3f5963da7e097503d222ddfc4cdf7f81  gcc/dwarf2asm.c
 73944fce2a805f3b1672e5ed81f76558  gcc/dwarf2asm.h
 8b34c3660aa997b685d65ad9a84e597b  gcc/dwarf2cfi.c
-51d0612220d98685eda04b28b7ea03da  gcc/dwarf2out.c
+f7421d7c819ea7001d975537283f1a8c  gcc/dwarf2out.c
 f2cf5c1bba29ec5e6a5fe0e97d33704b  gcc/dwarf2out.h
 07467e53d8d2dd27f0b59fe696a8fcdf  gcc/emit-rtl.c
 abbd65c7d3f556b7463e8840d7f9d930  gcc/emit-rtl.h
@@ -4625,9 +4591,9 @@
 9666a2458f11468dd9979a7cfca842e3  gcc/flags.h
 b34c1b95a54e16d433363b08e57e7f85  gcc/fold-const-call.c
 f4d19b0528d646f769792430919be6ff  gcc/fold-const-call.h
-1bf1b7a47740199e5e017d0f600ea220  gcc/fold-const.c
+ab9e31d4b5b605eaefc60186362e2cc6  gcc/fold-const.c
 b6b5bb4a4f17604d5bcfb47ecba0768c  gcc/fold-const.h
-ed25f9d2614579b109469f8baa000ba2  gcc/fortran/ChangeLog
+b725b15824f1c7b81c7c09cd56e1047e  gcc/fortran/ChangeLog
 3330102ad3a0217cba963be6b5eefd58  gcc/fortran/ChangeLog-2002
 d000ab985b1eeb1ad5749f98b8fef99f  gcc/fortran/ChangeLog-2003
 bf42f94f0c51dcc7d8051cc7fda1efdc  gcc/fortran/ChangeLog-2004
@@ -4648,8 +4614,8 @@
 7c9d0f5b639be38a283363657ac1f70c  gcc/fortran/arith.h
 47059c016e7595b3af1c42922178dc19  gcc/fortran/array.c
 c9fae371f8d0a027b1391ff1d82faaa8  gcc/fortran/bbt.c
-f59852c5908a5588db5020c4a01cbee9  gcc/fortran/check.c
-f7730bc6ae7c77ead5b22c3f2b5461a3  gcc/fortran/class.c
+b82a728d2bb98adde289da10985ecbf6  gcc/fortran/check.c
+a54bd3b33cbf5c815eca096b74430780  gcc/fortran/class.c
 4819f6163cdda697542442ead8d1edb9  gcc/fortran/config-lang.in
 1564600ca4ee09dae677a32e9632817c  gcc/fortran/constructor.c
 03ded9e724f957a8caca8c58de189bf9  gcc/fortran/constructor.h
@@ -4658,71 +4624,70 @@
 83041f3879c600754744a8da84761bc9  gcc/fortran/cpp.h
 112c4ba412ed2704834031ec9a0838fa  gcc/fortran/data.c
 167ea51b39af01ee143176fe03d80fb1  gcc/fortran/data.h
-3d4d10f9c3e0c5d35981b319a48df113  gcc/fortran/decl.c
+041660eff35c68c150d0c59550bcdc63  gcc/fortran/decl.c
 76e1e7c9f910f76e4134669998e6f5ac  gcc/fortran/dependency.c
 272c4deffabcf4caf71d639c1c58c42d  gcc/fortran/dependency.h
-56d1d5b261cad142e3fc2bcfa6a69537  gcc/fortran/dump-parse-tree.c
+749e2d991f54b00758f19992599df58f  gcc/fortran/dump-parse-tree.c
 726b63587675a95a5baa3c5ecd44fdea  gcc/fortran/error.c
-53ea5a6a4cfd9e58dc9d21a5fdf3a66b  gcc/fortran/expr.c
-03994a1d9a0e1e568a7e80de80cadd76  gcc/fortran/f95-lang.c
-5d5cd20adfebef574904cf848b554c25  gcc/fortran/frontend-passes.c
+91f1586393e9f6eb09a1561d84979855  gcc/fortran/expr.c
+8183028b3162dfef1b367f187a615b42  gcc/fortran/f95-lang.c
+91fd2dbe4eb9796193093e1bcaa31c35  gcc/fortran/frontend-passes.c
 9295becaf3bc8598cfdf49e3a4dd9f9b  gcc/fortran/gfc-diagnostic.def
 23d6c9cd5c12c7f2aca8fd69d8420b43  gcc/fortran/gfc-internals.texi
-a91b46a5fa5e96eb13e61cc2659add8a  gcc/fortran/gfortran.h
-69a791c44c97de4c0fa19fc541a917b3  gcc/fortran/gfortran.info
-5cf4acb87001e9c73595e36b73c568b8  gcc/fortran/gfortran.texi
+d27235635f3a8da5058b24e0f055bf7d  gcc/fortran/gfortran.h
+80c16dc56896ccc10c0dc114ac976580  gcc/fortran/gfortran.texi
 f3790a90748e52fe5ebfcdc7a009181c  gcc/fortran/gfortranspec.c
-636f2f2ff53625bc7cbe85f8bcdddec7  gcc/fortran/interface.c
+6cde23691b96f6c87e0d76a0dcd7e1c5  gcc/fortran/interface.c
 5ca2460ab8e955aa2f34d6add206ff50  gcc/fortran/intrinsic.c
 abc87572b30804f606b83e64ad5d40b1  gcc/fortran/intrinsic.h
 142af973fab400802b42296914efd857  gcc/fortran/intrinsic.texi
-8b7f5aaf3c22e50130731d0800d89704  gcc/fortran/invoke.texi
-8acca318648ff2c56c871a498daca0e2  gcc/fortran/io.c
+e8e86258dcee5ce75ba45253468ca0db  gcc/fortran/invoke.texi
+df84ac32a26404cf85547111270da776  gcc/fortran/io.c
 16ad8502e6ce930b9b973c52995c76cb  gcc/fortran/ioparm.def
 459cab99c8502733fbd738cabfbdd329  gcc/fortran/iresolve.c
 c0cd4b25b09215a792a381b8685eaabb  gcc/fortran/iso-c-binding.def
 5ca7449ebd20d33390a2d51e103db236  gcc/fortran/iso-fortran-env.def
 278f6140c8d0ffbc2aa9d5f5fe6915f5  gcc/fortran/lang-specs.h
-e3f67bf5957e58cc1a3b62ea7bfcd9b1  gcc/fortran/lang.opt
-911edc7f24a9b8ac6bf223d3fcd525cc  gcc/fortran/libgfortran.h
-25ef827d548f8cb705a38ba62f6db89c  gcc/fortran/match.c
-7b8b9983bd8ed1ce9c04851260d8eb27  gcc/fortran/match.h
+c3e9aefddeb997bc391f60d52a473432  gcc/fortran/lang.opt
+c1444c8a9c2ed90afc8ea627a0d94f85  gcc/fortran/libgfortran.h
+cec7003f1a53e551725030fefc65eae1  gcc/fortran/match.c
+65f0f415082a41f7976f30657958fc69  gcc/fortran/match.h
 8cd46cabc2dfb1a7496801a089b86445  gcc/fortran/matchexp.c
 e91ec831c84ed9fa96a1533122ba5461  gcc/fortran/mathbuiltins.def
-4a5bd735a771c8b0245b0bf5c972216a  gcc/fortran/misc.c
-100ade2e21fec64ad80d084582a5f622  gcc/fortran/module.c
-5b1a6971820f53e62c69d0455d6d93b4  gcc/fortran/openmp.c
-32b64c520ae2d457708ccafb56bdb398  gcc/fortran/options.c
-e4982905a015e74a947f5cba2fd5bf8e  gcc/fortran/parse.c
-5163fc3c6029dd5a8197395b4377afa0  gcc/fortran/parse.h
-061decb36333beede21dd5b1e6397fe8  gcc/fortran/primary.c
-5905d4d8099abc01becd40e015f04536  gcc/fortran/resolve.c
-9ed23a8532184ec8065a2896d8638c3c  gcc/fortran/scanner.c
+0b73aa1351022bc9b69b35d237f97d12  gcc/fortran/misc.c
+90de8ceb7bf48f35b7e7bc456635ccb5  gcc/fortran/module.c
+e023aea3b853e2aac54c491b0c7dceaa  gcc/fortran/openmp.c
+f8b10b2e5c40bc25b4d9eef7295880fc  gcc/fortran/options.c
+025d3494f9ed075d99b64b4a7781543b  gcc/fortran/parse.c
+043cf75f229c25d3de2bb79cc984c69d  gcc/fortran/parse.h
+4e0e2fd36510d98c289456edbed2c292  gcc/fortran/primary.c
+be434b3f3d88d0010cc278c8d17d84f6  gcc/fortran/resolve.c
+99540dc62dd0f048881facab0517a129  gcc/fortran/scanner.c
 075cca4c5736634c587f4ed50ddc9f93  gcc/fortran/scanner.h
 4b5ab4f68e70934e8adea730a3fa4149  gcc/fortran/simplify.c
 75d50e5ade35f92e65fab4fe0b20630b  gcc/fortran/st.c
-80b966958d6948acbf1c4c33cbe28c3b  gcc/fortran/symbol.c
+f8bbffd124aabc78dbead99719f3d071  gcc/fortran/symbol.c
 186ec08e98303bc7e25afdb9f5e9aab9  gcc/fortran/target-memory.c
 2e5ed3113ab460b7be0e63a724f9f45d  gcc/fortran/target-memory.h
-0295dbb04ca0ac845ba36122f250b6e6  gcc/fortran/trans-array.c
+adab4b79e93efc39a98d2bde342814f8  gcc/fortran/trans-array.c
 4e46ac05c6b8e884925b4b58c7d78a30  gcc/fortran/trans-array.h
 e9814dc5252693185f3e60d55d55a701  gcc/fortran/trans-common.c
 7ca10244eca4229e1c832b3c393d9a24  gcc/fortran/trans-const.c
 d23a0f8bcd86907559306d74723ffdbd  gcc/fortran/trans-const.h
-9ed6a0a514291d5e841dd6379125ab8e  gcc/fortran/trans-decl.c
-341c6bcf2a7d37d50cb6d5c0ed1affb6  gcc/fortran/trans-expr.c
+36a4681903f12b16f44566186a2691b9  gcc/fortran/trans-decl.c
+a146a0181d77d0294e107bf0c9ce93f6  gcc/fortran/trans-expr.c
 55c2dd391599f5dc06e34c6058f48ee4  gcc/fortran/trans-intrinsic.c
-6388c76555cc1e06e93cbe1e40796c0f  gcc/fortran/trans-io.c
-109c58b7d897545dbe960eef88f09a06  gcc/fortran/trans-openmp.c
-12c15965589066ffdc046103e74eb21e  gcc/fortran/trans-stmt.c
+988afa7187f8648d73cbbdd53cf6155b  gcc/fortran/trans-io.c
+2f638266866f5af39a561ef341e82662  gcc/fortran/trans-openmp.c
+368d4cd52e8634e9fc5c1072a5640e29  gcc/fortran/trans-stmt.c
 bd26fd364f82b04b35ca797f1500c5cd  gcc/fortran/trans-stmt.h
-2dc8f56209eae7fbe3d3ad38d2c6fca0  gcc/fortran/trans-types.c
+3a0a015557497b74675a5808c440f290  gcc/fortran/trans-types.c
 82b8673b874f75d8200f4128222beeee  gcc/fortran/trans-types.h
 adca0f1898c7b04c8e1d9aee387964bd  gcc/fortran/trans.c
 584e7bad1d3257b528944c0a88ac18e9  gcc/fortran/trans.h
 ce4ba327ea19d94b982917bf5b2884d4  gcc/fortran/types.def
 e02967179fdfb529c8aff94baaf469c2  gcc/fp-test.c
-59bd42fe759500cea34d37618a023b2e  gcc/function.c
+b61f1a62642aad6032bd3875e55d56ac  gcc/function.c
 047cfc91e18845f3b5cf442dbbdd1ee7  gcc/function.h
 497184e6dc781c16b3012d224ab58dd0  gcc/fwprop.c
 51d4643fae226ae5cb6c726118db12a3  gcc/gcc-ar.c
@@ -4731,7 +4696,7 @@
 22091c79c390a71cf211f90328383954  gcc/gcc-rich-location.c
 6ab0670ac8edcc1a6f5cd76e7e47a982  gcc/gcc-rich-location.h
 3ec648b31caf0bcc6b2062384510367b  gcc/gcc-symtab.h
-c8beb6d15ada1f869e8a126ba1fe0944  gcc/gcc.c
+1c6a4afc775cce3b78a2d8cedde32118  gcc/gcc.c
 8a5a93ab3252c5ded6be74e451700891  gcc/gcc.h
 1bf3695cc620fbe4091e454d41be48a5  gcc/gcov-counter.def
 46c61075acf42b3a7891409b607f0d19  gcc/gcov-dump.c
@@ -4766,7 +4731,6 @@
 25b1b08c7f2e15a61f67137a395f2be5  gcc/genextract.c
 282f3c7433a024d985ddccc10c82d417  gcc/genflags.c
 d44b194500c23b5c542dbac2c46abcec  gcc/gengenrtl.c
-48ade094be628d6e2f9bf4c0255ab482  gcc/gengtype-lex.c
 5a1368b972210328f48b0ea87a7191c1  gcc/gengtype-lex.l
 ff52666a6b0aebb48f2a4f746fe39b50  gcc/gengtype-parse.c
 0151a4b7715cf1cb836ee33cf7bfdf27  gcc/gengtype-state.c
@@ -4776,7 +4740,7 @@
 3be5935abab096a672b81c80b559ef1b  gcc/genmatch.c
 07b0962a5b0ac2a5f29d44d710ce1ea7  gcc/genmddeps.c
 43130364faec8aac159d938938a22fad  gcc/genmddump.c
-7ecbd5f6591a89cdfd2fa1fff7b6db01  gcc/genmodes.c
+7c6aaaace1e7de1494b16ba3c1abbdb0  gcc/genmodes.c
 ed5f5653c43e59c6b9281e0950f9666d  gcc/genmultilib
 5dc9ce1d95f7efc01f7131e05df3e506  gcc/genopinit.c
 6b491dad9092e779224522d123ead72d  gcc/genoutput.c
@@ -4795,7 +4759,7 @@
 18fb4705ad51bdf06734fbcfc8e39d64  gcc/gimple-builder.h
 f4acee1cf4c45a5b6db4d0ce9806d3cd  gcc/gimple-expr.c
 c17954a852b3ab19a3008cca3b24c128  gcc/gimple-expr.h
-b0cdbb6b0843346f1808c16e699dcbee  gcc/gimple-fold.c
+a86905e31e7631aeec47b8745ae228f1  gcc/gimple-fold.c
 8951c8587158bdc60d4e7d612c6f838c  gcc/gimple-fold.h
 a14e519ebabb942d1e8a48a4403acab5  gcc/gimple-iterator.c
 efd0e45c5f633c150550050337d54cd2  gcc/gimple-iterator.h
@@ -4818,12 +4782,12 @@
 8c571fcc3b1ac0c3989e3a4973246484  gcc/gimple-streamer.h
 5b4269de0e90ff1a0e228f16c36acf15  gcc/gimple-walk.c
 ad1356d1aee1bfaba3647e9dd12fb0bc  gcc/gimple-walk.h
-e38c521db81137fc28162233d6a5c618  gcc/gimple.c
+b174a67cf43b8c8919274680e0b3ed21  gcc/gimple.c
 65f6f08852f115424e8495c343dcba61  gcc/gimple.def
 641cc4b975ba19a5b0e628733901c0cd  gcc/gimple.h
 e679c1b4ca7b2361262d0c6fa84805d2  gcc/gimplify-me.c
 16af853ca2f3e873e723eb5ff29a8168  gcc/gimplify-me.h
-965c6bde778d881723e3447c823a254f  gcc/gimplify.c
+c685b720121fa09a6b261d5e5056561b  gcc/gimplify.c
 89047a7045c4653b6016516742695593  gcc/gimplify.h
 f8d3ba18b33f417a9767d330d93c0783  gcc/ginclude/float.h
 619900a9f2191899ea818da9819f1182  gcc/ginclude/iso646.h
@@ -4901,10 +4865,10 @@
 02e7e8c97cb2d8864b2f8a3135ed0011  gcc/graphds.c
 43af169612c4e4d04e00673de385a56b  gcc/graphds.h
 800359328b63c4c5c0ef9d59bad00fca  gcc/graphite-dependences.c
-1527a741b446889615bccc68cd40c1ed  gcc/graphite-isl-ast-to-gimple.c
+b3037189d263bf2518bd3521a8652edb  gcc/graphite-isl-ast-to-gimple.c
 d7586bd35c3d11933ceb61445987b1be  gcc/graphite-optimize-isl.c
 44fa75ae4f5cb0ac377521ea75ea1739  gcc/graphite-poly.c
-a6fb22307a3a995855f46e2bb900025b  gcc/graphite-scop-detection.c
+24cb5670390b40885b9f7e8cbc9e8f2d  gcc/graphite-scop-detection.c
 2145e44f71f0e71c5d7525d412b11dc6  gcc/graphite-sese-to-poly.c
 5b53b1f39257a74d35d74267a10667d2  gcc/graphite.c
 e2a89ed2d54d88eb79e9c45ac760ba2d  gcc/graphite.h
@@ -4930,7 +4894,7 @@
 3b0d55aa66be65dbe57933c94fa21773  gcc/hsa-brig-format.h
 68951ed27601fde925296e7050c19b08  gcc/hsa-brig.c
 3b45b6386324afbef0330d9d8cdbc09d  gcc/hsa-dump.c
-78fc9f283cc1eabaf8bd8d95e6461dfe  gcc/hsa-gen.c
+cbd0b5366af70ed50a5aa9583995daed  gcc/hsa-gen.c
 74ffebc0a61f0ac8bd7a90c8454cdc14  gcc/hsa-regalloc.c
 ca9a2dd3e189ffb7385e163641e91f95  gcc/hsa.c
 e13e5df371956a53173b7fb59f95b1d5  gcc/hsa.h
@@ -4954,7 +4918,7 @@
 f6eb1829b56b52c1a98e463764f15bb2  gcc/internal-fn.h
 fdde96aa99d01f4a2e122427c73416e1  gcc/intl.c
 364233341b4f1261da8627eb826e6269  gcc/intl.h
-8a05f2b124212ea048784639ae1805fc  gcc/ipa-chkp.c
+26faa305263ec4b39061a74359f92d08  gcc/ipa-chkp.c
 0c2184ed06610d2b6afe4b6f4d417dbe  gcc/ipa-chkp.h
 f3a24a98107ccc8ad76113ede465029e  gcc/ipa-comdats.c
 0da86e2392b6146c88d243312dd82027  gcc/ipa-cp.c
@@ -4962,15 +4926,15 @@
 09da3707dcc58023f746ab4e5fabd815  gcc/ipa-hsa.c
 8cbeebf152275e9611ce91064d1006f3  gcc/ipa-icf-gimple.c
 455a02b19595e17d311284b20cd9946f  gcc/ipa-icf-gimple.h
-a46784b0082b24c3723a6bd34efd2056  gcc/ipa-icf.c
+a42f3827f0d168e29f65c96a9e41e40a  gcc/ipa-icf.c
 5021b0bbc0eb5fdd57764d9440bc112c  gcc/ipa-icf.h
-937ec1ea45a11c5be2f5a51a4835000a  gcc/ipa-inline-analysis.c
-55c5111a5231b83f1b37edd7c28362a2  gcc/ipa-inline-transform.c
+a218a778bd374b99f367df36983a2e05  gcc/ipa-inline-analysis.c
+02dbb68319cd1e4e8561bbcdc37e0b9d  gcc/ipa-inline-transform.c
 6ffb5637e26835334d307237572a86d3  gcc/ipa-inline.c
-1ede16ebb03f841de4dd96f559a4147b  gcc/ipa-inline.h
+5b9e28f57d5dcf8db033236d6d5ff9d7  gcc/ipa-inline.h
 6229fae545ec5dfe5099feff68acbc25  gcc/ipa-polymorphic-call.c
 dd94f55f59c59919fcfe73719b53804c  gcc/ipa-profile.c
-449b3b4152d0852cd2ec595c89f56dda  gcc/ipa-prop.c
+6ece3a1963d838aa977b891f381ccc7f  gcc/ipa-prop.c
 7a7386b290a6a93fcfde58bd22cfb1f2  gcc/ipa-prop.h
 74d1b10d200d7553ee6f2ca92c0887df  gcc/ipa-pure-const.c
 ef575b78ba6545da9a738bb6492ffaea  gcc/ipa-ref.c
@@ -4982,7 +4946,7 @@
 d01eb784d4a63008ba2460c3b47972b2  gcc/ipa-utils.h
 380724728441c80c569b8ee31d8ab4f1  gcc/ipa-visibility.c
 f5194dfc342426fb120aa6ef0dac2984  gcc/ipa.c
-bb05e32e874641496c916e3bbe6bd1d5  gcc/ira-build.c
+d40b36379402518db3bf0d60d97b5b55  gcc/ira-build.c
 964fe62f78d9da617c7eb903c20eb3da  gcc/ira-color.c
 e983cefc45ef903cf9ff61d0968b3bab  gcc/ira-conflicts.c
 4a40c778a56feadfe0bd42965dbe084b  gcc/ira-costs.c
@@ -4992,7 +4956,7 @@
 048a61ff1463a425c9c13312cc4f2b77  gcc/ira.c
 74580aa160542aa4992d6a08ca5bc8f2  gcc/ira.h
 31f4d25e8f125875a26ac35cbc927cb8  gcc/is-a.h
-ffc43ab034b5486bf1b22c4e25652589  gcc/java/ChangeLog
+ceee6770040d5c58de02381d5a65fb30  gcc/java/ChangeLog
 507793f7d137759eaebce11bb6904781  gcc/java/ChangeLog.gimple-classes
 c52fb3faa0748d26588a8c62e7a032e3  gcc/java/ChangeLog.jit
 3becfaac793f49e1f52cd74e78172b48  gcc/java/ChangeLog.ptr
@@ -5003,7 +4967,7 @@
 dd4e349eb537ed7cee7033421af1777f  gcc/java/class.c
 08aee25cbbca0291809291e30cdd28e9  gcc/java/config-lang.in
 597e80cf93fe17c733b3325596a87089  gcc/java/constants.c
-62abdb3fb4dda2d1403f2255fcf02e67  gcc/java/decl.c
+4357af4636c74da6a36170ca55e3d8da  gcc/java/decl.c
 87a5f387a742a553449af36a17f3d81f  gcc/java/except.c
 193d30afff097161bfcd483e0fbf9389  gcc/java/expr.c
 6ca90df13b6db79a291d03502b2d026a  gcc/java/gcj.texi
@@ -5157,7 +5121,7 @@
 0e62588ade895bd5b41e9a9f468db224  gcc/lto-streamer-in.c
 b93b516820b533bd1682f7a148299c10  gcc/lto-streamer-out.c
 bdae986759b0d2c19d10cd95a3469cd6  gcc/lto-streamer.c
-239c64daad087416ff10a8a4cee81b36  gcc/lto-streamer.h
+cbc225f3a9d78c6fa301299f140baa3b  gcc/lto-streamer.h
 fdd4f9b1c13609e47f794ce0d6f0e8da  gcc/lto-wrapper.c
 1ecfbd8094590b170282d2a351b69028  gcc/lto/ChangeLog
 bdc9ad4ddf80ce5b1548924f27f8df54  gcc/lto/Make-lang.in
@@ -5176,9 +5140,9 @@
 7055ad53a5a9d81672428d858bc0affe  gcc/lto/lto.c
 ccfecfc6344c571f12776c61c50b98e1  gcc/lto/lto.h
 1ad92c4f2096f1f11a9d722298472ee5  gcc/machmode.def
-2c8fae29dd077ed25751d1dd04ca361f  gcc/machmode.h
+89fb633ceadc86168379eec86b822225  gcc/machmode.h
 cf42eb61030c258fdda933a353c46798  gcc/main.c
-cd34301f756f23f585a735b5e74be501  gcc/match.pd
+541198a830d7864394eae8377a18b824  gcc/match.pd
 b4586a3a75b5dc7b5d62ccb834ea81ef  gcc/mcf.c
 2befd16012fa1d3dc246e33d405b79f8  gcc/mem-stats-traits.h
 3e4b7d3dfbb311377553673371f9561e  gcc/mem-stats.h
@@ -5216,7 +5180,7 @@
 7d680f67db0eb1b8ff1b353ceb2caa2c  gcc/objcp/objcp-decl.h
 8cfb48ffee764ccd1ab5dbf70f0234e0  gcc/objcp/objcp-lang.c
 742609336d1f57839866345f3fe16a98  gcc/omp-builtins.def
-4933dc01313d0d9f8a01f52eee41e354  gcc/omp-low.c
+264284b664c34974388708ea2973fc49  gcc/omp-low.c
 17f7f9a5279dd46aca82fdd23c6ed175  gcc/omp-low.h
 56f009a0f93f52fc6e4bec4b17949a48  gcc/omp-simd-clone.c
 f773f4ea009b64414353473ab70fc22d  gcc/opt-functions.awk
@@ -5235,11 +5199,11 @@
 5d7c8672928d8e9cb91ef0f415fdbedc  gcc/optc-gen.awk
 c4436c027680fe15e299195629d8d8ab  gcc/optc-save-gen.awk
 0d8d3a459ed81fd2fa69cc19981521a8  gcc/opth-gen.awk
-ff58d1ec1d48045472754120b193b85c  gcc/opts-common.c
+99b50659a43b24a13195fa23816dcca5  gcc/opts-common.c
 52240b1476d05158d2811656568e12f0  gcc/opts-diagnostic.h
 2f24b289e6b216a31c7775b6bcbe41e4  gcc/opts-global.c
 b2e8f32205053e2c288e98224914182a  gcc/opts.c
-6af4347f770893f6a8f33ce0d86e55da  gcc/opts.h
+8bd47fc4db78292cef3e264347c4e0d3  gcc/opts.h
 f7daf01f2540429baa36f933638dd34d  gcc/output.h
 ffc82aaffe672d77f230f006908b6fd0  gcc/params-enum.h
 6d350f6a56aff3c29a7b7ca665bc7c77  gcc/params-list.h
@@ -5252,48 +5216,29 @@
 c35d166939d6fdbd9bb5853c96bb673b  gcc/plugin.c
 03231f119da6e6638a69e3c5111324f8  gcc/plugin.def
 eb08b5caab095677d912ce793705caf7  gcc/plugin.h
-c896550ea8a704b726f70ca8cbe9f083  gcc/po/ChangeLog
+ba8a67e2a742b229f49c824c74fdb505  gcc/po/ChangeLog
 b2d1566753aedf7900d55d33f985138c  gcc/po/EXCLUDES
-73f5a360156bb96df0876f8ae49ee539  gcc/po/be.gmo
-858a8db5418c9d759b39a4a7da86584a  gcc/po/be.po
-34603ebce82e592915a19c8e7c06f46b  gcc/po/da.gmo
-f2678a98410da89c6ec8aa2b1908d0c6  gcc/po/da.po
-fa35eedf6605508229d033bc58e2a1f0  gcc/po/de.gmo
-1b41215282905586b826b85e24c8d1a3  gcc/po/de.po
-7e7ab58b8fc61fe93e33decf96ef8c73  gcc/po/el.gmo
-6b015487bd35c40a3fb5996908172cda  gcc/po/el.po
-053a5568dc887cbbc880dfc566074b43  gcc/po/es.gmo
-d7b7435f6bfba7bcf40b5414a1358ea3  gcc/po/es.po
+da41f20602b08cf3060fdc3573e8bcf3  gcc/po/be.po
+94220484b47be9ea5471835c19a32a5b  gcc/po/da.po
+739379c3b5456e6649601d0c629fd327  gcc/po/de.po
+6db04b03851e69d9513b958b788474a7  gcc/po/el.po
+cddbc322a1b9f50ba1b2de6c0235a2da  gcc/po/es.po
 f9ca050e999d59313ea3c78909a9f041  gcc/po/exgettext
-0e57143fe61f4f6ee0257ca229d161ad  gcc/po/fi.gmo
-75abf91d71cecb1c755024e40d93ab22  gcc/po/fi.po
-b62f58644438cf2aaaae0f59982e73f8  gcc/po/fr.gmo
-b55a5d1e9f16c3a3aa2a44cfe4efec60  gcc/po/fr.po
+288d71e5a20c49fd49706768856b698f  gcc/po/fi.po
+34a30c8ec15ddbd58918aa29b49d7faa  gcc/po/fr.po
 7b979b2fb5ee1d4b22999b6b9f35f0d3  gcc/po/gcc.pot
-c2a77d92023af97b968c73b45528e1b0  gcc/po/hr.gmo
-e17454f620b1863396f3f2683af797ae  gcc/po/hr.po
-f15aba6d908d5270942778e0ccbfb6cc  gcc/po/id.gmo
-dd277eb29469e63bfe00ae4782905714  gcc/po/id.po
-77592ad1824b3f39700fe7b1894b1349  gcc/po/ja.gmo
-3fdef1cfc12a664bf8d23dde1e55244d  gcc/po/ja.po
-2b1aa89972f54a139e091dbbeb7aa326  gcc/po/nl.gmo
-4605a46fbbc2dc43cf1ce2801b22d368  gcc/po/nl.po
-4a8ad42adb20bb31f9221cdbaa8f0d56  gcc/po/ru.gmo
-c15f983cd43fd56b2e0eed90ca85a5fe  gcc/po/ru.po
-cd4395a161628525beb444f240c2307d  gcc/po/sr.gmo
-fc88c9385f4e2e71082a6abd49bc898f  gcc/po/sr.po
-ce69b0580d1817b86e13fd6c4428f476  gcc/po/sv.gmo
-e0a608252df131356ec65d17a9061c8b  gcc/po/sv.po
-ff242c916dea333c8e317ec48003d4d1  gcc/po/tr.gmo
-45707ffef56abe9faf5b143a3bd3fdab  gcc/po/tr.po
-4334a12890be23c351f96df0fffe489b  gcc/po/uk.gmo
-baa5ef734ce0408426feb6b807ce880f  gcc/po/uk.po
-29fda96b949730c3b7a8b4189bccabca  gcc/po/vi.gmo
-f3ba9df1249e315a2d10d2cb75d5e357  gcc/po/vi.po
-6659d133d2a567dc01c9940413a53a17  gcc/po/zh_CN.gmo
-d8948f3a5f1de605509a5eb57b822e59  gcc/po/zh_CN.po
-c51a9eefbe0b85753a8853ac8eeb2caa  gcc/po/zh_TW.gmo
-e0670c5e297590bdd0c77686fc15685a  gcc/po/zh_TW.po
+abb2afd8fe7053a42cdea743592af384  gcc/po/hr.po
+ba1393a5c416098225a3f67e87525864  gcc/po/id.po
+26448d201f1c6a7c98d3da75046f49fb  gcc/po/ja.po
+ea4a08bfee865ce879b44946bacb60eb  gcc/po/nl.po
+71622d38892673e00a8acb1e9e495835  gcc/po/ru.po
+3d67f8989dd67ea4d0e1f94afa44e6e2  gcc/po/sr.po
+b6679504541e91960333afe4e78cf341  gcc/po/sv.po
+a986ac0aa1813678d4f968df72abdf9d  gcc/po/tr.po
+289dcc1d2584b6c8ae1700abf19b1501  gcc/po/uk.po
+9a88bed7d4b0cfa06a9710a236f1dd37  gcc/po/vi.po
+6a15d527f4bb660ac2ebc11b87810e21  gcc/po/zh_CN.po
+14871a1a198c4b42159769507328fab2  gcc/po/zh_TW.po
 69cb8c2cd669d2ccb4d80d86bafa9b03  gcc/postreload-gcse.c
 136c02b2e1e680f2f1222e7b27b7719a  gcc/postreload.c
 02aac36ac6c8089e57cdd45796f95237  gcc/predict.c
@@ -5353,7 +5298,7 @@
 a65b0839331cc74338b9a698a8c6516e  gcc/sanopt.c
 b765a177a40fac9fa436794081ec1a30  gcc/sbitmap.c
 baf1028052c2a830de61b24d81ee5da7  gcc/sbitmap.h
-0aab6489f94f24f5fe2eafe5261de2dd  gcc/sched-deps.c
+75438eaf5eff450c06d49e939f97fc11  gcc/sched-deps.c
 d30bdfafacf75a59010d260990ec7582  gcc/sched-ebb.c
 b3011146b1ff654e200cdd1c84fec4f0  gcc/sched-int.h
 39622a83269e62f7612fe8d39aea6bce  gcc/sched-rgn.c
@@ -5386,8 +5331,8 @@
 704b277d6624cf0434ceb4413e457e58  gcc/statistics.h
 7b179dec806446f7af9f32ba1fa83b4e  gcc/stmt.c
 db0a871bfd07020c451cf0485edc8552  gcc/stmt.h
-49f0ea4833afb345b5e18ca1f285b75c  gcc/stor-layout.c
-e6d4593c48e3361d44b0e1053250fd6c  gcc/stor-layout.h
+7e2228b71f5d90edc613ec0c4848cdac  gcc/stor-layout.c
+364b3f58d3ac50134a8eefb5f91fa0ad  gcc/stor-layout.h
 8e3a2b656051f3ce59d1cde56e90e8ff  gcc/store-motion.c
 f5f79d3f7f15413b9096d592037d0446  gcc/streamer-hooks.c
 1a4f5f53317ad7289c572457c76a8610  gcc/streamer-hooks.h
@@ -5406,7 +5351,7 @@
 43bc671be91bb4d94848b3e7f27a2930  gcc/target.h
 390fdb346018f2dac89921ab740e4205  gcc/targhooks.c
 4e44e54a960fb8713cc9c2975d7d27f9  gcc/targhooks.h
-5787a5d3f70d58542e3517734f0ad8f1  gcc/testsuite/ChangeLog
+71f38c7eec649ccf0aa40be00b8367a6  gcc/testsuite/ChangeLog
 862f04afbd87da2cc6bc432c3f28430f  gcc/testsuite/ChangeLog-1993-2007
 029a5d8dacd25eb5d4711452ac448e5b  gcc/testsuite/ChangeLog-2008
 13ac28c41d51b66b4ec40dba6bd50f39  gcc/testsuite/ChangeLog-2009
@@ -8145,6 +8090,7 @@
 0a221c339accacadef51e91e2f07b9ba  gcc/testsuite/c-c++-common/asan/pr63888.c
 2a794af8b446f3413fe5b973ea309b7b  gcc/testsuite/c-c++-common/asan/pr64820.c
 430079f735bd0792e25216b9c0862dae  gcc/testsuite/c-c++-common/asan/pr70541.c
+dee6718aa031ca364c15580524cba02b  gcc/testsuite/c-c++-common/asan/pr70712.c
 53382ff9da47e361b5e5dc525d26e518  gcc/testsuite/c-c++-common/asan/red-align-1.c
 40dc4b3092482d9427dfbc9415f0b0a8  gcc/testsuite/c-c++-common/asan/red-align-2.c
 8940936501084c6e4d7f6d110ba612d8  gcc/testsuite/c-c++-common/asan/rlimit-mmap-test-1.c
@@ -8428,11 +8374,13 @@
 25018148b12e7e9ba0bb52c882a3c39b  gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1.c
 318406ae2dc40af036abc40c46d96836  gcc/testsuite/c-c++-common/goacc/Wparentheses-1.c
 a784e64918008022358c8ee789eb6150  gcc/testsuite/c-c++-common/goacc/asyncwait-1.c
-8c9f8683e5b47206924e6f5b01d98e86  gcc/testsuite/c-c++-common/goacc/cache-1.c
+f2b008762a25069d1c4d34ad85325ccc  gcc/testsuite/c-c++-common/goacc/cache-1.c
+23d462264295eb148c028e9cc0c451ea  gcc/testsuite/c-c++-common/goacc/cache-2.c
 ed0df84115a0f8b333602804bdee2a95  gcc/testsuite/c-c++-common/goacc/clauses-fail.c
 8bfd01f209498815723e71000488572c  gcc/testsuite/c-c++-common/goacc/collapse-1.c
 ca2517a3cc3cd3ae7a63df0a68ad4598  gcc/testsuite/c-c++-common/goacc/combined-directives-2.c
-6a3920d3728f9ade384ff4fd7f3a5d2c  gcc/testsuite/c-c++-common/goacc/combined-directives.c
+4b20350010ccaafbe6720c0beec63fb9  gcc/testsuite/c-c++-common/goacc/combined-directives.c
+c68fccfb3ff8b00b01d51396677c6d59  gcc/testsuite/c-c++-common/goacc/combined-reduction.c
 6ff2b7486e948a4634adb071ea7906c0  gcc/testsuite/c-c++-common/goacc/data-1.c
 c6b67854e61db0e6384c49c9402e9939  gcc/testsuite/c-c++-common/goacc/data-2.c
 b0b60bf50600ebe553878a82dfa99c8d  gcc/testsuite/c-c++-common/goacc/data-clause-duplicate-1.c
@@ -8531,7 +8479,7 @@
 99033a31ad0844a80bb561d39f21bc2c  gcc/testsuite/c-c++-common/gomp/atomic-8.c
 a6583e4cf6c5bb3b1a46172a0635d197  gcc/testsuite/c-c++-common/gomp/atomic-9.c
 6eec1bac67576f5cb167599634a153cb  gcc/testsuite/c-c++-common/gomp/cancel-1.c
-443946b78808c77b5280fbe5ad4c87ff  gcc/testsuite/c-c++-common/gomp/clauses-1.c
+4643decfdedb2843b4b2903c5f686d54  gcc/testsuite/c-c++-common/gomp/clauses-1.c
 aeca3a50d934c2d4e5e18c86aa8ec65c  gcc/testsuite/c-c++-common/gomp/clauses-2.c
 657094047e2432f3bc3c5cafde1eafcd  gcc/testsuite/c-c++-common/gomp/clauses-3.c
 8d9ef02ce9840a58a8c64026e4df30b2  gcc/testsuite/c-c++-common/gomp/clauses-4.c
@@ -8592,6 +8540,8 @@
 f230f09eac11df86e31192d6bf15c8d3  gcc/testsuite/c-c++-common/gomp/pr67521.c
 befbc361d92f725fefa0029d54d3c22b  gcc/testsuite/c-c++-common/gomp/pr70550-1.c
 4c7e38cbcd8c76fb43d8ce5a9a036711  gcc/testsuite/c-c++-common/gomp/pr70550-2.c
+9c6ccd1b697ca4b2f7de134bafdfda56  gcc/testsuite/c-c++-common/gomp/pr71371.c
+8d4187a1bda8777b2ff9ff3a8693ac86  gcc/testsuite/c-c++-common/gomp/pr71758.c
 5d522e2f1f7455bc45f6c1f230d5a5b0  gcc/testsuite/c-c++-common/gomp/priority-1.c
 1dc7bbbafb91e179ac43fa3959ab125f  gcc/testsuite/c-c++-common/gomp/reduction-1.c
 a73d7c3b3886856e6621c6e5854c3333  gcc/testsuite/c-c++-common/gomp/schedule-modifiers-1.c
@@ -8714,7 +8664,7 @@
 cbe3fc815940c07168eae35940a68240  gcc/testsuite/c-c++-common/pr69558-3.c
 021fff0470a2865e5a38b50712393164  gcc/testsuite/c-c++-common/pr69558-4.c
 11a73961cd31ec2471c0e9cc3200e966  gcc/testsuite/c-c++-common/pr69558.c
-31a4c6dc3751ea2efa2efa81ce54fc52  gcc/testsuite/c-c++-common/pr69669.c
+388b963ce0a6d74b387fe44e74666652  gcc/testsuite/c-c++-common/pr69669.c
 dc7d9d40dac973e012fc8b7b6f54d784  gcc/testsuite/c-c++-common/pr69764.c
 f4386df5fa5c32d56388c75bdf15c9d4  gcc/testsuite/c-c++-common/pr69797.c
 65bc4d5f65c8acc789b20b18a397a09c  gcc/testsuite/c-c++-common/pr70144-1.c
@@ -8723,6 +8673,7 @@
 25c6ea4844eb15010d49a3780fb6bb37  gcc/testsuite/c-c++-common/pr70297.c
 ccc164356d4817396e516749bf924ce8  gcc/testsuite/c-c++-common/pr70336.c
 ddcfc64c63208f870fb7e0fe0276319d  gcc/testsuite/c-c++-common/pr70651.c
+ab8ceba35b76e5122ef1d15e5a6d31ba  gcc/testsuite/c-c++-common/pr71372.c
 b0ba836310044e7b419ef679f0b48d6f  gcc/testsuite/c-c++-common/raw-string-1.c
 554e7071d2525351de28445762633866  gcc/testsuite/c-c++-common/raw-string-10.c
 fc54e7227094f307fa566b3a8cd0ba9a  gcc/testsuite/c-c++-common/raw-string-11.c
@@ -8901,6 +8852,7 @@
 f7ac21b5467fdafd31e4d63c13bba697  gcc/testsuite/c-c++-common/ubsan/bounds-10.c
 8a79b5ac2324b237d4b97f40d8caef20  gcc/testsuite/c-c++-common/ubsan/bounds-11.c
 c0cea811b60785fdbeb5a8c17cbfe97d  gcc/testsuite/c-c++-common/ubsan/bounds-12.c
+e41a9c9640280bfabdc970ff41f1e444  gcc/testsuite/c-c++-common/ubsan/bounds-13.c
 5ce7dbfd4301c9cde8b861eef45a151b  gcc/testsuite/c-c++-common/ubsan/bounds-2.c
 e7f60e0642d24587e57ad55271053c36  gcc/testsuite/c-c++-common/ubsan/bounds-3.c
 55d21c141077691618a0992441b77856  gcc/testsuite/c-c++-common/ubsan/bounds-4.c
@@ -9522,9 +9474,9 @@
 0f37e29f62414944ff8ae0b75a77f2c0  gcc/testsuite/g++.dg/concepts/constrained-parm.C
 b5e01f926b642aa30736fa60d24db29a  gcc/testsuite/g++.dg/concepts/decl-diagnose.C
 391bcf94c298040bce05a2bc3c1fe6a6  gcc/testsuite/g++.dg/concepts/deduction-constraint1.C
-61025db31db6fc9bd377f8dbcc5b997c  gcc/testsuite/g++.dg/concepts/diagnostic1.C
+ef831b23357717a1194aabd267da39eb  gcc/testsuite/g++.dg/concepts/diagnostic1.C
 d8f521f37e4f01ddd0581d00a83a9be0  gcc/testsuite/g++.dg/concepts/disjunction1.C
-d9435abbf2c120b3e86351722c471f92  gcc/testsuite/g++.dg/concepts/dr1430.C
+eca2e51caee3cfce80ec8e3714c464f4  gcc/testsuite/g++.dg/concepts/dr1430.C
 5088c07f3bb6eeb91fa790bf5e35ac12  gcc/testsuite/g++.dg/concepts/equiv.C
 8d8c066843ef43dad83d062249b81c9e  gcc/testsuite/g++.dg/concepts/equiv2.C
 1952696facfb66a6315b0d4f4705c4ee  gcc/testsuite/g++.dg/concepts/explicit-inst1.C
@@ -9538,7 +9490,7 @@
 501c4dfeab8ff32a18f46ad605b6546d  gcc/testsuite/g++.dg/concepts/explicit-spec5.C
 8119a7faeb5616c44ff49d2bd334eac9  gcc/testsuite/g++.dg/concepts/explicit-spec6.C
 96104c437a91a0fb547269950a1e36f4  gcc/testsuite/g++.dg/concepts/expression.C
-52f0561a49ff6a8c9b047023f5157daf  gcc/testsuite/g++.dg/concepts/expression2.C
+9cd0bdf0163dc59d13bb259276c6ae5e  gcc/testsuite/g++.dg/concepts/expression2.C
 87c2debb21e393a5ad7cace00e6e3ebc  gcc/testsuite/g++.dg/concepts/expression3.C
 1014808baa24324e788c7dd8365e1ce3  gcc/testsuite/g++.dg/concepts/feature-macro.C
 b7abb47c2caa2a79fd16fab511bb2732  gcc/testsuite/g++.dg/concepts/fn-concept1.C
@@ -9608,11 +9560,13 @@
 027f2c7c0ad7e093a74f28f9d0d7d647  gcc/testsuite/g++.dg/concepts/req16.C
 561f41b46177b2306d20376cbf26d558  gcc/testsuite/g++.dg/concepts/req17.C
 8af4e2969556c6e997e15e5f597d1321  gcc/testsuite/g++.dg/concepts/req18.C
+9ffd899c33f7220af9323a4c2742bd97  gcc/testsuite/g++.dg/concepts/req19.C
 fc37b1d1ffeb8646c92ec29e5dedb414  gcc/testsuite/g++.dg/concepts/req2.C
+0ca7d0d8ad43bd2d06816711d6448be1  gcc/testsuite/g++.dg/concepts/req20.C
 9240432b308eb3d01848b9219bf54574  gcc/testsuite/g++.dg/concepts/req3.C
-789edfd6a18eb7aefdb70de5ee2d7fc0  gcc/testsuite/g++.dg/concepts/req4.C
-e6fadc6e6565a21c82b671cf83db5509  gcc/testsuite/g++.dg/concepts/req5.C
-a837c9f121398c34d9d464990ba30ef4  gcc/testsuite/g++.dg/concepts/req6.C
+1bdb8c23a97fc02dc59b0fca6be8514d  gcc/testsuite/g++.dg/concepts/req4.C
+a847d33fd2714f5bc1c7bf82c0176102  gcc/testsuite/g++.dg/concepts/req5.C
+9553bc47ec33281c4ec07de996a4989b  gcc/testsuite/g++.dg/concepts/req6.C
 cf1a1cf4f90160b4b86afb8e6484459d  gcc/testsuite/g++.dg/concepts/req7.C
 16d982b507ffee80be5a1bc873fff0ea  gcc/testsuite/g++.dg/concepts/req8.C
 8280cb973b01ac7880086901d73a394e  gcc/testsuite/g++.dg/concepts/req9.C
@@ -9637,16 +9591,17 @@
 28cce2ca57d1f29a0d0eade359d3c202  gcc/testsuite/g++.dg/concepts/var-concept4.C
 014df05bdbdfd4aef2968bb90ad28e65  gcc/testsuite/g++.dg/concepts/var-concept5.C
 c0a0dd84a577ada307b7869dc3ea7612  gcc/testsuite/g++.dg/concepts/var-concept6.C
-b6115b5e4ac7a76ce3c27db80d14c531  gcc/testsuite/g++.dg/concepts/var-templ1.C
+d686009ae0430347493849435d065149  gcc/testsuite/g++.dg/concepts/var-templ1.C
 e943848fb59fdc24e521fa408a8d7684  gcc/testsuite/g++.dg/concepts/var-templ2.C
 55d37ce4725b2bb2562b6bf081fb2d6e  gcc/testsuite/g++.dg/concepts/variadic1.C
-1c6ba3dc03a4aac6e93ecddc77820621  gcc/testsuite/g++.dg/concepts/variadic2.C
+49188af171efd3fc7a4910e5f4c2ed79  gcc/testsuite/g++.dg/concepts/variadic2.C
 b090b7633124e41a8ed5f692e4b2bdef  gcc/testsuite/g++.dg/concepts/variadic3.C
 47d50ea9841dfff2e1add4fe21d8cdd8  gcc/testsuite/g++.dg/conflict-markers-1.C
 f25f03bef75b49b3242b2b981a26687a  gcc/testsuite/g++.dg/constexpr-null1.C
 f0aed431ce3357281e21fdd3e10a7644  gcc/testsuite/g++.dg/conversion/access1.C
 cae83e7bca15183b3b346f9a00467f2c  gcc/testsuite/g++.dg/conversion/ambig1.C
 65bec450f1ba3239f73319431b72958b  gcc/testsuite/g++.dg/conversion/ambig2.C
+722f350c4414b8268cd41e6ba6e87739  gcc/testsuite/g++.dg/conversion/ambig3.C
 692916f43054879ce077252221b118a2  gcc/testsuite/g++.dg/conversion/base1.C
 f1b5334044ded17fb9949549b0502764  gcc/testsuite/g++.dg/conversion/bitfield1.C
 38f6bad87ae88f3b5e8814eb2a0cb3cd  gcc/testsuite/g++.dg/conversion/bitfield10.C
@@ -9747,6 +9702,7 @@
 74bb2cd707774dcc79b45b939b21d2a8  gcc/testsuite/g++.dg/cpp0x/Wnarrowing3.C
 98f5997ac53fff61b85f99bfe358a506  gcc/testsuite/g++.dg/cpp0x/Wnarrowing4.C
 6ae3451e0c7b222e73c985a0c76a4253  gcc/testsuite/g++.dg/cpp0x/Wunused-parm.C
+c9c65f2ce729014de1f8d5a02bf08a2a  gcc/testsuite/g++.dg/cpp0x/Wunused-variable-1.C
 948a776d6405969529e65e69911b6f98  gcc/testsuite/g++.dg/cpp0x/Wzero-as-null-pointer-constant-1.C
 1821a76c969bbe9fe98225106370d360  gcc/testsuite/g++.dg/cpp0x/Wzero-as-null-pointer-constant-2.C
 1388db9b52c8fb258faed2c95049bb99  gcc/testsuite/g++.dg/cpp0x/__func__.C
@@ -9804,6 +9760,7 @@
 8202db24e0fe65d1f9e1618bd0be1554  gcc/testsuite/g++.dg/cpp0x/alias-decl-50.C
 72736d15450a5e2c6eff6d212a1c62ea  gcc/testsuite/g++.dg/cpp0x/alias-decl-51.C
 ff3cdd35e9b74954a4247257ac643335  gcc/testsuite/g++.dg/cpp0x/alias-decl-52.C
+aeae7dcc61eb495ebb095caa00a5f429  gcc/testsuite/g++.dg/cpp0x/alias-decl-55.C
 a16b0e12dce894e9bc097e3fbad8787d  gcc/testsuite/g++.dg/cpp0x/alias-decl-6.C
 816dbf372a71890f9515376534ec312b  gcc/testsuite/g++.dg/cpp0x/alias-decl-7.C
 77aa48fcd9f9b9ffab08fa7ebc5d52e2  gcc/testsuite/g++.dg/cpp0x/alias-decl-8.C
@@ -9820,6 +9777,7 @@
 f441b8f61e57b375afffc578a0ab410b  gcc/testsuite/g++.dg/cpp0x/alignas3.C
 842d4bc39d9ce4591190d72ce324a6a8  gcc/testsuite/g++.dg/cpp0x/alignas4.C
 2490568ef637fae72e27c31a035040f2  gcc/testsuite/g++.dg/cpp0x/alignas5.C
+6cd5b5dc6ccc7b589a806bdced15c4db  gcc/testsuite/g++.dg/cpp0x/alignas7.C
 dad14da1d0b01a33c9cdabaaf609eb0a  gcc/testsuite/g++.dg/cpp0x/alignof.C
 f6ed96119608d817c8a36a47de91e2bc  gcc/testsuite/g++.dg/cpp0x/alignof2.C
 a341935f38f4b4581206e23c9027c975  gcc/testsuite/g++.dg/cpp0x/alignof3.C
@@ -9866,6 +9824,7 @@
 d9b716e1c070d979f6ba213732af91c4  gcc/testsuite/g++.dg/cpp0x/auto45.C
 19479e39ea80e3649e4b4b41c4c2abeb  gcc/testsuite/g++.dg/cpp0x/auto46.C
 44db23ed368948ddb9b1a48f48c7bdaa  gcc/testsuite/g++.dg/cpp0x/auto47.C
+a9475f77c4033a39fd7cae71ded2db91  gcc/testsuite/g++.dg/cpp0x/auto48.C
 7abd7f6467fdec05adaab6e23e984bfb  gcc/testsuite/g++.dg/cpp0x/auto5.C
 a2ff527dcef7e9b2af2703655b2eda60  gcc/testsuite/g++.dg/cpp0x/auto7.C
 e90d2ff3c84b5ead3e920a1d12881e02  gcc/testsuite/g++.dg/cpp0x/auto9.C
@@ -9928,6 +9887,7 @@
 6d2a7bdbddfaf87d584b814bf1961f04  gcc/testsuite/g++.dg/cpp0x/constexpr-70204b.C
 4b441a48b11747fe319801157a36c4a6  gcc/testsuite/g++.dg/cpp0x/constexpr-70323.C
 afb210848d078a6555666048b75692fb  gcc/testsuite/g++.dg/cpp0x/constexpr-70323a.C
+34638f51d99af855474a3feb1f02e5d7  gcc/testsuite/g++.dg/cpp0x/constexpr-71828.C
 de3d6255780c29f63df3f8d96932bd39  gcc/testsuite/g++.dg/cpp0x/constexpr-98.C
 1bc1c995533b047ed8df6f6f24905cd1  gcc/testsuite/g++.dg/cpp0x/constexpr-99.C
 3ccc1912e7827aae6b55936a3bf3bb24  gcc/testsuite/g++.dg/cpp0x/constexpr-__func__.C
@@ -9955,6 +9915,8 @@
 c674590e5f0bbd6aa35938ccaa364818  gcc/testsuite/g++.dg/cpp0x/constexpr-array13.C
 a3fe89999694d5e28c05f50283b43674  gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C
 9a2ca70ccd537baf9a32359fd8f4b890  gcc/testsuite/g++.dg/cpp0x/constexpr-array15.C
+0d357130ee7bed073a309d7d917b8baa  gcc/testsuite/g++.dg/cpp0x/constexpr-array16.C
+b67bdded4c1fdae8a63fc397fa97f855  gcc/testsuite/g++.dg/cpp0x/constexpr-array17.C
 687c6e77d4af3cd918c0ff421773a66c  gcc/testsuite/g++.dg/cpp0x/constexpr-array2.C
 8b7c8e7c1b64cfa0626f7f2311c9fef5  gcc/testsuite/g++.dg/cpp0x/constexpr-array3.C
 6451aa5bb5fa736dda3ebad1dc2e8336  gcc/testsuite/g++.dg/cpp0x/constexpr-array4.C
@@ -10123,10 +10085,11 @@
 4d49e9b974a931e39b282bff1452e17a  gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem3.C
 3123b806108a774709cd5a02856fa2a3  gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem4.C
 207019aa55e1983b45122db974bd0948  gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem5.C
+bdbdee9b8211644ca4eaf7ef1be48857  gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem6.C
 32da508b62d5ba45ac51680a9a5638a4  gcc/testsuite/g++.dg/cpp0x/constexpr-ptrsub.C
 c893e2388f9acef593b874b1e6b02071  gcc/testsuite/g++.dg/cpp0x/constexpr-pure.C
 3d462eb6b34feb0c1cf9349c9e6e976c  gcc/testsuite/g++.dg/cpp0x/constexpr-recursion.C
-e928dbbe606fe0e66600ffb39f8ec1ac  gcc/testsuite/g++.dg/cpp0x/constexpr-recursion2.C
+d0613cd67d583f80a028bb4816e6c9e8  gcc/testsuite/g++.dg/cpp0x/constexpr-recursion2.C
 5e160a188aef7805034f272bd43d2ab7  gcc/testsuite/g++.dg/cpp0x/constexpr-redeclaration1.C
 dc7a7eb622691a6363e90822f0e39072  gcc/testsuite/g++.dg/cpp0x/constexpr-ref1.C
 d1d1aecd66ba1c7f2b50e13b37172d43  gcc/testsuite/g++.dg/cpp0x/constexpr-ref2.C
@@ -10204,7 +10167,7 @@
 58e380f5c0bc16e86009e605e19acb07  gcc/testsuite/g++.dg/cpp0x/constexpr-volatile.C
 7bca20d6ac21d6cb78ab16d5c52b7e64  gcc/testsuite/g++.dg/cpp0x/constexpr-wstring1.C
 1bd363de99cf0f80a7a4045242fee01f  gcc/testsuite/g++.dg/cpp0x/constexpr-wstring2.C
-dd5a416dd6cf70c8d633073c2bdfd8b3  gcc/testsuite/g++.dg/cpp0x/conv-tmpl1.C
+70dc080523c40a07cec30261f6f7007a  gcc/testsuite/g++.dg/cpp0x/conv-tmpl1.C
 38cf671e2c9af718ef5149c2d09c8383  gcc/testsuite/g++.dg/cpp0x/cplusplus.C
 61947bc3307a11bf874ab41c139e4d41  gcc/testsuite/g++.dg/cpp0x/cplusplus_0x.C
 785a499e3417eea504fae30dbd16a77f  gcc/testsuite/g++.dg/cpp0x/dc1.C
@@ -10287,6 +10250,7 @@
 052b7eec67bbc39fded7404fdeff4428  gcc/testsuite/g++.dg/cpp0x/decltype61.C
 b7d187347381223b6effdb89e05e85df  gcc/testsuite/g++.dg/cpp0x/decltype62.C
 e0815b98196aea0739acd0b3e2b6b78f  gcc/testsuite/g++.dg/cpp0x/decltype63.C
+d2625dbb2a029ee93a5c64304e4db88e  gcc/testsuite/g++.dg/cpp0x/decltype65.C
 c3626f3b26fbb53bd234a4e39649b63f  gcc/testsuite/g++.dg/cpp0x/decltype7.C
 bbdff105c665351973aaa6a25eaa0940  gcc/testsuite/g++.dg/cpp0x/decltype8.C
 4b13c00f57a3a7cb225369c29f8fd6f6  gcc/testsuite/g++.dg/cpp0x/decltype9.C
@@ -10534,6 +10498,8 @@
 d3df2168b01c7df3891e31a076616e58  gcc/testsuite/g++.dg/cpp0x/inh-ctor18.C
 798dc3612d523e6b99b6a497b1f8ae60  gcc/testsuite/g++.dg/cpp0x/inh-ctor19.C
 69ee4b066e7054d7163a882761fcc7c7  gcc/testsuite/g++.dg/cpp0x/inh-ctor2.C
+1e245cab6f0228068139bd22ddc79d66  gcc/testsuite/g++.dg/cpp0x/inh-ctor20.C
+ae53be78261501cbb9b25c7630f78cb5  gcc/testsuite/g++.dg/cpp0x/inh-ctor21.C
 6a7a4b5897b83f2f6ebdd08eb567d152  gcc/testsuite/g++.dg/cpp0x/inh-ctor3.C
 071eafda7f7d2d4bff42921fbd048a45  gcc/testsuite/g++.dg/cpp0x/inh-ctor4.C
 fda4f7d4f4b57c79d7734d634ae9041f  gcc/testsuite/g++.dg/cpp0x/inh-ctor5.C
@@ -10558,6 +10524,7 @@
 e3ec7ab89d20e6ccf50aa92954896f07  gcc/testsuite/g++.dg/cpp0x/initlist-postfix-open-square.C
 1b5c7e432be89c3edcbfaad424a2e353  gcc/testsuite/g++.dg/cpp0x/initlist-protected.C
 fd02e573e3be3d0a146192cd840840a1  gcc/testsuite/g++.dg/cpp0x/initlist-pure.C
+b981bb775821a5230961a162ba38ff43  gcc/testsuite/g++.dg/cpp0x/initlist-template1.C
 742c772ced8eedc3c0511b94b8410082  gcc/testsuite/g++.dg/cpp0x/initlist-value.C
 fab23eb9efdcf1b8c0f8393aa5ad7913  gcc/testsuite/g++.dg/cpp0x/initlist-value2.C
 93763afe3eb7edb5553f76daf0ed0de3  gcc/testsuite/g++.dg/cpp0x/initlist-vect.C
@@ -10690,6 +10657,7 @@
 fc87adf1aa8763a35e80b1067faf9948  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const5.C
 25265bcafc26c3a0ab3727a9ff348916  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv.C
 862ed5b4e67a8a0e32b42b5792ae7fff  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv10.C
+522c3e9a3e7905c1f6e87fc6ce263930  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv11.C
 299fbfde279f22ba6cf7e79d7e17f49b  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv2.C
 13859d1112ce3900c792dcdc2e8ae085  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv3.C
 b91c55a7472ec7a8d2f35a01f04cc387  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv4.C
@@ -10737,6 +10705,7 @@
 c4dbb33289335abfc0e81ecec97d4f05  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice13.C
 dc3a51c8d29b09710666fc488cca027c  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice14.C
 1042a4840f48bd0952ae8bb7b25b0885  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice15.C
+37dfc8c9afae1533f73b7fca269e891d  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice16.C
 f7f1dbbd136c0efa4e64ac7431acecd4  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice2.C
 32e4ddab4dbbba84634a9be94759430d  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice3.C
 47226bea0ac5dc3c286fd8fe05473a80  gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice4.C
@@ -11095,6 +11064,9 @@
 ab186fe632aff8530f69060d5961b489  gcc/testsuite/g++.dg/cpp0x/pr68726.C
 d584417478a609ab589447aa7e173812  gcc/testsuite/g++.dg/cpp0x/pr69056.C
 4ca96cbe7b69845eba2cf016007957a4  gcc/testsuite/g++.dg/cpp0x/pr70528.C
+cf9cf154014255688dedeb39cfe8e73b  gcc/testsuite/g++.dg/cpp0x/pr70869.C
+c69896dc2fac3243e492d5e8acf8d0b8  gcc/testsuite/g++.dg/cpp0x/pr71054.C
+bf28b34cff6af29465046bf24b9bff82  gcc/testsuite/g++.dg/cpp0x/pr71739.C
 53428f69a6d0153074c9b06ee9fbe9e7  gcc/testsuite/g++.dg/cpp0x/ptrmem-cst-arg1.C
 6e8e648c26d9bf237cc152180e88c2c2  gcc/testsuite/g++.dg/cpp0x/range-for1.C
 5c7a98d8ca2f0f427c081bf6902aa831  gcc/testsuite/g++.dg/cpp0x/range-for10.C
@@ -11120,11 +11092,12 @@
 64c77a507ebcd58347cb4a538ae16807  gcc/testsuite/g++.dg/cpp0x/range-for29.C
 ba9e5975a5058b94945c4d18bb19b344  gcc/testsuite/g++.dg/cpp0x/range-for3.C
 4b0681c49d2c294d37da68e8ae679248  gcc/testsuite/g++.dg/cpp0x/range-for30.C
+2e0b59cf549f3ada1e2c24f0828fd564  gcc/testsuite/g++.dg/cpp0x/range-for31.C
 cf3faabae812bd6f8ade13f3c1d36871  gcc/testsuite/g++.dg/cpp0x/range-for4.C
 9d70da20463079b62be580867a3e6601  gcc/testsuite/g++.dg/cpp0x/range-for5.C
 bf09a13cfe61445a898ea383c44bc795  gcc/testsuite/g++.dg/cpp0x/range-for6.C
 cf6c66c2c1f26f78f53b3a006d996662  gcc/testsuite/g++.dg/cpp0x/range-for7.C
-52e4fd10daa41fb157218e52014c09f1  gcc/testsuite/g++.dg/cpp0x/range-for8.C
+b111f953ff16a99ffc3ad09a151f0958  gcc/testsuite/g++.dg/cpp0x/range-for8.C
 68a9925bd047631ad89890587ebf286d  gcc/testsuite/g++.dg/cpp0x/range-for9.C
 87cba3bd81389f956a4ab8405ad5dc46  gcc/testsuite/g++.dg/cpp0x/ref-qual-mangle1.C
 af4673410b97bcc5393dd82a2599c2d1  gcc/testsuite/g++.dg/cpp0x/ref-qual-multi-neg.C
@@ -11251,6 +11224,7 @@
 6cdcb8a895c4b3868012fd320d412513  gcc/testsuite/g++.dg/cpp0x/sfinae54.C
 1e0939ee9e6841aacffde1ae4c5d3023  gcc/testsuite/g++.dg/cpp0x/sfinae55.C
 c0fee994e880e6032fe6c1fa1a6efa69  gcc/testsuite/g++.dg/cpp0x/sfinae56.C
+2628399b955cc58affa3be676427e085  gcc/testsuite/g++.dg/cpp0x/sfinae57.C
 7d2a515d9dca41b0e82b2e6ea54bd2d3  gcc/testsuite/g++.dg/cpp0x/sfinae6.C
 ec1a51ea3fd41e6e61c8f425bde1fd0b  gcc/testsuite/g++.dg/cpp0x/sfinae7.C
 547894832b1452d5f513938e0cb8a166  gcc/testsuite/g++.dg/cpp0x/sfinae8.C
@@ -11385,6 +11359,10 @@
 aaa90c1c2261698f9319415498163db1  gcc/testsuite/g++.dg/cpp0x/variadic-function.C
 fb23a824547af5cbc2d6ee6a52d5e3c0  gcc/testsuite/g++.dg/cpp0x/variadic-init.C
 f64443a27f946984ec474714387b99a8  gcc/testsuite/g++.dg/cpp0x/variadic-lambda.C
+61d159a494882dad368e53517bf8df8d  gcc/testsuite/g++.dg/cpp0x/variadic-mangle1a.C
+7727443a155c2eed9930c6bc3f808465  gcc/testsuite/g++.dg/cpp0x/variadic-mangle2a.C
+8dd845093d366e371bdaf222fda42413  gcc/testsuite/g++.dg/cpp0x/variadic-mangle3.C
+efdeb5b65b79fc6ff926b12f711edcb1  gcc/testsuite/g++.dg/cpp0x/variadic-mangle3a.C
 6c67e276177a53a05508b5e974504d12  gcc/testsuite/g++.dg/cpp0x/variadic-mem_fn.C
 7d2b8191fa109fd1786f979fbfa18b4e  gcc/testsuite/g++.dg/cpp0x/variadic-new.C
 5ad1db01bdd9d87f2a8276b08cff8db7  gcc/testsuite/g++.dg/cpp0x/variadic-new2.C
@@ -11646,6 +11624,8 @@
 c62290c3433fd946afe248d80f2f0e63  gcc/testsuite/g++.dg/cpp1y/auto-fn29.C
 c4e86a95bc6b38f69a4a30b1b1cf1e4e  gcc/testsuite/g++.dg/cpp1y/auto-fn3.C
 51f8ba9d1f0f20256658a6298e611261  gcc/testsuite/g++.dg/cpp1y/auto-fn30.C
+2166d3092f2a511f64d91ad91795c1ac  gcc/testsuite/g++.dg/cpp1y/auto-fn31.C
+f475a3e97ef5d08fb361f8070d183611  gcc/testsuite/g++.dg/cpp1y/auto-fn32.C
 a87641c12e6bf65af1e8d592973cba76  gcc/testsuite/g++.dg/cpp1y/auto-fn4.C
 eaab8c47716923537d6580ede6fbe3ae  gcc/testsuite/g++.dg/cpp1y/auto-fn5.C
 3861eed28323480e4913eea3d9c0ec00  gcc/testsuite/g++.dg/cpp1y/auto-fn6.C
@@ -11702,28 +11682,34 @@
 695cc86426b24103c2a80eda00cf2189  gcc/testsuite/g++.dg/cpp1y/digit-sep-neg.C
 2ccf049767734b973a90dea30576d8a8  gcc/testsuite/g++.dg/cpp1y/digit-sep.C
 7f7fdf0f184e22144c0d2d80c0827581  gcc/testsuite/g++.dg/cpp1y/feat-cxx11-neg.C
-c254f2d5cb21443479f2bf917857354d  gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C
+f7b649949cc8d31bf746a3565f161066  gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C
 a3ed2dff5176ed6eef5ae2d57cf13c3c  gcc/testsuite/g++.dg/cpp1y/feat-cxx14-neg.C
-abea85deb4cd6b8a3a2d8a806b4779a7  gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
-3aa0ecb004b47e939728528453a77d12  gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C
+593fb77a3a5089f92e2c81898ae570ff  gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
+d8f10984fce17881f14be647e37c6342  gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C
 d9680a99825535ba499a795339ce02c2  gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C
 01260d1a223a8398c967796299932d12  gcc/testsuite/g++.dg/cpp1y/feat-neg.C
 018149928d964ce66689bf4960400c07  gcc/testsuite/g++.dg/cpp1y/feat-sized-dealloc-neg.C
 b7edad357bb503949f49802295729019  gcc/testsuite/g++.dg/cpp1y/feat-sized-dealloc.C
 fc5875e8af08d0f9488344e80bf6f764  gcc/testsuite/g++.dg/cpp1y/feat-vla.C
 f4be44f045dc9cb6f8b7acd5e3193c1d  gcc/testsuite/g++.dg/cpp1y/fn-generic-member-ool.C
+2cf8b2b7a7dc5ba828766c37a54e2315  gcc/testsuite/g++.dg/cpp1y/lambda-conv1.C
+4734b77212418e40ce4f8965c6017a39  gcc/testsuite/g++.dg/cpp1y/lambda-conv2.C
 5f112fcc57ff57c8e803342bde4e9c25  gcc/testsuite/g++.dg/cpp1y/lambda-deduce-mult-neg.C
 a5fcad1d0708a6218c6fe69c1871df02  gcc/testsuite/g++.dg/cpp1y/lambda-deduce-mult.C
 18a2431f49a5d003b8c4af0ee1ee26fb  gcc/testsuite/g++.dg/cpp1y/lambda-generic-cfun.C
 043e19917f87f2b2acd754fc6d7db469  gcc/testsuite/g++.dg/cpp1y/lambda-generic-const1.C
 565bd59fb2dca8cbcfbfa5b7e1e94368  gcc/testsuite/g++.dg/cpp1y/lambda-generic-const2.C
 2e80b291e01a2cfa45ff49e595eefeb5  gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv1.C
+4826d92e5c4d99fa506ff2e846ff01a4  gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv2.C
+78cdb2dc3c8d671d96c375fa61f96dc5  gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv3.C
 254c0618a7c86ead274dccfd78d8434f  gcc/testsuite/g++.dg/cpp1y/lambda-generic-dep.C
 82fea772a2540cf9ab702c17cc2cdb54  gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice1.C
 767d5be8b02f5e7228313580ecdc27bf  gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice2.C
 fd449c2760b279bd0767e28da8a563bf  gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice3.C
 2d18bbc76edb8b7a9ae068d833d222fb  gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice4.C
 3982e2c97cd56293f3566844b67df18c  gcc/testsuite/g++.dg/cpp1y/lambda-generic-mixed.C
+db3760d317d0220aeddc9a1ce4072105  gcc/testsuite/g++.dg/cpp1y/lambda-generic-static1.C
+c6cfff44332b8bfb7c52ace4e1af76c5  gcc/testsuite/g++.dg/cpp1y/lambda-generic-static2.C
 06ba6684e3759115ec5098f38667687b  gcc/testsuite/g++.dg/cpp1y/lambda-generic-trailing1.C
 c175c183205acb7386648c9340cb5b77  gcc/testsuite/g++.dg/cpp1y/lambda-generic-udt.C
 7515a5372d247dd5a94ef0626c25c2ae  gcc/testsuite/g++.dg/cpp1y/lambda-generic-uneval1.C
@@ -11766,6 +11752,7 @@
 7d97ba4392709fc8da484e897e085d27  gcc/testsuite/g++.dg/cpp1y/paren1.C
 b37062a8a2160ab7a8f6b2faf63a7687  gcc/testsuite/g++.dg/cpp1y/paren2.C
 e8c6da7fb812f06074a9399c95d62136  gcc/testsuite/g++.dg/cpp1y/paren3.C
+86a0b848e4db7d7f6ee1c78dcc897448  gcc/testsuite/g++.dg/cpp1y/paren4.C
 a59e5fd28eae5235838080483b6939a6  gcc/testsuite/g++.dg/cpp1y/phoobhar.h
 7d18afb36bcaa55af2030c6546d5df38  gcc/testsuite/g++.dg/cpp1y/pr57640.C
 c4165eafc91468f7acbe5ba99603b2e7  gcc/testsuite/g++.dg/cpp1y/pr57644.C
@@ -11863,7 +11850,8 @@
 1d11dd14feca38229a393d32dcdfc3d2  gcc/testsuite/g++.dg/cpp1y/var-templ36.C
 69d95f597d98b91cb3856be43d3c5546  gcc/testsuite/g++.dg/cpp1y/var-templ37.C
 8794fe86c499aa19549c780c79aa368a  gcc/testsuite/g++.dg/cpp1y/var-templ38.C
-f050d11349ddbf7b7819f451dc9afd8d  gcc/testsuite/g++.dg/cpp1y/var-templ39.C
+8d67f45e619e5e401002587bef8da3a5  gcc/testsuite/g++.dg/cpp1y/var-templ39.C
+8fbb09c96293e0ad0adec02f8c333330  gcc/testsuite/g++.dg/cpp1y/var-templ39a.C
 a82697cf228f6c067aa7a0fdefbfe94c  gcc/testsuite/g++.dg/cpp1y/var-templ4.C
 bb4283f25d1a9ee27311f1ab54256222  gcc/testsuite/g++.dg/cpp1y/var-templ40.C
 da28be896a54e4517281f1dced095bee  gcc/testsuite/g++.dg/cpp1y/var-templ42.C
@@ -11876,6 +11864,8 @@
 6795aca168270525552bd48975a98225  gcc/testsuite/g++.dg/cpp1y/var-templ49.C
 34e14d27e3c00f201eeb1fb1d4d286c1  gcc/testsuite/g++.dg/cpp1y/var-templ5.C
 5160d45ceedf6faed4671f12ca9eae37  gcc/testsuite/g++.dg/cpp1y/var-templ50.C
+868d0756ba26f1a2a91e775d64bad123  gcc/testsuite/g++.dg/cpp1y/var-templ51.C
+145d4d5f8a5e4afaf223d9a444d14037  gcc/testsuite/g++.dg/cpp1y/var-templ52.C
 46f96806c3f041172407dd6ff7943dc8  gcc/testsuite/g++.dg/cpp1y/var-templ6.C
 3c670164f1a7f8f91ef1db2f80526182  gcc/testsuite/g++.dg/cpp1y/var-templ7.C
 7490ba7f2bf9511118a48f52e8c4ceed  gcc/testsuite/g++.dg/cpp1y/var-templ8.C
@@ -11894,8 +11884,9 @@
 68f716938002307e7dcda9d5dc357f14  gcc/testsuite/g++.dg/cpp1z/attributes-enum-1.C
 c0f76eabaeee19f702ca129c32355700  gcc/testsuite/g++.dg/cpp1z/attributes-enum-1a.C
 98b1106ed209b91da77baabfe32a0221  gcc/testsuite/g++.dg/cpp1z/cplusplus.C
-90ef12e7060fa023a9c65acb99fbd917  gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
+b78ef62cdf62c62127e6ef6b082f3bbf  gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
 f6bf72fc22cf2e0b2625b0da029798a4  gcc/testsuite/g++.dg/cpp1z/fold-ice1.C
+89cd455176ece385a64d1d1b18aa7468  gcc/testsuite/g++.dg/cpp1z/fold-mangle.C
 31887e84574fe8c28417b43ab6292361  gcc/testsuite/g++.dg/cpp1z/fold1.C
 ec8f049d9f6e3cc6a0a94adeaf70a315  gcc/testsuite/g++.dg/cpp1z/fold2.C
 402016faa295175165f8ebd8f741b826  gcc/testsuite/g++.dg/cpp1z/fold3.C
@@ -12078,6 +12069,7 @@
 5c1e2db64783ad9531a0a03f6e23da46  gcc/testsuite/g++.dg/debug/pr56819.C
 41269ba367aaa19e5abac5932fdc247c  gcc/testsuite/g++.dg/debug/pr65678.C
 ccda43f2f659360264083e64ebc66d22  gcc/testsuite/g++.dg/debug/pr70271.C
+441b2b85c00e5fb81636a85d6732eb55  gcc/testsuite/g++.dg/debug/pr71057.C
 a5e8d546d53a780cc3eb41574ea9f263  gcc/testsuite/g++.dg/debug/ra1.C
 c3f392076ad11f8768ef0321b89abd5f  gcc/testsuite/g++.dg/debug/static1.C
 7e13d86d33b17cfb7cdf61b7b8cca961  gcc/testsuite/g++.dg/debug/template1.C
@@ -12630,6 +12622,7 @@
 53628223a07c6bbfb1cd7aef3f2b93cf  gcc/testsuite/g++.dg/ext/flexary13.C
 c4a658a25ef8a25aeef375a3ce711fa2  gcc/testsuite/g++.dg/ext/flexary14.C
 aaba8fe44d3e6fec2f01feeb83885ba8  gcc/testsuite/g++.dg/ext/flexary15.C
+858ff0064f04a2ffe669c5f8458aa820  gcc/testsuite/g++.dg/ext/flexary16.C
 fa0fdbfe242e37c8962c867f656e7e36  gcc/testsuite/g++.dg/ext/flexary2.C
 21926590c31816347bbb7ba438127f63  gcc/testsuite/g++.dg/ext/flexary3.C
 c59d230f31793ac10c850433a29a2a25  gcc/testsuite/g++.dg/ext/flexary4.C
@@ -12946,6 +12939,7 @@
 586098ef0e0e0ff1300efeabda4cf0fa  gcc/testsuite/g++.dg/ext/vector29.C
 06e44a4208434952189cfd9cd55ae2d8  gcc/testsuite/g++.dg/ext/vector3.C
 6ca255361ad69ad75b523ad0b133b0fb  gcc/testsuite/g++.dg/ext/vector30.C
+c3b38049951f0b2eddec58e423441ed3  gcc/testsuite/g++.dg/ext/vector31.C
 1d6b45dce331a414b31b64c5104ab383  gcc/testsuite/g++.dg/ext/vector4.C
 3231264b4b96091ab8a2351e76707e8d  gcc/testsuite/g++.dg/ext/vector5.C
 9dca9632e59d179ee1b85a181a34cae7  gcc/testsuite/g++.dg/ext/vector6.C
@@ -13102,6 +13096,7 @@
 aba75e24bfe044cbb1a628f1d1daccc3  gcc/testsuite/g++.dg/gomp/declare-simd-3.C
 7cee1de25d2f28d3760c1bdfb7d95411  gcc/testsuite/g++.dg/gomp/declare-simd-4.C
 d66c2d955608b28091f45938dce39989  gcc/testsuite/g++.dg/gomp/declare-simd-5.C
+5a587ac99f134c07ba81955351d61058  gcc/testsuite/g++.dg/gomp/declare-simd-6.C
 634bd3d929883e4c691a682ea0817a3e  gcc/testsuite/g++.dg/gomp/declare-target-1.C
 c75b0d654d83deb86c542efca3d79c2b  gcc/testsuite/g++.dg/gomp/depend-1.C
 cdd29f4ee662c46448400d10d8f0535c  gcc/testsuite/g++.dg/gomp/depend-2.C
@@ -13243,6 +13238,7 @@
 69587a534832b53372f1e04087c04986  gcc/testsuite/g++.dg/gomp/pr67514.C
 55299f8d5853e349499aeed5c702a80a  gcc/testsuite/g++.dg/gomp/pr67522.C
 1c935120e3c1e7d165ea068f57519a6e  gcc/testsuite/g++.dg/gomp/pr67523.C
+79e222486ea33d87026b4ecac4bb3593  gcc/testsuite/g++.dg/gomp/pr71941.C
 d2c2484d4d1236326efc32a01fddaa03  gcc/testsuite/g++.dg/gomp/predetermined-1.C
 edac71d2b358ecd6e646fece69c5426d  gcc/testsuite/g++.dg/gomp/private-1.C
 d447246d410ae61ed9f733998e77b958  gcc/testsuite/g++.dg/gomp/reference-1.C
@@ -13635,6 +13631,7 @@
 a5a0c6bb188e4c01d4db2d84a5014752  gcc/testsuite/g++.dg/init/pr66857.C
 788ed5b002d14f945d06c72d6b7c78bc  gcc/testsuite/g++.dg/init/pr69658.C
 154196e0320831a54c0ed5e880a704cd  gcc/testsuite/g++.dg/init/pr70501.C
+effadbfc637d03ffccebf5ad6b37c6c0  gcc/testsuite/g++.dg/init/pr71516.C
 697d82f637fb8839d98efadd58ededf5  gcc/testsuite/g++.dg/init/ptrfn1.C
 c3eaccdcf8e35f944dee4d4b3d720336  gcc/testsuite/g++.dg/init/ptrfn2.C
 111716aa5bd4c456321772f776bd97d1  gcc/testsuite/g++.dg/init/ptrfn3.C
@@ -13781,6 +13778,7 @@
 890af13d278e4e0706986dbc2c5a1884  gcc/testsuite/g++.dg/ipa/ipa-icf-5.C
 97e97070da1c97a8b6352ba2dbe100c3  gcc/testsuite/g++.dg/ipa/ipa-icf-6.C
 baa7a26fbd7f93011660ae486b2d5a03  gcc/testsuite/g++.dg/ipa/ipa-pta-1.C
+10ce8060f456afad572b21a436f24c5c  gcc/testsuite/g++.dg/ipa/ipa-pta-2.C
 dce8034edae4f3ebb13a737d288cc800  gcc/testsuite/g++.dg/ipa/ivinline-1.C
 394623fa3c8fc8afefe76c7e05bcd23d  gcc/testsuite/g++.dg/ipa/ivinline-2.C
 4ade5754b9cadd69737394051664462b  gcc/testsuite/g++.dg/ipa/ivinline-3.C
@@ -14018,6 +14016,7 @@
 bcba89d3ec64e8fc005f26cebc29ef75  gcc/testsuite/g++.dg/lookup/redecl1.C
 a0c29cb4b5f7577e6f70badabcf54df5  gcc/testsuite/g++.dg/lookup/scope-operator1.C
 ac54cbb864f44961ac42e88050c9ad49  gcc/testsuite/g++.dg/lookup/scoped1.C
+bf3eaff26a33ccd4611b5f6e55765a4d  gcc/testsuite/g++.dg/lookup/scoped10.C
 b7a658adf99cb82ba017f02f1f2411c6  gcc/testsuite/g++.dg/lookup/scoped2.C
 fd5b1d6b45ff24d721908d389585b869  gcc/testsuite/g++.dg/lookup/scoped3.C
 aa72bf12de95e37fe79a3293544473d4  gcc/testsuite/g++.dg/lookup/scoped4.C
@@ -14025,6 +14024,7 @@
 d0e63df38adea95bde4f29a4a8adbd7a  gcc/testsuite/g++.dg/lookup/scoped6.C
 36c8df686ba39d71b24a97d15b78bcba  gcc/testsuite/g++.dg/lookup/scoped7.C
 26af3964407b493bd173a74dadeb7ffb  gcc/testsuite/g++.dg/lookup/scoped8.C
+6369d16eb28b1bd2774c54434aaec082  gcc/testsuite/g++.dg/lookup/scoped9.C
 2b1b09d91910d20eece0379cd7533859  gcc/testsuite/g++.dg/lookup/strong-using-1.C
 9cf5f616cd7d12356a4b60ef67aaf1e1  gcc/testsuite/g++.dg/lookup/strong-using-2.C
 7da1d317c0e74ab901f17a10189784da  gcc/testsuite/g++.dg/lookup/strong-using-3.C
@@ -14592,6 +14592,12 @@
 3cc6fd0213a86e9af54303b476324b4f  gcc/testsuite/g++.dg/opt/pr70245.C
 3ca6d038cb6338c3f99ac2cf4bb8b829  gcc/testsuite/g++.dg/opt/pr70245.h
 4c279781e65c3062bc3ebe4f9a883ad8  gcc/testsuite/g++.dg/opt/pr70641.C
+1248cf51218287e0763e9bafddb6e95e  gcc/testsuite/g++.dg/opt/pr70847.C
+b4565019d3f57b4cde7d76aea63e2b00  gcc/testsuite/g++.dg/opt/pr71100.C
+2683b031136335ebc445306bbda40ed6  gcc/testsuite/g++.dg/opt/pr71210-1.C
+e8fd45f660a33add25be711bbf9a8aed  gcc/testsuite/g++.dg/opt/pr71210-2.C
+ea8361ea831bc7d6110a725ab74d2721  gcc/testsuite/g++.dg/opt/pr71387.C
+a380c45913d5ec3d5feed82fd2ba5c78  gcc/testsuite/g++.dg/opt/pr71528.C
 90bdbfd9313461944756a9e9f01ce788  gcc/testsuite/g++.dg/opt/pr7503-1.C
 1451eba24eea82cbd0c1ab87885c0f77  gcc/testsuite/g++.dg/opt/preinc1.C
 0841088f825be785d32663d712ecf675  gcc/testsuite/g++.dg/opt/ptrintsum1.C
@@ -14803,6 +14809,7 @@
 88d3ce293bea84b74d7f26a42a8538fb  gcc/testsuite/g++.dg/other/gc4.C
 47195a1b7ad4c24c5ccc7cbf50e26bb0  gcc/testsuite/g++.dg/other/gc5.C
 3ca5017faf45f39326ff4e30a1ec1ba8  gcc/testsuite/g++.dg/other/i386-1.C
+9913a24914ce11f6a0606c70ed58cb96  gcc/testsuite/g++.dg/other/i386-10.C
 76d10b67eca4193b848abdfb0dbf492a  gcc/testsuite/g++.dg/other/i386-2.C
 ad4545acd2416049630459a66f6c3f86  gcc/testsuite/g++.dg/other/i386-3.C
 a4ad4c2cb3c1448496351241a77aedb7  gcc/testsuite/g++.dg/other/i386-4.C
@@ -14897,6 +14904,7 @@
 3634dbc3147618af0685ced6e33189ea  gcc/testsuite/g++.dg/other/pr63815.C
 edba4dc64424b99c4e6984f1aa7e9507  gcc/testsuite/g++.dg/other/pr66130.C
 335c58f031e8af025ac6bd25a8f5e0ed  gcc/testsuite/g++.dg/other/pr67065.C
+3c357334529bfcf67faa2a847f3c9290  gcc/testsuite/g++.dg/other/pr71728.C
 2b96e0cda3aaa703c284fca6a0dd72c9  gcc/testsuite/g++.dg/other/pragma-re-1.C
 bdec0c9208af6ee3a9ab1f2c07d3ba19  gcc/testsuite/g++.dg/other/pragma-re-2.C
 f804e6064a0c7cd94d73f58ba8f6e5e0  gcc/testsuite/g++.dg/other/profile1.C
@@ -15422,6 +15430,7 @@
 5cf1aa6b471b7c8c4120c7b9642955c6  gcc/testsuite/g++.dg/parse/pr68722.C
 af9e56882c04892fe78e6734f13353e2  gcc/testsuite/g++.dg/parse/pr69628.C
 1e79347577849ae03e3a20e2fc6247ff  gcc/testsuite/g++.dg/parse/pr70635.C
+5eb3f5d17e121a7a8f7884b589a7a7ce  gcc/testsuite/g++.dg/parse/pr71909.C
 5a9d33aff7826f90760a0154af35d9f0  gcc/testsuite/g++.dg/parse/pragma1.C
 b8553036b01aadac9e932e75221336ae  gcc/testsuite/g++.dg/parse/pragma2.C
 d516a5d017b9be02cd665abb61b0fbaf  gcc/testsuite/g++.dg/parse/pragma3.C
@@ -15669,9 +15678,12 @@
 29300174b10233fd47c932d1ffd4c3bf  gcc/testsuite/g++.dg/pr69123.C
 07ceb93faa4d6543359b7c47e9a5e94a  gcc/testsuite/g++.dg/pr69379.C
 e77af829a8368cadb2874c601ccda7ee  gcc/testsuite/g++.dg/pr69667.C
-514f19a372e6da2045ad3ac8a01eff0a  gcc/testsuite/g++.dg/pr70098.C
+6574022bacba25e4efad4b7c4931c69a  gcc/testsuite/g++.dg/pr70098.C
 b6486240b7f881b41363b5c5aed08fef  gcc/testsuite/g++.dg/pr70590-2.C
 78887d1698e74e4fca9c756431fc9a37  gcc/testsuite/g++.dg/pr70590.C
+0b728dae13a5f48195e47018a83c4f35  gcc/testsuite/g++.dg/pr71184.C
+dd5b895f9e8e377b3fc861eecf9bdbf7  gcc/testsuite/g++.dg/pr71389.C
+bb847cc20ee8eeae077a40b58e2964fc  gcc/testsuite/g++.dg/pr71624.C
 d038107e5b87bb2651ccfef7fa33748a  gcc/testsuite/g++.dg/predict-loop-exit-1.C
 b091c5510d946f61175720e0e6a70c8e  gcc/testsuite/g++.dg/predict-loop-exit-2.C
 89ad4872e69c75752e361c89ce72b02b  gcc/testsuite/g++.dg/predict-loop-exit-3.C
@@ -16066,6 +16078,7 @@
 c2f7a35b429490ab54f2fba257ca0dd9  gcc/testsuite/g++.dg/template/defarg19.C
 21ce3e77355010aaab1b59936da8bfbb  gcc/testsuite/g++.dg/template/defarg2.C
 307285b77c17f229ecbeb4c647090190  gcc/testsuite/g++.dg/template/defarg20.C
+c96940bb22962f4c0c4140417e941221  gcc/testsuite/g++.dg/template/defarg21.C
 e55baeaf118c452b9f707b8236ee86b1  gcc/testsuite/g++.dg/template/defarg3.C
 64d2588370b2c020d9d5828deadfc7dc  gcc/testsuite/g++.dg/template/defarg4.C
 84d085b3ed907df1747cc523efd8d714  gcc/testsuite/g++.dg/template/defarg5.C
@@ -16259,6 +16272,7 @@
 fa72543a9a7163dc659966b7f85022ea  gcc/testsuite/g++.dg/template/friend61.C
 eee225d465c763fca3009704a441430f  gcc/testsuite/g++.dg/template/friend61a.C
 c83fbbe1bf313e9ff650368a049b6600  gcc/testsuite/g++.dg/template/friend61b.C
+0546ae6263680a8b8e42b5726f432e63  gcc/testsuite/g++.dg/template/friend62.C
 1d4f923241bfe8578940f39c34f80d7c  gcc/testsuite/g++.dg/template/friend7.C
 ceb858e95982ac0af2e9168f31aea229  gcc/testsuite/g++.dg/template/friend8.C
 59b5bf61b7f6210d3cf3b9b45692794a  gcc/testsuite/g++.dg/template/friend9.C
@@ -16543,6 +16557,8 @@
 af6d997be6d23572000a1f53fb362c54  gcc/testsuite/g++.dg/template/pr69091.C
 74c16422bfee14becfdab59426868fb7  gcc/testsuite/g++.dg/template/pr69961a.C
 2bb8ec1b3640d593c78682666bf1f95a  gcc/testsuite/g++.dg/template/pr69961b.C
+fd9d0d596049d0cdf35f01b62e86ae81  gcc/testsuite/g++.dg/template/pr70466-1.C
+a351a9dbecc556fb14937111d4035d00  gcc/testsuite/g++.dg/template/pr70466-2.C
 18029bea1be37e44787c856e7688884a  gcc/testsuite/g++.dg/template/pr70610-2.C
 a02fabd2632ab8c07600d017af625b9d  gcc/testsuite/g++.dg/template/pr70610-3.C
 f85232cc2d2ce2406ad9221174563c83  gcc/testsuite/g++.dg/template/pr70610-4.C
@@ -17052,6 +17068,7 @@
 2023e08d493ba5b9b6b027ead9dbcdfb  gcc/testsuite/g++.dg/tm/pr58635-2.C
 c9e5bbfe98ec7fbaa16a15a1f925bb18  gcc/testsuite/g++.dg/tm/pr60004.C
 106a3fd65d1feeb38d0f2a3224a6087b  gcc/testsuite/g++.dg/tm/pr67811.C
+f20200faa0befb0bfc51cc6eb591119c  gcc/testsuite/g++.dg/tm/pr71909.C
 3081869c37283a01aeadd31d8c3a912d  gcc/testsuite/g++.dg/tm/pretty-print1.C
 247e972c9babb265ea63db256a00ff3e  gcc/testsuite/g++.dg/tm/static_cast1.C
 ce59808ad2521265d21615e9fd232ebd  gcc/testsuite/g++.dg/tm/sync1.C
@@ -17386,6 +17403,11 @@
 3e80469d72e0d17bb9473080988a1256  gcc/testsuite/g++.dg/torture/pr70251.C
 a8995237f42d84212dd09e432dd3f071  gcc/testsuite/g++.dg/torture/pr70499.C
 742e71bf561b5af56ed84fc963a0fe07  gcc/testsuite/g++.dg/torture/pr70526.C
+256b51401f6858dc5a0cad2e0da871b1  gcc/testsuite/g++.dg/torture/pr71002.C
+561facc41670baebfb84a4231ec62bca  gcc/testsuite/g++.dg/torture/pr71405.C
+874216a8c65d270dcf488d29a8847247  gcc/testsuite/g++.dg/torture/pr71448.C
+411a467861248626a89023d9cd86be57  gcc/testsuite/g++.dg/torture/pr71452.C
+6d87997ae70f613b7ae47faba21523d9  gcc/testsuite/g++.dg/torture/pr71874.C
 389892c1f2e87d69449479d1b053c70c  gcc/testsuite/g++.dg/torture/predcom-1.C
 d28910105d9c9253d94d70eacd5e19d4  gcc/testsuite/g++.dg/torture/pushpop_macro.C
 a1b47b9c3e69d79d1895ebc4fd11032b  gcc/testsuite/g++.dg/torture/stackalign/check.h
@@ -17638,6 +17660,7 @@
 f4706f41ca654ceb8586f65654dc9bed  gcc/testsuite/g++.dg/ubsan/null-4.C
 e33cd115b2a5b1796134963715ca2601  gcc/testsuite/g++.dg/ubsan/null-5.C
 ebc4dd8d7b9c346d612ab748d0d8bda0  gcc/testsuite/g++.dg/ubsan/null-6.C
+9a6263b0a0fc24a8d910d2b11d215637  gcc/testsuite/g++.dg/ubsan/null-7.C
 cefd426836ca36a8554ac0ad41946a30  gcc/testsuite/g++.dg/ubsan/object-size-1.C
 a654df71119821a4303cc9fe0501191b  gcc/testsuite/g++.dg/ubsan/pr59250.C
 420a6623146bb014dc1310134356d81f  gcc/testsuite/g++.dg/ubsan/pr59306.C
@@ -17666,6 +17689,8 @@
 ce9a3608f9ea7f32723d27471f56a902  gcc/testsuite/g++.dg/ubsan/pr70135.C
 56810c4012d688f214e18664f2974426  gcc/testsuite/g++.dg/ubsan/pr70147-1.C
 af8fe8f8c142ba4099bf3fd97c7fb5f4  gcc/testsuite/g++.dg/ubsan/pr70147-2.C
+1248cf51218287e0763e9bafddb6e95e  gcc/testsuite/g++.dg/ubsan/pr70847.C
+3ad68deac55fd26921bbcc306e06b206  gcc/testsuite/g++.dg/ubsan/pr71393.C
 23b03c04f7b3df05a2e3c261dbfbc91d  gcc/testsuite/g++.dg/ubsan/return-1.C
 c729687b59770dc8f9e0991370cb1879  gcc/testsuite/g++.dg/ubsan/return-2.C
 40257a16173db28137a5538f88bfea0e  gcc/testsuite/g++.dg/ubsan/return-3.C
@@ -17740,6 +17765,7 @@
 98d320060b90cb4d7efb2ca7dd9ca6a7  gcc/testsuite/g++.dg/vect/simd-clone-4.cc
 4147d578711be9e486c8907900862fdd  gcc/testsuite/g++.dg/vect/simd-clone-4.h
 c3079a303a422fbdcc1f72b0e2a98a47  gcc/testsuite/g++.dg/vect/simd-clone-5.cc
+b8fb5b23ece050421d669915c600780b  gcc/testsuite/g++.dg/vect/simd-clone-6.cc
 3bc95c24ca829b61efcb7f80670d3ab5  gcc/testsuite/g++.dg/vect/simd-mask-store-bool.cc
 3c7b50dc56c581720a466e94943ccdae  gcc/testsuite/g++.dg/vect/slp-pr50413.cc
 ba398e1bec8514d144840b9f8de00b90  gcc/testsuite/g++.dg/vect/slp-pr50819.cc
@@ -17814,6 +17840,7 @@
 d3017d025f43f9093bf016847e418a34  gcc/testsuite/g++.dg/warn/Wmissing-declarations-1.C
 050c0fd9eb9dcd48940d99ba2041761b  gcc/testsuite/g++.dg/warn/Wmissing-field-initializers-1.C
 13048d07bf8630f21562df0b77b67343  gcc/testsuite/g++.dg/warn/Wno-div-by-zero.C
+7c3ea8d27e4d862f83fc6998269f6f42  gcc/testsuite/g++.dg/warn/Wno-narrowing1.C
 26f056d6de0144f7aed85c81b3e4f583  gcc/testsuite/g++.dg/warn/Wno-return-local-addr.C
 e3b6729ae62aef0d9d8acd63677ef06e  gcc/testsuite/g++.dg/warn/Wnonnull-compare-1.C
 79a3c427fc105036228222b1a6ea9772  gcc/testsuite/g++.dg/warn/Wnonnull-compare-2.C
@@ -17867,6 +17894,7 @@
 6ac2e35b5e4a2de47ad29a14a6dbe103  gcc/testsuite/g++.dg/warn/Wparentheses-9.C
 18e91a351f8fd1aae42cc8fbbe2dcbc5  gcc/testsuite/g++.dg/warn/Wplacement-new-size-1.C
 6b2c96f7011ece11947155ec8924a6f8  gcc/testsuite/g++.dg/warn/Wplacement-new-size-2.C
+d384bb1bb46e31c69b6a5c612b417019  gcc/testsuite/g++.dg/warn/Wplacement-new-size-3.C
 d61eea5f0486bf652aaee2370544ea0e  gcc/testsuite/g++.dg/warn/Wplacement-new-size.C
 10ae80ca102a17979ad4df9d03d42f13  gcc/testsuite/g++.dg/warn/Wpointer-arith-1.C
 bc5f141d5ba64d906981c425b810d3ed  gcc/testsuite/g++.dg/warn/Wredundant-decls-spec.C
@@ -23012,6 +23040,9 @@
 1906f2e6e6b20628e9f16d77bc066d28  gcc/testsuite/gcc.c-torture/compile/pr70263-1.c
 d47f5879509ae9dfb39ea1ee1063230e  gcc/testsuite/gcc.c-torture/compile/pr70355.c
 86500b6aaf9f75325f0cad332855ed1b  gcc/testsuite/gcc.c-torture/compile/pr70633.c
+6aa2a7d0fe94be24238130841efe702b  gcc/testsuite/gcc.c-torture/compile/pr70916.c
+97df20a3b66d4cb718ca2f94a7c64ec5  gcc/testsuite/gcc.c-torture/compile/pr71693.c
+6893a5c3e89b00abc6ffaaadabf19bbb  gcc/testsuite/gcc.c-torture/compile/pr71916.c
 9611ffa8936d9c80d0a9ccde8dd093b2  gcc/testsuite/gcc.c-torture/compile/pret-arg.c
 b9e6ce52b90320c1c3803c25113844c5  gcc/testsuite/gcc.c-torture/compile/pta-1.c
 ed716c1d1727fc2c748162e0cbc4ee47  gcc/testsuite/gcc.c-torture/compile/ptr-conv-1.c
@@ -24656,6 +24687,10 @@
 58bb262f9c1fe471c7bd11fc8440aac8  gcc/testsuite/gcc.c-torture/execute/pr70566.c
 7356d2dac86027ec545537d18ff109d1  gcc/testsuite/gcc.c-torture/execute/pr70586.c
 a1122f266904033a972f83a856de97b9  gcc/testsuite/gcc.c-torture/execute/pr70602.c
+0a9fc76972569359d91049d017cdf51e  gcc/testsuite/gcc.c-torture/execute/pr71494.c
+94c81d0c20f6b48a221fefb5a7c9f0f7  gcc/testsuite/gcc.c-torture/execute/pr71554.c
+1f4a197e0d6f4357f1917d680858eacb  gcc/testsuite/gcc.c-torture/execute/pr71626-1.c
+2b843741017aa652b5af0855cf7945c3  gcc/testsuite/gcc.c-torture/execute/pr71626-2.c
 3a2dbae8c6dae23b46868ca068ba47d6  gcc/testsuite/gcc.c-torture/execute/pr7284-1.c
 85441b3599a9d20a4ede0f10c54a4e6b  gcc/testsuite/gcc.c-torture/execute/printf-1.c
 54f80bf321bfe46d44040493d9821a03  gcc/testsuite/gcc.c-torture/execute/printf-chk-1.c
@@ -25250,6 +25285,7 @@
 ab3955f55aa596a98faf0528f22b1d0c  gcc/testsuite/gcc.dg/alias-9.c
 b87d726d798335bcf014c51ea61e9a4c  gcc/testsuite/gcc.dg/align-1.c
 ecaba7c928af85c280e63fa96b9b5e1b  gcc/testsuite/gcc.dg/align-2.c
+6583b4f8147fde31faab62b525508999  gcc/testsuite/gcc.dg/align-3.c
 b3869c9bd68bb9659f230f48bf56f83c  gcc/testsuite/gcc.dg/always_inline.c
 5ad6d0d750af2e3c8488e96cfa1aa195  gcc/testsuite/gcc.dg/always_inline2.c
 99fe8a4ba9676a42a20bb593c81371e0  gcc/testsuite/gcc.dg/always_inline3.c
@@ -26232,8 +26268,8 @@
 1e77dbdb1a2f17c79ae5421293c320fd  gcc/testsuite/gcc.dg/const-1.c
 6ccf395fc674b370645bdd0d50fb25b8  gcc/testsuite/gcc.dg/const-elim-1.c
 8aeed4136d64b28976407e1f80bce896  gcc/testsuite/gcc.dg/const-elim-2.c
-b73512af2bf6823cc97da864bfc84920  gcc/testsuite/gcc.dg/const-float128-ped.c
-737e99e3ec08db1f5521d0ecc2431cc8  gcc/testsuite/gcc.dg/const-float128.c
+40322523d50e8ca68ce1454542758211  gcc/testsuite/gcc.dg/const-float128-ped.c
+88bbf89357957ad93147bfe868e6a9e3  gcc/testsuite/gcc.dg/const-float128.c
 e3f3945c878b9cf4fa5b3f0074bd6302  gcc/testsuite/gcc.dg/const-float80-ped.c
 e781844c1655d36c9b6e04d59aad8996  gcc/testsuite/gcc.dg/const-float80.c
 d6841b339bfbaf4ab219c4c497889936  gcc/testsuite/gcc.dg/const-uniq-1.c
@@ -26921,6 +26957,7 @@
 94f8101679e6cc4b9fabcf3f776ded40  gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c
 01ec5869a59f91af2fdeee3396a4b76f  gcc/testsuite/gcc.dg/debug/dwarf2/pr53948.c
 eb3e8d32cc98a65b9bf903f485425719  gcc/testsuite/gcc.dg/debug/dwarf2/pr66482.c
+3aefd6c464c0631839d12e370ea3b504  gcc/testsuite/gcc.dg/debug/dwarf2/pr71855.c
 8c1766fffa68df425fe8305ed4ddb614  gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
 84c94e8435cec0cb1a4a8e83a9c3633d  gcc/testsuite/gcc.dg/debug/dwarf2/short-circuit.c
 fd5753c0c85e2e3c862b46c2f851ad80  gcc/testsuite/gcc.dg/debug/dwarf2/sso.c
@@ -27508,8 +27545,11 @@
 b0c5cb8db5ab29eb4607edcfaf632c3c  gcc/testsuite/gcc.dg/goacc-gomp/goacc-gomp.exp
 e301304e13590c1ce7f775ce00ef95b0  gcc/testsuite/gcc.dg/goacc/acc_on_device-1.c
 e16a173a45eff735a99e16e66cc01685  gcc/testsuite/gcc.dg/goacc/goacc.exp
+9e00e7a94f979942198724398d213cee  gcc/testsuite/gcc.dg/goacc/nested-function-1.c
+d28df196e898f3e95d6f476710c89624  gcc/testsuite/gcc.dg/goacc/nested-function-2.c
 acdc22584322b69f4483834bf48a45e9  gcc/testsuite/gcc.dg/goacc/nvptx-merged-loop.c
 73513698286ba33d0b064ff8b57e6775  gcc/testsuite/gcc.dg/goacc/nvptx-sese-1.c
+75dd052bd164a3a9070c1d0861bc0e3c  gcc/testsuite/gcc.dg/goacc/pr71373.c
 2f3333af08b8042445e79536694a34b4  gcc/testsuite/gcc.dg/gomp/appendix-a/a.1.1.c
 885f61f4895f1224def50fcf707b2f2e  gcc/testsuite/gcc.dg/gomp/appendix-a/a.10.1.c
 c8cf5f6a748356f3bcea8e2dbb2e4196  gcc/testsuite/gcc.dg/gomp/appendix-a/a.12.1.c
@@ -27907,8 +27947,11 @@
 f8f3d098512d881d68138c6f1e3a363f  gcc/testsuite/gcc.dg/graphite/pr68809.c
 bdbd7edf45b97574c83d3755df22a28b  gcc/testsuite/gcc.dg/graphite/pr68953.c
 d0f22c16c5fac5ae8f190b3564aba97d  gcc/testsuite/gcc.dg/graphite/pr68976.c
+cbc1d72a5a486c20f3b581d86ceb6480  gcc/testsuite/gcc.dg/graphite/pr69067.c
+47d652714c7a00602400f743b5e3c11c  gcc/testsuite/gcc.dg/graphite/pr69068.c
 4e7f8240209ca1b787c57a784dd3ab73  gcc/testsuite/gcc.dg/graphite/pr69292.c
 469d8e302d82650a54a8f0b48adb251a  gcc/testsuite/gcc.dg/graphite/pr70045.c
+187adff90265612446489b184d1ca625  gcc/testsuite/gcc.dg/graphite/pr70956.c
 16574d3df752f79e2361bed11b712e31  gcc/testsuite/gcc.dg/graphite/run-id-1.c
 69c11dc302a921c92977db519167bec1  gcc/testsuite/gcc.dg/graphite/run-id-2.c
 84a75a861553ce658d85018a3ced0a6b  gcc/testsuite/gcc.dg/graphite/run-id-3.c
@@ -27976,6 +28019,7 @@
 bc96d3d7a369ee1d75a9841b80312226  gcc/testsuite/gcc.dg/guality/param-2.c
 4f7560385c9b3bd900cc1de342ed58bc  gcc/testsuite/gcc.dg/guality/param-3.c
 523107373abe1115fc7567ad1914508b  gcc/testsuite/gcc.dg/guality/param-4.c
+f932e4faa7d538859c699e070447bc01  gcc/testsuite/gcc.dg/guality/param-5.c
 19bacc1e91869a8697eb548fb674e517  gcc/testsuite/gcc.dg/guality/pr36728-1.c
 15b728fbd163d9aa4e4d3a41ff5d237c  gcc/testsuite/gcc.dg/guality/pr36728-2.c
 3a0a4f52233f47c7abff4081856aa824  gcc/testsuite/gcc.dg/guality/pr36728-3.c
@@ -28288,6 +28332,7 @@
 3fa23bf649fb3d873b131ed5fb5ed9fe  gcc/testsuite/gcc.dg/ipa/pr68035.c
 6391743d2f9ed0c57ef00442b79ff9fa  gcc/testsuite/gcc.dg/ipa/pr68790.c
 47f323ada98e8576e87b3d61e280cf39  gcc/testsuite/gcc.dg/ipa/pr70306.c
+9e20144eec96000223a2e983ffcba9fa  gcc/testsuite/gcc.dg/ipa/pr70646.c
 923d1086789aa370483859e89c2a5e1e  gcc/testsuite/gcc.dg/ipa/propalign-1.c
 c42a02d7f371ea4de7e4bb2088296655  gcc/testsuite/gcc.dg/ipa/propalign-2.c
 b9df72c49860f187596351812c6e05be  gcc/testsuite/gcc.dg/ipa/propalign-3.c
@@ -30227,6 +30272,13 @@
 ac328b834a1ea6428569ff38945772b0  gcc/testsuite/gcc.dg/pr70442.c
 36a35251047803a79950fef784d13ae4  gcc/testsuite/gcc.dg/pr70725.c
 99ff30c22aa2b72409036bea8bda66da  gcc/testsuite/gcc.dg/pr70747.c
+0c7a5fc07d2ac3fe95b4a3f606e9fddc  gcc/testsuite/gcc.dg/pr71006.c
+b2932869d7ba5888238dbb86f20e94de  gcc/testsuite/gcc.dg/pr71071.c
+dc3c7225f47bd3f37227cbbb8d77804b  gcc/testsuite/gcc.dg/pr71279.c
+9e22a8b7163e8cdad2514a0bcaaf73e3  gcc/testsuite/gcc.dg/pr71518.c
+79f760cb1168bdcad7ceef62cd0034c3  gcc/testsuite/gcc.dg/pr71558.c
+2d57cd18f3b5a4ce14ac9f867103994d  gcc/testsuite/gcc.dg/pr71581.c
+0b5d052704c3f9b22ab6c09c3a2c44d1  gcc/testsuite/gcc.dg/pr71685.c
 8b7d73da2d5d78000716492365a85d5a  gcc/testsuite/gcc.dg/pr8715.c
 3d08410b2dd57259aa63f0e1c64b376e  gcc/testsuite/gcc.dg/pr8788-1.c
 be04382a35ebb1cfae1b2168f1693a94  gcc/testsuite/gcc.dg/pr8835-1.c
@@ -30411,6 +30463,7 @@
 cc4ae3ffffb03645629e69a469281efb  gcc/testsuite/gcc.dg/spellcheck-fields.c
 ad32dc4c817caee29dda724b10b45399  gcc/testsuite/gcc.dg/spellcheck-options-1.c
 2d679bf081885df2fd43ceb67d70169a  gcc/testsuite/gcc.dg/spellcheck-options-10.c
+44c49d832fbefb746e48d86f5808c52f  gcc/testsuite/gcc.dg/spellcheck-options-12.c
 59ceb721847c724a4d56bf8a0d6c13d6  gcc/testsuite/gcc.dg/spellcheck-options-2.c
 a2aa8beaba2a63cd762df20a0ff259f9  gcc/testsuite/gcc.dg/spellcheck-options-3.c
 533ff9109ecb7635d6ee9e965bed64d5  gcc/testsuite/gcc.dg/spellcheck-options-4.c
@@ -30797,10 +30850,10 @@
 4db0a33ee448d1a3cb855abe7fd5dd87  gcc/testsuite/gcc.dg/torture/cris-volatile-1.c
 8e9f5b7c091bd1c8d9aad12b2fe2c7e8  gcc/testsuite/gcc.dg/torture/darwin-cfstring-3.c
 537c85296c73ca5b8d5644f2db0f4333  gcc/testsuite/gcc.dg/torture/dg-torture.exp
-d0e69d6fa9e82fcd758b481dd8566f35  gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c
-5347ab8c7c39b162eae4e5405881495f  gcc/testsuite/gcc.dg/torture/float128-div-underflow.c
+58373efe3ee21c51efa41c133c58b857  gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c
+f866a0ec75af63274fded6d6e704572a  gcc/testsuite/gcc.dg/torture/float128-div-underflow.c
 4c582f75a6506b2d756ac4784481eef0  gcc/testsuite/gcc.dg/torture/float128-exact-underflow.c
-2fa501d06d2488d2bb44859676922e40  gcc/testsuite/gcc.dg/torture/float128-extend-nan.c
+7439f4476ac9bb24498a6a5c7da023c4  gcc/testsuite/gcc.dg/torture/float128-extend-nan.c
 9e1eb456af728c416f591eacdc4d7fb7  gcc/testsuite/gcc.dg/torture/float128-extendxf-underflow.c
 1d581b89a6131cdc2bd3dc2b34fc7fa9  gcc/testsuite/gcc.dg/torture/float128-mul-underflow.c
 a0352637f21fc07fa0443b4c4e043743  gcc/testsuite/gcc.dg/torture/float128-truncdf-underflow.c
@@ -30809,9 +30862,9 @@
 4a1efbe908d1984e5c7866446e422e72  gcc/testsuite/gcc.dg/torture/fp-int-convert-2.c
 c7193c3a55681849a60a8019763547be  gcc/testsuite/gcc.dg/torture/fp-int-convert-double.c
 740b8077c12192879798984879fe4c76  gcc/testsuite/gcc.dg/torture/fp-int-convert-float.c
-f13160e874231fbfd5ad487b1a65a359  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-2.c
-0e198766e1144ee6a29b4e083231ef2b  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c
-48cf228cef8e597a9a40466b1f579f1f  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c
+6faf10cae6549a32de0e939a1032515b  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-2.c
+4290c9342edd63f5948e29a0e4e61fbe  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c
+0fc40435832160baeff38f387f5ab974  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c
 bc0467f96f8340a44838f93689215df9  gcc/testsuite/gcc.dg/torture/fp-int-convert-float128.c
 80a27657c85bbe07fc57a74624f9f20a  gcc/testsuite/gcc.dg/torture/fp-int-convert-float80-timode.c
 55b7dc542b219e0ef16ee001197d2ce4  gcc/testsuite/gcc.dg/torture/fp-int-convert-float80.c
@@ -31472,6 +31525,12 @@
 da4037959e336e19cb95c25f91f8eb52  gcc/testsuite/gcc.dg/torture/pr70628.c
 4bf720800970b360938f42a250aa3e59  gcc/testsuite/gcc.dg/torture/pr70724.c
 058fe139380690d2ec38aa882c1f7908  gcc/testsuite/gcc.dg/torture/pr70780.c
+e8b6639bf1f3ed2ec4f89afdb36f44f9  gcc/testsuite/gcc.dg/torture/pr70935.c
+b6bb0c63d9e968f4f16f282365518a50  gcc/testsuite/gcc.dg/torture/pr70941.c
+08b15e14c6c9f4cc6291f19fc8ba963b  gcc/testsuite/gcc.dg/torture/pr71423.c
+0c398d952cf20fc83aec050f85d8a44b  gcc/testsuite/gcc.dg/torture/pr71452.c
+d7822d9246b54abacbdc7d6230ab041d  gcc/testsuite/gcc.dg/torture/pr71522.c
+b0020481b01ba2fea155b7e666817dc3  gcc/testsuite/gcc.dg/torture/pr71606.c
 62b28db4200d0c4e51bde8d1e5693886  gcc/testsuite/gcc.dg/torture/pr8081.c
 d086c3946230ba05df33a45be4862730  gcc/testsuite/gcc.dg/torture/pta-callused-1.c
 39620328710fd9ff170741766805e426  gcc/testsuite/gcc.dg/torture/pta-escape-1.c
@@ -32331,6 +32390,7 @@
 885c1be5e32bb9fbd61002b21649165d  gcc/testsuite/gcc.dg/tree-ssa/pr69845-2.c
 6e6845a9fd535b1e4161176393d5993c  gcc/testsuite/gcc.dg/tree-ssa/pr70232.c
 f1ac7f1c1aea72571d0586fcaa61bef4  gcc/testsuite/gcc.dg/tree-ssa/pr70372.c
+f25359056dca264e17755adacd92210b  gcc/testsuite/gcc.dg/tree-ssa/pr70919.c
 183e9199984b76de9f1701381d4f612d  gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c
 e1366016e9a4c05dbd1cdb3f152b83dc  gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c
 49817baec76470758acdd34458c9fb91  gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
@@ -32759,6 +32819,8 @@
 b18ed34db76e8a818f24ae5532580fdb  gcc/testsuite/gcc.dg/tree-ssa/vrp08.c
 00af09eb12b671fc3835354fe975d76f  gcc/testsuite/gcc.dg/tree-ssa/vrp09.c
 8c9b46ae3e96ee0bd4ea529a368c310d  gcc/testsuite/gcc.dg/tree-ssa/vrp10.c
+35a86d5c3d5d6dfdbf910fd80c544328  gcc/testsuite/gcc.dg/tree-ssa/vrp100.c
+43b49a2dc407364da07b46e140893140  gcc/testsuite/gcc.dg/tree-ssa/vrp101.c
 02186bb95ddef36513b909863c8d3ed8  gcc/testsuite/gcc.dg/tree-ssa/vrp11.c
 419ced6aac18d78614ce2296a1a6b660  gcc/testsuite/gcc.dg/tree-ssa/vrp12.c
 5c02e78e0a19d3b4ab362211af9c057d  gcc/testsuite/gcc.dg/tree-ssa/vrp13.c
@@ -32874,6 +32936,7 @@
 38f4467be27d0432adea9abcaf9cc366  gcc/testsuite/gcc.dg/typespec-1.c
 b9d67dbc50419a82b76d70029936f329  gcc/testsuite/gcc.dg/ubsan/bounds-1.c
 8ef707e5f4c734c1b8be85269cd93d06  gcc/testsuite/gcc.dg/ubsan/bounds-2.c
+804ebe3c0a2fc929bc12b7e5c7c4098f  gcc/testsuite/gcc.dg/ubsan/bounds-3.c
 7740693c7bb19d8fc6ab727a6ffbb65c  gcc/testsuite/gcc.dg/ubsan/c-shift-1.c
 577cc36a854722ee2c73da1a6a6e2322  gcc/testsuite/gcc.dg/ubsan/c-shift-2.c
 2dbfddf9f012a91eb07b3c83841941a1  gcc/testsuite/gcc.dg/ubsan/c99-shift-1.c
@@ -33468,7 +33531,7 @@
 909245027a67eed899841d65ca788c26  gcc/testsuite/gcc.dg/vect/pr66142.c
 94ba2ffa702e68550138d2586c87e9d7  gcc/testsuite/gcc.dg/vect/pr66251.c
 fe55b7b3a0180146eb06495eed9f01a0  gcc/testsuite/gcc.dg/vect/pr66253.c
-013ee9e98fd328680fc3f320b6adc0f3  gcc/testsuite/gcc.dg/vect/pr66636.c
+31de59c90b606bb80ee8c60486379cc0  gcc/testsuite/gcc.dg/vect/pr66636.c
 86169de4aac395fc7dd49fd713661f87  gcc/testsuite/gcc.dg/vect/pr66677.c
 f4505aa6c41d3aa5d36144edc00b927e  gcc/testsuite/gcc.dg/vect/pr66951.c
 b0c728b20c3631680ab365d1bc5a0fd8  gcc/testsuite/gcc.dg/vect/pr67790.c
@@ -33489,6 +33552,9 @@
 78b19e684925d21a4076e909bc9096cf  gcc/testsuite/gcc.dg/vect/pr70138-2.c
 0918022cdf657101e47743d5c80133f3  gcc/testsuite/gcc.dg/vect/pr70354-1.c
 72d0484eead5cc2ea42d3951a7cd63f2  gcc/testsuite/gcc.dg/vect/pr70354-2.c
+05e2c1c28c7f8e8f0887ba6298c0b0cb  gcc/testsuite/gcc.dg/vect/pr71259.c
+c03f1f02e7f7d30e17a072dbbe18a16b  gcc/testsuite/gcc.dg/vect/pr71264.c
+bfbd314e67532ca23e292ce54b72762f  gcc/testsuite/gcc.dg/vect/pr71823.c
 32d06c886c85516fbdce4ca1bd516496  gcc/testsuite/gcc.dg/vect/section-anchors-pr27770.c
 00b8b4e778221f5bedb59cfc69f6c9d7  gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
 218f2e2bcfb33c838c80a2ae8c302759  gcc/testsuite/gcc.dg/vect/slp-1.c
@@ -33581,7 +33647,7 @@
 b1336a4a12ea0ec587c41f16332879bc  gcc/testsuite/gcc.dg/vect/slp-widen-mult-s16.c
 31669e2cb35c18913f0b7f913f2a0f63  gcc/testsuite/gcc.dg/vect/slp-widen-mult-u8.c
 613196aaada7504743f2f4d92488772b  gcc/testsuite/gcc.dg/vect/trapv-vect-reduc-4.c
-5f4c323565e9614879f28bd4f7091c96  gcc/testsuite/gcc.dg/vect/tree-vect.h
+402f466a32d7175024ee9b8ec5e02d1b  gcc/testsuite/gcc.dg/vect/tree-vect.h
 908fa625b55d7d283163e9dfb4e3cb97  gcc/testsuite/gcc.dg/vect/unswitch-loops-pr26969.c
 6520c3dd9e657028a89c31328634d22a  gcc/testsuite/gcc.dg/vect/vec-scal-opt.c
 9b5d0a9d2e1a81f9454f0082b9f240b7  gcc/testsuite/gcc.dg/vect/vec-scal-opt1.c
@@ -34977,7 +35043,7 @@
 a8bddbe3eece3831dd80ac4cdf09f85e  gcc/testsuite/gcc.target/aarch64/nofp_1.c
 16f10ec9128105b137b7139eec150171  gcc/testsuite/gcc.target/aarch64/noplt_1.c
 a08d94353bf55af1d22441a406d830ca  gcc/testsuite/gcc.target/aarch64/noplt_2.c
-766dade6022566e9d591b71777427f70  gcc/testsuite/gcc.target/aarch64/noplt_3.c
+5adbb32c5ec104efca72061e09229b8f  gcc/testsuite/gcc.target/aarch64/noplt_3.c
 03797fef944cc43885e1c80c25f368e4  gcc/testsuite/gcc.target/aarch64/pic-constantpool1.c
 8084b7f8a23ba9dc5bb389d20d29ec1b  gcc/testsuite/gcc.target/aarch64/pic-small.c
 dca6942a94e55d4ebfd32c380eb279ff  gcc/testsuite/gcc.target/aarch64/pic-symrefplus.c
@@ -35013,6 +35079,7 @@
 0eb5fd232a04413cc6f2bd5fd4c3c47d  gcc/testsuite/gcc.target/aarch64/pr70120-2.c
 61ea50a51a3ed94b38acd7cd026cd077  gcc/testsuite/gcc.target/aarch64/pr70120-3.c
 eb748e6de8945b3aa35ce6b22a073829  gcc/testsuite/gcc.target/aarch64/pr70398.c
+e7efe396ef16dbc7526785247ead6d84  gcc/testsuite/gcc.target/aarch64/pr70809_1.c
 d3e6defa85b5cd4bb506306377e59a53  gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
 1f95766b4ed5bfb5f2cf1f168a607a8d  gcc/testsuite/gcc.target/aarch64/predefine_large.c
 d38e476730748c653068e7cb2d8d6ca6  gcc/testsuite/gcc.target/aarch64/predefine_small.c
@@ -35125,6 +35192,7 @@
 a675084fb22386c9d27ff4bd900947af  gcc/testsuite/gcc.target/aarch64/simd/vgetq_lane_u32_indices_1.c
 83cf956b7cb17956c744f7db38fe3416  gcc/testsuite/gcc.target/aarch64/simd/vgetq_lane_u64_indices_1.c
 099bad0585432f164e86079dbf03595e  gcc/testsuite/gcc.target/aarch64/simd/vgetq_lane_u8_indices_1.c
+163cc0d113c2aef5ebd776e9553efbf1  gcc/testsuite/gcc.target/aarch64/simd/vminmaxnm_1.c
 d3471e819805085e851c6ef99b412fc9  gcc/testsuite/gcc.target/aarch64/simd/vmla_f64.c
 76bd294b136cfc9375488944eb7f3ba0  gcc/testsuite/gcc.target/aarch64/simd/vmls_f64.c
 f4f3b7ca3433b577e0c8b5a94bd6c11a  gcc/testsuite/gcc.target/aarch64/simd/vmul_f64_1.c
@@ -35466,7 +35534,7 @@
 f87f898044cd78f2ebf530577d3cf7bb  gcc/testsuite/gcc.target/aarch64/sync-op-release.c
 95f377cbd6e6173deb76efafbc90634f  gcc/testsuite/gcc.target/aarch64/sync-op-release.x
 0168137c2b608147cb69283541a282f1  gcc/testsuite/gcc.target/aarch64/table-intrinsics.c
-d5d082ded76a499c259ef0099673369a  gcc/testsuite/gcc.target/aarch64/tail_indirect_call_1.c
+e259ba8323c6ae474eebb9f1a89e0a1d  gcc/testsuite/gcc.target/aarch64/tail_indirect_call_1.c
 84204d959d96933bbdeb4d6f2a41264c  gcc/testsuite/gcc.target/aarch64/target_attr_1.c
 fa7117ece82474e6ad64b002ff16f391  gcc/testsuite/gcc.target/aarch64/target_attr_10.c
 495425b7459f1a259607e93ad71f13c5  gcc/testsuite/gcc.target/aarch64/target_attr_11.c
@@ -35940,8 +36008,8 @@
 4b9f02224346043bca551bf81124f90b  gcc/testsuite/gcc.target/arm/headmerge-2.c
 b7fc1639bee153568add250d53ea751f  gcc/testsuite/gcc.target/arm/identical-invariants.c
 6b37d9e567d7851e4e037dc6ffb87d9c  gcc/testsuite/gcc.target/arm/ifcvt-size-check.c
-5a6755f195973a69d09c58dc46caa013  gcc/testsuite/gcc.target/arm/interrupt-1.c
-fc9965e47a9641a2b14bf7461100be94  gcc/testsuite/gcc.target/arm/interrupt-2.c
+b8c039847c1a73baf76ec3ceb27b1a11  gcc/testsuite/gcc.target/arm/interrupt-1.c
+80759aaae06958909d3fcc2edf843783  gcc/testsuite/gcc.target/arm/interrupt-2.c
 5fb126c6d9486e40aebcb4051dcefd2a  gcc/testsuite/gcc.target/arm/iordi3-opt.c
 942d9efedfb779e0de45df976f1585de  gcc/testsuite/gcc.target/arm/iordi_notdi-1.c
 88f7d27029fb631e0a53d287d5f7f83c  gcc/testsuite/gcc.target/arm/its.c
@@ -38203,6 +38271,8 @@
 32fee62df6d98765a5508d0d96c9eb65  gcc/testsuite/gcc.target/arm/pr69904.c
 1099addf5e35417ab2cda454cb2ec7f0  gcc/testsuite/gcc.target/arm/pr70278.c
 7b0dff48f8c89cbeb037deb0439e2888  gcc/testsuite/gcc.target/arm/pr70496.c
+48ed10e4b1714bfea3579dda3447be58  gcc/testsuite/gcc.target/arm/pr70830.c
+dc5c76ff01c564582222b3a2ea1fc21c  gcc/testsuite/gcc.target/arm/pr71056.c
 321232597c3b16471c510b972ad557b4  gcc/testsuite/gcc.target/arm/pragma_attribute.c
 cdf14fd079c2cd544c152c39ceb8ac66  gcc/testsuite/gcc.target/arm/pragma_cpp_fma.c
 639f9aee9e13df807ade02e6ee96c2d3  gcc/testsuite/gcc.target/arm/reg_equal_test.c
@@ -38490,11 +38560,13 @@
 2028ceccf9f97e5e84e9adf6beb7597e  gcc/testsuite/gcc.target/avr/exit-abort.h
 2931177f4aeff49d531d5474224448f6  gcc/testsuite/gcc.target/avr/pr46779-1.c
 572dc228e08385a1db0fcbab66dbaa4e  gcc/testsuite/gcc.target/avr/pr46779-2.c
+d92831f37e30237d1dc568f585e4c2c9  gcc/testsuite/gcc.target/avr/pr50739.c
 fc917fcfe7cfe97b5f27265d5960f0e6  gcc/testsuite/gcc.target/avr/pr52472.c
 421d2b9b36fa2496dce05d129d2c352b  gcc/testsuite/gcc.target/avr/pr58545.c
 9e82df166e8b559cb56d2c4f48cbaf30  gcc/testsuite/gcc.target/avr/pr60991.c
 94f026369213dad7565383028ef6afcf  gcc/testsuite/gcc.target/avr/pr65210.c
 efe0a9fdac4e9b6140f4228816b9db64  gcc/testsuite/gcc.target/avr/pr67839.c
+292bf2dc33b5cfededd107fe1c0ebc88  gcc/testsuite/gcc.target/avr/pr71103.c
 881cb1836ddfc3105e0aacacc481aa09  gcc/testsuite/gcc.target/avr/progmem-error-1.c
 2eb3f167ae58b534e25afc1b94617746  gcc/testsuite/gcc.target/avr/progmem-error-1.cpp
 56de611fd29076ce9da389a853476819  gcc/testsuite/gcc.target/avr/progmem-warning-1.c
@@ -38532,6 +38604,7 @@
 7f56c1b750dfe8d7e4128f15aa3eaffe  gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c
 44584f49cd0975073be7b86102774077  gcc/testsuite/gcc.target/avr/torture/pr64331.c
 dcabffeb42e88a442661b9e47e43a9c1  gcc/testsuite/gcc.target/avr/torture/pr64452.c
+ab53af0eb6dbfe2791a8ac1bbaf0c11f  gcc/testsuite/gcc.target/avr/torture/pr71103-2.c
 21a45d34960ba9567b9f2483d22c843f  gcc/testsuite/gcc.target/avr/torture/progmem-1.c
 564c71a894aff68e98d5c4a6db2b47ae  gcc/testsuite/gcc.target/avr/torture/progmem-1.cpp
 e3e1c41865f5287c9ff7e200745758fd  gcc/testsuite/gcc.target/avr/torture/sat-hr-plus-minus.c
@@ -39055,6 +39128,7 @@
 b6e744a5c521873cc8be2dbb5f25790d  gcc/testsuite/gcc.target/i386/avx-pr57233.c
 ab15d222e706bd85c87c037d1e9b6f51  gcc/testsuite/gcc.target/i386/avx-pr63594-1.c
 7e490de1d2a70d21844cdc70c1546f49  gcc/testsuite/gcc.target/i386/avx-pr63594-2.c
+52efc199588007563ddb240d620c0f01  gcc/testsuite/gcc.target/i386/avx-pr71559.c
 4e3d37bb04b99394790fa9e8caddf790  gcc/testsuite/gcc.target/i386/avx-recip-vec.c
 02ae18a66bd7b76f7a651b896f066b70  gcc/testsuite/gcc.target/i386/avx-reduc-1.c
 772f703b19bb27d5947d136a2f72221e  gcc/testsuite/gcc.target/i386/avx-rint-sfix-2-vec.c
@@ -40324,10 +40398,22 @@
 c88d598d6edb7c0c743c1dc16a2cc16d  gcc/testsuite/gcc.target/i386/avx512f-broadcast-gpr-2.c
 499c39d2a4857a6b8d1b83ff9a57f0ff  gcc/testsuite/gcc.target/i386/avx512f-ceil-sfix-vec-1.c
 043ca358343e3cd8084b52ddd77fc44b  gcc/testsuite/gcc.target/i386/avx512f-ceil-sfix-vec-2.c
+0d4151fb05d050a11cf92664e9209d3a  gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-1.c
+e37893c9abd7382a7def7fd7274dcd64  gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-2.c
+576df336a9d07a5da958ad681902765b  gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-1.c
+8a2399e65f2d83ffe127b069db603b09  gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-2.c
+5b2ffd909879a410f6b4a26c1a8e5676  gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-1.c
+a4b256bf9501d70dd2182eab7f624689  gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-2.c
 b40bff9ed49ef04a7cc3b22ed64e6ebb  gcc/testsuite/gcc.target/i386/avx512f-check.h
 9db780c1e1f36c905bedd1fd077c44bc  gcc/testsuite/gcc.target/i386/avx512f-dummy.c
 0de473631153a37da362d01bb42a56bd  gcc/testsuite/gcc.target/i386/avx512f-floor-sfix-vec-1.c
 f449e800780313dbf245bac9b4df7ed5  gcc/testsuite/gcc.target/i386/avx512f-floor-sfix-vec-2.c
+147745798007b9631a908f9e78411336  gcc/testsuite/gcc.target/i386/avx512f-floor-vec-1.c
+ae10c62470cea283261617eaed4fb4bd  gcc/testsuite/gcc.target/i386/avx512f-floor-vec-2.c
+f3f3241adb2a57e08f624dd5dee7bde2  gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-1.c
+36f5b8ecaa1309fea47c6565009b0e43  gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-2.c
+2ab0eec1590b189f1c4f7fe79a454db5  gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-1.c
+0e2a8a11b7939edbb836489d6d1ae8cb  gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-2.c
 093d097bdccce35c0df38597a7980d22  gcc/testsuite/gcc.target/i386/avx512f-gather-1.c
 c8ce7ffcdf3dead2fa41448cdfd421d8  gcc/testsuite/gcc.target/i386/avx512f-gather-2.c
 fba9972cad8dda541a5aa6eec12675fc  gcc/testsuite/gcc.target/i386/avx512f-gather-3.c
@@ -40386,6 +40472,15 @@
 381f53de01f1e9893e6903d9fac40b87  gcc/testsuite/gcc.target/i386/avx512f-pr63594-2.c
 e97c0c19cafc88b7e3701f64c4ee5e2f  gcc/testsuite/gcc.target/i386/avx512f-pr70059.c
 d3690c9abdc1f96ff5183a85ab642fc8  gcc/testsuite/gcc.target/i386/avx512f-pr70421.c
+2bec208bfec85d6675be24e134318011  gcc/testsuite/gcc.target/i386/avx512f-pr71559.c
+ada32523be27898684e961dc8a530319  gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-1.c
+cf72f487882aa5cbbf2a730ccced5372  gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-2.c
+afd1c2340191f1da5c9f296da3642106  gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-1.c
+3e831baba699ee173a9b5a01e94803d7  gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-2.c
+e6b938f5b671843917a112a53a8a7860  gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-1.c
+8ec0c6ee2d9b777f1da5706d825590f4  gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-2.c
+7b55ada214bda7b0ec5755ad95771081  gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-1.c
+8b538e860606539734b2c832df5c63eb  gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-2.c
 5158ac78802e368957a44c0f68b3b5d8  gcc/testsuite/gcc.target/i386/avx512f-rounding.c
 8eb7f0638fb7f71388916d2f90f89f93  gcc/testsuite/gcc.target/i386/avx512f-scatter-1.c
 a705c702fd9fc8889d25e23e48746f5b  gcc/testsuite/gcc.target/i386/avx512f-scatter-2.c
@@ -40413,6 +40508,10 @@
 5e82ba7d6ba2bc9eb1ce979813f8d396  gcc/testsuite/gcc.target/i386/avx512f-setzero-pd-1.c
 47fee7cb6c90c9ac41c16bb5604a8121  gcc/testsuite/gcc.target/i386/avx512f-setzero-ps-1.c
 45e69165f83009060e6547672824081d  gcc/testsuite/gcc.target/i386/avx512f-setzero-si512-1.c
+9f1be97318b9c5fe371f3dc949de070d  gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-1.c
+b74179ff996ee056241e1c5238385936  gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-2.c
+22ac9712c0faaf3a282e62daa525a8a2  gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-1.c
+75f99d519bd7e5ff40d6b2db26925c32  gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-2.c
 06c531d6ffd8e2dc9c35db5a25f946d2  gcc/testsuite/gcc.target/i386/avx512f-typecast-1.c
 4ebc7b200a5160aa639c1a2a5b13a59f  gcc/testsuite/gcc.target/i386/avx512f-vaddpd-1.c
 9c96dcbb2e757b7198aeba742c29a128  gcc/testsuite/gcc.target/i386/avx512f-vaddpd-2.c
@@ -41870,6 +41969,7 @@
 9fa05574c82a870139a2524c4a9ea84c  gcc/testsuite/gcc.target/i386/extract-6.c
 b9e834d41c948e584d3f1cd39c3a5959  gcc/testsuite/gcc.target/i386/extract-insert-combining.c
 4ea9a85bc3f40b1ebeb0581bd96620de  gcc/testsuite/gcc.target/i386/f16c-check.h
+019f466ae9c955f33a105efa418493cf  gcc/testsuite/gcc.target/i386/fabsneg-1.c
 c8661d46af4e71184c4904ae6ab3be9b  gcc/testsuite/gcc.target/i386/fastcall-1.c
 dbf3cc9b53b5e2d78a16330cbb9137e5  gcc/testsuite/gcc.target/i386/fastcall-sseregparm.c
 ba226e9b8c6e56794bbc8f0d614ee8c6  gcc/testsuite/gcc.target/i386/fentry-override.c
@@ -42002,7 +42102,7 @@
 7aef940035776cbf7ecabc540f63e33e  gcc/testsuite/gcc.target/i386/hle-xor-rel-1.c
 27f333984dddefbecb9e2c639d7c3066  gcc/testsuite/gcc.target/i386/i386.exp
 7272fad8a3b85477e1b6954e2c36656d  gcc/testsuite/gcc.target/i386/iamcu/abi-iamcu.exp
-a75b4ffb604aa8a4ae22652bfd0455d0  gcc/testsuite/gcc.target/i386/iamcu/args.h
+824179ec90e1e4fdb872aed133f8d523  gcc/testsuite/gcc.target/i386/iamcu/args.h
 75e691882a781a986cbf2b848eacc017  gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
 a77c8e89ec538edb98eb4ac96da0db61  gcc/testsuite/gcc.target/i386/iamcu/defines.h
 ced3e7fc25757fe027f4eacc904e6881  gcc/testsuite/gcc.target/i386/iamcu/macros.h
@@ -43246,6 +43346,7 @@
 939cb1764c085054007c93662975586c  gcc/testsuite/gcc.target/i386/pr68497.c
 e783cba59986d894ea86576ba3dba9de  gcc/testsuite/gcc.target/i386/pr68633.c
 86970bbb2e352887837e71a47d7d1b1b  gcc/testsuite/gcc.target/i386/pr68647.c
+ef3f1636440165ca1e8cb1ff5a7fd262  gcc/testsuite/gcc.target/i386/pr68657.c
 ed977b2e07a2b51f6a0171f6ad454c88  gcc/testsuite/gcc.target/i386/pr68674.c
 37cbc35061a580832dbc0ce4a1604d83  gcc/testsuite/gcc.target/i386/pr68680.c
 82889ba70f826af56789c8d9456aea07  gcc/testsuite/gcc.target/i386/pr68691.c
@@ -43319,6 +43420,14 @@
 4fbcd5b3350355ed9b86fc2f9efebbcf  gcc/testsuite/gcc.target/i386/pr70593.c
 c4dd0a4466890153a50da4018a6840e3  gcc/testsuite/gcc.target/i386/pr70596.c
 63614f4a8e03a5baed97479f04e87900  gcc/testsuite/gcc.target/i386/pr70662.c
+b98041baad19fb37bd266fc10bd5bc38  gcc/testsuite/gcc.target/i386/pr70728.c
+0adbcabe255b36ad14e5fced66fe8a7c  gcc/testsuite/gcc.target/i386/pr70750-1.c
+683fe4353ec025a523da5da93c42a89a  gcc/testsuite/gcc.target/i386/pr70750-2.c
+1003b2af30448864252327bd08ddb57b  gcc/testsuite/gcc.target/i386/pr70858.c
+c4f6a31f14b030cd9290db1df9495760  gcc/testsuite/gcc.target/i386/pr70876.c
+960f365b62f7bf57c12061d19e6822e3  gcc/testsuite/gcc.target/i386/pr70877.c
+61d0b6b6f6714737a9330dc7fae9ed11  gcc/testsuite/gcc.target/i386/pr71529.C
+a9c6395b5501af8f7e41af6ddea5ede0  gcc/testsuite/gcc.target/i386/pr71647.c
 849234c7a569c1e86023244bc5561263  gcc/testsuite/gcc.target/i386/pr9771-1.c
 24ceb6d5f3f5cde4b9d852839bdb98ae  gcc/testsuite/gcc.target/i386/prefetchw-1.c
 f11f4731c396f099373c033ab016a64f  gcc/testsuite/gcc.target/i386/prefetchwt1-1.c
@@ -43594,6 +43703,7 @@
 bdbcd892d3f88fe1d7a07a2122cb928d  gcc/testsuite/gcc.target/i386/sse2-pr57233.c
 ab93046758268c8e3106f1bed7d4e8a5  gcc/testsuite/gcc.target/i386/sse2-pr63594-1.c
 ae0d76797c5135e83ce818bce0003cfa  gcc/testsuite/gcc.target/i386/sse2-pr63594-2.c
+f83e050eb6a6a72950d4ead5f0340a6a  gcc/testsuite/gcc.target/i386/sse2-pr71559.c
 306e316bf36fd1022168fa5560198f41  gcc/testsuite/gcc.target/i386/sse2-psadbw-1.c
 31949c673c69db630bfaf04449d2677f  gcc/testsuite/gcc.target/i386/sse2-pshufd-1.c
 2890c692e114956ac819984c965d389e  gcc/testsuite/gcc.target/i386/sse2-pshufhw-1.c
@@ -44861,6 +44971,7 @@
 59520e2fbc082b0ec9e051f4e7c804f9  gcc/testsuite/gcc.target/powerpc/440-nmaclhw-1.c
 1740cc665d8423adf426eedd3a8276eb  gcc/testsuite/gcc.target/powerpc/440-nmaclhw-2.c
 5931e32eea29c20bbd53794357f5ebad  gcc/testsuite/gcc.target/powerpc/980827-1.c
+3836ca1b6787ffdabd915481b096bf59  gcc/testsuite/gcc.target/powerpc/abs128-1.c
 c441836462a082b52b8df4f3644b8ee1  gcc/testsuite/gcc.target/powerpc/altivec-1.c
 7594d13b6afbb5788fd3ff108fa1798d  gcc/testsuite/gcc.target/powerpc/altivec-10.c
 87921f986b2e966c18eb11c96891c323  gcc/testsuite/gcc.target/powerpc/altivec-11.c
@@ -44962,12 +45073,18 @@
 76368ec7aa2b631ffe91a52dbe0c7e7a  gcc/testsuite/gcc.target/powerpc/compress-float-ppc-pic.c
 caf3aba39c0565b4369f2e0263b16af5  gcc/testsuite/gcc.target/powerpc/compress-float-ppc.c
 6419d1aaea22c0476688f484ac4f0f43  gcc/testsuite/gcc.target/powerpc/const-compare.c
+1f7277471f008809ee3572d95097e11a  gcc/testsuite/gcc.target/powerpc/copysign128-1.c
 4b60a8662648a73cedee85dd08e278eb  gcc/testsuite/gcc.target/powerpc/cprophard.c
 4c8d1f97ae959775777a07679512e4b5  gcc/testsuite/gcc.target/powerpc/cpu-builtin-1.c
 1fb2215d04b688ce2fdb0faccd58b012  gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
 14fe4a3bc84df2b97d9440c94d7c8339  gcc/testsuite/gcc.target/powerpc/crypto-builtin-2.c
 4e3992362b37b544083ac6eaeaa1acca  gcc/testsuite/gcc.target/powerpc/ctz-1.c
 9266181f224f779baa6b98a2f3b171e8  gcc/testsuite/gcc.target/powerpc/ctz-2.c
+dcd67b030ac5a36c48772f45c9311a7a  gcc/testsuite/gcc.target/powerpc/ctz-3.c
+531f016ec3779129874335e4d662190c  gcc/testsuite/gcc.target/powerpc/ctz-4.c
+dff00811bdc4a0d32afb132f16084b8c  gcc/testsuite/gcc.target/powerpc/darn-0.c
+a3b7e0d3cc77ae3e0b0aea94e91b58e5  gcc/testsuite/gcc.target/powerpc/darn-1.c
+3a484a34727d320db4da25fdd45adeeb  gcc/testsuite/gcc.target/powerpc/darn-2.c
 965986b227062a2b8c664c916a71ad45  gcc/testsuite/gcc.target/powerpc/darwin-abi-1.c
 9a0e4836781f28669ddca26eb214c2b2  gcc/testsuite/gcc.target/powerpc/darwin-abi-10.c
 66e5cfd1b7491e37c0ef258d09b6634d  gcc/testsuite/gcc.target/powerpc/darwin-abi-11.c
@@ -44990,8 +45107,9 @@
 a034d7a8bf265623a75800f01113e836  gcc/testsuite/gcc.target/powerpc/darwin-split-ld-stret.c
 548fc585bcbf766f23bef7319f0b0a18  gcc/testsuite/gcc.target/powerpc/darwin64-abi.c
 48cfcb8d91718cca2ec942edea2af044  gcc/testsuite/gcc.target/powerpc/dfmode_off.c
-37c328fb120fbf675f6e47f6e2626f1f  gcc/testsuite/gcc.target/powerpc/dform-1.c
-062afe6d6e8128fc20cdfb56900ba68d  gcc/testsuite/gcc.target/powerpc/dform-2.c
+f6511eaddea2d2d6dbb6428c8e9f5822  gcc/testsuite/gcc.target/powerpc/dform-1.c
+bf3533458cbe01184881116cdb4e822c  gcc/testsuite/gcc.target/powerpc/dform-2.c
+571072f2c83195496efb8b6a3d7921a1  gcc/testsuite/gcc.target/powerpc/dform-3.c
 f2e8694ab86e1d671840cc1b4d010431  gcc/testsuite/gcc.target/powerpc/dfp-builtin-1.c
 70b901aef4fec169c6e0277e173417fe  gcc/testsuite/gcc.target/powerpc/dfp-builtin-2.c
 edc590c61b2a5fd6c1f8da5e10b52099  gcc/testsuite/gcc.target/powerpc/dfp-dd-2.c
@@ -44999,6 +45117,87 @@
 918f43d2707c381ec6a3c8f95d06ba7a  gcc/testsuite/gcc.target/powerpc/dfp-td-2.c
 d29a538f7ef7ada44a91b35380ca809c  gcc/testsuite/gcc.target/powerpc/dfp-td-3.c
 f99e26532b9bfe0b24631290281df325  gcc/testsuite/gcc.target/powerpc/dfp-td.c
+cc553c1019d680b116be75246855e5d0  gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp
+03cc7e47a4479ec2055b9af5a2055522  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-0.c
+6959ef5cd0438cde997e2af826ef2d8d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-1.c
+8f82047dd5d13bd7808101a6cae2f96a  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-10.c
+758f013931d8cc97a719f89662e5f559  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-11.c
+3b8212a7bdbfd7228a56f2142a77082d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-12.c
+65380dd3577ee9e0a9b22cad78b2565c  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-13.c
+80d4ddd21f937e7f5cc6b1f54d5d3777  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-14.c
+f2469b3c94f1f566011419ed3f6c54c3  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-15.c
+9a597227f69d2f2ce0f06ce5d68e7e46  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-16.c
+98c6e4c9b297b48f787a19ea13166fee  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-17.c
+6278ed0a2ff858f774d06e4fa6833c07  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-18.c
+b50bd5c52b5f27cf4b0eee6c78eef867  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-19.c
+68c7553b8028a8c430aa1c40c8f624da  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-2.c
+70da3a0ca0e2c3a4e51d3fbbbcd51313  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-20.c
+fa0668a907811b58e0a0c4f409996798  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-21.c
+abe6816951e1b9e949e8b911a3b180cd  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-22.c
+2c31ee89174617e3ba574448053a4776  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-23.c
+3e0335739986a16a45163048e08ed006  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-24.c
+a22bc1b3d29bb75f9e9f4da82ccf7000  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-25.c
+f3a402fb571a70912ac64e7756e95960  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-26.c
+48fd4c4f5b16ff2839d5091efc51bc1c  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-27.c
+0c90090dac2694d64341be49176ef464  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-28.c
+d6c16f057f007ccdd7d443182f2f58ed  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-29.c
+36c01ff92130550706fac5b98007820d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-3.c
+8e75374fe860fe454da6f1a680c53093  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-30.c
+03f7f40b1ee77245c4ed1db91842709e  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-31.c
+134a1c8226d793ac94d0652e4b65ae51  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-32.c
+67f1fa247cbccff554d48bb98247665d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-33.c
+4edb941d627fbc374887b9f23e0f17e3  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-34.c
+e5cc2dfa10fd84ddaad3943264a4ad7f  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-35.c
+418c5a05711f0f9acd8020fe4b275a27  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-36.c
+df4d094eb16f0b1be12e3e39058baccf  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-37.c
+91d74d67304699dcaa0bcc5fea885968  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-38.c
+99ba4e76415ae84299cdbd2e35e691be  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-39.c
+955c200f2a3a98a7dc3ce9fbf4a5d301  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-4.c
+39dac34ae8d1af68556468f7c696b8aa  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-40.c
+a1cf710e376403fc2fa6bc0a774cd55a  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-41.c
+239e077c75c03ada560d0ef45ba111ed  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-42.c
+6a91cd2b45b92620b9b44d1e1d6c8a1d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-43.c
+4c0f2cfece2b5a5e87eaa33c36b3b3c7  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-44.c
+ff7d194ce3581accd4fd84661a45b7e5  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-45.c
+b6c2800bdfb9e964c574e9f6647766b7  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-46.c
+a384e1a8d2656a2eded5ddbbbb85944d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-47.c
+1af4396cdb9e44ea23e581e3bc867f1a  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-48.c
+3a822bc78662a47bca3c325640886000  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-49.c
+42702dc12a998715cd502e0f58c1a084  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-5.c
+59131225f967e9974e4056c8724eb44d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-50.c
+ca1730fffd35b4df6944a51eb8e6ecd0  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-51.c
+6f290c19a8e109a3d2386b1bf4ec52fb  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-52.c
+e0c0eb7cd795a9e89a8d3bb2a7dae3c1  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-53.c
+d17666a7a3f1f4012dea704edcb358c1  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-54.c
+bc14720a9dc1307f25839ed1e2ea1df8  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-55.c
+5f29e6111a8c4445a3d2e82737ed852c  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-56.c
+4ecd75bfc45420b8fe41eb1a6f75d1a6  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-57.c
+0b3e0dd4599b91e7eb77033764ef84f4  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-58.c
+1898d182bb390c8c6491b7c435026a9e  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-59.c
+a348525fc964f3f41e12f8381fd4bcf0  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-6.c
+8fe72a2d44a5dbae21dedb5009bd7060  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-60.c
+1b1a3ecb85d752278437daf2eea0e6eb  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-61.c
+52a091925e77ba1144deef4224d6f9ca  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-62.c
+f26a1170d2c83041d7a069b94343a9d7  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-63.c
+7f10d8beb44cbeb34704f04daf38dca2  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-64.c
+1243afa79ef71c09ca472c7ad6965e54  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-65.c
+54e131b3227f901fd2e26be9a409249d  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-66.c
+e771d4d8a905e5bf787121a83f8fb1bd  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-67.c
+231bcc25e02275bc7eba589b808e66c4  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-68.c
+f72240bd263e9d2959d34419b48ec7a1  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-69.c
+e5c6066babd8f328700bb917a676f848  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-7.c
+7f5d4d6487570d1848a67d1deb2569de  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-70.c
+11baa718d3b7a09edcd806f460dbbc25  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-71.c
+b8a10e75320b7331731319d76c48b973  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-72.c
+af92c107465b701524293f2e133ca47b  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-73.c
+630a7ec679fff8883a406b022cf38aff  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-74.c
+c1e8ae021e1d249573f6608e39e8d86e  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-75.c
+b33ec26b8a79deea82491f02092ff7eb  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-76.c
+9f6e7688c4fef262f7ed52de311ab068  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-77.c
+2b710812d98f7baa361e357f4e747316  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-78.c
+2652ccf7999779ff5319bf65f0b659c1  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-79.c
+341058672752eae6a423c51813b90e2c  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-8.c
+e8ac5024db4f3ad13af9c932702e4b7f  gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-9.c
 e1dbd1140383b4dbafeb6bc38684cf93  gcc/testsuite/gcc.target/powerpc/dimode_off.c
 c6886ac188c6209f2a35a8c394fabfa1  gcc/testsuite/gcc.target/powerpc/direct-move-double1.c
 bdc2a6ba20c8709781a896620fe1326b  gcc/testsuite/gcc.target/powerpc/direct-move-double2.c
@@ -45010,6 +45209,7 @@
 8d289ff49f69a167c01f4b6855e110ac  gcc/testsuite/gcc.target/powerpc/direct-move-vint1.c
 c08abaae6dddb0af0b1430cc189c6040  gcc/testsuite/gcc.target/powerpc/direct-move-vint2.c
 6aa10299b67de4618abcf699cb851ce8  gcc/testsuite/gcc.target/powerpc/direct-move.h
+be7ab318182d2d9e0f83da284efdde33  gcc/testsuite/gcc.target/powerpc/divkc3-1.c
 8f2229fba1c4dc16358c52a26e62a35e  gcc/testsuite/gcc.target/powerpc/doloop-1.c
 1e28ad29e43de3bf402fb713b7540c32  gcc/testsuite/gcc.target/powerpc/e500-1.c
 6b480fbd59c1e52ed8af5509486a3432  gcc/testsuite/gcc.target/powerpc/e500-ord-1.c
@@ -45025,6 +45225,8 @@
 44257db5dbf13763224f09982671b766  gcc/testsuite/gcc.target/powerpc/float128-1.c
 8431c27a8973acc6b663c3e4190c2f2e  gcc/testsuite/gcc.target/powerpc/float128-2.c
 9e6f60ec112f9373cd63307f592ff5a7  gcc/testsuite/gcc.target/powerpc/float128-call.c
+da43f175c7dca2bbe0139db71bea74f9  gcc/testsuite/gcc.target/powerpc/float128-complex-1.c
+ba0af867a51a0f317dfaf5694d966c85  gcc/testsuite/gcc.target/powerpc/float128-complex-2.c
 278c3bcb22b5f3322ae25ff38796870a  gcc/testsuite/gcc.target/powerpc/float128-hw.c
 e930a70de9d4456cf3f5cae8c611ac1c  gcc/testsuite/gcc.target/powerpc/float128-mix.c
 437cac345cf3e7c88a4c1c8b8480547f  gcc/testsuite/gcc.target/powerpc/fusion.c
@@ -45037,6 +45239,7 @@
 238571a7588bf04ee725a409029ddaf1  gcc/testsuite/gcc.target/powerpc/htm-ttest.c
 bd2f03394b7690c22ce1aab465adb75f  gcc/testsuite/gcc.target/powerpc/htm-xl-intrin-1.c
 8d634b2a7d443f1e5b4b69716e57ac00  gcc/testsuite/gcc.target/powerpc/indexed-addr.c
+1cc843325d44861ca12b01f8232baced  gcc/testsuite/gcc.target/powerpc/inf128-1.c
 de6c3cf42bacd45ce2c483d586831396  gcc/testsuite/gcc.target/powerpc/le-altivec-consts.c
 7893fdf7b4681a84cb4d049bea9ffc10  gcc/testsuite/gcc.target/powerpc/leaf.c
 1853e044fc4484c52b41a7d64cfddd8c  gcc/testsuite/gcc.target/powerpc/lhs-1.c
@@ -45052,6 +45255,8 @@
 cfbe35822c519cf32e8f41ddb02759ed  gcc/testsuite/gcc.target/powerpc/mmfpgpr.c
 995bc75d9399474fb48494a941a1e00a  gcc/testsuite/gcc.target/powerpc/mod-1.c
 68dd42cf85da89132923bd22aec1f9dc  gcc/testsuite/gcc.target/powerpc/mod-2.c
+3aa7fc41d135e303f0c05c03811cfb39  gcc/testsuite/gcc.target/powerpc/mulkc3-1.c
+1f98efd43a15bde30353489bd97a085d  gcc/testsuite/gcc.target/powerpc/nan128-1.c
 e22a7266629ff9fe810fc66e708b11a6  gcc/testsuite/gcc.target/powerpc/no-r11-1.c
 0f3e464b60c769b9067c0b49078b50e5  gcc/testsuite/gcc.target/powerpc/no-r11-2.c
 302a3a348ae2f60a0b1366d1c9481f97  gcc/testsuite/gcc.target/powerpc/no-r11-3.c
@@ -45069,7 +45274,7 @@
 218190fe0e4f681dda260926232e56b5  gcc/testsuite/gcc.target/powerpc/p8vector-builtin-7.c
 39413d857162f864cd0cfa0c0a600923  gcc/testsuite/gcc.target/powerpc/p8vector-builtin-8.c
 3f96842d16ce43bf9d8c92dab6d38fb8  gcc/testsuite/gcc.target/powerpc/p8vector-fp.c
-f29a688c117106072da0c3eb645375e9  gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c
+36ce3b715645c5b3d320e55d92cecb36  gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c
 dc5273f33a688389eb35c5a79b6b04b9  gcc/testsuite/gcc.target/powerpc/p8vector-int128-2.c
 fa4a7a4c3fc9401f5f7a3c80eca753f3  gcc/testsuite/gcc.target/powerpc/p8vector-ldst.c
 11c5f55b0b21129d8c523e1f11c76274  gcc/testsuite/gcc.target/powerpc/p8vector-vbpermq.c
@@ -45080,8 +45285,17 @@
 8c128eee1ed213711e07bd5bbf4ea8c5  gcc/testsuite/gcc.target/powerpc/p8vector-vectorize-5.c
 f368a72cbfc951f5d512a015f6e8c2fe  gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-1.c
 46765159df83126bf98a3389decd9548  gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-2.c
-ec4a1b33aeb2dc10bc385f3a5cab0690  gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-3.c
-44fb83fb0d58cbe1b55027ec048d86a7  gcc/testsuite/gcc.target/powerpc/p9-permute.c
+b2136c61215bc040108f9a44241aa4b3  gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-3.c
+a56e3fa096d4eb9c5d04e5ef09bccdf7  gcc/testsuite/gcc.target/powerpc/p9-minmax-1.c
+a67318a36c32f549811fc609d45bcebe  gcc/testsuite/gcc.target/powerpc/p9-minmax-2.c
+1778c48c8bde0f502ec1184c17d6661b  gcc/testsuite/gcc.target/powerpc/p9-permute.c
+ce1b8af0ff483cd3f89e77c6158773e6  gcc/testsuite/gcc.target/powerpc/p9-splat-1.c
+ae816fd528711a489a96d36403ab4796  gcc/testsuite/gcc.target/powerpc/p9-splat-2.c
+90f06243a7fc1c6079c823376b9b6cc4  gcc/testsuite/gcc.target/powerpc/p9-splat-3.c
+76e637efba841cdc036746e8f48a0914  gcc/testsuite/gcc.target/powerpc/p9-splat-4.c
+1001e87b8d8b5b7135c100a89e4def45  gcc/testsuite/gcc.target/powerpc/p9-vneg.c
+69dc6d7d44a9c96a4258141385a846d7  gcc/testsuite/gcc.target/powerpc/p9-vparity.c
+7d6c7bf2bdc6cb2de461278049408eb4  gcc/testsuite/gcc.target/powerpc/p9-vpermr.c
 de89784ed878c699a73dbedef03c25ef  gcc/testsuite/gcc.target/powerpc/pack01.c
 c9ce448310ccdac5da6fa5b69ec461fa  gcc/testsuite/gcc.target/powerpc/pack02.c
 fa72c1f9512bac14ea57ebf20c94c152  gcc/testsuite/gcc.target/powerpc/pack03.c
@@ -45198,7 +45412,7 @@
 09542fc0756c51e091818e0d1a7a05b5  gcc/testsuite/gcc.target/powerpc/pr47197.c
 524c7b62ac0c9686a6bdb4804a11fce4  gcc/testsuite/gcc.target/powerpc/pr47251.c
 9bcd4da8d1ead179f5ca0c94808c2ec3  gcc/testsuite/gcc.target/powerpc/pr47755-2.c
-bcabc94dfa3cff99515bf6e3ff144a3a  gcc/testsuite/gcc.target/powerpc/pr47755.c
+b15f022f6f08a7dca1b72ba59441c31f  gcc/testsuite/gcc.target/powerpc/pr47755.c
 a126c8ee58b9156d861ed2d613db885a  gcc/testsuite/gcc.target/powerpc/pr47862.c
 187f203dd54fe5ba94f23b9af10db192  gcc/testsuite/gcc.target/powerpc/pr48053-1.c
 e3647ff87eca8354091eead60728a16f  gcc/testsuite/gcc.target/powerpc/pr48053-2.c
@@ -45254,7 +45468,7 @@
 1dc925cae1c688a77865627d749d015c  gcc/testsuite/gcc.target/powerpc/pr67071-3.c
 35c73d31cfb2ab34903671c0ed5ded53  gcc/testsuite/gcc.target/powerpc/pr67789.c
 d513afbb48bce30e890a5d3d76987740  gcc/testsuite/gcc.target/powerpc/pr67808.c
-f9c4133177a090e3d877342b2d04766f  gcc/testsuite/gcc.target/powerpc/pr68805.c
+b0dae0a08b67b28c3e8a71536d261274  gcc/testsuite/gcc.target/powerpc/pr68805.c
 d369a7045eda68cbec3227a16d5de67b  gcc/testsuite/gcc.target/powerpc/pr68872.c
 faf2ed46677346059dd2b7fd42254985  gcc/testsuite/gcc.target/powerpc/pr69252.c
 49c8c108299a8b499707f5665d377a18  gcc/testsuite/gcc.target/powerpc/pr69461.c
@@ -45264,6 +45478,17 @@
 a31fef5f59c5f12ea342e66137c45ae7  gcc/testsuite/gcc.target/powerpc/pr70117.c
 222fda9019693e635c2d63ebdda27d2b  gcc/testsuite/gcc.target/powerpc/pr70640.c
 da2f788bebe8f041672950b7347513cf  gcc/testsuite/gcc.target/powerpc/pr70669.c
+d3a79432800e585b3905439b686d873b  gcc/testsuite/gcc.target/powerpc/pr70963.c
+31132ce703c42e34a14c7d103e655da2  gcc/testsuite/gcc.target/powerpc/pr71186.c
+18f516c22671e1293affe8823881c35c  gcc/testsuite/gcc.target/powerpc/pr71493-1.c
+7d83053012a7579379ae3f803b73b2ec  gcc/testsuite/gcc.target/powerpc/pr71493-2.c
+28b1e9d8edb2081a7279eaec89871fee  gcc/testsuite/gcc.target/powerpc/pr71656-1.c
+d9ffd95a09400f5746357a34145f6515  gcc/testsuite/gcc.target/powerpc/pr71656-2.c
+a6ef0034e7b09484d521e41a8f3e2b46  gcc/testsuite/gcc.target/powerpc/pr71670.c
+9d1ceb34ff4072b9b15ceedc2d7a4618  gcc/testsuite/gcc.target/powerpc/pr71698.c
+140c404b55422d7f1ea527d9803d6b5f  gcc/testsuite/gcc.target/powerpc/pr71720.c
+d9ccfe0048f3d64bbe5861c9aea6294f  gcc/testsuite/gcc.target/powerpc/pr71763.c
+743729f568d85b4bd156413e92dea820  gcc/testsuite/gcc.target/powerpc/pr71805.c
 17f878b62dd2e08735d53fce64232a47  gcc/testsuite/gcc.target/powerpc/quad-atomic.c
 171a411d14f30e8450dc3f2ef38b1bd7  gcc/testsuite/gcc.target/powerpc/recip-1.c
 6b7c4920c070e84f6819377bcdb90c0d  gcc/testsuite/gcc.target/powerpc/recip-2.c
@@ -45287,6 +45512,9 @@
 65a53924a48d5df99017fa40a01962f4  gcc/testsuite/gcc.target/powerpc/sd-vsx.c
 a53a4937c325ba3bc85e0bdea0b94e11  gcc/testsuite/gcc.target/powerpc/shift-dot.c
 416332739a98fa1f2023fe8c217782e4  gcc/testsuite/gcc.target/powerpc/shift-int.c
+4262b23e41d93c06cc511429249fcda3  gcc/testsuite/gcc.target/powerpc/signbit-1.c
+289a117f2abe4e588c45c20e3418566e  gcc/testsuite/gcc.target/powerpc/signbit-2.c
+1ef9b2c104b31118ee37ca3c09991d00  gcc/testsuite/gcc.target/powerpc/signbit-3.c
 b3e9870bc5d831fd67c299ee87dfb2f7  gcc/testsuite/gcc.target/powerpc/spe-evmerge.c
 89537cc7476c27c7c10b811da61def34  gcc/testsuite/gcc.target/powerpc/spe-small-data-1.c
 9d04892083c467f0ebf1fc75e043d6d8  gcc/testsuite/gcc.target/powerpc/spe-small-data-2.c
@@ -45325,6 +45553,18 @@
 d1f9b55044b5c80d668c846e0f160115  gcc/testsuite/gcc.target/powerpc/timode_off.c
 fe21d9465e0313b29a24703b2cef2b7e  gcc/testsuite/gcc.target/powerpc/upper-regs-df.c
 7f45b205e570d7d45266076bd4fd4f4c  gcc/testsuite/gcc.target/powerpc/upper-regs-sf.c
+fe1198a185fcf0cf3c192cb7e0f554af  gcc/testsuite/gcc.target/powerpc/vadsdu-0.c
+0623613fbcbc6fa96d28c319582034e3  gcc/testsuite/gcc.target/powerpc/vadsdu-1.c
+9ee678d38841407e553ad5d916841cbd  gcc/testsuite/gcc.target/powerpc/vadsdu-2.c
+cd4f138fd346361e2e3103806fd8e4c8  gcc/testsuite/gcc.target/powerpc/vadsdu-3.c
+d80a979aa0ab824dbdb31e5e8db1d686  gcc/testsuite/gcc.target/powerpc/vadsdu-4.c
+3e300989c07659ab970072f3d95fde1f  gcc/testsuite/gcc.target/powerpc/vadsdu-5.c
+dd9d9603bf7f30ea24dc69a515e1018f  gcc/testsuite/gcc.target/powerpc/vadsdub-1.c
+d899788117c4e5a72b4b1f588fe2d14e  gcc/testsuite/gcc.target/powerpc/vadsdub-2.c
+99d98db6a63856f69d9535bde676d0dc  gcc/testsuite/gcc.target/powerpc/vadsduh-1.c
+b4f95876fdcc9d9ee6da80cca9fda9c6  gcc/testsuite/gcc.target/powerpc/vadsduh-2.c
+8ea44287fbf60977cedb44fec5928530  gcc/testsuite/gcc.target/powerpc/vadsduw-1.c
+f89bc692aa33f0a854308215a8c5a45c  gcc/testsuite/gcc.target/powerpc/vadsduw-2.c
 6359ddccab89d64974aacae92509fc9e  gcc/testsuite/gcc.target/powerpc/vec-cg.c
 4137a1d7e936bac5292a51f907266de1  gcc/testsuite/gcc.target/powerpc/vec-cmp-sel.c
 2d193a6a4c276dd8b48c488c547c2063  gcc/testsuite/gcc.target/powerpc/vec-cmp.c
@@ -45332,6 +45572,10 @@
 fa102cb45e48c286b356759209443dea  gcc/testsuite/gcc.target/powerpc/vec-mult-char-2.c
 bbd74596ca12fe9aac0347c6253db300  gcc/testsuite/gcc.target/powerpc/vec-shift.c
 8ee50015e788404267646adf1ac95972  gcc/testsuite/gcc.target/powerpc/vec-shr.c
+2c89883d083bc93d292eb8be25a26a55  gcc/testsuite/gcc.target/powerpc/vslv-0.c
+3032ccdc175db10c55ecb393e9757ea8  gcc/testsuite/gcc.target/powerpc/vslv-1.c
+249c2e1b9f88f56726ab8ecfe5c4e957  gcc/testsuite/gcc.target/powerpc/vsrv-0.c
+b5ff35f6c27a48ed531cd0cb2035da0b  gcc/testsuite/gcc.target/powerpc/vsrv-1.c
 4ceb6855c2485b8644bf41d0692dce88  gcc/testsuite/gcc.target/powerpc/vsx-builtin-1.c
 9e3c77c5253ece30391881a511c37067  gcc/testsuite/gcc.target/powerpc/vsx-builtin-2.c
 2cbc6ebb458b1e9d41b7cd611b4dbd55  gcc/testsuite/gcc.target/powerpc/vsx-builtin-3.c
@@ -45340,6 +45584,10 @@
 0b61a376e7164778a523a0766df4ce6e  gcc/testsuite/gcc.target/powerpc/vsx-builtin-6.c
 aec0aad4ad9d1a50c30d68081c0f2184  gcc/testsuite/gcc.target/powerpc/vsx-builtin-7.c
 88cd9f4d3675a8897d01117429ae8094  gcc/testsuite/gcc.target/powerpc/vsx-builtin-8.c
+60164d527bd21ab51c50c80abf146df1  gcc/testsuite/gcc.target/powerpc/vsx-elemrev-1.c
+3af84d85921a35dbef53567c5ede1159  gcc/testsuite/gcc.target/powerpc/vsx-elemrev-2.c
+5b80f1ec62fecc5421d5ce52af4b330c  gcc/testsuite/gcc.target/powerpc/vsx-elemrev-3.c
+6b19bf3ff62b230d7085a802e8199e3f  gcc/testsuite/gcc.target/powerpc/vsx-elemrev-4.c
 29415c0ab3cf79b03ca4a55fa764901b  gcc/testsuite/gcc.target/powerpc/vsx-extract-1.c
 ad77cf7854ac810c73e5ad0184232f20  gcc/testsuite/gcc.target/powerpc/vsx-extract-2.c
 e4ac7f141f61cf4cf8934fe3ee7cf407  gcc/testsuite/gcc.target/powerpc/vsx-extract-3.c
@@ -45466,6 +45714,7 @@
 c06cf2adc5393d32c0b9a8d805d6afb4  gcc/testsuite/gcc.target/s390/md/setmem_long-1.c
 a105158cf4633c30f58d84f95c33ee67  gcc/testsuite/gcc.target/s390/morestack.c
 ee3f00537b1c391d545c37c6ea4a145c  gcc/testsuite/gcc.target/s390/nearestint-1.c
+20772d696b36be5fe8027a9f6a1a5faa  gcc/testsuite/gcc.target/s390/nolrl-1.c
 25c3bd00fd3d097e42ac8cfc215fd0c4  gcc/testsuite/gcc.target/s390/pfpo.c
 765307a040de72f2f4376b7068d68018  gcc/testsuite/gcc.target/s390/pr20927.c
 85f31fb9b4b15529205376d3f6fa385c  gcc/testsuite/gcc.target/s390/pr24624.c
@@ -45882,6 +46131,8 @@
 7efe7d6dfe46005ac34237aa9e3e023c  gcc/testsuite/gcc.target/sparc/fpadd32s.c
 e7a16562b49f44afb077d0a7befb1888  gcc/testsuite/gcc.target/sparc/fpadds.c
 e291921904c28ad0957b701bb53b0dda  gcc/testsuite/gcc.target/sparc/fpaddsubi.c
+ac111f461cdeae36912fd3f8404ed990  gcc/testsuite/gcc.target/sparc/fpcmp.c
+2744da28c2a65f937a5d696009a68964  gcc/testsuite/gcc.target/sparc/fpcmpu.c
 d5c0d8820b76e85d8f0cf1c69966a388  gcc/testsuite/gcc.target/sparc/fpmerge-2.c
 a7cc3a1dfad8c1fc65ae115cb1af1560  gcc/testsuite/gcc.target/sparc/fpmerge.c
 c589849053db19bd27d64bfbabf5ea20  gcc/testsuite/gcc.target/sparc/fpmul-2.c
@@ -45956,6 +46207,7 @@
 51fff32a202c8bd3aa39b5f219127064  gcc/testsuite/gcc.target/sparc/vis3move-1.c
 b19cd6113dbe3ce177bc3a6f0edd515b  gcc/testsuite/gcc.target/sparc/vis3move-2.c
 c743e0cdebd780532edc2e21e3de15e4  gcc/testsuite/gcc.target/sparc/vis3move-3.c
+c6e8cea536062af6f23168b438e096e3  gcc/testsuite/gcc.target/sparc/vis4misc.c
 56b799e8f22e02ad94a3b78e432a129c  gcc/testsuite/gcc.target/sparc/wrgsr.c
 8ab1e95b1174d62330ff11c4ce7c22d3  gcc/testsuite/gcc.target/sparc/xmul.c
 723fd6618b2db81b9d1ef55c7f12b2d5  gcc/testsuite/gcc.target/spu/Wmain.c
@@ -46653,7 +46905,7 @@
 d5ea8f5a9e2574f03e0f07aefb628587  gcc/testsuite/gfortran.dg/array_constructor_46.f90
 43de0ab156de7b0350c7425df3859e4a  gcc/testsuite/gfortran.dg/array_constructor_47.f90
 71b1b67746cb3b141002319b6af5c534  gcc/testsuite/gfortran.dg/array_constructor_48.f90
-962a7a6b6e5f15ede68a20cff87053b5  gcc/testsuite/gfortran.dg/array_constructor_49.f90
+b3fed1ef4a2d1acbb8f29ba81a3ade35  gcc/testsuite/gfortran.dg/array_constructor_49.f90
 9918ac77cf760a3800e94da773f0a74b  gcc/testsuite/gfortran.dg/array_constructor_5.f90
 6dc05669b848d267b25c38806e59d51f  gcc/testsuite/gfortran.dg/array_constructor_6.f90
 0965c3437a2116ac32e573441184fdee  gcc/testsuite/gfortran.dg/array_constructor_7.f90
@@ -47361,6 +47613,7 @@
 50b3c8143d77c8ce5bb9d993685e5e6b  gcc/testsuite/gfortran.dg/class_array_2.f03
 5d685c52e64583cc42131880a4b0d8fc  gcc/testsuite/gfortran.dg/class_array_20.f03
 15af94e79a85d05449886a154d162bff  gcc/testsuite/gfortran.dg/class_array_21.f03
+91de14bd0e1e34515a91a4245b3da873  gcc/testsuite/gfortran.dg/class_array_22.f03
 3c6c7feaa5267df5f131a4ddb69162d9  gcc/testsuite/gfortran.dg/class_array_3.f03
 cb5261f2acfcf95396bea9e699efcd14  gcc/testsuite/gfortran.dg/class_array_4.f03
 b4dd99bc2d3d2741e6f3769df3b8d9e0  gcc/testsuite/gfortran.dg/class_array_5.f03
@@ -47534,6 +47787,8 @@
 b2dba23fc22128a647db42769be9f272  gcc/testsuite/gfortran.dg/coindexed_1.f90
 f921a7c5a0e4098dd6b6edf4e317a4e1  gcc/testsuite/gfortran.dg/com_block_driver.f90
 2595b7b0d8e86ae62cf503bd5080ee45  gcc/testsuite/gfortran.dg/comma.f
+ca9b384b7523fa630f1d4edff3cd4267  gcc/testsuite/gfortran.dg/comma_IO_extension_1.f90
+7b4fe3be18cf5d3e2bcac0b98a2191d6  gcc/testsuite/gfortran.dg/comma_IO_extension_2.f90
 b68510025102f4e42c5ab3a0ebf1b5aa  gcc/testsuite/gfortran.dg/comma_format_extension_1.f
 e9f174aaa655ec093b7c3dc075581e89  gcc/testsuite/gfortran.dg/comma_format_extension_2.f
 e38edb0e607a003fddf67b7597b40626  gcc/testsuite/gfortran.dg/comma_format_extension_3.f
@@ -47693,6 +47948,24 @@
 311f4c5de7848479e7c29ad08de71190  gcc/testsuite/gfortran.dg/debug/trivial.f
 431530310efb9ec01e397a4a411f8e67  gcc/testsuite/gfortran.dg/debug_1.f90
 f12fc8f8c675ad90dacda21c47b123cf  gcc/testsuite/gfortran.dg/debug_2.f
+299b547bcb6b486a2e1f3e6ff0e387b8  gcc/testsuite/gfortran.dg/dec_structure_1.f90
+facc0d311d19c38571f70f8db13044bc  gcc/testsuite/gfortran.dg/dec_structure_10.f90
+bebb7b5cba927374343e4d102d6bdef2  gcc/testsuite/gfortran.dg/dec_structure_11.f90
+c065ec9eab467c19e2503ea2b5ec35f6  gcc/testsuite/gfortran.dg/dec_structure_2.f90
+17d1e3238da3930c57838b7f1d610c40  gcc/testsuite/gfortran.dg/dec_structure_3.f90
+17bdec7f0e2ee1d7fce0b23ebd82610a  gcc/testsuite/gfortran.dg/dec_structure_4.f90
+e60b5448cb28834a5043d778f28b0029  gcc/testsuite/gfortran.dg/dec_structure_5.f90
+5276660c4588b2f9922aacd54e303a2d  gcc/testsuite/gfortran.dg/dec_structure_6.f90
+b7df816a5764cf98d0af9a21fc087015  gcc/testsuite/gfortran.dg/dec_structure_7.f90
+a3842131746a182a4d0d806a0ead8cf9  gcc/testsuite/gfortran.dg/dec_structure_8.f90
+ba7bd70d8f9beaa28febfa1d800b3cf7  gcc/testsuite/gfortran.dg/dec_structure_9.f90
+13560c998f2fbbcc2fd45b4777d0e4c9  gcc/testsuite/gfortran.dg/dec_union_1.f90
+069da68835dead9331318c2f9a653aec  gcc/testsuite/gfortran.dg/dec_union_2.f90
+83928614f196067ade7992b31468aef9  gcc/testsuite/gfortran.dg/dec_union_3.f90
+0557177e9e8702f52b8f249aa7941985  gcc/testsuite/gfortran.dg/dec_union_4.f90
+3f6b8d2969f783d7204a320cf8b95cd2  gcc/testsuite/gfortran.dg/dec_union_5.f90
+ac7e4f8e406a6c26533909c71fa6b3fd  gcc/testsuite/gfortran.dg/dec_union_6.f90
+3bf903f4b6b040909bf42cbcf85d3330  gcc/testsuite/gfortran.dg/dec_union_7.f90
 24aa7ef3c5125fd57a6bf5b0d5a11a5f  gcc/testsuite/gfortran.dg/default_format_1.f90
 42dc43ca59716a600a5d47ef02504fc7  gcc/testsuite/gfortran.dg/default_format_1.inc
 6639ce11899c92de50597c547e431fe7  gcc/testsuite/gfortran.dg/default_format_2.f90
@@ -47715,6 +47988,7 @@
 c26c871bf08605ce024253a49da3b53a  gcc/testsuite/gfortran.dg/deferred_character_14.f90
 1c4f05212f5447da65bd477a1f755ce9  gcc/testsuite/gfortran.dg/deferred_character_15.f90
 bcdb84ffa3c50231ecd967d3114134ae  gcc/testsuite/gfortran.dg/deferred_character_16.f90
+c2d3fe3d7d640f7941cc2bc632a62dae  gcc/testsuite/gfortran.dg/deferred_character_17.f90
 0065ab4e114bfcdbbb2b3374d1ffdc63  gcc/testsuite/gfortran.dg/deferred_character_2.f90
 496fec17b89042f5546165ec11d36f09  gcc/testsuite/gfortran.dg/deferred_character_3.f90
 1d0633419cdd140f8ca51872f6219b2d  gcc/testsuite/gfortran.dg/deferred_character_4.f90
@@ -47789,6 +48063,7 @@
 dca63cf93efe22616e44d9f46b5b1933  gcc/testsuite/gfortran.dg/dependency_43.f90
 52a475961b0e9c97d571fa626e1754b5  gcc/testsuite/gfortran.dg/dependency_44.f90
 9908775fdc0125fcca5e0250d562cdb1  gcc/testsuite/gfortran.dg/dependency_45.f90
+18bd6a173b22bb353c669d8ab0cbe6df  gcc/testsuite/gfortran.dg/dependency_46.f90
 590a99c4ec44cc37aa92b225e93d6e87  gcc/testsuite/gfortran.dg/dependency_5.f90
 03218919538313b26e09fa1b8f0efda0  gcc/testsuite/gfortran.dg/dependency_6.f90
 699f1378f5c1fcdc54eb21fdb4a59be1  gcc/testsuite/gfortran.dg/dependency_7.f90
@@ -48477,17 +48752,19 @@
 6efd4df3178f228cb542d2003c66b882  gcc/testsuite/gfortran.dg/goacc/array-reduction.f90
 c92cb05a4e19077108b80407be41b8f4  gcc/testsuite/gfortran.dg/goacc/assumed.f95
 8cdce510706db86c42684ec44b8eb828  gcc/testsuite/gfortran.dg/goacc/asyncwait-1.f95
-7bd472524bf42138d88fa89386d66b65  gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95
-e6a2926ae0de810c7fe830bb89c73ecf  gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95
-fdc3c66ef32cd5b7ad3182aa063ae0b2  gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95
+e5c0af740e47a34c175a9ceb878b8228  gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95
+a9a3cfdb74f2e089482e586df93f98f6  gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95
+0084be36b4e094fd83e8998262213cba  gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95
 b5ce38fdd599e1809965f838521def2e  gcc/testsuite/gfortran.dg/goacc/branch.f95
-34313aee22abd0152799e922857be58d  gcc/testsuite/gfortran.dg/goacc/cache-1.f95
-90ecc7d89f74c8968e175f4f1d53be80  gcc/testsuite/gfortran.dg/goacc/coarray.f95
+109a3ecc87b1bc758772cc9eeee4d842  gcc/testsuite/gfortran.dg/goacc/cache-1.f95
+0770d02d65abc7014c30751880ebe628  gcc/testsuite/gfortran.dg/goacc/cache-2.f95
+83d4a89dbb466047d65da89db7eebee2  gcc/testsuite/gfortran.dg/goacc/coarray.f95
 802487ba26d5909068b6a8fd851b3b28  gcc/testsuite/gfortran.dg/goacc/coarray_2.f90
-55f389e7d2475dfd568dc4cfc36ee031  gcc/testsuite/gfortran.dg/goacc/combined-directives.f90
+a7d31e00fe9a2d414bb73e11030c72bc  gcc/testsuite/gfortran.dg/goacc/combined-directives.f90
 d1e02d6d5cf7ba5e1a5efb88f2c97c94  gcc/testsuite/gfortran.dg/goacc/combined_loop.f90
 9d0226e6bd1816759f20d69d9cfb27cc  gcc/testsuite/gfortran.dg/goacc/continuation-free-form.f95
-95640396b34a8b7bad7efe08268dc32c  gcc/testsuite/gfortran.dg/goacc/cray.f95
+1d2b9f57ee07b286f80f6b187af2ff1b  gcc/testsuite/gfortran.dg/goacc/cray-2.f95
+decf3300196fa1217139ef97f2e0edda  gcc/testsuite/gfortran.dg/goacc/cray.f95
 4bb22bcb9fe8f7604be602bc77be659f  gcc/testsuite/gfortran.dg/goacc/critical.f95
 022517e8228f065e890dddca8b9c62eb  gcc/testsuite/gfortran.dg/goacc/data-clauses.f95
 cf1b8cb94fd316d9739bca6a5a62b7c8  gcc/testsuite/gfortran.dg/goacc/data-tree.f95
@@ -48522,26 +48799,30 @@
 b3ec1dda65c543c847dd7dddd2c4225d  gcc/testsuite/gfortran.dg/goacc/kernels-tree.f95
 69f03def6f88f62ff022aa924b3ef5ec  gcc/testsuite/gfortran.dg/goacc/list.f95
 e6dbc70731a1d1ca5862632bc04ef617  gcc/testsuite/gfortran.dg/goacc/literal.f95
-2b88ae51fe174e583daaf03c09fcec02  gcc/testsuite/gfortran.dg/goacc/loop-1.f95
+b26795c8c89b35d75e8f259a55524874  gcc/testsuite/gfortran.dg/goacc/loop-1-2.f95
+687f26e7d2845bfca2374df935de0ad8  gcc/testsuite/gfortran.dg/goacc/loop-1.f95
 f89d863f93581b48d43a32a8190ba33e  gcc/testsuite/gfortran.dg/goacc/loop-2.f95
-c9153e6a6dac5781507ac515cab62dd5  gcc/testsuite/gfortran.dg/goacc/loop-3.f95
+7a6e1274863fdd10d60c8e28013470ad  gcc/testsuite/gfortran.dg/goacc/loop-3-2.f95
+4ab6f70640fa56a4b2322cbd843dc31e  gcc/testsuite/gfortran.dg/goacc/loop-3.f95
 7650c1b33dcca66bb9a4288605d35e20  gcc/testsuite/gfortran.dg/goacc/loop-4.f95
 9cd553c36e742f7b04d15d0cb0a6a48e  gcc/testsuite/gfortran.dg/goacc/loop-5.f95
 1d6f955c573654211baccdf5274140f4  gcc/testsuite/gfortran.dg/goacc/loop-6.f95
 6cf3587f7d4ad23454dd236855ca4765  gcc/testsuite/gfortran.dg/goacc/loop-7.f95
 6a1610362e13864115701f5d730ee4d1  gcc/testsuite/gfortran.dg/goacc/loop-tree-1.f90
 677cbf9fd090598ed630bcfe28346d68  gcc/testsuite/gfortran.dg/goacc/multi-clause.f90
+d8029a1c26556a69cbb64f6e00104fc1  gcc/testsuite/gfortran.dg/goacc/nested-function-1.f90
 0eceec0214676eaf97b87027864084f8  gcc/testsuite/gfortran.dg/goacc/omp-fixed.f
 7ac95438e9a28b224841f382a0cd1c73  gcc/testsuite/gfortran.dg/goacc/omp.f95
 858af9153dd1e561ac2db5bbc63970fc  gcc/testsuite/gfortran.dg/goacc/parallel-kernels-clauses.f95
 1ba4b22dac74c58581a0548cc088e27d  gcc/testsuite/gfortran.dg/goacc/parallel-kernels-regions.f95
 f111c33f57aecc85e59e669c980e4436  gcc/testsuite/gfortran.dg/goacc/parallel-tree.f95
 4f9ac2d37e02e4f60dbb47924519e3ad  gcc/testsuite/gfortran.dg/goacc/parameter.f95
+b4f5bf838607d6206aae8d768d23c64e  gcc/testsuite/gfortran.dg/goacc/pr71704.f90
 93028fbaf2e1d8a3907db1cacb627cf7  gcc/testsuite/gfortran.dg/goacc/private-1.f95
 24e251dd88a9ea6377e535f5ee5f31ed  gcc/testsuite/gfortran.dg/goacc/private-2.f95
 a70416eb409bcd3ad178b3d0127d84e8  gcc/testsuite/gfortran.dg/goacc/private-3.f95
 62b5f5b00b9662a8b75727b0922b367d  gcc/testsuite/gfortran.dg/goacc/pure-elemental-procedures.f95
-d12cf9a036092d8d5b7280b4a40b9ca0  gcc/testsuite/gfortran.dg/goacc/reduction-2.f95
+9b703807d8c979fc38c25732d2b58ed7  gcc/testsuite/gfortran.dg/goacc/reduction-2.f95
 d3ab76f25073383b9b4da99d0ae1d5da  gcc/testsuite/gfortran.dg/goacc/reduction-3.f95
 05592ff32b84187f44ceb5b9e28798d2  gcc/testsuite/gfortran.dg/goacc/reduction-promotions.f90
 46fd853a6275991852de09ff935972f6  gcc/testsuite/gfortran.dg/goacc/reduction.f95
@@ -48555,7 +48836,6 @@
 1de77dbd04bee79fc48688363255fcd9  gcc/testsuite/gfortran.dg/goacc/several-directives.f95
 f06b08508075bc5860b3aef6a69260fe  gcc/testsuite/gfortran.dg/goacc/sie.f95
 cb4390c1c6c7c2a0935783bfe228925e  gcc/testsuite/gfortran.dg/goacc/subarrays.f95
-541c6f516c94b64ec10c75b4beec8152  gcc/testsuite/gfortran.dg/goacc/subroutines.f90
 2fcae0aca98e7612762a0d64de5d1b4d  gcc/testsuite/gfortran.dg/goacc/uninit-copy-clause.f95
 1b773656b8a7d541df7a20f4cb0b21c5  gcc/testsuite/gfortran.dg/goacc/uninit-dim-clause.f95
 dd2a54a711f3f1fc2d508534164228f9  gcc/testsuite/gfortran.dg/goacc/uninit-firstprivate-clause.f95
@@ -48649,6 +48929,8 @@
 31f5c4996a25be6d38e18faf28b150b4  gcc/testsuite/gfortran.dg/gomp/openmp-simd-1.f90
 2b03c97061d19eddde270a6c9dd3fc38  gcc/testsuite/gfortran.dg/gomp/openmp-simd-2.f90
 7b53af38ad214d98f0d0550bbb80b654  gcc/testsuite/gfortran.dg/gomp/openmp-simd-3.f90
+ab6d18741860d8f9094676890b96e068  gcc/testsuite/gfortran.dg/gomp/order-1.f90
+618c952f5bbb7326c70d6e7a786f679d  gcc/testsuite/gfortran.dg/gomp/order-2.f90
 9a6817790a272cd8153d4303d324c00f  gcc/testsuite/gfortran.dg/gomp/pr26224.f
 d2c74a71f2bea0005d853821e6f0142c  gcc/testsuite/gfortran.dg/gomp/pr27573.f90
 7905e149c2a2dbed5b9dd43384d712f4  gcc/testsuite/gfortran.dg/gomp/pr29759.f90
@@ -48688,6 +48970,11 @@
 624512980f4f3b39deb857cfdd5fdeba  gcc/testsuite/gfortran.dg/gomp/pr62131.f90
 5d7b04ab3b84314d89ea68a7f054ea17  gcc/testsuite/gfortran.dg/gomp/pr66633.f90
 008d934abb38a4acedd9f90092aa4b6d  gcc/testsuite/gfortran.dg/gomp/pr69128.f90
+94a8931b1a8c928dadf01cdde210bbba  gcc/testsuite/gfortran.dg/gomp/pr70855.f90
+a21e59357a45d319e791dda388391242  gcc/testsuite/gfortran.dg/gomp/pr71687.f90
+1724cefc87db9a0a62b6387ee74cffc2  gcc/testsuite/gfortran.dg/gomp/pr71704.f90
+7d3f1abdbdd106580173760b443a9b40  gcc/testsuite/gfortran.dg/gomp/pr71705.f90
+d07d71ded0663c9dc2e67b06e6231cfc  gcc/testsuite/gfortran.dg/gomp/pr71758.f90
 b4be3f9de7631846875a711ae9b67293  gcc/testsuite/gfortran.dg/gomp/proc_ptr_1.f90
 87885556568e657ef4c936c53e1c7305  gcc/testsuite/gfortran.dg/gomp/proc_ptr_2.f90
 59e444df8ec8f5ea9859b5aef4d75865  gcc/testsuite/gfortran.dg/gomp/reduction1.f90
@@ -48770,7 +49057,7 @@
 5754b3cf46378cb45f6e5a1d41b0cd4a  gcc/testsuite/gfortran.dg/graphite/pr37852.f90
 d056a2044b7a3f7f763fe76fad38958d  gcc/testsuite/gfortran.dg/graphite/pr37857.f90
 39980079ddf92937d334ad4fa7d63b74  gcc/testsuite/gfortran.dg/graphite/pr37980.f90
-9fd92c1b4b047e3ecad9e87cacd557e5  gcc/testsuite/gfortran.dg/graphite/pr38083.f90
+5d9ba2a3b15bd5a5d3fec321b23e780b  gcc/testsuite/gfortran.dg/graphite/pr38083.f90
 2f361e4dc036f2a777b5340709d7cbad  gcc/testsuite/gfortran.dg/graphite/pr38459.f90
 68989e2f56ab16cebeffc96df65b3c7d  gcc/testsuite/gfortran.dg/graphite/pr38953.f90
 c5c4a63aba69d822a86d91f0242eb7c9  gcc/testsuite/gfortran.dg/graphite/pr39516.f
@@ -48811,7 +49098,7 @@
 c6ccb0077483440bf572afc0c07cf295  gcc/testsuite/gfortran.dg/graphite/vect-pr40979.f90
 f9932e22f4bc6baa989154035dbac7c1  gcc/testsuite/gfortran.dg/guality/arg1.f90
 49b421794f66b18bf7f66026f68f035f  gcc/testsuite/gfortran.dg/guality/guality.exp
-34aa3a6f198ba5d265275076a07dbf9a  gcc/testsuite/gfortran.dg/guality/pr41558.f90
+d4523e218e3a6d976774e7e026bca339  gcc/testsuite/gfortran.dg/guality/pr41558.f90
 85b827d8051a3d9581ba2a6e6709d5c9  gcc/testsuite/gfortran.dg/hollerith.f90
 855af7807ad9d75aef7ff85c2859a0c2  gcc/testsuite/gfortran.dg/hollerith2.f90
 ac7abff09db32e7d44719f0d0472dc64  gcc/testsuite/gfortran.dg/hollerith3.f90
@@ -49025,7 +49312,7 @@
 fa2faf183145bf87d1497a8e18cf67c2  gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90
 901fdf8ccfce7240b5e2cfa3f7fcb07c  gcc/testsuite/gfortran.dg/integer_exponentiation_4.f90
 ebd2c7181d1d1a74fb8d92fa4d5dcadf  gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90
-fcfb49c9fc1a86ba81cd5f03602cd781  gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90
+5436c9710c4dbacc08026642a5d88b2d  gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90
 9a94a4b4c3991300273d3eff16279572  gcc/testsuite/gfortran.dg/intent_optimize_1.f90
 6ad3133cfe62e722e018d386dbfd3404  gcc/testsuite/gfortran.dg/intent_out_1.f90
 56f012500f1600964f96a00b144bd1bb  gcc/testsuite/gfortran.dg/intent_out_2.f90
@@ -50114,7 +50401,14 @@
 4dfe5b03dbae8d8845caac4e7f7c0a89  gcc/testsuite/gfortran.dg/pr69155.f90
 f0a6995f73ec38a5c8e24e5d968a365b  gcc/testsuite/gfortran.dg/pr69554-1.F90
 fe55b4afdea6006daace9aa79199e551  gcc/testsuite/gfortran.dg/pr69554-2.F90
+68938073de3c2383615f40d0ec615519  gcc/testsuite/gfortran.dg/pr69603.f90
 c718be52c08cbfe5941dc1bb7a50bcb5  gcc/testsuite/gfortran.dg/pr69987.f90
+23dc11b0707086a8168e76c17d13d620  gcc/testsuite/gfortran.dg/pr70673.f90
+0e424f05f2fdeb786b877ace2617112d  gcc/testsuite/gfortran.dg/pr70931.f90
+a16162b0759105febc1efc1311184688  gcc/testsuite/gfortran.dg/pr71047.f08
+75b8abd1f0f9d2e236605ecc6792b9fb  gcc/testsuite/gfortran.dg/pr71204.f90
+dffe49f90e191f0e0d1a1c6f8d53f854  gcc/testsuite/gfortran.dg/pr71688.f90
+ea322d8eb84f224e47f5c54a96e8cd2d  gcc/testsuite/gfortran.dg/pr71764.f90
 6ff99f4b0021f30bee039a61db7cba9d  gcc/testsuite/gfortran.dg/predcom-1.f
 20a411a7e5a57891297c4c6a96d92009  gcc/testsuite/gfortran.dg/predcom-2.f
 80cf60710448ac2378aecda5fc4a57b6  gcc/testsuite/gfortran.dg/present_1.f90
@@ -50711,8 +51005,9 @@
 3318d144c2d4abef44dd2d14c35a6adc  gcc/testsuite/gfortran.dg/submodule_11.f08
 9542945224c8744c6179ede6b10e8b0d  gcc/testsuite/gfortran.dg/submodule_12.f08
 f52d9c0fcdf271bd2e5abda2cc3b4855  gcc/testsuite/gfortran.dg/submodule_13.f08
-afd5cd591a97b8e5a6e049931330c963  gcc/testsuite/gfortran.dg/submodule_14.f08
-475ea51fbff182674030048c7b52aaec  gcc/testsuite/gfortran.dg/submodule_15.f08
+04974d3f93910435057c4f73f05e14cd  gcc/testsuite/gfortran.dg/submodule_14.f08
+adcecf1db1bbd9194a601cae633dbba7  gcc/testsuite/gfortran.dg/submodule_15.f08
+76252beb42c84ee49919cc34174e21af  gcc/testsuite/gfortran.dg/submodule_16.f08
 97424405e3e17827757a639a19573fa4  gcc/testsuite/gfortran.dg/submodule_2.f08
 ac42e5598feef42b948692956c7ed537  gcc/testsuite/gfortran.dg/submodule_3.f08
 68f9f70d888318a31160ba732171726f  gcc/testsuite/gfortran.dg/submodule_4.f08
@@ -50931,6 +51226,7 @@
 0e692a977ecc4ab86f2eddee444794b4  gcc/testsuite/gfortran.dg/uncommon_block_data_1.f90
 6f108a647e3b73bca74907355e7a2d85  gcc/testsuite/gfortran.dg/unconstrained_commons.f
 2fb717fe29fa528056cd388b7064ce96  gcc/testsuite/gfortran.dg/underflow.f90
+39050472f0bc284f515f1898b0c79a2e  gcc/testsuite/gfortran.dg/unexpected_eof.f
 7b6179afe920e46575539bf900b34222  gcc/testsuite/gfortran.dg/unexpected_interface.f90
 deb2555ff248a9775b72c008e6de9795  gcc/testsuite/gfortran.dg/unf_io_convert_1.f90
 52c34a568acefcf68e800ca5c3b7f7e8  gcc/testsuite/gfortran.dg/unf_io_convert_2.f90
@@ -51812,6 +52108,7 @@
 e2983168c9a3f63dee423c9ab7489d56  gcc/testsuite/gnat.dg/c_words.adb
 818af14f525730860678bca32d713541  gcc/testsuite/gnat.dg/c_words.ads
 d52f72e41d04b3c98fb25494f2645bea  gcc/testsuite/gnat.dg/capture_value.adb
+9db4166fc85c98e9ec451ab5419d883a  gcc/testsuite/gnat.dg/case_character.adb
 4770f7aff2ceceb688301adf7cfb0c13  gcc/testsuite/gnat.dg/case_null.adb
 8847695c0d583376223247da04d2d2e5  gcc/testsuite/gnat.dg/case_null.ads
 1bf3fc0381b629fc3f416a475d1302fb  gcc/testsuite/gnat.dg/case_optimization1.adb
@@ -51878,6 +52175,7 @@
 00416c1ffc3228fc0f9bd2f529abeaeb  gcc/testsuite/gnat.dg/debug4.adb
 972c01247ac04a4b8e00f62a95d4f0fc  gcc/testsuite/gnat.dg/debug4_pkg.adb
 6ea95671601e0326e72591fbfc5de13a  gcc/testsuite/gnat.dg/debug4_pkg.ads
+c1bc8b0ecc894424728b5b4911bf1cc6  gcc/testsuite/gnat.dg/debug5.adb
 11735efa0b9cef4f67d8e3f4899d5dcb  gcc/testsuite/gnat.dg/decl_ctx_def.ads
 1e3eab2cf62e279c000f95051138781d  gcc/testsuite/gnat.dg/decl_ctx_use.adb
 d647ddf65b566e41973afeb047912147  gcc/testsuite/gnat.dg/decl_ctx_use.ads
@@ -52427,6 +52725,8 @@
 a6c7953bc37af2c4687583d602b5357c  gcc/testsuite/gnat.dg/opt51.adb
 3036c312a42a98f72343dcfb25c615a2  gcc/testsuite/gnat.dg/opt51_pkg.ads
 d715f4258a659b9f52add768ec0176d3  gcc/testsuite/gnat.dg/opt52.adb
+61534b77f2217dab18d66d63b8866b3a  gcc/testsuite/gnat.dg/opt56.adb
+589d51425474ad576aae93a10d95f178  gcc/testsuite/gnat.dg/opt56.ads
 e5e7ff61479fbeb7973786d07f72ba84  gcc/testsuite/gnat.dg/opt6.adb
 87097de987361854f4c5179a6de42c2c  gcc/testsuite/gnat.dg/opt6.ads
 a441d166cc0d4b34342468308b350060  gcc/testsuite/gnat.dg/opt7.adb
@@ -52529,6 +52829,8 @@
 a69c0bfa5361221d9a3ccb55aba36f65  gcc/testsuite/gnat.dg/remote_type.ads
 5a11b23912d6e1695fe7b02ca1ab1e79  gcc/testsuite/gnat.dg/renaming1.adb
 bd812535e6617c5f4dde6719c8748277  gcc/testsuite/gnat.dg/renaming1.ads
+95d7703afe25fd090863c05ffcded594  gcc/testsuite/gnat.dg/renaming10.adb
+404005db149a5434ece08f5fccea5a18  gcc/testsuite/gnat.dg/renaming10.ads
 3afb13f37cfc3455f0f0be64d053892f  gcc/testsuite/gnat.dg/renaming2.adb
 1a954da0b1e7e11673319b058eb82146  gcc/testsuite/gnat.dg/renaming3.adb
 9c415422ce59266c9af89e8d3fd1df74  gcc/testsuite/gnat.dg/renaming4.ads
@@ -54379,7 +54681,7 @@
 bc3c7df09495f62a7ff924aeda27871f  gcc/testsuite/lib/scantree.exp
 fd4fe0b217182ec61ad209b8b9560725  gcc/testsuite/lib/target-libpath.exp
 f475e8e2d4f9bd50e1c4f5ee88955e99  gcc/testsuite/lib/target-supports-dg.exp
-2ca0216d437918962131c6e27c219116  gcc/testsuite/lib/target-supports.exp
+81a83339c4e05edfaa689434dae89de5  gcc/testsuite/lib/target-supports.exp
 cfcacc2a887c0ba90640d2646cdb13df  gcc/testsuite/lib/target-utils.exp
 d0478737f0c5786d095c1ca581b0dafa  gcc/testsuite/lib/timeout-dg.exp
 ab858bda48392f10cfc775daebf0bbd8  gcc/testsuite/lib/timeout.exp
@@ -55328,9 +55630,11 @@
 10d4ea2c47febed0bbc5688f380b3439  gcc/testsuite/objc/execute/static-2.m
 a57e521085412bbde60e78229ace4fd5  gcc/testsuite/objc/execute/trivial.m
 2d60a6650416d3bcd6a3f5f1fb61dece  gcc/testsuite/objc/execute/va_method.m
+03f60b73f1fbd1151f587782de731364  gcc/testsuite/opt55.adb
+2f8548e74c5a464d97ac0283d9d45017  gcc/testsuite/opt55.ads
 8e810400df215d5a3c3a5918414f2567  gcc/timevar.c
-dd062f4defa1af2bf819c4c11f39b79a  gcc/timevar.def
-e105ea612b809c4eb10d1f55004990f0  gcc/timevar.h
+270ecff76752a63ed71a9cd892884668  gcc/timevar.def
+5d6d78630ce2cf12488bfb9fba34b7da  gcc/timevar.h
 1db6f2e372b1af92e0671da08d9bae7b  gcc/tlink.c
 67e5012a5b3f405f6257abc6a945e73e  gcc/toplev.c
 4b9e8fd609c1573d9fd5d43bde33866c  gcc/toplev.h
@@ -55346,7 +55650,7 @@
 f713f4da05f4d4a13d250939a5eb4703  gcc/tree-cfgcleanup.c
 00f42379eee5485bfc493cb60e0d7d5b  gcc/tree-cfgcleanup.h
 aca1f99bd5df778be73f5678d6f93360  gcc/tree-chkp-opt.c
-7f29bc54f04d7bdb5d970c8ced9ce727  gcc/tree-chkp.c
+7e6ad67e923cf3b95ff981d14d0c4a1d  gcc/tree-chkp.c
 2ff57aba516c82bd2d6d9444d695ca7c  gcc/tree-chkp.h
 a5085f5177f0f41d2b8a37af4391a3c7  gcc/tree-chrec.c
 43ea0ae76ce17d30b45a0433304ef5b7  gcc/tree-chrec.h
@@ -55366,17 +55670,17 @@
 735714950a7040219bdede8abc940737  gcc/tree-hash-traits.h
 4646d637e5cb964a4e6ad3a2589d1cda  gcc/tree-hasher.h
 4bbc44b137c67f0e938bded3978e7037  gcc/tree-if-conv.c
-30043a2564222962bda8aab68b1f7255  gcc/tree-inline.c
+c4c7b3c7029ba618985649e12ee59731  gcc/tree-inline.c
 38646e6febfe5a1052ade3533870efa3  gcc/tree-inline.h
 0f77f4c320b8b8381c286d3e856c6093  gcc/tree-into-ssa.c
 fd4c3d5580777d50b0274967152c64a0  gcc/tree-into-ssa.h
 222c5d841b6028c827eae9f43d0f4d20  gcc/tree-iterator.c
 395c4cd006e9cc4fac2ccacbb10dc907  gcc/tree-iterator.h
 01811cd206083ef2a619b39628839651  gcc/tree-loop-distribution.c
-47d8ad95b524f5ccaab1a2df951d9ddb  gcc/tree-nested.c
+3e9bbd47ca0a40ea54d1fd57a83164c8  gcc/tree-nested.c
 89c3120b4f9580284e45b7c3b4a302d4  gcc/tree-nested.h
 f5b4890f3ea137bd50a75635cdf58410  gcc/tree-nrv.c
-f1b1405192c96ea15ae6e64f005f0761  gcc/tree-object-size.c
+f68eba59616ea0d71903e45ebf4f301b  gcc/tree-object-size.c
 09aeb8e8a96f12d60fd3221cd8bbd33c  gcc/tree-object-size.h
 bfdff86bbeca1fa7f1812fcf614346ef  gcc/tree-outof-ssa.c
 d54568e25cf2ea37efc4fdbdb7cc946a  gcc/tree-outof-ssa.h
@@ -55391,13 +55695,13 @@
 99a21e7e99ce428caf4aff51ca2328a3  gcc/tree-profile.c
 c4a672c5b34898471e4c09cd7d897c6f  gcc/tree-scalar-evolution.c
 ddd74c800272e36b5e04e6b839d5aaf9  gcc/tree-scalar-evolution.h
-b1365506126df71ada53674e6e684695  gcc/tree-sra.c
+fc0f9a64091d8fb69026693b3385fafe  gcc/tree-sra.c
 5cbd1c07136c29a87b15ca8006f24649  gcc/tree-ssa-address.c
 1fb91694b7ea342f3f4755974d570401  gcc/tree-ssa-address.h
 630bd55e80d8b02f04bf9979745e5eaa  gcc/tree-ssa-alias.c
 b2112211d28a5a985396b2b827acfd25  gcc/tree-ssa-alias.h
 9a7c8e81ccb787bb00b0ee8ef2a71586  gcc/tree-ssa-ccp.c
-f14c1971c50057b0efda7772baa2d122  gcc/tree-ssa-coalesce.c
+4e0e13ee3807e5c0daad9489f9fd55d2  gcc/tree-ssa-coalesce.c
 0a798eb3055ef1b38167cee71723befe  gcc/tree-ssa-coalesce.h
 d655d555dd2ea00da5e0e3cfe76f03a6  gcc/tree-ssa-copy.c
 7430a47cea2356d7083f6b39087b46cc  gcc/tree-ssa-dce.c
@@ -55418,27 +55722,27 @@
 037e46f901b04e1897e0f5338070fceb  gcc/tree-ssa-loop-niter.c
 e39c11a700556495027cf2594eda607e  gcc/tree-ssa-loop-niter.h
 7206349f9866f4040378a141a4a3fc10  gcc/tree-ssa-loop-prefetch.c
-84aa2feb3f8ea51e2cc8fe865216939a  gcc/tree-ssa-loop-unswitch.c
+cedc12f866ad14c0ce0ff80357554e21  gcc/tree-ssa-loop-unswitch.c
 7b56fac467e6a65d335907e274999ddb  gcc/tree-ssa-loop.c
 4c430ffbb3398e58ddeb42580926a06a  gcc/tree-ssa-loop.h
 83739b381655c7ccd1da3706e62f763a  gcc/tree-ssa-math-opts.c
 09e6cc3a775fe10a83c1b13a20ff8ad5  gcc/tree-ssa-operands.c
 ae2259e78bf92cdab02fb8c53b1f6140  gcc/tree-ssa-operands.h
 169a3b8b19b7f59128b8fe9f320c7fcd  gcc/tree-ssa-phionlycprop.c
-49410965fa7b486577975e8debd36e2f  gcc/tree-ssa-phiopt.c
+b85be844891ced7fd987529031c3d383  gcc/tree-ssa-phiopt.c
 27c779dd8cb8a44e82d9efddf8d5e8e1  gcc/tree-ssa-phiprop.c
 b203f1a7e87223f4283cef39502baa59  gcc/tree-ssa-pre.c
 6eca612875babdeead518212272356c7  gcc/tree-ssa-propagate.c
 2c2fdda0693f653ff6694bec50f9c6be  gcc/tree-ssa-propagate.h
 33d8e1cb9a77d4f2092ec76958543645  gcc/tree-ssa-reassoc.c
-c657927d72df8ff9c34292cc1f741095  gcc/tree-ssa-sccvn.c
+db75889847d8554f03c878a71e52ee38  gcc/tree-ssa-sccvn.c
 bf9606517975c072a298e6e9648d84fe  gcc/tree-ssa-sccvn.h
 27f3203e67b17d43acb249774afcce00  gcc/tree-ssa-scopedtables.c
 faf7ec5d35f4c8016f9e652447e47297  gcc/tree-ssa-scopedtables.h
 b5d1efde969440d8b72d27d076a0ded2  gcc/tree-ssa-sink.c
-46a7699a73f5e5286886d89d2bd5de52  gcc/tree-ssa-strlen.c
-33dafcfeaf6c84a5506cc3816c86faf8  gcc/tree-ssa-structalias.c
-1d75d06dc18c08ea9eae1d79c319be9b  gcc/tree-ssa-tail-merge.c
+5ca1b76e4fefc9dd0b6407eef1209e54  gcc/tree-ssa-strlen.c
+d738280db76fb802d569cd6be9d607d8  gcc/tree-ssa-structalias.c
+1a154f97147787cf927ca27f492d0000  gcc/tree-ssa-tail-merge.c
 a31830f7606f1d982bb91bfda1036ca7  gcc/tree-ssa-ter.c
 72d07b4d9955684fab7636c602c4b360  gcc/tree-ssa-ter.h
 f01de11598fc3072fc0b64a42e7d2825  gcc/tree-ssa-threadbackward.c
@@ -55448,8 +55752,8 @@
 cdc7062662420b220cbdf71ad079b3da  gcc/tree-ssa-threadupdate.c
 268d9ea686863a09a4d82c900aa4c453  gcc/tree-ssa-threadupdate.h
 2aceb281be597588bf8b234371f7f9b0  gcc/tree-ssa-uncprop.c
-8ea45b89bc709fa068dda47244128737  gcc/tree-ssa-uninit.c
-ddc52810a19a908dfb484ac2adcd0a8f  gcc/tree-ssa.c
+d5a1e950b0f1aec43c3cdc2e60194636  gcc/tree-ssa-uninit.c
+8144927d9c28207da8408d4fe6f74dd9  gcc/tree-ssa.c
 d10beb2794c644e7d51b66973cf5f119  gcc/tree-ssa.h
 462f5e30bf38034f61977d169ac9b1d7  gcc/tree-ssanames.c
 db5115461f6035db3ac2359d88de6bb6  gcc/tree-ssanames.h
@@ -55461,26 +55765,26 @@
 d582f891f95af854317037e4020c5f90  gcc/tree-streamer.h
 11bd30d126bfef5e25674bf369287718  gcc/tree-switch-conversion.c
 88fc834970e1ba32e98998d7ce7ecf09  gcc/tree-tailcall.c
-ff2c431cb2ebc6c957f22bf35b8a688f  gcc/tree-vect-data-refs.c
+3df1efa82963e06359c8d728ff0de39f  gcc/tree-vect-data-refs.c
 a78063c6f19eea041e35fe5515a935f2  gcc/tree-vect-generic.c
 318b8e4c49ce9ec44a055d34b947f5c9  gcc/tree-vect-loop-manip.c
-ca460ecf31dfad6c90712eb57309221b  gcc/tree-vect-loop.c
-59b33d1d3db9231379ab4bc62f42cdad  gcc/tree-vect-patterns.c
-fa66db0d8c17a25f34719a755a575ea6  gcc/tree-vect-slp.c
-05c56dc171e2656047de4e06c36f2cf0  gcc/tree-vect-stmts.c
+295d03e5d7392b0acca8257dea216f96  gcc/tree-vect-loop.c
+799481f961907f33717a68493fea6818  gcc/tree-vect-patterns.c
+c2b28b1f389315c73c5ffce684eb42a1  gcc/tree-vect-slp.c
+6b5219bb5e6297fb4ca0981626118339  gcc/tree-vect-stmts.c
 7729076c55712e0bfb562f337107c400  gcc/tree-vectorizer.c
 99cdf0e00b25ff01da509c7f6bd7f8fd  gcc/tree-vectorizer.h
-357a693e48ab9a122428746f6bbda9c9  gcc/tree-vrp.c
-41531148c5417dcde8dba9bf26c66867  gcc/tree.c
+519f725a2fcd44fc90e9a7b380b3f9ba  gcc/tree-vrp.c
+f90241266bdebc4600cc5d1f2d672654  gcc/tree.c
 756c1546f4b1318f8d59106e5a786041  gcc/tree.def
-d3ec69521a1c446bbd5dc30b78fbea7c  gcc/tree.h
+8f21fb5a83ef2833a239d86c64c6fe49  gcc/tree.h
 59d18b65bc8897bea70f8d136681423f  gcc/treestruct.def
 7a21c960d344023b96194e4bc4625c10  gcc/tsan.c
 59b8e58a7954f6d352d923f0bbdd24ba  gcc/tsan.h
 4fcf15c72e56a3360214b87bd3df82de  gcc/tsystem.h
 abc8eba4119c9cb0bc421df5afb01334  gcc/typeclass.h
 572fb9b575cab50b68cebce0e6aaab5b  gcc/typed-splay-tree.h
-e32ea98c8ae093ac3b194bfcdff55030  gcc/ubsan.c
+c7235fe9fe050b768fe698d0edf40e4a  gcc/ubsan.c
 81e340a3b45094070fa00910435108f6  gcc/ubsan.h
 7435de97b351df3a173bb3259cdfa730  gcc/valtrack.c
 fd43fe3f222442739550a35e7bad2e4f  gcc/valtrack.h
@@ -55610,7 +55914,7 @@
 68395a53adb86132c753b865a97f49e5  libada/configure
 dc03104644ef27c11606ab0f4f675f06  libada/configure.ac
 46d3fe6da7a771cc2d5420c4137a6861  libatomic/.gitignore
-a748d5a529fba14ffb71ba76af37f394  libatomic/ChangeLog
+c6d6b7a83aac18a7ec19f90d870b4223  libatomic/ChangeLog
 f7e487a2a8e032a211ad21a5681e4b55  libatomic/Makefile.am
 685ebec1fe8aa94deb1729b48bb2fc6c  libatomic/Makefile.in
 f7853b06953072a9987a45a5b00782d6  libatomic/acinclude.m4
@@ -55630,12 +55934,14 @@
 3a5510d41511e835335114b73128a52e  libatomic/config/posix/host-config.h
 2ef059ec5908eac5b9f19da9e90e4717  libatomic/config/posix/lock.c
 d04f86e742ddfedb71fb4a3d0ceede39  libatomic/config/powerpc/host-config.h
+9bf3d2dd5ae558a4d9ab5b393b86c96b  libatomic/config/rtems/host-config.h
+472ff64130ea77e3d5e080beacca1fa8  libatomic/config/rtems/lock.c
 fc9523d1ea4e96a55adfb15c3031cf12  libatomic/config/x86/fenv.c
 e87431bfab4d41697b1e7bfa18624f2f  libatomic/config/x86/host-config.h
 5343c7f0d7449e34a4123a65183e280d  libatomic/config/x86/init.c
 6c35813a8871f271868fb796ae4b6e4a  libatomic/configure
 db061ec219987557cec2ae3ea3c97870  libatomic/configure.ac
-05354b654eadd0af2e2aa91621996955  libatomic/configure.tgt
+0b2f1d581b06d5e45b083e9759ffeef0  libatomic/configure.tgt
 bea3c296a69d67a89a6da22714ca34d4  libatomic/exch_n.c
 b899afba4d403aec004c33141df2324d  libatomic/fadd_n.c
 ee6f02fad9bd551a906477f16740578f  libatomic/fand_n.c
@@ -55692,7 +55998,7 @@
 8a7308fda7ed1543cb9e3be0f8e47bce  libatomic/testsuite/libatomic.c/atomic-store-5.c
 40618200985a15bcba64f871863da498  libatomic/testsuite/libatomic.c/c.exp
 97b0c9cdfcb733664bdf4efe0f5dc449  libatomic/testsuite/libatomic.c/generic-2.c
-5af0cf98353185e14ab202d5134d1a07  libbacktrace/ChangeLog
+6e3d18e0325321481dd8fc6b0c938244  libbacktrace/ChangeLog
 eb3a88b53140eb234a99a4b3a55e56bf  libbacktrace/ChangeLog.jit
 adcff7cabf0971aed26d7fe5e3630a23  libbacktrace/Makefile.am
 a4bbeef6b43604c1ca251b56c1bc4888  libbacktrace/Makefile.in
@@ -55708,7 +56014,7 @@
 ba93ae2239d2af1adfed22f2fa91164b  libbacktrace/configure
 f2bbca83f94ce0b40a14c2014386aa1e  libbacktrace/configure.ac
 150cbd2ed23f310bcc41f347e524098e  libbacktrace/dwarf.c
-cc7a845678c203d3820e434fd187feaa  libbacktrace/elf.c
+210330106bbc3adbabf0934be8ff1b60  libbacktrace/elf.c
 ccbfca5254d57415f02229b05852fe4c  libbacktrace/fileline.c
 51926f4b28baf759f214371541616bd8  libbacktrace/filetype.awk
 4a1619d74095c0d90ed2047cfe801a8f  libbacktrace/internal.h
@@ -55747,9 +56053,9 @@
 7b5e3c71c404e08cbe1d3ca92449c0eb  libcc1/plugin.cc
 595b9a542a8f80367ebbeecbc51b1ac7  libcc1/rpc.hh
 14f215429d450a743fce24b101552f3e  libcc1/status.hh
-a90aa9053a5c89426bbbe4367988cf16  libcilkrts/ChangeLog
-4fa054d244a7b7a99d1173bc6c24ff2c  libcilkrts/Makefile.am
-f837283c8a4f9034983ce5d009c42546  libcilkrts/Makefile.in
+45b9413325d303caf626b976ded66a4e  libcilkrts/ChangeLog
+df0ff198f37089171b490f87912f9602  libcilkrts/Makefile.am
+71d9f8e3f82862af1e8d523b0ae6a587  libcilkrts/Makefile.in
 4a307b1474cad63768b2ae0c183b6259  libcilkrts/README
 6126c8d03f6c3cc1a2f5e502f3196cd7  libcilkrts/aclocal.m4
 991e7c85d4800532c24900dc8e2f9e11  libcilkrts/configure
@@ -55883,50 +56189,29 @@
 8b169f1ea64fbdcd4eb3b28cc2a20e5d  libcpp/makeucnid.c
 13e85e048fd80372c5ee39c177ccda58  libcpp/mkdeps.c
 2037cc2be924ca9b3d6dcf813bb1f5a5  libcpp/pch.c
-7f8703b9dde7cc96a7b38b846eb0edda  libcpp/po/ChangeLog
-16add93743f11e9d1d0205a04e4bda1b  libcpp/po/be.gmo
-1559c0a42bd004e676cda54ca272f453  libcpp/po/be.po
-93772efdb39bca70542c9eb4cfd69115  libcpp/po/ca.gmo
-abc67e73d2df075360bb47d03f966a60  libcpp/po/ca.po
+e19317ae35b73c8ec3b221f66011547d  libcpp/po/ChangeLog
+2ef89459bd607154106cddd9d5643379  libcpp/po/be.po
+a1a6f36f6fb1c4f5a648dcd391370e6c  libcpp/po/ca.po
 2eaff30752e253bbc6a6f3147f29ae27  libcpp/po/cpplib.pot
-f4665bf2cfc8ea52a9c5dcd603b4c87d  libcpp/po/da.gmo
-291ea628726a545a31faf6e603d06a2e  libcpp/po/da.po
-183186721a93f35ebe5cb5efef452541  libcpp/po/de.gmo
-129478a9526671f9f1aeb11c29ee4417  libcpp/po/de.po
-50dcba779ef25b226362151a23815e88  libcpp/po/el.gmo
-904c98c8ea71a366440f9b040ba6fde8  libcpp/po/el.po
-8ecdc42ad242ed543e6024cc56a48ef5  libcpp/po/eo.gmo
-a7b5efb5f3491c3e787d25790c599713  libcpp/po/eo.po
-603c006aec9cb9504359e7f20c6dab7f  libcpp/po/es.gmo
-d1b55d77237726db4bd7a3b1d30a0c6f  libcpp/po/es.po
-0f532ddd0b5a92abe2c8620bdcf23d32  libcpp/po/fi.gmo
-fe350d53bed05a2b47fc8fff10fcaaaf  libcpp/po/fi.po
-55e47fb744d48b8e20159311c0a4c0cb  libcpp/po/fr.gmo
-58c29873a41dfefa30d2aff45818ae54  libcpp/po/fr.po
-39ddd555e334249c8130e512452c8fc3  libcpp/po/id.gmo
-48482d6240ce173ee2d785d5a2eaa743  libcpp/po/id.po
-37ed1f49679dbc578a78dc66a7ea3998  libcpp/po/ja.gmo
-36d7c68b0bd77115142ff130d0b0bfae  libcpp/po/ja.po
-fd30c6f79433b2872abe0a2217fbd291  libcpp/po/nl.gmo
-3f6ebd19290c98eea7cef9914f9654d8  libcpp/po/nl.po
-94a998c3581a719af78c5cdf216fad18  libcpp/po/pt_BR.gmo
-0aaf233a0d7f79627ee398ea192bdd74  libcpp/po/pt_BR.po
-79b63b3694b5060a3b38fa8a8573db1f  libcpp/po/ru.gmo
-17e810f41cd8152d067ee843834605b9  libcpp/po/ru.po
-0d50dac9aff5591b5c493123801f5915  libcpp/po/sr.gmo
-456bf096ac10652d86537242aeb463c3  libcpp/po/sr.po
-3270d407f458f07423f181ee4a40fb53  libcpp/po/sv.gmo
-6f366f83d29717cdb9e64cbf89997abf  libcpp/po/sv.po
-a3a472f46bd1cd7bf3c58618f21cc54e  libcpp/po/tr.gmo
-1972ca01f7590354477a7256df8a6db7  libcpp/po/tr.po
-95e35a0dd2e18bc3ef2c510f396b0fcd  libcpp/po/uk.gmo
-f4e29e663311363944e207217605faa1  libcpp/po/uk.po
-eb9d4c6abf39c08631813497c1e88143  libcpp/po/vi.gmo
-ed63d3d462ea423d0e69dc4bfece599d  libcpp/po/vi.po
-ecdc35f641666bac52fcf050bcf706f3  libcpp/po/zh_CN.gmo
-1e612707435e6b2f431d0ea58b86b964  libcpp/po/zh_CN.po
-9c28154d3d01abba175e54808d337cf1  libcpp/po/zh_TW.gmo
-e936ed69aa5357776e3ff4842baaa7d9  libcpp/po/zh_TW.po
+278cf1b2cce22dea3763b28344886a2a  libcpp/po/da.po
+e89016e7c45ec01c20197636ede2cbd0  libcpp/po/de.po
+11c21873f5e6ec33ebfb8fd2edc15ae5  libcpp/po/el.po
+d8ed72c7d26634e8c95da70edb7bc372  libcpp/po/eo.po
+a424670f1e7c781212fcc8b6fc84fde6  libcpp/po/es.po
+0b9472443ff28c36c40f04f1a3088fab  libcpp/po/fi.po
+1355bfb80461bd6990de22e13e1f3544  libcpp/po/fr.po
+dbefe42ad79c2a361c8d2874a638509b  libcpp/po/id.po
+e8d46de87f8be79612a738a3364a9953  libcpp/po/ja.po
+74c354860e824a03efc4a4d0a0f7f5af  libcpp/po/nl.po
+ad9e0f793ad848abb020dd1582d7c506  libcpp/po/pt_BR.po
+9718e0dd8553312042790da1bd8ed557  libcpp/po/ru.po
+2aa02b3cdd59ca4f029ff1e84e5baf58  libcpp/po/sr.po
+474e69915194f83eb88ad85ae241016c  libcpp/po/sv.po
+1d16e54e582bc5236bed93a33fb6baa5  libcpp/po/tr.po
+c0676321d8fd8f22839d400145a59e55  libcpp/po/uk.po
+097c8a713da9fbb048eca497169f9e93  libcpp/po/vi.po
+52fade796713669a418cd39a18e2c750  libcpp/po/zh_CN.po
+10138794552573c15bfc3be6c6e35235  libcpp/po/zh_TW.po
 f4fb93166f911a7496d4dd7cd1e57f8c  libcpp/symtab.c
 1b0ca94d69c0fcdb8b4a544998579e84  libcpp/system.h
 5faa90d66b891533b7d68fa1dcc88bf8  libcpp/traditional.c
@@ -55996,7 +56281,7 @@
 1b8d5bd512629f5b4d1895fe4dd2c645  libdecnumber/dpd/decimal64.c
 33e09faa8cbe6117509446874a776fc6  libdecnumber/dpd/decimal64.h
 0f6db29710e7075c2fd62bc4478b3b8d  libdecnumber/dpd/decimal64Symbols.h
-a3e0d6f60a337a91aecc3dc56e0acda6  libffi/ChangeLog
+bf52041046c368175a62277d781b7dc7  libffi/ChangeLog
 ba66fc19311348d373ec271be939a659  libffi/ChangeLog.libffi
 fbbc216bc25d759a72ea3e6d734af56b  libffi/ChangeLog.libgcj
 d946d2b97454ad50a1dbfbf48923c5be  libffi/ChangeLog.v1
@@ -56009,7 +56294,6 @@
 60bcb183fb531852628fcecb1ea6ed66  libffi/configure
 c9655a9cea2ec7adcdd5ca72cb247b90  libffi/configure.ac
 84d2d9f2ebfac28a1697db5dc956a25b  libffi/configure.host
-b966104ceafa5618f9898a1a3bb1ca13  libffi/doc/libffi.info
 cfec4a5a1bb5d36550e15ac051c14148  libffi/doc/libffi.texi
 2969ffc23f66d73392207633f25ab252  libffi/doc/version.texi
 22b7acb3b27a7bc2c6d5e436e1944367  libffi/fficonfig.h.in
@@ -56158,7 +56442,7 @@
 2e5e042bd1709c208dd670c61bbc5ef1  libffi/testsuite/Makefile.am
 e52378e7fee52f7a3af3b8e8267c4c15  libffi/testsuite/Makefile.in
 dce80ba7e038ca18591aabc6d3d2582c  libffi/testsuite/config/default.exp
-0cfcd6f2d3b7c42d7e918c631681ad09  libffi/testsuite/lib/libffi.exp
+cff6a796e12fcc98d74bd98cac4cdf67  libffi/testsuite/lib/libffi.exp
 88f888c66cee8d916e1ac91000ecc87a  libffi/testsuite/lib/target-libpath.exp
 68db067550882b3b091a82df87310fff  libffi/testsuite/lib/wrapper.exp
 e2b2182b50885f833527f9ccc86eeaa4  libffi/testsuite/libffi.call/call.exp
@@ -56354,9 +56638,9 @@
 291be426192f460f6a07dfe1c96ab094  libffi/testsuite/libffi.special/special.exp
 93fc3ea311b79f64004992807ce75d1e  libffi/testsuite/libffi.special/unwindtest.cc
 185d0795017fbbe253a13db8e34085f9  libffi/testsuite/libffi.special/unwindtest_ffi_call.cc
-1863571149697e4b63ce3f4a6271960c  libgcc/ChangeLog
+fbddbb651e2206a97d9d80ba4ba1e9fc  libgcc/ChangeLog
 d35f709a03da6e07d660c91956551a36  libgcc/Makefile.in
-a6e140bfee349c6b1e07f463c967a52a  libgcc/config.host
+bee9ede19588ab9e5fc65f2f422488b2  libgcc/config.host
 3b9d11b9f405d47c079d725f2f16271e  libgcc/config.in
 c1dd89f96f28e8843a51c0c7b560c6c7  libgcc/config/aarch64/crtfastmath.c
 9dca9ad5de19b368a1b3ec83a660a34f  libgcc/config/aarch64/crti.S
@@ -57280,6 +57564,8 @@
 32d9de959d3c6e0ae0519a32b9019cf1  libgcc/config/rl78/t-rl78
 48a7e3ef8d25dc3fe190d63c81df0ccc  libgcc/config/rl78/trampoline.S
 760912f22e59adbfe0317ee3df1b4849  libgcc/config/rl78/vregs.h
+c8d40dfa3c5da5264575681c125cf8e5  libgcc/config/rs6000/_divkc3.c
+6b20fcda7294bd54b5687f751561cae1  libgcc/config/rs6000/_mulkc3.c
 c16e3f7c33fc7e6d7b9fc3848e9fef80  libgcc/config/rs6000/aix-unwind.h
 737841f917469789a5f925e6f08da1de  libgcc/config/rs6000/aixinitfini.c
 d8742cbcf2910ae155f782fd708e4650  libgcc/config/rs6000/atexit.c
@@ -57343,7 +57629,7 @@
 be7356b9f07a2aec27b9513356b579bb  libgcc/config/rs6000/morestack.S
 f509faf6a043b7f628b9a5b7b64497c7  libgcc/config/rs6000/on_exit.c
 aa98229d1fb7829c9c2736a6f235b935  libgcc/config/rs6000/ppc64-fp.c
-0e804e76a84bf2fe403fa63a69cbe8f2  libgcc/config/rs6000/quad-float128.h
+5decdd89de7b5048dcc33ea7e516457b  libgcc/config/rs6000/quad-float128.h
 aba354b12ccddf23281f544a4b3c446a  libgcc/config/rs6000/sfp-exceptions.c
 8ec74aa9b81fc396f992f9900794bfc0  libgcc/config/rs6000/sfp-machine.h
 692f688b65e81676c6fe126268165355  libgcc/config/rs6000/sol-ci.S
@@ -57354,7 +57640,7 @@
 d7cdc73d7a8e658f872ea07474837bc2  libgcc/config/rs6000/t-darwin64
 f809b3f51cd4c6b7b1b2a01f98f5917a  libgcc/config/rs6000/t-e500v1-fp
 9553248d1ebf726cfc8ab5c14e739322  libgcc/config/rs6000/t-e500v2-fp
-f7b847fe7c81592dd38f899900b92306  libgcc/config/rs6000/t-float128
+b9b0914220774c0a3a5958018b9adf0d  libgcc/config/rs6000/t-float128
 6b46d6077e82665fed06030e9dbf0d0c  libgcc/config/rs6000/t-float128-hw
 491851bed60093e210455661abd50ba3  libgcc/config/rs6000/t-freebsd
 4976aac1da0b181cf133fe8ef7243000  libgcc/config/rs6000/t-freebsd64
@@ -60580,7 +60866,7 @@
 1526040f769ea611af781d4ed150f258  libgo/testsuite/gotest
 ead4e721beb57b319fcd7da8ddf10705  libgo/testsuite/lib/libgo.exp
 6df485581d2f02246f41b5ca46f5bb5d  libgo/testsuite/libgo.testmain/testmain.exp
-9befdbc414a14f64f3bf9d882a6cc3d3  libgomp/ChangeLog
+e2942a09bb570e700d8ab4230a14bce1  libgomp/ChangeLog
 0d55aa862aee66efdc5f8d62c94ff8fb  libgomp/ChangeLog.graphite
 255738c9562136c311d799ad06684be1  libgomp/Makefile.am
 a97552ea29bea4babb0d125f47fbc5f9  libgomp/Makefile.in
@@ -60693,7 +60979,6 @@
 2a682110865cc758a3c1df97dd3992a3  libgomp/libgomp-plugin.c
 dd8799786633c7a3094553dfc8a9ca8b  libgomp/libgomp-plugin.h
 99fefc96d4bc2d4b96c65131330e2c70  libgomp/libgomp.h
-4bec48b377f524140d3caa7eea71c995  libgomp/libgomp.info
 9a1ab09c02391af1c95e6d63cb8eb499  libgomp/libgomp.map
 8b2aa50aecad82171348a6918309afd6  libgomp/libgomp.spec.in
 6a91bc2eda39d9eddffc49cbcb5e07f2  libgomp/libgomp.texi
@@ -60910,6 +61195,8 @@
 f7b3ed0affdfcdc8be33426e55f56c65  libgomp/testsuite/libgomp.c++/target-19.C
 a7edc8ba5a137d69a617a4d3675b5b01  libgomp/testsuite/libgomp.c++/target-2-aux.cc
 adba67f432b50b18b63fd983c7c0402a  libgomp/testsuite/libgomp.c++/target-2.C
+37e4e40177aed08ff1f53d7b901a11ce  libgomp/testsuite/libgomp.c++/target-20.C
+0348df8a93fdb7c3f0a0f7923eb9555c  libgomp/testsuite/libgomp.c++/target-21.C
 f5f370945da4ed9519d04fd309672472  libgomp/testsuite/libgomp.c++/target-3.C
 da31150d5d916f6dc9bde797015a2f2f  libgomp/testsuite/libgomp.c++/target-4.C
 1ef24f8ab6abe7b7355060391f0ec986  libgomp/testsuite/libgomp.c++/target-5.C
@@ -61207,6 +61494,8 @@
 37da387849a1a7da3f75e528c47ee2cb  libgomp/testsuite/libgomp.c/pr68960.c
 9995ebc7d239ebe751419090068c6f33  libgomp/testsuite/libgomp.c/pr69110.c
 fae0065b967df85f2d4ef6b0d6a27837  libgomp/testsuite/libgomp.c/pr69805.c
+44e637116f58b1ad19c190f3b5a123fa  libgomp/testsuite/libgomp.c/pr70680-1.c
+2c3d1f7b987fcb66ad2f7ba2adc2dc73  libgomp/testsuite/libgomp.c/pr70680-2.c
 2a0a447db3ae892c0c62b0136b00360e  libgomp/testsuite/libgomp.c/priority.c
 ea7c9e74bda402b1663a903b26400fab  libgomp/testsuite/libgomp.c/private-1.c
 a594cebdf052900dd0c8792068e14d85  libgomp/testsuite/libgomp.c/reduction-1.c
@@ -61350,6 +61639,7 @@
 6116086a89b906c26bd9afe26e57a07a  libgomp/testsuite/libgomp.fortran/appendix-a/a10.1.f90
 ba05d0e1b584ec6c750d14a486ac83b2  libgomp/testsuite/libgomp.fortran/associate1.f90
 41cd3ed9183e6bc7b20ef8836663fbdd  libgomp/testsuite/libgomp.fortran/associate2.f90
+aa03f95280189c0147b6c2ec288164ba  libgomp/testsuite/libgomp.fortran/associate3.f90
 cb0b79f7bddc47118981784eb7ba6f75  libgomp/testsuite/libgomp.fortran/cancel-do-1.f90
 2a5fe3d97ff9f23e08df5e015a45e3bc  libgomp/testsuite/libgomp.fortran/cancel-do-2.f90
 a110324b7cb72dc5755c1ad39c5230fd  libgomp/testsuite/libgomp.fortran/cancel-parallel-1.f90
@@ -61575,6 +61865,7 @@
 f3d2ea4630d1fcb25d84b6ba89ae47f2  libgomp/testsuite/libgomp.hsa.c/builtins-1.c
 6e3e2fc227f8fad61ddcb85fcddd983d  libgomp/testsuite/libgomp.hsa.c/c.exp
 27fb32a6a737ec1b4f131bda0a196191  libgomp/testsuite/libgomp.hsa.c/complex-1.c
+7c0ddbedd6b281bc9300f36374a8e5df  libgomp/testsuite/libgomp.hsa.c/complex-align-2.c
 9ca2d40b0829f30ffd252bf29d77c6f6  libgomp/testsuite/libgomp.hsa.c/formal-actual-args-1.c
 566a787a23dbfd923ff41ba6a4a30736  libgomp/testsuite/libgomp.hsa.c/function-call-1.c
 a4130e550c56fec85239c9db68e18fdb  libgomp/testsuite/libgomp.hsa.c/get-level-1.c
@@ -61587,9 +61878,10 @@
 dfc590b024995313958247342296f179  libgomp/testsuite/libgomp.hsa.c/rotate-1.c
 bfac6d74739b95deba27861d2be18215  libgomp/testsuite/libgomp.hsa.c/switch-1.c
 e410b9a2ecc042fbefbbbcff667b3510  libgomp/testsuite/libgomp.hsa.c/switch-branch-1.c
+ca9f24c1fc8b56e57a5e25787159b637  libgomp/testsuite/libgomp.hsa.c/switch-sbr-2.c
 e4d2b044d4aee116d4062f8d22fe1113  libgomp/testsuite/libgomp.oacc-c++/c++.exp
 b27cecd237d0e2ce459988833e90f28a  libgomp/testsuite/libgomp.oacc-c++/declare-1.C
-50a71d368a1d2347284a608ab6a629aa  libgomp/testsuite/libgomp.oacc-c++/template-reduction.C
+4b124b6e487c75fcb15e9f0e8d1f85b5  libgomp/testsuite/libgomp.oacc-c++/template-reduction.C
 451978dda3b58f6a597aa1b515da90e7  libgomp/testsuite/libgomp.oacc-c-c++-common/abort-1.c
 2187ea0d1f3ce15e1d66e17ed2fecfc6  libgomp/testsuite/libgomp.oacc-c-c++-common/abort-2.c
 659c1e7c321078b832a4fe638bb81184  libgomp/testsuite/libgomp.oacc-c-c++-common/abort-3.c
@@ -61603,7 +61895,7 @@
 7701cc2c5657c7e8793bdc8a296226d0  libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-2.c
 97f62618e6e37c14b2b9ed17c7579fd0  libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_rw-1.c
 276fea47eb47f5b846d12e7f4013aaa1  libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_update-1.c
-9ecb1a6355fa4295e382d463432d8e21  libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c
+b38b68cea6a76f0b24d0695e8101f2cf  libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c
 1f516ecd3b6c4ad48b36e5fe908cae6a  libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c
 e69ad21264603585ada7277411b59fab  libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-2.c
 a4310590c76fb5671abb7e599593076d  libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-1.c
@@ -61611,6 +61903,7 @@
 89f08493dc1d069d2b20c950dc3daeb3  libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
 ca0f03a313f6823442da3d981e03bc9f  libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-4.c
 19f2f5601f95ec58b09b95258b0818b1  libgomp/testsuite/libgomp.oacc-c-c++-common/combined-directives-1.c
+958046e6274805975b0db25945fb2609  libgomp/testsuite/libgomp.oacc-c-c++-common/combined-reduction.c
 e05c73847f8ec27c6cb39c45216fcf0f  libgomp/testsuite/libgomp.oacc-c-c++-common/context-1.c
 082ce69140a390063d0f7f40d1eb2046  libgomp/testsuite/libgomp.oacc-c-c++-common/context-2.c
 223e42eece140c60f9e6b5befdcca4e1  libgomp/testsuite/libgomp.oacc-c-c++-common/context-3.c
@@ -61820,6 +62113,8 @@
 e65c44041c15898765a99f6782a191d2  libgomp/testsuite/libgomp.oacc-c-c++-common/vector-type-1.c
 ab9847c46ebba2b7d32c8dd686d0dd0c  libgomp/testsuite/libgomp.oacc-c-c++-common/vprop.c
 6a3ebccf985a3d14104d3ff79347af01  libgomp/testsuite/libgomp.oacc-c/c.exp
+cbdcc7dbb1bbfcb008b972db87d6a771  libgomp/testsuite/libgomp.oacc-c/nested-function-1.c
+009dee52db49f02bd518c318808bd4ab  libgomp/testsuite/libgomp.oacc-c/nested-function-2.c
 00763c45e9c4a49ef7249e327925090e  libgomp/testsuite/libgomp.oacc-fortran/abort-1.f90
 92672ea2291844ee4dc0b00666eb7766  libgomp/testsuite/libgomp.oacc-fortran/abort-2.f90
 c280f253738f9ec4dac767225d094975  libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90
@@ -61831,6 +62126,7 @@
 7c923f2a5e595d3e5bc0ae52b8c3b1d2  libgomp/testsuite/libgomp.oacc-fortran/atomic_capture-1.f90
 1239e7569c34d9842432ab6666cd411c  libgomp/testsuite/libgomp.oacc-fortran/atomic_rw-1.f90
 41253d0cb8d36acbbcd34b0461a3bb46  libgomp/testsuite/libgomp.oacc-fortran/atomic_update-1.f90
+c459a54e791263602dae13c9b38a66ad  libgomp/testsuite/libgomp.oacc-fortran/cache-1.f95
 2ccddd43e49018b56fe9e1a45e9f9901  libgomp/testsuite/libgomp.oacc-fortran/clauses-1.f90
 0d6c26df6be6cef756b12696e14e07b5  libgomp/testsuite/libgomp.oacc-fortran/collapse-1.f90
 5a8991a0764ce9b04257546e4fa5f658  libgomp/testsuite/libgomp.oacc-fortran/collapse-2.f90
@@ -61841,6 +62137,7 @@
 13468844967101467070cb7ac463c16b  libgomp/testsuite/libgomp.oacc-fortran/collapse-7.f90
 6b3128948ec46f6c5a25eb114b5fc9c4  libgomp/testsuite/libgomp.oacc-fortran/collapse-8.f90
 8c396e2144fc18a3de1818ae8108bda5  libgomp/testsuite/libgomp.oacc-fortran/combined-directives-1.f90
+3733716c9184c05cf46fd635d0943a6d  libgomp/testsuite/libgomp.oacc-fortran/combined-reduction.f90
 6306783e85f144ba81b9aac0fc341a71  libgomp/testsuite/libgomp.oacc-fortran/data-1.f90
 e8adb123c09781787869ea368c1fa278  libgomp/testsuite/libgomp.oacc-fortran/data-2.f90
 ce578dabaea526c76233d523eab686f7  libgomp/testsuite/libgomp.oacc-fortran/data-3.f90
@@ -61882,6 +62179,9 @@
 efcda465915ae848c58a3ea43c284842  libgomp/testsuite/libgomp.oacc-fortran/lib-7.f90
 e055a49425dde48525db5350406511b2  libgomp/testsuite/libgomp.oacc-fortran/lib-8.f90
 8166a0c9b27377f05eb06d5dd0735cee  libgomp/testsuite/libgomp.oacc-fortran/map-1.f90
+9dcc6a7c4180d3d892e5cdd3df4f088b  libgomp/testsuite/libgomp.oacc-fortran/nested-function-1.f90
+bd7a72425ffbe9f89587d5a5138fe462  libgomp/testsuite/libgomp.oacc-fortran/nested-function-2.f90
+a1fa3ef264aa86add5dc08b5e9bd4b89  libgomp/testsuite/libgomp.oacc-fortran/nested-function-3.f90
 a09b08acb0185066a021ba50ed1dacc8  libgomp/testsuite/libgomp.oacc-fortran/non-scalar-data.f90
 7702e59e2172a9499f765f4c9327f0bb  libgomp/testsuite/libgomp.oacc-fortran/openacc_version-1.f
 77ec7fb0079c057c097fef3a8693467e  libgomp/testsuite/libgomp.oacc-fortran/openacc_version-2.f90
@@ -61912,7 +62212,7 @@
 6d7b9ef24d9986c5e4cb3f32834b1653  libgomp/work.c
 99c2e5e712b990ee07be10f53e41f3fb  libiberty/.gitignore
 a916467b91076e631dd8edb7424769c7  libiberty/COPYING.LIB
-e4968519e78a8d9b3a6eb68364f43232  libiberty/ChangeLog
+dca230bedb414d8383bd5c94687b76e5  libiberty/ChangeLog
 347c31392973de6a4872d540c1718dc1  libiberty/ChangeLog.jit
 f925c3515902a26a68a6019f355abc56  libiberty/Makefile.in
 c68dbf7834af4281ebd84caa3fd54680  libiberty/README
@@ -61944,7 +62244,7 @@
 5824bd0f9be9f4fa74bb3bdc7fd9431c  libiberty/configure.com
 32149e9d61d873be9c2950bee2ae7137  libiberty/copying-lib.texi
 fe053283d3559af3ec5cac45f8ead009  libiberty/copysign.c
-c6b40d8511eeaeb0b11a26fee6683f34  libiberty/cp-demangle.c
+a246775fbbbac2ddc6a2adc29a33a106  libiberty/cp-demangle.c
 652cd1eb0406f7c91f9297b189af4715  libiberty/cp-demangle.h
 5868438b5b6c384018d526ccee754b8f  libiberty/cp-demint.c
 93007574a947e87f0a09933f28203e4a  libiberty/cplus-dem.c
@@ -62047,7 +62347,7 @@
 9e1bb6fe95ebb6415672ddf1da29ec65  libiberty/strverscmp.c
 6c6e2b1b21232455a5e54af57d46f959  libiberty/testsuite/Makefile.in
 69dd92f0372ec3a77e992bb9318dbdac  libiberty/testsuite/d-demangle-expected
-c22ce95c546f35923318dbdd235fb561  libiberty/testsuite/demangle-expected
+be18dcce0dfaec61638eb3172a13fe50  libiberty/testsuite/demangle-expected
 10ce55269f247e57d2901ee11e88d8bd  libiberty/testsuite/demangler-fuzzer.c
 8b476ce26e8583eea8df7d77fe287a5a  libiberty/testsuite/test-demangle.c
 d629c8f2adde10d53657e437416cf27f  libiberty/testsuite/test-expandargv.c
@@ -62132,7 +62432,6 @@
 ca06f6a22290f04aac1fc335ece29711  libitm/dispatch.h
 c4d7034d2f52d605b4b8f4644d0b669e  libitm/eh_cpp.cc
 f545350500de7fa7f56cff5f11802e73  libitm/libitm.h
-3619f31e0d1c048d49bf8b940ad76a78  libitm/libitm.info
 0c43820b921ecdbe9d98f068100e716a  libitm/libitm.map
 ea467d7117853d139bb288ab75261139  libitm/libitm.spec.in
 1c481e6f4cca694530ceaa0fdf2623a5  libitm/libitm.texi
@@ -62178,7 +62477,7 @@
 62d4ccb869b56e1e27163303bf2a85f0  libitm/useraction.cc
 3028050fc7e9c2aa747445850c00fe86  libitm/util.cc
 94d55d512a9ba36caa9b7df079bae19f  libjava/COPYING
-77b69809abcc46abd5e609709c803b57  libjava/ChangeLog
+3155232b54d6470236f6ff13fd9b4714  libjava/ChangeLog
 03e1f38b916604fdf1470238201325f3  libjava/ChangeLog-1998
 691acb61fbd6a2235826ff55db5578be  libjava/ChangeLog-1999
 b58c6701706771a02bf00a77666941ef  libjava/ChangeLog-2000
@@ -62259,21 +62558,8 @@
 b343eec566430e85d1f95c21438aa4ee  libjava/classpath/doc/api/Makefile.am
 1d310e1c7d51b6af013da87024dc9620  libjava/classpath/doc/api/Makefile.in
 5ddd829b35fc94b0cdb119084089edb8  libjava/classpath/doc/cp-hacking.texinfo
-862e32ddcce3928c53d25ceb1608b8f1  libjava/classpath/doc/cp-tools.info
 0349e5c38c548584225423ef4bafd20b  libjava/classpath/doc/cp-tools.texinfo
 3155d9bd9a7bf4aff2ff0dfe4a2cb878  libjava/classpath/doc/cp-vmintegration.texinfo
-9766e6c08e86644094f635b7c9f26311  libjava/classpath/doc/gappletviewer.1
-a13d380ac9cfbfab4d349255c7e2e583  libjava/classpath/doc/gjar.1
-620518f40be66424ca3f3554ff11d9a2  libjava/classpath/doc/gjarsigner.1
-99a3b53ff1caa9d501559d63c3f1a8ab  libjava/classpath/doc/gjavah.1
-8946f2588c6fc6b9ec95f3aa67dc0ebf  libjava/classpath/doc/gjdoc.1
-e23154e1fde98eb1e2a036311e26079e  libjava/classpath/doc/gkeytool.1
-e2138b41681a6410660c264ac6110b01  libjava/classpath/doc/gnative2ascii.1
-5f3880893ede4b0bda9592d85edbfe77  libjava/classpath/doc/gorbd.1
-2730c7c5094b36af6f622d423ac4415f  libjava/classpath/doc/grmid.1
-e12a5f4399bcd70334461eafe135ad3c  libjava/classpath/doc/grmiregistry.1
-9e8815d844b257ea8d78b6c8120512b2  libjava/classpath/doc/gserialver.1
-f2565826380e1f2dffe56404bb279a41  libjava/classpath/doc/gtnameserv.1
 f7edd2bbe78e9a7e7aa706fbfa6f467e  libjava/classpath/doc/texi2pod.pl
 01b23c87dcf82048a5958c8224653305  libjava/classpath/doc/texinfo.tex
 b1e0c0c30547d57d7a09b04d47c70b06  libjava/classpath/examples/.cvsignore
@@ -85323,7 +85609,7 @@
 4eaec6ec74d70ecea0976f23533030a8  libjava/testsuite/Makefile.am
 fb42187d8e0bcb05191ae145e2ad631c  libjava/testsuite/Makefile.in
 dce80ba7e038ca18591aabc6d3d2582c  libjava/testsuite/config/default.exp
-046515428f7068fa92b4af50db67e94f  libjava/testsuite/lib/libjava.exp
+12cddc134208161f95fe25d2b6ce9eed  libjava/testsuite/lib/libjava.exp
 5bc5f3c2b92712d89b8fa8d99293ad20  libjava/testsuite/libjava.cni/PR9577.h
 783e9ef77859cbe3613da93348196aa4  libjava/testsuite/libjava.cni/PR9577.jar
 1cb376d608ce588877129087d302ad27  libjava/testsuite/libjava.cni/PR9577.java
@@ -86189,7 +86475,7 @@
 434ac04eb066f5075299583492846410  libjava/verify.cc
 355440a0c2fb5e16259d7ae381b37ed5  libjava/win32-threads.cc
 434d5e5e91727dec004f0d1d1fab47ec  libjava/win32.cc
-f3fe0508b7217ee2f00578980c8b8c54  libmpx/ChangeLog
+1c2946e52a9e26c93e4b6fcd49671624  libmpx/ChangeLog
 38b5a5961bf81cf96b7905974a000dc2  libmpx/Makefile.am
 52ceef9cd663650f4d1d9c8e91656d14  libmpx/Makefile.in
 9883ed42b491d8aea83fdde90561cf2a  libmpx/acinclude.m4
@@ -86211,7 +86497,7 @@
 e67fb1bdc86e2be5473ab0192835f369  libmpx/mpxwrap/Makefile.in
 e7c62aca341ea472234d7cb0bc4af328  libmpx/mpxwrap/libmpxwrappers.map
 514fed0b52cdd26987101b36d86a7cf8  libmpx/mpxwrap/libtool-version
-e2c59f29f5e40b045f5ffb7b1b983c89  libmpx/mpxwrap/mpx_wrappers.c
+c32d22d10f53f727607e2159bb49c6c2  libmpx/mpxwrap/mpx_wrappers.c
 c281087ccf06b1126d489b8de6de6263  libobjc/ChangeLog
 b9ae0bf274b89fa44e8eee13ad306f00  libobjc/Makefile.in
 261388284fa6d545a9a911c95536c866  libobjc/NXConstStr.m
@@ -86379,7 +86665,6 @@
 bf09ede5c6d78e3d132bde0f933590d8  libquadmath/config.h.in
 e2528fdd401f4aa4949acf6b7472c6e5  libquadmath/configure
 29e66c9d2ef7b7621276c63bee20d622  libquadmath/configure.ac
-598ff623da7a336b4221c56150947711  libquadmath/libquadmath.info
 c4e13f3169f2de58d737acfdba76647b  libquadmath/libquadmath.texi
 77280bb7ee423875e03d9c0d34527df6  libquadmath/libtool-version
 f44065462735b4699d44588271a5f09a  libquadmath/math/acoshq.c
@@ -86503,7 +86788,7 @@
 a81cc82679e80c86cfbd5575867450d0  libquadmath/strtod/strtod_l.c
 da808e110fc09ebd41ebd405790a70df  libquadmath/strtod/strtoflt128.c
 d15a18f7c46ba2add6148edc5b7563c0  libquadmath/strtod/tens_in_limb.c
-0448d915a72917daa48bf8ca1e9263a8  libsanitizer/ChangeLog
+7fe19e70f12e02776cbac41f1a7ee6d8  libsanitizer/ChangeLog
 be9b1514f2ae0907d5459acd6331993d  libsanitizer/HOWTO_MERGE
 0249c37748936faf5b1efd5789587909  libsanitizer/LICENSE.TXT
 e9eb4a77cb6d1457005493aeef54478e  libsanitizer/MERGE
@@ -86534,7 +86819,7 @@
 de5adde40dad853f62e7f6f02fb39c63  libsanitizer/asan/asan_linux.cc
 68b329da9893e34099c7d8ad5cb9c940  libsanitizer/asan/asan_lock.h
 6e3e514ee98224b3d35eedd20f31dc69  libsanitizer/asan/asan_mac.cc
-6fb2bb576d0db871840b266caacf5b4c  libsanitizer/asan/asan_malloc_linux.cc
+7f4eda2466f1bea4ffea043b3ad74fb1  libsanitizer/asan/asan_malloc_linux.cc
 fe8e70d61f125f2574ee3f7cabb27f2b  libsanitizer/asan/asan_malloc_mac.cc
 a0ee9f2d00416a8d00d5ac0a4f3758d7  libsanitizer/asan/asan_malloc_win.cc
 0e28518acb95e6eafea10c5aaa44562a  libsanitizer/asan/asan_mapping.h
@@ -86822,7 +87107,7 @@
 e9ab923d2562bf5f5be6883dfb9f0184  libssp/strncpy-chk.c
 5e0d8b8a766c31b12354baec1b7a159c  libssp/vsnprintf-chk.c
 f56ab1f8922a16f7e9e4f5270ae1e34e  libssp/vsprintf-chk.c
-f1d092ccae45492fea4540383deb77bc  libstdc++-v3/ChangeLog
+71074b77ce0c343a8adaf3aff273b763  libstdc++-v3/ChangeLog
 7aa6c40440a44fcf5ec94c066160c2f8  libstdc++-v3/ChangeLog-1998
 7aff86600b6a1ed3fa87305075a92db0  libstdc++-v3/ChangeLog-1999
 a6f28e8fc9bb07696a9e068b439a3a87  libstdc++-v3/ChangeLog-2000
@@ -87499,7 +87784,7 @@
 4a4591228c96b08e8cfafd659ca4e914  libstdc++-v3/include/bits/boost_concept_check.h
 6c698861fbe30dd645b02cc9332c3cc9  libstdc++-v3/include/bits/c++0x_warning.h
 156583d00adec3e9c84f8cd3ab85473d  libstdc++-v3/include/bits/c++14_warning.h
-8ab4f9b79a29c20a2247731d46677e7d  libstdc++-v3/include/bits/c++config
+3391eba3a0b35521e3a211d2f69ddc63  libstdc++-v3/include/bits/c++config
 56792010974749b8b8d1f8f4a87bdff7  libstdc++-v3/include/bits/char_traits.h
 d4c48cb0855253bba8b25e24a6717ac1  libstdc++-v3/include/bits/codecvt.h
 8c6f43ad3e5d5237110200d354580da1  libstdc++-v3/include/bits/concept_check.h
@@ -87559,8 +87844,8 @@
 81a9105e594bdd4f31466efb0ea2591c  libstdc++-v3/include/bits/specfun.h
 a046bed66696adfb2a6c4a593d6a1e3d  libstdc++-v3/include/bits/sstream.tcc
 dca1017544bda4f3e231a60f4bfb96aa  libstdc++-v3/include/bits/std_mutex.h
-ccd3933342ad7b6b8f8eb265794edd01  libstdc++-v3/include/bits/stl_algo.h
-68a5fbc2687db7264a5ec538cab5ef20  libstdc++-v3/include/bits/stl_algobase.h
+11add78efd9f165a0d9767f4ef18f5e4  libstdc++-v3/include/bits/stl_algo.h
+23ea4a3aeea06844a671d0edb8f31227  libstdc++-v3/include/bits/stl_algobase.h
 243fe3e2f3c79e871cf74b93be35026e  libstdc++-v3/include/bits/stl_bvector.h
 5ca41a37aa22865a2e5acf8a62c8f437  libstdc++-v3/include/bits/stl_construct.h
 8fd1c24a11e47aa7313171f7d4fe3b0f  libstdc++-v3/include/bits/stl_deque.h
@@ -87723,11 +88008,11 @@
 23e7049f7e8b7983c52206aab9113937  libstdc++-v3/include/decimal/decimal
 71e2a65287f65ee51824acf28e1d9f7a  libstdc++-v3/include/decimal/decimal.h
 5ad6f3f20409d7de29835de97387918e  libstdc++-v3/include/experimental/algorithm
-e65a44cf13272360ff0478fcc8ee5a57  libstdc++-v3/include/experimental/any
+c64f903aa7f538c08886fe5dc1582f0a  libstdc++-v3/include/experimental/any
 89b45a19b6cf153e676d40cf2f37aaf7  libstdc++-v3/include/experimental/array
 29b77f84375c4242993cfe208f650912  libstdc++-v3/include/experimental/bits/erase_if.h
-f9f6312c24ee02dc5cd916d50da8fb83  libstdc++-v3/include/experimental/bits/fs_dir.h
-4c72ea9fbedf180024c0cf4dd5fe4e1b  libstdc++-v3/include/experimental/bits/fs_fwd.h
+122d1256bd80e98d1c61240bbfaf59f1  libstdc++-v3/include/experimental/bits/fs_dir.h
+e1c40a546f26acefc0463b336869af95  libstdc++-v3/include/experimental/bits/fs_fwd.h
 158630c37ddb30cc20d99ff56ac65063  libstdc++-v3/include/experimental/bits/fs_ops.h
 eed4217b2f9fe20ca72578b391c7a2d2  libstdc++-v3/include/experimental/bits/fs_path.h
 34de3fdf15beca4475dd988e0184df6f  libstdc++-v3/include/experimental/bits/shared_ptr.h
@@ -87736,14 +88021,14 @@
 6826964fdd0c501df4e92c523e2862f1  libstdc++-v3/include/experimental/deque
 f88ee31c92f92057c2fd3ac31e24d93e  libstdc++-v3/include/experimental/filesystem
 2bff8bbef91fcc1b5d11d98bf5905df8  libstdc++-v3/include/experimental/forward_list
-4264211c5282d287ebadc45d97d4de45  libstdc++-v3/include/experimental/functional
+e59810aa4afce25362a948f28b60b9de  libstdc++-v3/include/experimental/functional
 6c5f935e4fff3629ee30c039f4c55bb6  libstdc++-v3/include/experimental/iterator
 cfe5bab2e8a6e1cfbfba279ecd095b9b  libstdc++-v3/include/experimental/list
 5ea3575f34c060bd14c6163b5c02910d  libstdc++-v3/include/experimental/map
 9f2ff72def8b2ccefde5f79da53d689c  libstdc++-v3/include/experimental/memory
 0ea55299535b43a37b77451c2a04adb4  libstdc++-v3/include/experimental/memory_resource
 b0a72f080296c31dcf5665d20d230540  libstdc++-v3/include/experimental/numeric
-e625ff0e60fda3fc4623907cbba234be  libstdc++-v3/include/experimental/optional
+b0e91dbbf7e68aa5f99049900d816b46  libstdc++-v3/include/experimental/optional
 7283a9f678ec265aa97152d6dca56bea  libstdc++-v3/include/experimental/propagate_const
 dbf6b0596c17e1fe3bb7c3646ab1fbfa  libstdc++-v3/include/experimental/random
 1e0349a2dbba50ce5eaf18062017033e  libstdc++-v3/include/experimental/ratio
@@ -88047,12 +88332,12 @@
 08ed130b911c8861f17b625300af7808  libstdc++-v3/include/parallel/algobase.h
 c3b97fba09aac2b83819d8dcd1517672  libstdc++-v3/include/parallel/algorithm
 0e840c628f0736ab041408bcada33951  libstdc++-v3/include/parallel/algorithmfwd.h
-59c030b3f0ec2df5766b985d1bd49305  libstdc++-v3/include/parallel/balanced_quicksort.h
+255353a08bb95bf6328d3e2b85d90de0  libstdc++-v3/include/parallel/balanced_quicksort.h
 581bdc62656985390da46c99509e6d12  libstdc++-v3/include/parallel/base.h
 088195ce733ee584f5b8a0b095d0cda8  libstdc++-v3/include/parallel/basic_iterator.h
 233e2ab9c418055cb6565f1be8665f71  libstdc++-v3/include/parallel/checkers.h
 fff9a8759ef5329e1b198ecd68df5d87  libstdc++-v3/include/parallel/compatibility.h
-8550b5411dea9e7a7d09dc2e2286c025  libstdc++-v3/include/parallel/compiletime_settings.h
+a429f2c927389fab5d0c8b3c06a21616  libstdc++-v3/include/parallel/compiletime_settings.h
 31cb4710e1cbb06626f80fad6dba2f86  libstdc++-v3/include/parallel/equally_split.h
 d790719d808ca3e1f934654ba35f4c23  libstdc++-v3/include/parallel/features.h
 8a450ac00797e5880593bd1798d33c89  libstdc++-v3/include/parallel/find.h
@@ -88162,7 +88447,7 @@
 4b6625c7cbce87a5b4a6e79c315b0f1d  libstdc++-v3/include/std/string
 56ecd8ef9e669ad9046f93b40c6adeb0  libstdc++-v3/include/std/system_error
 3c38cff34b5471d6ef6b8f5ebd334363  libstdc++-v3/include/std/thread
-a20360f1d00c525b1c3a82a850399bbb  libstdc++-v3/include/std/tuple
+69c9fe68e28b9c6a300b100398e4eff3  libstdc++-v3/include/std/tuple
 8dfc4dc705dbfdceed5a96a1d17dcb31  libstdc++-v3/include/std/type_traits
 66c41d38d5277a5c6662a5c974f65fc4  libstdc++-v3/include/std/typeindex
 b23b42f90aab11eae50546959be31645  libstdc++-v3/include/std/unordered_map
@@ -88339,7 +88624,7 @@
 30665c8b6d46064d472972b057ac96cb  libstdc++-v3/src/c++11/Makefile.am
 a71513788b148a7ade2ec04c6070aa8e  libstdc++-v3/src/c++11/Makefile.in
 4fdcbea8f299a029c4f5ea8d59f630c6  libstdc++-v3/src/c++11/chrono.cc
-e577d458447700de0808ac76b14c07ec  libstdc++-v3/src/c++11/codecvt.cc
+28ba9ca2926c19035cb646b2329710f4  libstdc++-v3/src/c++11/codecvt.cc
 8bfae905b9eab9ab26ee92eb3978ab4a  libstdc++-v3/src/c++11/compatibility-atomic-c++0x.cc
 5d0b8ad9f6d2ee8e8040a8b666bf9e40  libstdc++-v3/src/c++11/compatibility-c++0x.cc
 4c716fd1981b6de7c33c9ee168aaa28d  libstdc++-v3/src/c++11/compatibility-chrono.cc
@@ -88350,7 +88635,7 @@
 98214d46bbe793351796b07e0a42a42d  libstdc++-v3/src/c++11/cow-locale_init.cc
 8b1fca2685592e27c6e2512aab409c53  libstdc++-v3/src/c++11/cow-shim_facets.cc
 a1e95554d798e75aaf108cf99555acbe  libstdc++-v3/src/c++11/cow-sstream-inst.cc
-d24f762e5c1518d3d881dec110cd3015  libstdc++-v3/src/c++11/cow-stdexcept.cc
+11f38398949bd792c8cf299bb71de812  libstdc++-v3/src/c++11/cow-stdexcept.cc
 f24a3851a742dd9c9e641146183b51a8  libstdc++-v3/src/c++11/cow-string-inst.cc
 2fc29df6c120b834cdf25d9a94bb04be  libstdc++-v3/src/c++11/cow-wstring-inst.cc
 a85f17026568d8b29a5918c5fdb0de37  libstdc++-v3/src/c++11/ctype.cc
@@ -88437,7 +88722,7 @@
 a55f615eaeda6a459dd7afb072d7b189  libstdc++-v3/src/filesystem/cow-ops.cc
 69cc034ef75e4e41c856abb14ff6a9c6  libstdc++-v3/src/filesystem/cow-path.cc
 d65d2e058df05915cedab245e7b83ebb  libstdc++-v3/src/filesystem/dir.cc
-4bd5a2c20b1ea1acbeadb448465d6e91  libstdc++-v3/src/filesystem/ops.cc
+ae63ac87d47a4928b951406c3e823ce4  libstdc++-v3/src/filesystem/ops.cc
 565e7324068b67ac6d423123a8796c82  libstdc++-v3/src/filesystem/path.cc
 588e1f8e679966c86b3269c806c1baaa  libstdc++-v3/src/shared/hashtable-aux.cc
 fd840c906f4a0cf5df5cd7bc96c757e5  libstdc++-v3/testsuite/17_intro/freestanding.cc
@@ -89315,6 +89600,7 @@
 f2c34e193c19314affc8a00a6a445a92  libstdc++-v3/testsuite/20_util/tuple/cons/constexpr-3.cc
 a9cd6398ea857a03537f88c7e23f4b60  libstdc++-v3/testsuite/20_util/tuple/cons/constructor.cc
 0aabd51cea226df6c82b765ef09c9441  libstdc++-v3/testsuite/20_util/tuple/cons/converting.cc
+26bb13fcf5c5e3ab980dfe85b16b7496  libstdc++-v3/testsuite/20_util/tuple/cons/element_accepts_anything_byval.cc
 7e5c8d7e9d12164bb1347a124ace6a37  libstdc++-v3/testsuite/20_util/tuple/cons/explicit_construct.cc
 080671dc61cd5a1adb690c82272a7aa5  libstdc++-v3/testsuite/20_util/tuple/cons/nested_tuple_construct.cc
 441b45a224b065aa135d3ec04bd9a4b2  libstdc++-v3/testsuite/20_util/tuple/cons/noexcept_move_construct.cc
@@ -89660,8 +89946,9 @@
 c97f26a8973c209ae0f7d360ad9f2fcc  libstdc++-v3/testsuite/22_locale/codecvt/char32_t.cc
 c5071e3bdcb84c6edc7d311f74de1d4a  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf16/66417.cc
 a9d0a70ac98a0b17d2d1cc8c848a8efc  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf16/requirements/1.cc
+d1ed67ee033e3f14a4e84f4874b7f324  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc
 ff59d91f6f27e3904a6f0c4e0fc63592  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/requirements/1.cc
-69fc313af596ee07d279da2f57847abc  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc
+a6f9396f0c42a4c6d1d6de7ae30882e3  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc
 50aec117b3903134dc297553a6e7d171  libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/requirements/1.cc
 fb446a5424dced8689e50d049d902d15  libstdc++-v3/testsuite/22_locale/codecvt/encoding/char/1.cc
 fb4c80aa2f3965e8a807cf632dd40511  libstdc++-v3/testsuite/22_locale/codecvt/encoding/char/wrapped_env.cc
@@ -91461,6 +91748,7 @@
 7a12e960fa6c1e202b05b2045bf30243  libstdc++-v3/testsuite/25_algorithms/binary_search/1.cc
 fa283b2c4d3165d0550387d9bea029e9  libstdc++-v3/testsuite/25_algorithms/binary_search/2.cc
 39f41d4b1f8549c8788b2a85a1c1a063  libstdc++-v3/testsuite/25_algorithms/binary_search/check_type.cc
+dbcdd5ed11c3e7f7c6993f08d03a384a  libstdc++-v3/testsuite/25_algorithms/binary_search/partitioned.cc
 b9a614d8754b69aacd56a041d87d4f4c  libstdc++-v3/testsuite/25_algorithms/binary_search/requirements/explicit_instantiation/2.cc
 00923b3f1fe62755ccaea3e61a14e149  libstdc++-v3/testsuite/25_algorithms/binary_search/requirements/explicit_instantiation/pod.cc
 ee54ed262f118b0a86e1ba3198a8bbbb  libstdc++-v3/testsuite/25_algorithms/copy/1.cc
@@ -91517,6 +91805,7 @@
 471256a571753ee1e1eee18449dc96b8  libstdc++-v3/testsuite/25_algorithms/equal_range/1.cc
 911a0936f661b747ba8f0a5329a6dadd  libstdc++-v3/testsuite/25_algorithms/equal_range/2.cc
 111dc42bd57e81f298f0d17a0f4e7c91  libstdc++-v3/testsuite/25_algorithms/equal_range/check_type.cc
+e5252e8afeb3f5de27ed99de48b74b8b  libstdc++-v3/testsuite/25_algorithms/equal_range/partitioned.cc
 fe50e7ee7caeb1e75440d7f7b268af24  libstdc++-v3/testsuite/25_algorithms/equal_range/requirements/explicit_instantiation/2.cc
 5e6967d287d4c6526375184ee5831157  libstdc++-v3/testsuite/25_algorithms/equal_range/requirements/explicit_instantiation/pod.cc
 1ff6701c1f7885f5cf7ae178fa6e3a30  libstdc++-v3/testsuite/25_algorithms/fill/1.cc
@@ -91620,6 +91909,7 @@
 3fce4489cef94bc78fa0b2cfe622659f  libstdc++-v3/testsuite/25_algorithms/iter_swap/requirements/explicit_instantiation/2.cc
 563704df11793a2cb3925520a0584712  libstdc++-v3/testsuite/25_algorithms/iter_swap/requirements/explicit_instantiation/pod.cc
 4c615f82254ba19627efd93190dc8741  libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/1.cc
+981466c0627cc5b1a3a290dde5c624ea  libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/71545.cc
 6b2d034347a8395f85b112da5151e1eb  libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/check_type.cc
 ebb6313449d28677e1a105baa61eb93f  libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/debug/irreflexive_neg.cc
 3468195c2351971106ecfec5637ae780  libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/requirements/explicit_instantiation/2.cc
@@ -91630,6 +91920,7 @@
 f3bcfbb7cff9aba454e55e19bcf2baf8  libstdc++-v3/testsuite/25_algorithms/lower_bound/check_type.cc
 20a0ac6a9a8d6fefcde91c6b9e41e0c6  libstdc++-v3/testsuite/25_algorithms/lower_bound/debug/irreflexive.cc
 63320e25fd7aa7498b9e83cc5cd18506  libstdc++-v3/testsuite/25_algorithms/lower_bound/no_operator_ne.cc
+7539641d39861d52133a38d930f614e5  libstdc++-v3/testsuite/25_algorithms/lower_bound/partitioned.cc
 b081808f9153f80a70b6a6a0bcb10b0a  libstdc++-v3/testsuite/25_algorithms/lower_bound/requirements/explicit_instantiation/2.cc
 324cb134faf27bc3b70cead47184663a  libstdc++-v3/testsuite/25_algorithms/lower_bound/requirements/explicit_instantiation/pod.cc
 4152775a73ca52f1f39a0843d3711e9c  libstdc++-v3/testsuite/25_algorithms/make_heap/complexity.cc
@@ -91897,6 +92188,7 @@
 fcff315b520a5c220c95b06bf0afc3d7  libstdc++-v3/testsuite/25_algorithms/upper_bound/2.cc
 5799c9c188ff54c06a37c2b1684c3829  libstdc++-v3/testsuite/25_algorithms/upper_bound/33613.cc
 2367e61d5039679b915978b0831e9557  libstdc++-v3/testsuite/25_algorithms/upper_bound/check_type.cc
+a2a39374248d3f8330f33262bf983424  libstdc++-v3/testsuite/25_algorithms/upper_bound/partitioned.cc
 1bde07efc71b4272f874aa9b60b1c41a  libstdc++-v3/testsuite/25_algorithms/upper_bound/requirements/explicit_instantiation/2.cc
 831507ab22c2dd811af9549c9b05042a  libstdc++-v3/testsuite/25_algorithms/upper_bound/requirements/explicit_instantiation/pod.cc
 2ccc854d45ba39bdccef1dd6b95a2767  libstdc++-v3/testsuite/26_numerics/accumulate/1.cc
@@ -93837,8 +94129,8 @@
 4d143ca68b2fc8e2f44162f96937b954  libstdc++-v3/testsuite/experimental/any/cons/2.cc
 bcb1af3db3b58578f36d9fc7692922cf  libstdc++-v3/testsuite/experimental/any/cons/aligned.cc
 48399811d2d329c756e82d87ef698e93  libstdc++-v3/testsuite/experimental/any/cons/nontrivial.cc
-88fff9f76f2cb12f04ec3c220bd1bdf6  libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
-b4f7ba6bd9238f17d0e8c4fd7018dbeb  libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
+f202bdedc914a2ba5e8700ca4b541d88  libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
+d6699928a0c4ff31a16b82901e0135d9  libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
 ede8bc6c2abc8e8e88dd015c19f35bc9  libstdc++-v3/testsuite/experimental/any/misc/any_cast_no_rtti.cc
 4c83567229f17dfc9aeee2ceada69bc7  libstdc++-v3/testsuite/experimental/any/misc/swap.cc
 89d8fbc9a4c2072fb0d49f46675f92e7  libstdc++-v3/testsuite/experimental/any/modifiers/1.cc
@@ -93850,15 +94142,18 @@
 a6bed3df705f73fb6770e7e17600b531  libstdc++-v3/testsuite/experimental/deque/erasure.cc
 1c10a535f04c73dcb2dcf34a55e5f892  libstdc++-v3/testsuite/experimental/feat-cxx14.cc
 f1868e7d6427fc60964c1a38200d329f  libstdc++-v3/testsuite/experimental/feat-lib-fund.cc
-90f90e5d1004c083226bf7207a8b18f1  libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
-a7fea621d015988d3fa1fc76e86eedd9  libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
+e9dc54abe60b8b705c14ac3d74636838  libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
+af9d47d33b74004315b691b6346b9d86  libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
 6659047a437b84cfb9f2391f87429043  libstdc++-v3/testsuite/experimental/filesystem/operations/absolute.cc
-e9ab5236864aff79b6568b648c388648  libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
-3ba41914e00797409515d4219a56de5a  libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
-17841b5e8220264cf46deb635f6e3d3b  libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
+cb96d4f460d63079de67211a5fa98add  libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
+0cf2c31ebc01188c0a36787d294b6c6b  libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
+43478894c9ffeeff98b3c58779cdd278  libstdc++-v3/testsuite/experimental/filesystem/operations/copy_file.cc
+5b67c7238f734df125c006ea8e224a86  libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
+25adc7117e80c1cd1e18b1cde11f4c1e  libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
 c5446130c200098a30ef1dc1a283b2b9  libstdc++-v3/testsuite/experimental/filesystem/operations/current_path.cc
 7340da71f52f79524efcb005b8a0dfbf  libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
 543f1f3a74e4731a28b2350f36b57987  libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc
+a5fe820ebc0fc04c2078c67418d5e236  libstdc++-v3/testsuite/experimental/filesystem/operations/permissions.cc
 6c082c2b9134f256176dbd1ced18ec29  libstdc++-v3/testsuite/experimental/filesystem/operations/status.cc
 1d8c4e2df6535130a0759320e07efee6  libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
 6572ad4bfd145d4c0c079938a286897c  libstdc++-v3/testsuite/experimental/filesystem/path/append/path.cc
@@ -93889,6 +94184,7 @@
 5df8e09e624d87e17a044d9858058c9e  libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_extension.cc
 e2817cfd26742b69b8b7b73f942ccde9  libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_filename.cc
 d4e9d71c8fd2b42db51b8797aebca13f  libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/swap.cc
+2321736afe6f050de2a69492d9bd096c  libstdc++-v3/testsuite/experimental/filesystem/path/native/string.cc
 45a57bfce67b5460ea4ad3626a5133b5  libstdc++-v3/testsuite/experimental/filesystem/path/nonmember/hash_value.cc
 3e4cb85aec4dd2457d9b4efcbb7e8c0a  libstdc++-v3/testsuite/experimental/filesystem/path/query/empty.cc
 71662b7f8ba3c6eb3dd94d008fe8ce02  libstdc++-v3/testsuite/experimental/filesystem/path/query/has_extension.cc
@@ -93902,7 +94198,7 @@
 b427c42986c003d6253ad475d252580b  libstdc++-v3/testsuite/experimental/filesystem/path/query/is_relative.cc
 f670b614d1cc3d7d0ad24712e408b00d  libstdc++-v3/testsuite/experimental/forward_list/erasure.cc
 bbbce96b885b0a3e2fff3467f74603b3  libstdc++-v3/testsuite/experimental/functional/not_fn.cc
-8b60f23ac93b783a0235699abcca08e4  libstdc++-v3/testsuite/experimental/functional/searchers.cc
+854913f12196247a55853dd04d8eee4d  libstdc++-v3/testsuite/experimental/functional/searchers.cc
 043c6e8e4f78804111ba475b4b36f43a  libstdc++-v3/testsuite/experimental/functional/value.cc
 b8a37dc3290caea1a96660d87ea5a9a3  libstdc++-v3/testsuite/experimental/iterator/make_ostream_joiner.cc
 1c550ab3838807146948e05c220dd3c2  libstdc++-v3/testsuite/experimental/iterator/ostream_joiner.cc
@@ -93947,7 +94243,8 @@
 5cafc7a64c3fd8161ec5647978b89f4a  libstdc++-v3/testsuite/experimental/optional/cons/copy.cc
 ad6988975eb0537cef61d8ca1a71f663  libstdc++-v3/testsuite/experimental/optional/cons/default.cc
 f4226d3e8ed1ba519c69491709698d38  libstdc++-v3/testsuite/experimental/optional/cons/move.cc
-66f5ea892439f3d2ff2ef9f386ac41cd  libstdc++-v3/testsuite/experimental/optional/cons/value.cc
+cd8840b7866b44b7ceed99d196c79446  libstdc++-v3/testsuite/experimental/optional/cons/value.cc
+bfdb103f8e1eff6b08a67e1e20910b8a  libstdc++-v3/testsuite/experimental/optional/cons/value_neg.cc
 8ff6b45a9b1050aed7e2229378bea517  libstdc++-v3/testsuite/experimental/optional/constexpr/cons/default.cc
 64cafc604813d41180b02bbdb5175243  libstdc++-v3/testsuite/experimental/optional/constexpr/cons/value.cc
 87ed87ffad80d6207261ad9e9ccd90ec  libstdc++-v3/testsuite/experimental/optional/constexpr/in_place.cc
@@ -95306,12 +95603,12 @@
 23fd997da513a65fe1471c19a226fc52  libstdc++-v3/testsuite/util/testsuite_containers.h
 04a32a019d1586ab2217d06583f33404  libstdc++-v3/testsuite/util/testsuite_counter_type.h
 0dc60b6ac596bc87a4e7a40aa06f58e9  libstdc++-v3/testsuite/util/testsuite_error.h
-e09bbb8df91a8ee7256775a6d4d4d163  libstdc++-v3/testsuite/util/testsuite_fs.h
+8e55222cc23d00baba3a214230f59761  libstdc++-v3/testsuite/util/testsuite_fs.h
 ff826c1dd2ee6a0fe894da2321232547  libstdc++-v3/testsuite/util/testsuite_greedy_ops.h
 c2aa93a55fce4b410f3963907115507e  libstdc++-v3/testsuite/util/testsuite_hooks.cc
 a837c7d31a1866b0a6125d854aeeb3ba  libstdc++-v3/testsuite/util/testsuite_hooks.h
 03ef0d72a4d44308b72f20d48a98490f  libstdc++-v3/testsuite/util/testsuite_io.h
-426181cd245715e20a7e2d0a664f1875  libstdc++-v3/testsuite/util/testsuite_iterators.h
+014a5d7501d7109088bf371b70c55f19  libstdc++-v3/testsuite/util/testsuite_iterators.h
 915de1d2f670ce7f4b76542e99a70c50  libstdc++-v3/testsuite/util/testsuite_new_operators.h
 d8cb74dfe347cc7d377fbd19b3efb585  libstdc++-v3/testsuite/util/testsuite_performance.h
 78117be975dcbe3823aa930cfbce08c0  libstdc++-v3/testsuite/util/testsuite_random.h
@@ -95323,9 +95620,9 @@
 204ec69a032d5a889dacc11cf18fa4ed  libstdc++-v3/testsuite/util/thread/all.h
 b950d655469c477755252b1e18009596  libtool-ldflags
 7a2b83d2d625a4022b9213ceb75f5897  libtool.m4
-d2a523d344604dd6a3e8e1f7bfb1c2b4  libvtv/ChangeLog
-8cf2d09520df1da87dce0b192c1af79a  libvtv/Makefile.am
-31c82474804ec75aab274ed98b4e6b51  libvtv/Makefile.in
+780474b8d3fa8c8117ccfd8281527085  libvtv/ChangeLog
+580d40bdd6efd6663aa0d78101a2ef1a  libvtv/Makefile.am
+c9973f89d6d559403509edf0c5aa127f  libvtv/Makefile.in
 4ce86f8604e6c86211a4cb2025ffc53e  libvtv/acinclude.m4
 1fadd2a7f8c12da8f434cd33e68d271e  libvtv/aclocal.m4
 754a4cbfde648aca416470cd6c95e4d8  libvtv/configure
@@ -95419,11 +95716,11 @@
 bc2f6032c98896249eadb56177c7d357  ltsugar.m4
 c30cd33c496505f13d9fbdb6970c7c33  ltversion.m4
 293853a13b7e218e3a4342cf85fbbf25  lt~obsolete.m4
-b53da0da0c103a537dcf0ca69e0f0ef3  maintainer-scripts/ChangeLog
+b2ed68474b6ccc5f6ea1349c114e9064  maintainer-scripts/ChangeLog
 33c7bc2d2c55956dfac85a05d8a80eff  maintainer-scripts/README
 d0d4b92a5ba9606c481075c7bf65469a  maintainer-scripts/crontab
 91544f3a251dde1c76b2b9a58aee73a9  maintainer-scripts/gcc_release
-d87b258ea691681aca69f5c94d2f7cca  maintainer-scripts/generate_libstdcxx_web_docs
+4b1217d62242596f1d1b439c25dce68f  maintainer-scripts/generate_libstdcxx_web_docs
 33d97164a8610c7abf67eff7d28f47ff  maintainer-scripts/maintainer-addresses
 fd2c02d88bca262690f0cbbfaeab16e1  maintainer-scripts/update_version_svn
 c8dfca01bf19508e40afff1dcd255211  maintainer-scripts/update_web_docs_libstdcxx_svn
Only in gcc-6.1.0: NEWS
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/fixincludes/ChangeLog gcc-6-20160721/fixincludes/ChangeLog
--- gcc-6.1.0/fixincludes/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/fixincludes/ChangeLog	2016-06-15 14:32:35.000000000 +0000
@@ -1,3 +1,18 @@
+2016-06-15  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2016-06-13  David Edelsohn  <dje.gcc@gmail.com>
+
+	* inclhack.def (aix_stdlib_malloc): New fix.
+	(aix_stdlib_realloc): New fix.
+	(aix_stdlib_calloc): New fix.
+	(aix_stdlib_valloc): New fix.
+	* fixincl.x: Regenerate.
+	* tests/base/stdlib.h [AIX_STDLIB_MALLOC]: New test.
+	[AIX_STDLIB_REALLOC]: New test.
+	[AIX_STDLIB_CALLOC]: New test.
+	[AIX_STDLIB_VALLOC]: New test.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/fixincludes/fixincl.x gcc-6-20160721/fixincludes/fixincl.x
--- gcc-6.1.0/fixincludes/fixincl.x	2016-02-01 00:54:22.000000000 +0000
+++ gcc-6-20160721/fixincludes/fixincl.x	2016-06-15 14:32:35.000000000 +0000
@@ -2,11 +2,11 @@
  * 
  * DO NOT EDIT THIS FILE   (fixincl.x)
  * 
- * It has been AutoGen-ed  Sunday January 31, 2016 at 07:52:05 PM EST
+ * It has been AutoGen-ed  June 10, 2016 at 12:56:52 PM by AutoGen 5.18.3
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sun 31 Jan 2016 19:52:05 EST
+/* DO NOT SVN-MERGE THIS FILE, EITHER Fri Jun 10 12:56:52 UTC 2016
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 231 fixup descriptions.
+ * This file contains 235 fixup descriptions.
  *
  * See README for more information.
  *
@@ -1547,6 +1547,154 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Aix_Stdlib_Malloc fix
+ */
+tSCC zAix_Stdlib_MallocName[] =
+     "aix_stdlib_malloc";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zAix_Stdlib_MallocList[] =
+  "stdlib.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzAix_Stdlib_MallocMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zAix_Stdlib_MallocSelect0[] =
+       "#define[ \t]+malloc[ \t]+__linux_malloc";
+
+#define    AIX_STDLIB_MALLOC_TEST_CT  1
+static tTestDesc aAix_Stdlib_MallocTests[] = {
+  { TT_EGREP,    zAix_Stdlib_MallocSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Aix_Stdlib_Malloc
+ */
+static const char* apzAix_Stdlib_MallocPatch[] = {
+    "format",
+    "extern void *malloc(size_t) __asm__(\"__linux_malloc\");",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Aix_Stdlib_Realloc fix
+ */
+tSCC zAix_Stdlib_ReallocName[] =
+     "aix_stdlib_realloc";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zAix_Stdlib_ReallocList[] =
+  "stdlib.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzAix_Stdlib_ReallocMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zAix_Stdlib_ReallocSelect0[] =
+       "#define[ \t]+realloc[ \t]+__linux_realloc";
+
+#define    AIX_STDLIB_REALLOC_TEST_CT  1
+static tTestDesc aAix_Stdlib_ReallocTests[] = {
+  { TT_EGREP,    zAix_Stdlib_ReallocSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Aix_Stdlib_Realloc
+ */
+static const char* apzAix_Stdlib_ReallocPatch[] = {
+    "format",
+    "extern void *realloc(void *, size_t) __asm__(\"__linux_realloc\");",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Aix_Stdlib_Calloc fix
+ */
+tSCC zAix_Stdlib_CallocName[] =
+     "aix_stdlib_calloc";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zAix_Stdlib_CallocList[] =
+  "stdlib.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzAix_Stdlib_CallocMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zAix_Stdlib_CallocSelect0[] =
+       "#define[ \t]+calloc[ \t]+__linux_calloc";
+
+#define    AIX_STDLIB_CALLOC_TEST_CT  1
+static tTestDesc aAix_Stdlib_CallocTests[] = {
+  { TT_EGREP,    zAix_Stdlib_CallocSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Aix_Stdlib_Calloc
+ */
+static const char* apzAix_Stdlib_CallocPatch[] = {
+    "format",
+    "extern void *calloc(size_t, size_t) __asm__(\"__linux_calloc\");",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Aix_Stdlib_Valloc fix
+ */
+tSCC zAix_Stdlib_VallocName[] =
+     "aix_stdlib_valloc";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zAix_Stdlib_VallocList[] =
+  "stdlib.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzAix_Stdlib_VallocMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zAix_Stdlib_VallocSelect0[] =
+       "#define[ \t]+valloc[ \t]+__linux_valloc";
+
+#define    AIX_STDLIB_VALLOC_TEST_CT  1
+static tTestDesc aAix_Stdlib_VallocTests[] = {
+  { TT_EGREP,    zAix_Stdlib_VallocSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Aix_Stdlib_Valloc
+ */
+static const char* apzAix_Stdlib_VallocPatch[] = {
+    "format",
+    "extern void *valloc(size_t) __asm__(\"__linux_valloc\");",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Aix_Strtof_Const fix
  */
 tSCC zAix_Strtof_ConstName[] =
@@ -9485,9 +9633,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          268
+#define REGEX_COUNT          272
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            231
+#define FIX_COUNT            235
 
 /*
  *  Enumerate the fixes
@@ -9525,6 +9673,10 @@
     AIX_STDINT_4_FIXIDX,
     AIX_STDINT_5_FIXIDX,
     AIX_STDIO_INLINE_FIXIDX,
+    AIX_STDLIB_MALLOC_FIXIDX,
+    AIX_STDLIB_REALLOC_FIXIDX,
+    AIX_STDLIB_CALLOC_FIXIDX,
+    AIX_STDLIB_VALLOC_FIXIDX,
     AIX_STRTOF_CONST_FIXIDX,
     AIX_SYSMACHINE_FIXIDX,
     AIX_SYSWAIT_2_FIXIDX,
@@ -9887,6 +10039,26 @@
      AIX_STDIO_INLINE_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aAix_Stdio_InlineTests,   apzAix_Stdio_InlinePatch, 0 },
 
+  {  zAix_Stdlib_MallocName,    zAix_Stdlib_MallocList,
+     apzAix_Stdlib_MallocMachs,
+     AIX_STDLIB_MALLOC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aAix_Stdlib_MallocTests,   apzAix_Stdlib_MallocPatch, 0 },
+
+  {  zAix_Stdlib_ReallocName,    zAix_Stdlib_ReallocList,
+     apzAix_Stdlib_ReallocMachs,
+     AIX_STDLIB_REALLOC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aAix_Stdlib_ReallocTests,   apzAix_Stdlib_ReallocPatch, 0 },
+
+  {  zAix_Stdlib_CallocName,    zAix_Stdlib_CallocList,
+     apzAix_Stdlib_CallocMachs,
+     AIX_STDLIB_CALLOC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aAix_Stdlib_CallocTests,   apzAix_Stdlib_CallocPatch, 0 },
+
+  {  zAix_Stdlib_VallocName,    zAix_Stdlib_VallocList,
+     apzAix_Stdlib_VallocMachs,
+     AIX_STDLIB_VALLOC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aAix_Stdlib_VallocTests,   apzAix_Stdlib_VallocPatch, 0 },
+
   {  zAix_Strtof_ConstName,    zAix_Strtof_ConstList,
      apzAix_Strtof_ConstMachs,
      AIX_STRTOF_CONST_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/fixincludes/inclhack.def gcc-6-20160721/fixincludes/inclhack.def
--- gcc-6.1.0/fixincludes/inclhack.def	2016-02-01 00:54:22.000000000 +0000
+++ gcc-6-20160721/fixincludes/inclhack.def	2016-06-15 14:32:35.000000000 +0000
@@ -911,6 +911,48 @@
     test_text = "#ifdef __cplusplus\n}\n\n#ifdef ferror";
 };
 
+/*
+ * stdlib.h on AIX uses #define on malloc and friends.
+ */
+fix = {
+    hackname  = aix_stdlib_malloc;
+    mach      = "*-*-aix*";
+    files     = stdlib.h;
+    select    = "#define[ \t]+malloc[ \t]+__linux_malloc";
+    c_fix     = format;
+    c_fix_arg = "extern void *malloc(size_t) __asm__(\"__linux_malloc\");";
+    test_text = "#define malloc __linux_malloc";
+};
+
+fix = {
+    hackname  = aix_stdlib_realloc;
+    mach      = "*-*-aix*";
+    files     = stdlib.h;
+    select    = "#define[ \t]+realloc[ \t]+__linux_realloc";
+    c_fix     = format;
+    c_fix_arg = "extern void *realloc(void *, size_t) __asm__(\"__linux_realloc\");";
+    test_text = "#define realloc __linux_realloc";
+};
+
+fix = {
+    hackname  = aix_stdlib_calloc;
+    mach      = "*-*-aix*";
+    files     = stdlib.h;
+    select    = "#define[ \t]+calloc[ \t]+__linux_calloc";
+    c_fix     = format;
+    c_fix_arg = "extern void *calloc(size_t, size_t) __asm__(\"__linux_calloc\");";
+    test_text = "#define calloc __linux_calloc";
+};
+
+fix = {
+    hackname  = aix_stdlib_valloc;
+    mach      = "*-*-aix*";
+    files     = stdlib.h;
+    select    = "#define[ \t]+valloc[ \t]+__linux_valloc";
+    c_fix     = format;
+    c_fix_arg = "extern void *valloc(size_t) __asm__(\"__linux_valloc\");";
+    test_text = "#define valloc __linux_valloc";
+};
 
 /*
  * stdlib.h on AIX 4.3 declares strtof() with a non-const first argument.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/fixincludes/tests/base/stdlib.h gcc-6-20160721/fixincludes/tests/base/stdlib.h
--- gcc-6.1.0/fixincludes/tests/base/stdlib.h	2015-02-17 14:45:48.000000000 +0000
+++ gcc-6-20160721/fixincludes/tests/base/stdlib.h	2016-06-15 14:32:35.000000000 +0000
@@ -9,6 +9,26 @@
 
 
 
+#if defined( AIX_STDLIB_MALLOC_CHECK )
+extern void *malloc(size_t) __asm__("__linux_malloc");
+#endif  /* AIX_STDLIB_MALLOC_CHECK */
+
+
+#if defined( AIX_STDLIB_REALLOC_CHECK )
+extern void *realloc(void *, size_t) __asm__("__linux_realloc");
+#endif  /* AIX_STDLIB_REALLOC_CHECK */
+
+
+#if defined( AIX_STDLIB_CALLOC_CHECK )
+extern void *calloc(size_t, size_t) __asm__("__linux_calloc");
+#endif  /* AIX_STDLIB_CALLOC_CHECK */
+
+
+#if defined( AIX_STDLIB_VALLOC_CHECK )
+extern void *valloc(size_t) __asm__("__linux_valloc");
+#endif  /* AIX_STDLIB_VALLOC_CHECK */
+
+
 #if defined( AIX_STRTOF_CONST_CHECK )
 extern float    strtof(const char *, char **);
 #endif  /* AIX_STRTOF_CONST_CHECK */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/BASE-VER gcc-6-20160721/gcc/BASE-VER
--- gcc-6.1.0/gcc/BASE-VER	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/BASE-VER	2016-04-27 10:38:16.000000000 +0000
@@ -1 +1 @@
-6.1.0
+6.1.1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ChangeLog gcc-6-20160721/gcc/ChangeLog
--- gcc-6.1.0/gcc/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/ChangeLog	2016-07-21 16:18:46.000000000 +0000
@@ -1,3 +1,2020 @@
+2016-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/71953
+	* asan.c (asan_dynamic_init_call): Call asan_init_shadow_ptr_types
+	before builtin_decl_implicit.
+
+	* tree-object-size.c (unknown): Use HOST_WIDE_INT_M1U instead of -1.
+
+2016-07-21  Andrew Sutton  <andrew.n.sutton@gmail.com>
+
+	Improving concepts performance and diagnostics.
+	* timevar.def (TV_CONSTRAINT_SAT, TV_CONSTRAINT_SUB): New time vars
+	for constraint satisfaction and subsumption.
+	* timevar.h (auto_timevar): New constructor that matches the push/pop
+	pattern of usage in pt.c.
+
+2016-07-20  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2016-07-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (hppa_profile_hook): Allocate stack space for
+	register parameters.  Remove code to initialize argument pointer
+	on TARGET_64BIT.  Optimize call to _mcount when it can be reached
+	using a pc-relative branch.  Cleanup conditional code.
+	* config/pa/pa.md (call_mcount): New expander.
+	(call_mcount_nonpic): New insn.
+	(call_mcount_pic): New insn and split.
+	(call_mcount_pic_post_reload): New insn.
+	(call_mcount_64bit): New insn and split.
+	(call_mcount_64bit_post_reload): New insn.
+
+2016-07-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_encode_section_info): Remove mode size
+	check.
+
+2016-07-20  Martin Jambor  <mjambor@suse.cz>
+
+        PR fortran/71688
+        * trans-decl.c (gfc_generate_function_code): Use get_create rather
+        than create to get a call graph node.
+
+2016-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/71916
+	* cfgrtl.c (contains_no_active_insn_p): Return false also for
+	bb which have a single succ fake edge.
+
+2016-07-19  Aldy Hernandez  <aldyh@redhat.com>
+
+	PR debug/71855
+	* dwarf2out.c (gen_subprogram_die): Only call
+	gen_unspecified_parameters_die while dumping early dwarf.
+
+2016-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71874
+	* gimple-fold.c (fold_builtin_memory_op): Use
+	get_addr_base_and_unit_offset instead of get_ref_base_and_extent.
+
+2016-07-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from mainline
+	2016-07-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71493
+	* config/rs6000/rs6000.c (rs6000_function_value): Fix
+	unintentional System V.4 structure return breakage for structures
+	with a single floating point element.
+
+2016-07-18  Martin Liska  <mliska@suse.cz>
+
+	Backported from mainline
+	2016-07-12  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/71634
+	* ira-build.c (mark_loops_for_removal): Properly iterate
+	loops.
+
+2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_encode_section_info): Always set
+	notaligned marker if mode size is 0 or no MEM_ALIGN info could be
+	found.
+
+2016-07-15  Alan Modra  <amodra@gmail.com>
+
+	Apply from mainline
+	2016-07-11  Alan Modra  <amodra@gmail.com>
+	* config/rs6000/rs6000.md (UNSPEC_DOLOOP): New unspec.
+	(ctr<mode>): Add unspec.
+	(ctr<mode>_internal*): Likewise.
+
+2016-07-14  Alan Modra  <amodra@gmail.com>
+
+	PR target/71733
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Deal
+	with p9_vector override before power9-dform override.
+
+2016-07-13  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r238086.
+	2016-07-07  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR ipa/71624
+	* ipa-inline-analysis.c (compute_inline_parameters): Set
+	local.can_change_signature to false for intrumentation
+	thunk callees.
+
+2016-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-05  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	            Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-protos.h (rs6000_split_signbit): New
+	prototype.
+	* config/rs6000/rs6000.c (rs6000_split_signbit): New function.
+	* config/rs6000/rs6000.md (UNSPEC_SIGNBIT): New constant.
+	(SIGNBIT): New mode iterator.
+	(Fsignbit): New mode attribute.
+	(signbit<mode>2): Change operand1 to match FLOAT128 instead of
+	IBM128; dispatch to gen_signbit{kf,tf}2_dm for __float128
+	when direct moves are available.
+	(signbit<mode>2_dm): New define_insn_and_split).
+	(signbit<mode>2_dm2): New define_insn.
+
+2016-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71805
+	* config/rs6000/altivec.md (altivec_vperm_<mode>_internal):
+	The xxperm and xxpermr instructions require that the 2nd input
+	operand overlap with the output operand, and not the 1st.
+	(altivec_vperm_v8hiv16qi): Likewise.
+	(altivec_vperm_<mode>_uns_internal): Likewise.
+	(altivec_vpermr_<mode>_internal): Likewise.
+	(vperm_v8hiv4si): Likewise.
+	(vperm_v16qiv8hi): Likewise.
+
+2016-07-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2016-07-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/70098
+	PR target/71763
+	* config/rs6000/rs6000.md (*ctr<mode>_internal1, *ctr<mode>_internal2,
+	*ctr<mode>_internal5, *ctr<mode>_internal6): Add *wi to the output
+	constraint.
+
+2016-07-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71758
+	* omp-low.c (expand_omp_target): Gimplify device.
+
+	PR tree-optimization/71823
+	* tree-vect-stmts.c (vectorizable_operation): Use vect_get_vec_defs
+	to get vec_oprnds2 from op2.
+
+2016-07-11  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	Backport from mainline r238055.
+	2016-07-06  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	PR tree-optimization/71518
+	* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Adjust
+	misalign also for outer loops with negative step.
+
+2016-07-08  Martin Liska  <mliska@suse.cz>
+
+	Backported from mainline
+	2016-07-08  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/71606
+	* fold-const.c (fold_convertible_p): As COMPLEX_TYPE
+	folding produces SAVE_EXPRs, thus return false for the type.
+
+2016-07-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000-builtin.def (BU_P9_MISC_1): Remove
+	redundant and erroneous definition of this macro accidentally
+	inserted during backporting.
+	(BU_P9_64BIT_MISC_0): Likewise.
+	(BU_P9_MISC_0): Likewise.
+
+2016-07-08  Jiong Wang  <jiong.wang@arm.com>
+
+	Back port from the trunk
+	2016-07-08  Jiong Wang  <jiong.wang@arm.com>
+
+	* config/aarch64/aarch64-simd-builtins.def (smax): Remove float
+	variants.
+	(smin): Likewise.
+	(fmax): New entry.
+	(fmin): Likewise.
+	* config/aarch64/arm_neon.h (vmaxnm_f32): Use
+	__builtin_aarch64_fmaxv2sf.
+	(vmaxnmq_f32): Likewise.
+	(vmaxnmq_f64): Likewise.
+	(vminnm_f32): Likewise.
+	(vminnmq_f32): Likewise.
+	(vminnmq_f64): Likewise.
+
+2016-07-08  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-07-08  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71806
+	* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Do not
+	enable -mfloat128-hardware by default.
+	(ISA_3_0_MASKS_IEEE): New macro to give all of the VSX options
+	that IEEE 128-bit hardware support needs.
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): If
+	-mcpu=power9 -mfloat128, enable -mfloat128-hardware by default.
+	Use ISA_3_0_MASKS_IEEE as the set of options that IEEE 128-bit
+	floating point requires.
+	* doc/invoke.texi (RS/6000 and PowerPC Options): Document
+	-mfloat128 and -mfloat128-hardware changes.
+
+2016-07-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline r237912
+	2016-07-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/altivec.md (*altivec_vpermr_<mode>_internal):
+	Exchange the order of the second and third operands in the vpermr
+	instruction tmeplate.
+
+2016-07-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from the trunk
+	2016-07-01  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71720
+	* config/rs6000/vsx.md (vsx_splat_v4sf_internal): When splitting
+	the insns, use an insn form that does not adjust the offset on
+	little endian systems.
+
+2016-07-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline r237885
+	2016-06-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/altivec.md (darn_32): Change the condition to
+	TARGET_P9_MISC instead of TARGET_MODULO.
+	(darn_raw): Replace TARGET_MODULO with TARGET_P9_MISC in the
+	condition expression.
+	(darn): Replace TARGET_MODULO with TARGET_P9_MISC in the
+	condition expression.
+	* config/rs6000/dfp.md (UNSPEC_DTSTSFI): New unspec constant.
+	(DFP_TEST): New code iterator.
+	(dfptstsfi_<code>_mode>): New define_expand.
+	(*dfp_sgnfcnc_<mode>): New define_insn.
+	* config/rs6000/rs6000-builtin.def (BU_P9_MISC_0): Move this macro
+	definition next to BU_P9_MISC_1 definition and change the MASK
+	value to RS6000_BTM_P9_MISC.
+	(BU_P9_MISC_1): Change the MASK value to RS6000_BTM_P9_MISC.
+	(BU_P9_64BIT_MISC_0): Likewise.
+	(BU_P9_DFP_MISC_0): New macro definition.
+	(BU_P9_DFP_MISC_1): New macro definition.
+	(BU_P9_DFP_MISC_2): New macro definition.
+	(BU_P9_DFP_OVERLOAD_1): New macro definition.
+	(BU_P9_DFP_OVERLOAD_2): New macro definition.
+	(BU_P9_DFP_OVERLOAD_3): New macro definition.
+	(TSTSFI_LT_DD): New BU_P9_DFP_MISC_2.
+	(TSTSFI_LT_TD): Likewise.
+	(TSTSFI_EQ_DD): Likewise.
+	(TSTSFI_EQ_TD): Likewise.
+	(TSTSFI_GT_DD): Likewise.
+	(TSTSFI_GT_TD): Likewise.
+	(TSTSFI_OV_DD): Likewise.
+	(TSTSFI_OV_TD): Likewise.
+	(TSTSFI_LT): New BU_P9_DFP_OVERLOAD_2.
+	(TSTSFI_LT_DD): Likewise.
+	(TSTSFI_LT_TD): Likewise.
+	(TSTSFI_EQ): Likewise.
+	(TSTSFI_EQ_DD): Likewise.
+	(TSTSFI_EQ_TD): Likewise.
+	(TSTSFI_GT): Likewise.
+	(TSTSFI_GT_DD): Likewise.
+	(TSTSFI_GT_TD): Likewise.
+	(TSTSFI_OV): Likewise.
+	(TSTSFI_OV_DD): Likewise.
+	(TSTSFI_OV_TD): Likewise.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	overloaded test significance functions.
+	* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Add
+	OPTION_MASK_P9_MISC into the representation of this mask.
+	(POWERPC_MASKS): Add OPTION_MASK_P9_MISC into the representation
+	of this mask.
+	* config/rs6000/rs6000.c (rs6000_builtin_mask_calculate): Set the
+	RS6000_BTM_P9_MISC flag in the return value if TARGET_P9_MISC is
+	non-zero.
+	(rs6000_expand_binop_builtin): Enforce that argument 0 of the exp
+	argument is a 6-bit unsigned literal value if the icode argument
+	represents a DFP test significance built-in call.
+	(rs6000_invalid_builtin): Add support for the RS6000_BTM_P9_MISC
+	flag used independently and in combination with the
+	RS6000_BTM_64BIT flag.
+	(rs6000_opt_masks): Add entry for power9-misc command-line option.
+	(rs6000_builtin_mask_names): Add entry for power9-misc
+	command-line option.
+	* config/rs6000/rs6000.h: Redefine TARGET_P9_MISC as 0 if
+	HAVE_AS_POWER9 is not a defined macro.  Define MASK_P9_MISC and
+	RS6000_BTM_P9_MISC macros.
+	* config/rs6000/rs6000.opt: Add support for the -mpower9-misc
+	option and change the description of the -mpower9-vector option to
+	enable only vector instructions, removing its erroneously claimed
+	support for scalar instructions.
+	* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document
+	the ISA 3.0 digital floating point test significance built-in
+	functions.
+
+2016-07-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-06-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64516
+	* fold-const.c (fold_unary_loc): Preserve alignment when
+	folding a VIEW_CONVERT_EXPR into a MEM_REF.
+
+2016-07-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-05-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71264
+	* tree-vect-stmts.c (vect_init_vector): Properly deal with
+	vector type val.
+
+	2016-06-07  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/71423
+	* match.pd ((X | ~Y) -> Y <= X): Properly invert the comparison
+	for signed ops.
+
+	2016-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71521
+	* tree-vrp.c (extract_range_from_binary_expr_1): Guard
+	division int_const_binop against zero divisor.
+
+	2016-06-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71452
+	* tree-ssa.c (non_rewritable_lvalue_p): Make sure that the
+	type used for the SSA rewrite has enough precision to cover
+	the dynamic type of the location.
+
+	2016-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71522
+	* tree-ssa.c (non_rewritable_lvalue_p): Do not rewrite non-float
+	copying into float copying.
+
+2016-07-06  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	Backport from mainline
+	2016-07-06  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	PR target/50739	
+	* config/avr/avr.c (avr_asm_select_section): Strip off
+	SECTION_DECLARED from flags when calling get_section.
+
+2016-07-05  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline
+	2016-06-28  Pat Haugen  <pthaugen@us.ibm.com>
+
+	* config/rs6000/rs6000.md ('type' attribute): Add htmsimple/dfp types.
+	('size' attribute): Add '128'.
+	Include power9.md.
+	(*mov<mode>_hardfloat32, *mov<mode>_hardfloat64, *movdi_internal32,
+	*movdi_internal64, *movdf_update1): Set size attribute to '64'.
+	(add<mode>3, sub<mode>3, mul<mode>3, div<mode>3, sqrt<mode>2,
+	copysign<mode>3, neg<mode>2_hw, abs<mode>2_hw, *nabs<mode>2_hw,
+	*fma<mode>4_hw, *fms<mode>4_hw, *nfma<mode>4_hw, *nfms<mode>4_hw,
+	extend<SFDF:mode><IEEE128:mode>2_hw, trunc<mode>df2_hw,
+	*xscvqp<su>wz_<mode>, *xscvqp<su>dz_<mode>, *xscv<su>dqp_<mode>,
+	*trunc<mode>df2_odd): Set size attribute to '128'.
+	(*cmp<mode>_hw): Change type to veccmp and set size attribute to '128'.
+	* config/rs6000/power6.md (power6-fp): Include dfp type.
+	* config/rs6000/power7.md (power7-fp): Likewise.
+	* config/rs6000/power8.md (power8-fp): Likewise.
+	* config/rs6000/power9.md: New file.
+	* config/rs6000/t-rs6000 (MD_INCLUDES): Add power9.md.
+	* config/rs6000/htm.md (*tabort, *tabort<wd>c, *tabort<wd>ci,
+	*trechkpt, *treclaim, *tsr, *ttest): Change type attribute to
+	htmsimple.
+	* config/rs6000/dfp.md (extendsddd2, truncddsd2, extendddtd2,
+	trunctddd2, adddd3, addtd3, subdd3, subtd3, muldd3, multd3, divdd3,
+	divtd3, *cmpdd_internal1, *cmptd_internal1, floatdidd2, floatditd2,
+	ftruncdd2, fixdddi2, ftrunctd2, fixtddi2, dfp_ddedpd_<mode>,
+	dfp_denbcd_<mode>, dfp_dxex_<mode>, dfp_diex_<mode>, dfp_dscli_<mode>,
+	dfp_dscri_<mode>): Change type attribute to dfp.
+	* config/rs6000/crypto.md (crypto_vshasigma<CR_char>): Change type
+	attribute to vecsimple.
+	* config/rs6000/rs6000.c (power9_cost): Update costs, cache size
+	and prefetch streams.
+	(rs6000_option_override_internal): Remove temporary code setting
+	tuning to power8.  Don't set rs6000_sched_groups for power9.
+	(last_scheduled_insn): Change to rtx_insn *.
+	(divide_cnt, vec_load_pendulum): New variables.
+	(rs6000_adjust_cost): Add Power9 to test for store->load separation.
+	(rs6000_issue_rate): Set issue rate for Power9.
+	(is_power9_pairable_vec_type): New.
+	(power9_sched_reorder2): New.
+	(rs6000_sched_reorder2): Call new function for Power9 specific
+	reordering.
+	(insn_must_be_first_in_group): Remove Power9.
+	(insn_must_be_last_in_group): Likewise.
+	(force_new_group): Likewise.
+	(rs6000_sched_init): Fix initialization of last_scheduled_insn.
+	Initialize divide_cnt/vec_load_pendulum.
+	(_rs6000_sched_context, rs6000_init_sched_context,
+	rs6000_set_sched_context): Handle context save/restore of new
+	variables.
+
+2016-07-05  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline
+	2016-06-27  Pat Haugen  <pthaugen@us.ibm.com>
+
+	* config/rs6000/rs6000.md ('type' attribute): Add
+	veclogical,veccmpfx,vecexts,vecmove insn types.
+	(*abs<mode>2_fpr, *nabs<mode>2_fpr, *neg<mode>2_fpr, *extendsfdf2_fpr,
+	copysign<mode>3_fcpsgn, trunc<mode>df2_internal1, neg<mode>2_internal,
+	p8_fmrgow_<mode>, pack<mode>): Change type to fpsimple.
+	(*xxsel<mode>, copysign<mode>3_hard, neg<mode>2_hw, abs<mode>2_hw,
+	*nabs<mode>2_hw): Change type to vecmove.
+	(*and<mode>3_internal, *bool<mode>3_internal, *boolc<mode>3_internal,
+	*boolcc<mode>3_internal, *eqv<mode>3_internal,
+	*one_cmpl<mode>3_internal, *ieee_128bit_vsx_neg<mode>2_internal,
+	*ieee_128bit_vsx_abs<mode>2_internal,
+	*ieee_128bit_vsx_nabs<mode>2_internal, extendkftf2, trunctfkf2,
+	*ieee128_mfvsrd_64bit, *ieee128_mfvsrd_32bit, *ieee128_mtvsrd_64bit,
+	*ieee128_mtvsrd_32bit): Change type to veclogical.
+	(mov<mode>_hardfloat, *mov<mode>_hardfloat32, *mov<mode>_hardfloat64,
+	*movdi_internal32, *movdi_internal64): Update insn types.
+	* config/rs6000/vsx.md (*vsx_le_undo_permute_<mode>,
+	vsx_extract_<mode>): Change type to veclogical.
+	(*vsx_xxsel<mode>, *vsx_xxsel<mode>_uns): Change type to vecmove.
+	(vsx_sign_extend_qi_<mode>, *vsx_sign_extend_hi_<mode>,
+	*vsx_sign_extend_si_v2di): Change type to vecexts.
+	* config/rs6000/altivec.md (*altivec_mov<mode>, *altivec_movti): Change
+	type to veclogical.
+	(*altivec_eq<mode>, *altivec_gt<mode>, *altivec_gtu<mode>,
+	*altivec_vcmpequ<VI_char>_p, *altivec_vcmpgts<VI_char>_p,
+	*altivec_vcmpgtu<VI_char>_p): Change type to veccmpfx.
+	(*altivec_vsel<mode>, *altivec_vsel<mode>_uns): Change type to vecmove.
+	* config/rs6000/dfp.md (*negdd2_fpr, *absdd2_fpr, *nabsdd2_fpr,
+	negtd2, *abstd2_fpr, *nabstd2_fpr): Change type to fpsimple.
+	* config/rs6000/40x.md (ppc405-float): Add fpsimple.
+	* config/rs6000/440.md (ppc440-fp): Add fpsimple.
+	* config/rs6000/476.md (ppc476-fp): Add fpsimple.
+	* config/rs6000/601.md (ppc601-fp): Add fpsimple.
+	* config/rs6000/603.md (ppc603-fp): Add fpsimple.
+	* config/rs6000/6xx.md (ppc604-fp): Add fpsimple.
+	* config/rs6000/7xx.md (ppc750-fp): Add fpsimple.
+	(ppc7400-vecsimple): Add veclogical, vecmove, veccmpfx.
+	* config/rs6000/7450.md (ppc7450-fp): Add fpsimple.
+	(ppc7450-vecsimple): Add veclogical, vecmove.
+	(ppc7450-veccmp): Add veccmpfx.
+	* config/rs6000/8540.md (ppc8540_simple_vector): Add veclogical,
+	vecmove.
+	(ppc8540_vector_compare): Add veccmpfx.
+	* config/rs6000/a2.md (ppca2-fp): Add fpsimple.
+	* config/rs6000/cell.md (cell-fp): Add fpsimple.
+	(cell-vecsimple): Add veclogical, vecmove.
+	(cell-veccmp): Add veccmpfx.
+	* config/rs6000/e300c2c3.md (ppce300c3_fp): Add fpsimple.
+	* config/rs6000/e6500.md (e6500_vecsimple): Add veclogical, vecmove,
+	veccmpfx.
+	* config/rs6000/mpc.md (mpccore-fp): Add fpsimple.
+	* config/rs6000/power4.md (power4-fp): Add fpsimple.
+	(power4-vecsimple): Add veclogical, vecmove.
+	(power4-veccmp): Add veccmpfx.
+	* config/rs6000/power5.md (power5-fp): Add fpsimple.
+	* config/rs6000/power6.md (power6-fp): Add fpsimple.
+	(power6-vecsimple): Add veclogical, vecmove.
+	(power6-veccmp): Add veccmpfx.
+	* config/rs6000/power7.md (power7-fp): Add fpsimple.
+	(power7-vecsimple): Add veclogical, vecmove, veccmpfx.
+	* config/rs6000/power8.md (power8-fp): Add fpsimple.
+	(power8-vecsimple): Add veclogical, vecmove, veccmpfx.
+	* config/rs6000/rs64.md (rs64a-fp): Add fpsimple.
+	* config/rs6000/titan.md (titan_fp): Add fpsimple.
+	* config/rs6000/xfpu.md (fp-default, fp-addsub-s, fp-addsub-d): Add
+	fpsimple.
+	* config/rs6000/rs6000.c (rs6000_adjust_cost): Add TYPE_FPSIMPLE.
+
+2016-07-05  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline r237391
+	2016-06-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000.h (RS6000_BTM_COMMON): Add the
+	RS6000_BTM_MODULO flag into the set of flags that are considered
+	to be part of the common configuration.
+
+2016-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71739
+	* tree.c (attribute_value_equal): Use get_attribute_name instead of
+	directly using TREE_PURPOSE.
+
+2016-07-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2016-06-27  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/71670
+	* config/rs6000/rs6000.md (ashdi3_extswsli_dot): Use
+	gen_ashdi3_extswsli_dot2 instead of gen_ashdi3_extswsli_dot.
+
+2016-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-06-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71626
+	* config/i386/i386.c (ix86_expand_vector_move): For SUBREG of
+	a constant, force its SUBREG_REG into memory or register instead
+	of whole op1.
+
+	2016-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/71559
+	* config/i386/i386.c (ix86_fp_cmp_code_to_pcmp_immediate): Fix up
+	returned values and add UN*/LTGT/*ORDERED cases with values matching
+	D operand modifier on vcmp for AVX.
+
+2016-07-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from trunk r237659
+	2016-06-21  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000.h: Add conditional preprocessing directives
+	to disable Power9-specific compiler features if HAVE_AS_POWER9 is
+	not defined.
+
+2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from trunk
+	2016-06-27  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/71656
+	* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Add
+	OPTION_MASK_P9_DFORM_VECTOR.
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Do not
+	disable -mpower9-dform-vector when using reload.
+	(quad_address_p): Remove 'gpr_p' argument and all associated code.
+	New 'strict' argument.  Update all callers.  Add strict addressing
+	support.
+	(rs6000_legitimate_offset_address_p): Remove call to
+	virtual_stack_registers_memory_p.
+	(rs6000_legitimize_reload_address): Add quad address support.
+	(rs6000_legitimate_address_p): Move call to quad_address_p above
+	call to virtual_stack_registers_memory_p.  Adjust quad_address_p args
+	to account for new strict usage.
+	(rs6000_output_move_128bit): Adjust quad_address_p args to account
+	for new strict usage.
+	* config/rs6000/predicates.md (quad_memory_operand): Likewise.
+
+2016-07-01  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-06-24  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def (BU_FLOAT128_2): New #define.
+	(BU_FLOAT128_1): Likewise.
+	(FABSQ): Likewise.
+	(COPYSIGNQ): Likewise.
+	(RS6000_BUILTIN_NANQ): Likewise.
+	(RS6000_BUILTIN_NANSQ): Likewise.
+	(RS6000_BUILTIN_INFQ): Likewise.
+	(RS6000_BUILTIN_HUGE_VALQ): Likewise.
+	* config/rs6000/rs6000.c (rs6000_fold_builtin): New prototype.
+	(TARGET_FOLD_BUILTIN): New #define.
+	(rs6000_builtin_mask_calculate): Add TARGET_FLOAT128 entry.
+	(rs6000_invalid_builtin): Add handling for RS6000_BTM_FLOAT128.
+	(rs6000_fold_builtin): New target hook implementation, handling
+	folding of 128-bit NaNs and infinities.
+	(rs6000_init_builtins): Initialize const_str_type_node; ensure all
+	entries are filled in to avoid problems during bootstrap
+	self-test; define builtins for 128-bit NaNs and infinities.
+	(rs6000_opt_mask): Add entry for float128.
+	* config/rs6000/rs6000.h (RS6000_BTM_FLOAT128): New #define.
+	(RS6000_BTM_COMMON): Include RS6000_BTM_FLOAT128.
+	(rs6000_builtin_type_index): Add RS6000_BTI_const_str.
+	(const_str_type_node): New #define.
+	* config/rs6000/rs6000.md (copysign<mode>3 for IEEE128): Convert
+	to a define_expand that dispatches to either copysign<mode>3_soft
+	or copysign<mode>3_hard.
+	(copysign<mode>3_hard): Rename from copysign<mode>3.
+	(copysign<mode>3_soft): New define_insn.
+	* doc/extend.texi: Document new builtins.
+
+2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from trunk
+	2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/71698
+	* config/rs6000/rs6000.c (rs6000_secondary_reload_simple_move): Disallow
+	TDmode values.
+
+2016-07-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from trunk r236992
+	2016-06-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/altivec.h (vec_slv): New macro.
+	(vec_srv): New macro.
+	* config/rs6000/altivec.md (UNSPEC_VSLV): New value.
+	(UNSPEC_VSRV): New value.
+	(vslv): New insn.
+	(vsrv): New insn.
+	* config/rs6000/rs6000-builtin.def (vslv): New builtin definition.
+	(vsrv): New builtin definition.
+	* config/rs6000/rs6000-c.c (P9V_BUILTIN_VSLV): Macro expansion to
+	define argument types for new builtin.
+	(P9V_BUILTIN_VSRV): Macro expansion to define argument types for
+	new builtin.
+	* doc/extend.texi: Document the new vec_vslv and vec_srv built-in
+	functions.
+
+2016-07-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/arm/arm.c (arm_function_ok_for_sibcall): Add another check
+	for NULL decl.
+
+2016-06-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from trunk r237390
+	2016-06-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/altivec.h (vec_absd): New macro for vector absolute
+	difference unsigned.
+	(vec_absdb): New macro for vector absolute difference unsigned
+	byte.
+	(vec_absdh): New macro for vector absolute difference unsigned
+	half-word.
+	(vec_absdw): New macro for vector absolute difference unsigned word.
+	* config/rs6000/altivec.md (UNSPEC_VADU): New value.
+	(vadu<mode>3): New insn.
+	(*p9_vadu<mode>3): New insn.
+	* config/rs6000/rs6000-builtin.def (vadub): New built-in
+	definition.
+	(vaduh): New built-in definition.
+	(vaduw): New built-in definition.
+	(vadu): New overloaded built-in definition.
+	(vadub): New overloaded built-in definition.
+	(vaduh): New overloaded built-in definition.
+	(vaduw): New overloaded built-in definition.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	overloaded vector absolute difference unsigned functions.
+	* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document
+	the ISA 3.0 vector absolute difference unsigned built-in functions.
+
+2016-06-30  David Malcolm  <dmalcolm@redhat.com>
+
+	Backport from trunk r237880.
+	2016-06-30  David Malcolm  <dmalcolm@redhat.com>
+
+	PR driver/71651
+	* gcc.c (driver::build_option_suggestions): Pass "option" to
+	add_misspelling_candidates.
+	* opts-common.c (add_misspelling_candidates): Add "option" param;
+	use it to avoid adding negated forms for options marked with
+	RejectNegative.
+	* opts.h (add_misspelling_candidates): Add "option" param.
+
+2016-06-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71693
+	* fold-const.c (fold_binary_loc) <case RROTATE_EXPR>: Cast
+	TREE_OPERAND (arg0, 0) and TREE_OPERAND (arg0, 1) to type
+	first when permuting bitwise operation with rotate.  Cast
+	TREE_OPERAND (arg0, 0) to type when cancelling two rotations.
+
+2016-06-30  Martin Liska  <mliska@suse.cz>
+
+	Parting backport from mainline
+	2016-06-29  Martin Liska  <mliska@suse.cz>
+
+	* ipa-inline-transform.c (inline_call): Remove unnecessary call
+	of build_optimization_node.
+
+2016-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2016-06-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* df-problems.c (df_note_bb_compute): Guard use of DF_INSN_INFO_GET.
+
+2016-06-27  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-06-21  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* stor-layout.c (layout_type): Move setting complex MODE to
+	layout_type, instead of setting it ahead of time by the caller.
+
+	Back port from trunk
+	2016-05-11  Alan Modra  <amodra@gmail.com>
+
+	* config/rs6000/rs6000.c (is_complex_IBM_long_double,
+	abi_v4_pass_in_fpr): New functions.
+	(rs6000_function_arg_boundary): Exclude complex IBM long double
+	from 64-bit alignment when ABI_V4.
+	(rs6000_function_arg, rs6000_function_arg_advance_1,
+	rs6000_gimplify_va_arg): Use abi_v4_pass_in_fpr.
+
+	Back port from trunk
+	2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* machmode.h (mode_complex): Add support to give the complex mode
+	for a given mode.
+	(GET_MODE_COMPLEX_MODE): Likewise.
+	* stor-layout.c (layout_type): For COMPLEX_TYPE, use the mode
+	stored by build_complex_type and gfc_build_complex_type instead of
+	trying to figure out the appropriate mode based on the size. Raise
+	an assertion error, if the type was not set.
+	* genmodes.c (struct mode_data): Add field for the complex type of
+	the given type.
+	(blank_mode): Likewise.
+	(make_complex_modes): Remember the complex mode created in the
+	base type.
+	(emit_mode_complex): Write out the mode_complex array to map a
+	type mode to the complex version.
+	(emit_insn_modes_c): Likewise.
+	* tree.c (build_complex_type): Set the complex type to use before
+	calling layout_type.
+	* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Add
+	support for __float128 complex datatypes.
+	(rs6000_hard_regno_mode_ok): Likewise.
+	(rs6000_setup_reg_addr_masks): Likewise.
+	(rs6000_complex_function_value): Likewise.
+	* config/rs6000/rs6000.h (FLOAT128_IEEE_P): Likewise.
+	__float128 and __ibm128 complex.
+	(FLOAT128_IBM_P): Likewise.
+	(ALTIVEC_ARG_MAX_RETURN): Likewise.
+	* doc/extend.texi (Additional Floating Types): Document that
+	-mfloat128 must be used to enable __float128.  Document complex
+	__float128 and __ibm128 support.
+
+2016-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71647
+	* omp-low.c (lower_rec_input_clauses): Convert
+	omp_clause_aligned_alignment (c) to size_type_node for the
+	last argument of __builtin_assume_aligned.
+
+2016-06-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* function.c (assign_parm_setup_reg): Prevent sharing in another case.
+
+2016-06-21  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2016-06-21 trunk r237639.
+
+	PR target/30417
+	* config/avr/gen-avr-mmcu-specs.c (print_mcu):
+	[*link_data_start]: Wrap -Tdata into %{!Tdata:...}.
+	[*link_text_start]: Wrap -Ttext into %{!Ttext:...}.
+
+2016-06-21  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/71103
+	* config/avr/avr.md (movqi): Only handle loading subreg:qi of
+	constant addresses if can_create_pseudo_p.
+
+2016-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71588
+	* tree-ssa-strlen.c (valid_builtin_call): New function.
+	(adjust_last_stmt, handle_builtin_memset, strlen_optimize_stmt): Use
+	it.
+
+	Backported from mainline
+	2016-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71581
+	* tree-ssa-uninit.c (warn_uninit): If EXPR and VAR are NULL,
+	see if T isn't anonymous SSA_NAME with COMPLEX_EXPR created
+	for conversion of scalar user var to complex type and use the
+	underlying SSA_NAME_VAR in that case.  If EXPR is still NULL,
+	punt.
+
+	2016-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* gimplify.c (gimplify_scan_omp_clauses): Handle COMPONENT_REFs
+	with base of reference to struct.
+
+2016-06-20  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r237484.
+	2016-06-15  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR middle-end/71529
+	* ipa-chkp.c (chkp_build_instrumented_fndecl): Fix
+	DECL_CONTEXT for copied arguments.
+
+2016-06-20  Georg-Johann Lay  <avr@gjlay.de>
+	    Pitchumani Sivanupandi  <pitchumani.s@atmel.com>
+
+	Backport from 2016-06-20 trunk r237589, r236558.
+
+	PR target/71103
+	* config/avr/avr.md (movqi): Handle loading subreg:qi (const,
+	symbol_ref,label_ref).
+
+2016-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/71554
+	* config/i386/i386.md (setcc + movzbl peephole2): Use reg_set_p.
+	(setcc + and peephole2): Likewise.
+
+2016-06-15  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backported from mainline
+	2016-06-14  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/arm/freebsd.h: Only enable unaligned access for armv6 on
+	FreeBSD 11 and above.
+
+2016-06-15  Ilya Verbin  <ilya.verbin@intel.com>
+
+	Backport from mainline
+	2016-04-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/darwin.h (LINK_COMMAND_SPEC_A): Handle -fcilkplus.
+
+2016-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-06-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71494
+	* tree-nested.c (convert_nonlocal_reference_stmt): For GIMPLE_GOTO
+	without LABEL_DECL, set *handled_ops_p to false instead of true.
+
+	2016-06-08  Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR c++/71448
+	* fold-const.c (fold_comparison): Handle CONSTANT_CLASS_P (base0)
+	the same as DECL_P (base0) for indirect_base0.  Use equality_code
+	in one further place.
+
+	2016-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71405
+	* tree-ssa.c (execute_update_addresses_taken): For clobber with
+	incompatible type, build a new clobber with the right type instead
+	of building a VIEW_CONVERT_EXPR around it.
+
+2016-06-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Use a uniform test and
+	update shared_lookup_references only once after changing operands.
+
+2016-06-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71505
+	* tree-vect-data-refs.c (vect_analyze_data_ref_accesses): Make
+	assert match comment.
+
+2016-06-13  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-06-13  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/71379
+	* config/s390/s390.c (s390_expand_builtin): Increase MAX_ARGS by
+	one.
+
+2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/71373
+	Backport from trunk r237291:
+	* tree-nested.c (convert_nonlocal_omp_clauses)
+	(convert_local_omp_clauses): Handle OMP_CLAUSE_ASYNC,
+	OMP_CLAUSE_WAIT, OMP_CLAUSE_INDEPENDENT, OMP_CLAUSE_AUTO,
+	OMP_CLAUSE__CACHE_, OMP_CLAUSE_TILE.
+
+	Backport from trunk r237291:
+	* gimplify.c (gimplify_adjust_omp_clauses): Discard
+	OMP_CLAUSE_TILE.
+	* omp-low.c (scan_sharing_clauses): Don't expect OMP_CLAUSE_TILE.
+
+	Backport from trunk r237290:
+	* omp-low.c (scan_sharing_clauses): Don't expect
+	OMP_CLAUSE__CACHE_.
+
+	Backport trunk r235964:
+	2016-05-06  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* gimple.c (gimple_call_same_target_p): Unique functions are eq.
+	* tree-ssa-tail-merge.c (same_succ::equal): Check pointer eq
+	equality first.
+
+2016-06-09  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-31  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/vsx.md (vsx_splat_<mode>, V2DI/V2DF): Simplify
+	alternatives, eliminating preferred register class.  Add support
+	for the MTVSRDD instruction in ISA 3.0.
+	(vsx_splat_v4si_internal): Use splat_input_operand instead of
+	reg_or_indexed_operand.
+	(vsx_splat_v4sf_internal): Likewise.
+
+	Back port from trunk
+	2016-05-31  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71186
+	* config/rs6000/vsx.md (xxspltib_<mode>_nosplit): Add alternatives
+	for loading up all 0's or all 1's.
+
+	Back port from trunk
+	2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/70915
+	* config/rs6000/constraints.md (wE constraint): New constraint
+	for a vector constant that can be loaded with XXSPLTIB.
+	(wM constraint): New constraint for a vector constant of a 1's.
+	(wS constraint): New constraint for a vector constant that can be
+	loaded with XXSPLTIB and a vector sign extend instruction.
+	* config/rs6000/predicates.md (xxspltib_constant_split): New
+	predicates for wE/wS constraints.
+	(xxspltib_constant_nosplit): Likewise.
+	(easy_vector_constant): Add support for constants that can be
+	loaded via XXSPLTIB.
+	(splat_input_operand): Add support for ISA 3.0 word splat operations.
+	* config/rs6000/rs6000.c (xxspltib_constant_p): New function to
+	return if a constant can be loaded with the ISA 3.0 XXSPLTIB
+	instruction and possibly with a sign extension.
+	(output_vec_const_move): Add support for XXSPLTIB. If we are
+	loading up 0/-1 into Altivec registers, prefer using VSPLTISW
+	instead of XXLXOR/XXLORC.
+	(rs6000_expand_vector_init): Add support for ISA 3.0 word splat
+	operations.
+	(rs6000_legitimize_reload_address): Likewise.
+	(rs6000_output_move_128bit): Use output_vec_const_move to emit
+	constants.
+	* config/rs6000/vsx.md (VSX_M): Add TImode (if -mvsx-timode) and
+	combine VSX_M and VSX_M2 into one iterator.
+	(VSX_M2): Likewise.
+	(VSINT_84): New iterators for loading constants with XXSPLTIB.
+	(VSINT_842): Likewise.
+	(UNSPEC_VSX_SIGN_EXTEND): New UNSPEC.
+	(xxspltib_v16qi): New insns to load up constants with the ISA 3.0
+	XXSPLTIB instruction.
+	(xxspltib_<mode>_nosplit): Likewise.
+	(xxspltib_<mode>_split): New insn to load up constants with
+	XXSPLTIB and a sign extend instruction.
+	(vsx_mov<mode>): Replace single move that handled all vector types
+	with separate 32-bit and 64-bit moves.  Combine the movti_<bit>
+	moves (when -mvsx-timode is in effect) into the main vector
+	moves.  Eliminate separate moves for <VSr> <VSa>, where the
+	preferred register class (<VSr>) is listed first, and the
+	secondary register class (<VSa>) is listed second with a '?' to
+	discourage use.  Prefer loading 0/-1 in any VSX register for ISA
+	3.0, and Altivec registers for ISA 2.06/2.07 (PR target/70915) so
+	that if the register was involved in a slow operation, the
+	clear/set operation does not wait for the slow operation to
+	finish.  Adjust the length attributes for 32-bit mode.  Use
+	rs6000_output_move_128bit and drop the use of the string
+	instructions for 32-bit movti when -mvsx-timode is in effect.  Use
+	spacing so that the alternatives and attributes don't generate
+	long lines, and put things in columns, so that it is easier to
+	match up the operands and attributes with the insn alternatives.
+	(vsx_mov<mode>_64bit): Likewise.
+	(vsx_mov<mode>_32bit): Likewise.
+	(vsx_movti_64bit): Fold movti into normal vector moves.
+	(vsx_movti_32bit): Likewise.
+	(vsx_splat_<mode>, V4SI/V4SF modes): Add support for ISA 3.0 word
+	splat instructions.
+	(vsx_splat_v4si_internal): Likewise.
+	(vsx_splat_v4sf_internal): Likewise.
+	(vector fusion peepholes): Use VSX_M instead of VSX_M2.
+	(vsx_sign_extend_qi_<mode>): New ISA 3.0 instructions to sign
+	extend vector elements.
+	(vsx_sign_extend_hi_<mode>): Likewise.
+	(vsx_sign_extend_si_v2di): Likewise.
+	* config/rs6000/rs6000-protos.h (xxspltib_constant_p): Add
+	declaration.
+	* doc/md.texi (PowerPC constraints): Document the wE, wM, and wS
+	constraints.  Add trailing period to wL documentation.
+
+2016-06-08  Jose E. Marchesi  <jose.marchesi@oracle.com>
+
+	Backport from mainline
+	2016-06-08  Jose E. Marchesi  <jose.marchesi@oracle.com>
+
+	* config/sparc/driver-sparc.c (cpu_names): Fix the entry for the
+	SPARC-M7 and add an entry for SPARC-S7 cpus (Sonoma).
+
+2016-06-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2016-06-06  Jose E. Marchesi  <jose.marchesi@oracle.com>
+
+	* config/sparc/sparc.md (cpu): Add niagara7 cpu type.
+	Include the M7 SPARC DFA scheduler.
+	New attribute v3pipe.
+	Annotate insns with v3pipe where appropriate.
+	Define cpu_feature vis4.
+	Add lzd instruction type and set it on clzdi_sp64 and clzsi_sp64.
+	Add (V8QI "8") to vbits.
+	Add insns {add,sub}v8qi3
+	Add insns ss{add,sub}v8qi3
+	Add insns us{add,sub}{v8qi,v4hi}3
+	Add insns {min,max}{v8qi,v4hi,v2si}3
+	Add insns {minu,maxu}{v8qi,v4hi,v2si}3
+	Add insns fpcmp{le,gt,ule,ug,ule,ugt}{8,16,32}_vis.
+	* config/sparc/niagara4.md: Add a comment explaining the
+	discrepancy between the documented latenty numbers and the
+	implemented ones.
+	* config/sparc/niagara7.md: New file.
+	* configure.ac (HAVE_AS_SPARC5_VIS4): Define if the assembler
+	supports SPARC5 and VIS 4.0 instructions.
+	* configure: Regenerate.
+	* config.in: Likewise.
+	* config.gcc: niagara7 is a supported cpu in sparc*-*-* targets.
+	* config/sparc/sol2.h (ASM_CPU32_DEFAUILT_SPEC): Set for
+	TARGET_CPU_niagara7.
+	(ASM_CPU64_DEFAULT_SPEC): Likewise.
+	(CPP_CPU_SPEC): Handle niagara7.
+	(ASM_CPU_SPEC): Likewise.
+	* config/sparc/sparc-opts.h (processor_type): Add
+	PROCESSOR_NIAGARA7.
+	(mvis4): New option.
+	* config/sparc/sparc.h (TARGET_CPU_niagara7): Define.
+	(AS_NIAGARA7_FLAG): Define.
+	(ASM_CPU64_DEFAULT_SPEC): Set for niagara7.
+	(CPP_CPU64_DEFAULT_SPEC): Likewise.
+	(CPP_CPU_SPEC): Handle niagara7.
+	(ASM_CPU_SPEC): Likewise.
+	* config/sparc/sparc.c (niagara7_costs): Define.
+	(sparc_option_override): Handle niagara7 and adjust cache-related
+	parameters with better values for niagara cpus.  Also support VIS4.
+	(sparc32_initialize_trampoline): Likewise.
+	(sparc_use_sched_lookahead): Likewise.
+	(sparc_issue_rate): Likewise.
+	(sparc_register_move_cost): Likewise.
+	(dump_target_flag_bits): Support VIS4.
+	(sparc_vis_init_builtins): Likewise.
+	(sparc_builtins): Likewise.
+	* config/sparc/sparc-c.c (sparc_target_macros): Define __VIS__ for
+	VIS4 4.0.
+	* config/sparc/driver-sparc.c (cpu_names): Add SPARC-M7 and
+	UltraSparc M7.
+	* config/sparc/sparc.opt (sparc_processor_type): New value
+	niagara7.
+	* config/sparc/visintrin.h (__attribute__): Prototypes for the
+	VIS4 builtins.
+	* doc/invoke.texi (SPARC Options): Document -mcpu=niagara7 and
+	-mvis4.
+	* doc/extend.texi (SPARC VIS Built-in Functions): Document the
+	VIS4 builtins.
+
+	2016-05-30  Jose E. Marchesi  <jose.marchesi@oracle.com>
+
+	* config.gcc (sparc*-*-*): Support cpu_32, cpu_64, tune_32 and
+	tune_64.
+	* doc/install.texi (--with-cpu-32, --with-cpu-64): Document
+	support on SPARC.
+	* config/sparc/linux64.h (OPTION_DEFAULT_SPECS): Add entries for
+	cpu_32, cpu_64, tune_32 and tune_64.
+	* config/sparc/sol2.h (OPTION_DEFAULT_SPECS): Likewise.
+
+2016-06-08  Ilya Verbin  <ilya.verbin@intel.com>
+
+	Backport from mainline
+	2016-05-25  Ilya Verbin  <ilya.verbin@intel.com>
+
+	* config/i386/i386-builtin-types.def: Add V16SI_FTYPE_V16SF,
+	V8DF_FTYPE_V8DF_ROUND, V16SF_FTYPE_V16SF_ROUND, V16SI_FTYPE_V16SF_ROUND.
+	* config/i386/i386.c (enum ix86_builtins): Add
+	IX86_BUILTIN_CVTPS2DQ512_MASK, IX86_BUILTIN_FLOORPS512,
+	IX86_BUILTIN_FLOORPD512, IX86_BUILTIN_CEILPS512, IX86_BUILTIN_CEILPD512,
+	IX86_BUILTIN_TRUNCPS512, IX86_BUILTIN_TRUNCPD512,
+	IX86_BUILTIN_CVTPS2DQ512, IX86_BUILTIN_VEC_PACK_SFIX512,
+	IX86_BUILTIN_FLOORPS_SFIX512, IX86_BUILTIN_CEILPS_SFIX512,
+	IX86_BUILTIN_ROUNDPS_AZ_SFIX512.
+	(builtin_description bdesc_args): Add __builtin_ia32_floorps512,
+	__builtin_ia32_ceilps512, __builtin_ia32_truncps512,
+	__builtin_ia32_floorpd512, __builtin_ia32_ceilpd512,
+	__builtin_ia32_truncpd512, __builtin_ia32_cvtps2dq512,
+	__builtin_ia32_vec_pack_sfix512, __builtin_ia32_roundps_az_sfix512,
+	__builtin_ia32_floorps_sfix512, __builtin_ia32_ceilps_sfix512.
+	Change IX86_BUILTIN_CVTPS2DQ512 to IX86_BUILTIN_CVTPS2DQ512_MASK for
+	__builtin_ia32_cvtps2dq512_mask.
+	(ix86_expand_args_builtin): Handle V8DF_FTYPE_V8DF_ROUND,
+	V16SF_FTYPE_V16SF_ROUND, V16SI_FTYPE_V16SF_ROUND, V16SI_FTYPE_V16SF.
+	(ix86_builtin_vectorized_function): Handle builtins mentioned above.
+	* config/i386/sse.md
+	(<mask_codefor>avx512f_fix_notruncv16sfv16si<mask_name><round_name>):
+	Rename to ...
+	(avx512f_fix_notruncv16sfv16si<mask_name><round_name>): ... this.
+	(<mask_codefor>avx512f_cvtpd2dq512<mask_name><round_name>): Rename
+	to ...
+	(avx512f_cvtpd2dq512<mask_name><round_name>): ... this.
+	(avx512f_vec_pack_sfix_v8df): New define_expand.
+	(avx512f_roundpd512): Rename to ...
+	(avx512f_round<castmode>512): ... this.  Change iterator.
+	(avx512f_roundps512_sfix): New define_expand.
+	(round<mode>2_sfix): Change iterator.
+
+2016-06-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2016-06-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* doc/invoke.texi (RS/6000 and PowerPC Options): Document -mhtm and
+	-mno-htm.
+
+2016-06-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/71389
+	* config/i386/i386.c (ix86_avx256_split_vector_move_misalign):
+	Copy op1 RTX to avoid invalid sharing.
+	(ix86_expand_vector_move_misalign): Ditto.
+
+2016-06-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71259
+	* tree-vect-slp.c (vect_get_constant_vectors): For
+	VECTOR_BOOLEAN_TYPE_P, return all ones constant instead of
+	one for constant op, and use COND_EXPR for non-constant.
+
+2016-06-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from trunk
+	2016-06-02  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70830
+	* config/arm/arm.c (arm_output_multireg_pop): Guard "pop" on update.
+
+2016-06-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2016-06-01  Uros Bizjak  <ubizjak@gmail.com>
+		    Jocelyn Mayer  <l_indien@magic.fr>
+
+	PR target/67310
+	* config/i386/driver-i386.c (host_detect_local_cpu): Correctly
+	detect processor family for signature_CENTAUR_ebx.
+	<case PROCESSOR_I486>: Pass c3, winchip2 or winchip-c6 for
+	signature_CENTAUR_ebx.
+	<case PROCESSOR _PENTIUMPRO>: Pass c3-2 for signature_CENTAUR_ebx.
+	<default>: Pass x86-64 for has_longmode.
+
+2016-06-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71387
+	* cgraph.c (cgraph_edge::redirect_call_stmt_to_callee): If redirecting
+	to noreturn e->callee->decl that has void return type and void
+	arguments, adjust gimple_call_fntype and remove lhs even if it had
+	previously addressable type.
+
+2016-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-26  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_emit_p9_fp_minmax): New function
+	for ISA 3.0 min/max support.
+	(rs6000_emit_p9_fp_cmove): New function for ISA 3.0 floating point
+	conditional move support.
+	(rs6000_emit_cmove): Call rs6000_emit_p9_fp_minmax and
+	rs6000_emit_p9_fp_cmove if the ISA 3.0 instructions are
+	available.
+	* config/rs6000/rs6000.md (SFDF2): New iterator to allow doing
+	conditional moves where the comparison type is different from move
+	type.
+	(fp_minmax): New code iterator for smin/smax.
+	(minmax): New code attributes for min/max.
+	(SMINMAX): Likewise.
+	(smax<mode>3): Combine min, max insns into one insn using the
+	fp_minmax code iterator.  Add support for ISA 3.0 min/max
+	instructions that don't need -ffast-math.
+	(s<minmax><mode>3): Likewise.
+	(smax<mode>3_vsx): Likewise.
+	(smin<mode>3): Likewise.
+	(s<minmax><mode>3_vsx): Likewise.
+	(smin<mode>3_vsx): Likewise.
+	(pre-VSX min/max splitters): Likewise.
+	(s<minmax><mode>3_fpr): Likewise.
+	(movsfcc): Rewrite floating point conditional moves to combine
+	SFmode/DFmode into a single insn.
+	(mov<mode>cc): Likewise.
+	(movdfcc): Likewise.
+	(fselsfsf4): Combine FSEL cases into a single insn, using SFDF and
+	SFDF2 iterators to handle all combinations.
+	(fseldfsf4): Likewise.
+	(fsel<SFDF:mode><SFDF2:mode>4): Likewise.
+	(fseldfdf4): Likewise.
+	(fselsfdf4): Likewise.
+	(mov<SFDF:mode><SFDF2:mode>cc_p9): Add support for the ISA 3.0
+	comparison instructions that set a 0/-1 mask, and use it for
+	floating point conditional move via XXSEL.
+	(fpmask<mode>): Likewise.
+	(xxsel<mode>): Likewise.
+	* config/rs6000/predicates.md (min_max_operator): Delete, no
+	longer used.
+	(fpmask_comparison_operaton): New insn for ISA 3.0 comparison
+	instructions that generate a 0/-1 mask for use with XXSEL.
+	* config/rs6000/rs6000.h (TARGET_MINMAX_SF): New helper macros to
+	say whether floating point min/max is available, either through
+	FSEL, ISA 2.06 min/max, and ISA 3.0 min/max instrucitons.
+	(TARGET_MINMAX_DF): Likewise.
+
+	Back port from trunk
+	2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/predicate.md (all_ones_constant): New predicate
+	for vector constant with all 1's set.
+
+2016-06-02  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Back port from trunk
+	2016-05-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/altivec.md (UNSPEC_DARN): New unspec constant.
+	(UNSPEC_DARN_32): New unspec constant.
+	(UNSPEC_DARN_RAW): New unspec constant.
+	(darn_32): New instruction.
+	(darn_raw): New instruction.
+	(darn): New instruction.
+	* config/rs6000/rs6000-builtin.def (RS6000_BUILTIN_0): Add
+	support and documentation for this macro.
+	(BU_P9_MISC_1): New macro definition.
+	(BU_P9_64BIT_MISC_0): New macro definition.
+	(BU_P9_MISC_0): New macro definition.
+	(darn_32): New builtin definition.
+	(darn_raw): New builtin definition.
+	(darn): New builtin definition.
+	* config/rs6000/rs6000.c: Add #define RS6000_BUILTIN_0 and #undef
+	RS6000_BUILTIN_0 directives to surround each occurrence of
+	#include "rs6000-builtin.def".
+	(rs6000_builtin_mask_calculate): Add in the RS6000_BTM_MODULO and
+	RS6000_BTM_64BIT flags to the returned mask, depending on
+	configuration.
+	(def_builtin): Correct an error in the assignments made to the
+	debugging variable attr_string.
+	(rs6000_expand_builtin): Add support for no-operand built-in
+	functions.
+	(builtin_function_type): Remove fatal_error assertion that is no
+	longer valid.
+	(rs6000_common_init_builtins): Add support for no-operand built-in
+	functions.
+	* config/rs6000/rs6000.h (RS6000_BTM_MODULO): New macro
+	definition.
+	(RS6000_BTM_PURE): Enhance comment to clarify intent of this flag
+	definition.
+	(RS6000_BTM_64BIT): New macro definition.
+	* doc/extend.texi: Document __builtin_darn (void),
+	__builtin_darn_raw (void), and __builtin_darn_32 (void) built-in
+	functions.
+
+2016-06-01  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-23  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71201
+	* config/rs6000/altivec.md (altivec_vperm_<mode>_internal): Drop
+	ISA 3.0 xxperm fusion alternative.
+	(altivec_vperm_v8hiv16qi): Likewise.
+	(altivec_vperm_<mode>_uns_internal): Likewise.
+	(vperm_v8hiv4si): Likewise.
+	(vperm_v16qiv8hi): Likewise.
+
+	Back port from trunk
+	2016-05-23  Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000.c (rs6000_expand_vector_set): Generate
+	vpermr/xxpermr on ISA 3.0.
+	(altivec_expand_vec_perm_le): Likewise.
+	* config/rs6000/altivec.md (UNSPEC_VPERMR): New unspec.
+	(altivec_vpermr_<mode>_internal): Add VPERMR/XXPERMR support for
+	ISA 3.0.
+
+	Back port from trunk
+	2016-05-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.md (VParity): New mode iterator for vector
+	parity built-in functions.
+	(p9v_ctz<mode>2): Add support for ISA 3.0 vector count trailing
+	zeros.
+	(p9v_parity<mode>2): Likewise.
+	* config/rs6000/vector.md (VEC_IP): New mode iterator for vector
+	parity.
+	(ctz<mode>2): ISA 3.0 expander for vector count trailing zeros.
+	(parity<mode>2): ISA 3.0 expander for vector parity.
+	* config/rs6000/rs6000-builtin.def (BU_P9_MISC_1): New macros for
+	power9 built-ins.
+	(BU_P9_64BIT_MISC_0): Likewise.
+	(BU_P9_MISC_0): Likewise.
+	(BU_P9V_AV_1): Likewise.
+	(BU_P9V_AV_2): Likewise.
+	(BU_P9V_AV_3): Likewise.
+	(BU_P9V_AV_P): Likewise.
+	(BU_P9V_VSX_1): Likewise.
+	(BU_P9V_OVERLOAD_1): Likewise.
+	(BU_P9V_OVERLOAD_2): Likewise.
+	(BU_P9V_OVERLOAD_3): Likewise.
+	(VCTZB): Add vector count trailing zeros support.
+	(VCTZH): Likewise.
+	(VCTZW): Likewise.
+	(VCTZD): Likewise.
+	(VPRTYBD): Add vector parity support.
+	(VPRTYBQ): Likewise.
+	(VPRTYBW): Likewise.
+	(VCTZ): Add overloaded vector count trailing zeros support.
+	(VPRTYB): Add overloaded vector parity support.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	overloaded vector count trailing zeros and parity instructions.
+	* config/rs6000/rs6000.md (wd mode attribute): Add V1TI and TI for
+	vector parity support.
+	* config/rs6000/altivec.h (vec_vctz): Add ISA 3.0 vector count
+	trailing zeros support.
+	(vec_cntlz): Likewise.
+	(vec_vctzb): Likewise.
+	(vec_vctzd): Likewise.
+	(vec_vctzh): Likewise.
+	(vec_vctzw): Likewise.
+	(vec_vprtyb): Add ISA 3.0 vector parity support.
+	(vec_vprtybd): Likewise.
+	(vec_vprtybw): Likewise.
+	(vec_vprtybq): Likewise.
+	* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document
+	the ISA 3.0 vector count trailing zeros and vector parity built-in
+	functions.
+
+	Back port from trunk
+	2016-05-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.md (VNEG iterator): New iterator for
+	VNEGW/VNEGD instructions.
+	(p9_neg<mode>2): New insns for ISA 3.0 VNEGW/VNEGD.
+	(neg<mode>2): Add expander for V2DImode added in ISA 2.07, and
+	support for ISA 3.0 VNEGW/VNEGD instructions.
+
+	Back port from trunk
+	2016-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/predicates.md (quad_memory_operand): Move most of
+	the code into quad_address_p and call it to share code with
+	vsx_quad_dform_memory_operand.
+	(vsx_quad_dform_memory_operand): New predicate for ISA 3.0 vector
+	d-form support.
+	* config/rs6000/rs6000.opt (-mlra): Switch to being an option mask
+	bit instead of being a separate word.  Split -mpower9-dform into
+	two switches, -mpower9-dform-scalar and -mpower9-dform-vector.
+	* config/rs6000/rs6000.c (RELOAD_REG_QUAD_OFFSET): New addr_mask
+	for the register class supporting 128-bit quad word memory offsets.
+	(mode_supports_vsx_dform_quad): Helper function to return if the
+	register class uses quad word memory offsets.
+	(rs6000_debug_addr_mask): Add support for quad word memory offsets.
+	(rs6000_debug_reg_global): Always print if we are using LRA or not.
+	(rs6000_setup_reg_addr_masks): If ISA 3.0 vector d-form
+	instructions are enabled, set up the appropriate addr_masks for
+	128-bit types.
+	(rs6000_init_hard_regno_mode_ok): wb constraint is now based on
+	-mpower9-dform-scalar, instead of -mpower9-dform.
+	(rs6000_option_override_internal): Split -mpower9-dform into two
+	switches, -mpower9-dform-scalar and -mpower9-dform-vector.  The
+	-mpower9-dform switch sets or clears both.  If we are not using
+	the LRA register allocator, do not enable -mpower9-dform-vector by
+	default.  If we are using LRA, enable -mpower9-dform-vector and
+	-mvsx-timode if it is appropriate.  Issue a warning if either
+	-mpower9-dform-vector or -mvsx-timode are explicitly used without
+	enabling LRA.
+	(quad_address_offset_p): New helper function to return if the
+	offset is legal for quad word memory instructions.
+	(quad_address_p): New function to determin if GPR or vector
+	register quad word memory addresses are legal.
+	(mem_operand_gpr): Validate quad word address offsets.
+	(reg_offset_addressing_ok_p): Add support for ISA 3.0 vector
+	d-form (register + offset) instructions.
+	(offsettable_ok_by_alignment): Likewise.
+	(rs6000_legitimate_offset_address_p): Likewise.
+	(legitimate_lo_sum_address_p): Likewise.
+	(rs6000_legitimize_address): Likewise.
+	(rs6000_legitimize_reload_address): Add more debug statements for
+	-mdebug=addr.
+	(rs6000_legitimate_address_p): Add support for ISA 3.0 vector
+	d-form instructions.
+	(rs6000_secondary_reload_memory): Add support for ISA 3.0 vector
+	d-form instructions.  Distinguish different cases in debug
+	output.	(rs6000_secondary_reload_inner): Add support for ISA 3.0 vector
+	d-form instructions.
+	(rs6000_preferred_reload_class): Likewise.
+	(rs6000_output_move_128bit): Add support for ISA 3.0 d-form
+	instructions.  If ISA 3.0 is available, generate lxvx/stxvx instead
+	of the ISA 2.06 indexed memory instructions.
+	(rs6000_emit_prologue): If we have ISA 3.0 d-form instructions,
+	use them to save/restore the saved vector registers instead of
+	using Altivec instructions.
+	(rs6000_emit_epilogue): Likewise.
+	(rs6000_lra_p): Use TARGET_LRA instead of the old option word.
+	(rs6000_opt_masks): Split -mpower9-dform into
+	-mpower9-dform-scalar and -mpower9-dform-vector.
+	(rs6000_print_options_internal): Print -mno-<switch> if <switch>
+	was not selected.
+	* config/rs6000/vsx.md (p9_vecload_<mode>): Delete hack to emit
+	ISA 3.0 vector indexed memory instructions, and fold the code into
+	the normal mov<mode> patterns.
+	(p9_vecstore_<mode>): Likewise.
+	(vsx_mov<mode>): Add support for ISA 3.0 vector d-form
+	instructions.
+	(vsx_movti_64bit): Likewise.
+	(vsx_movti_32bit): Likewise.
+	* config/rs6000/constraints.md (wO constraint): New constraint for
+	ISA 3.0 vector d-form support.
+	* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Use
+	-mpower9-dform-scalar instead of -mpower9-dform.  Add note not to
+	include -mpower9-dform-vector until we switch over to LRA.
+	(POWERPC_MASKS): Add -mlra. Split -mpower9-dform into two.
+	switches, -mpower9-dform-scalar and -mpower9-dform-vector.
+	* config/rs6000/rs6000-protos.h (quad_address_p): Add declaration.
+	* doc/invoke.texi (RS/6000 and PowerPC Options): Add documentation
+	for -mpower9-dform and -mlra.
+	* doc/md.texi (wO constraint): Document wO constraint.
+
+2016-06-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-vect-loop.c (vect_determine_vectorization_factor): Also compute
+	the factor for live Phi nodes.
+
+2016-06-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71371
+	* gimplify.c (gimplify_omp_for): Temporarily clear gimplify_omp_ctxp
+	around creation of the temporary.
+
+2016-06-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-vect-loop.c (vect_determine_vectorization_factor): Also take
+	into account live statements for mask producers.
+
+2016-05-31  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR debug/71057
+	* dwarf2out.c (retry_incomplete_types): Set early_dwarf.
+	(dwarf2out_finish): Move retry_incomplete_types call ...
+	(dwarf2out_early_finish): ... here.
+
+2016-05-31  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71056
+	* config/arm/arm-builtins.c (arm_builtin_vectorized_function): Return
+	NULL_TREE early if NEON is not available.  Remove now redundant check
+	in ARM_CHECK_BUILTIN_MODE.
+
+2016-05-31  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-31  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69068
+	* graphite-isl-ast-to-gimple.c (copy_bb_and_scalar_dependences): Handle
+	phis with more than two args.
+
+2016-05-30  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2016-05-30  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config.gcc: Move hard float support for arm*hf*-*-freebsd* into
+	armv6*-*-freebsd* for FreeBSD 11. Eliminate the arm*hf*-*-freebsd*
+	target.
+
+2016-05-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-04-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h: Change definitions of vec_xl and
+	vec_xst.
+	* config/rs6000/rs6000-builtin.def (LD_ELEMREV_V2DF): New.
+	(LD_ELEMREV_V2DI): New.
+	(LD_ELEMREV_V4SF): New.
+	(LD_ELEMREV_V4SI): New.
+	(LD_ELEMREV_V8HI): New.
+	(LD_ELEMREV_V16QI): New.
+	(ST_ELEMREV_V2DF): New.
+	(ST_ELEMREV_V2DI): New.
+	(ST_ELEMREV_V4SF): New.
+	(ST_ELEMREV_V4SI): New.
+	(ST_ELEMREV_V8HI): New.
+	(ST_ELEMREV_V16QI): New.
+	(XL): New.
+	(XST): New.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	descriptions for VSX_BUILTIN_VEC_XL and VSX_BUILTIN_VEC_XST.
+	* config/rs6000/rs6000.c (rs6000_builtin_mask_calculate): Map from
+	TARGET_P9_VECTOR to RS6000_BTM_P9_VECTOR.
+	(altivec_expand_builtin): Add handling for
+	VSX_BUILTIN_ST_ELEMREV_<MODE> and VSX_BUILTIN_LD_ELEMREV_<MODE>.
+	(rs6000_invalid_builtin): Add error-checking for
+	RS6000_BTM_P9_VECTOR.
+	(altivec_init_builtins): Define builtins used to implement vec_xl
+	and vec_xst.
+	(rs6000_builtin_mask_names): Define power9-vector.
+	* config/rs6000/rs6000.h (MASK_P9_VECTOR): Define.
+	(RS6000_BTM_P9_VECTOR): Define.
+	(RS6000_BTM_COMMON): Include RS6000_BTM_P9_VECTOR.
+	* config/rs6000/vsx.md (vsx_ld_elemrev_v2di): New define_insn.
+	(vsx_ld_elemrev_v2df): Likewise.
+	(vsx_ld_elemrev_v4sf): Likewise.
+	(vsx_ld_elemrev_v4si): Likewise.
+	(vsx_ld_elemrev_v8hi): Likewise.
+	(vsx_ld_elemrev_v16qi): Likewise.
+	(vsx_st_elemrev_v2df): Likewise.
+	(vsx_st_elemrev_v2di): Likewise.
+	(vsx_st_elemrev_v4sf): Likewise.
+	(vsx_st_elemrev_v4si): Likewise.
+	(vsx_st_elemrev_v8hi): Likewise.
+	(vsx_st_elemrev_v16qi): Likewise.
+	* doc/extend.texi: Add prototypes for vec_xl and vec_xst.  Correct
+	grammar.
+
+2016-05-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/71002
+	* alias.c (reference_alias_ptr_type): Preserve alias-set zero
+	if the langhook insists on it.
+	* fold-const.c (make_bit_field_ref): Add arg for the original
+	reference and preserve its alias-set.
+	(decode_field_reference): Take exp by reference and adjust it
+	to the original memory reference.
+	(optimize_bit_field_compare): Adjust callers.
+	(fold_truth_andor_1): Likewise.
+
+	2016-05-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/71071
+	* fold-const.c (fold_checksum_tree): Allow modification
+	of TYPE_ALIAS_SET during folding.
+
+2016-05-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/visium/visium.c (visium_split_double_add): Minor tweaks.
+	(visium_expand_copysign): Use gen_int_mode directly.
+	(visium_compute_frame_size): Minor tweaks.
+
+2016-05-30  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-30  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69067
+	* graphite-isl-ast-to-gimple.c (get_def_bb_for_const): Remove assert.
+
+2016-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/visium/visium-protos.h (split_double_move): Rename into...
+	(visium_split_double_move): ...this.
+	(visium_split_double_add): Declare.
+	* config/visium/visium.c (split_double_move): Rename into...
+	(visium_split_double_move): ...this.
+	(visium_split_double_add): New function.
+	(visium_expand_copysign): Renumber operands for consistency.
+	* config/visium/visium.md (DImode move splitter): Adjust to renaming.
+	(DFmode move splitter): Likewise.
+	(*addi3_insn): Split by means of visium_split_double_add.
+	(*adddi3_insn_flags): Delete.
+	(*plus_plus_sltu<subst_arith>): New insn.
+	(*subdi3_insn): Split by means of visium_split_double_add.
+	(subdi3_insn_flags): Delete.
+	(*minus_minus_sltu<subst_arith>): New insn.
+	(*negdi2_insn): Split by means of visium_split_double_add.
+	(*negdi2_insn_flags): Delete.
+
+2016-05-27  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236810.
+	2016-05-27  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR middle-end/71279
+	* fold-const.c (fold_ternary_loc): Don't fold VEC_COND_EXPR
+	into comparison.
+
+2016-05-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-phiopt.c (factor_out_conditional_conversion): Remove
+	redundant test and bail out if the type of the new operand is not
+	a GIMPLE register type after stripping a VIEW_CONVERT_EXPR.
+
+2016-05-24  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/71147
+	* tree.h (complete_or_array_type_p): New inline function.
+
+2016-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/i386/i386.h (TARGET_AVOID_4BYTE_PREFIXES): Define.
+	* config/i386/constraints.md (Yr): Test TARGET_AVOID_4BYTE_PREFIXES
+	rather than X86_TUNE_AVOID_4BYTE_PREFIXES.  Use SSE_REGS instead
+	of ALL_SSE_REGS.  Return SSE_REGS also when TARGET_AVX.
+
+2016-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71257
+	* tree-vect-stmts.c (vectorizable_simd_clone_call): Handle
+	SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP like
+	SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP.  Add
+	SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP and
+	SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP cases explicitly.
+
+2016-05-23  Martin Jambor  <mjambor@suse.cz>
+
+	* hsa-gen.c (gen_hsa_insns_for_switch_stmt): Create an empty
+	default block if a PHI node in the original one would be resized.
+
+2016-05-23  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/70884
+	* tree-sra.c (initialize_constant_pool_replacements): Do not check
+	should_scalarize_away_bitmap and cannot_scalarize_away_bitmap bits.
+	(sort_and_splice_var_accesses): Do not consider multiple scalar reads
+	of constant pool data as a reason for scalarization.
+
+2016-05-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/arm/arm.c (arm_expand_prologue): Set the stack usage to 0
+	for naked functions.
+	(thumb1_expand_prologue): Likewise.
+
+2016-05-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71210
+	* gimple-fold.c (gimple_fold_call): Do not remove lhs of noreturn
+	calls if the LHS is variable length or has addressable type.
+	If targets[0]->decl is a noreturn call with void return type and
+	zero arguments, adjust fntype and remove lhs in that case.
+
+2016-05-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	* sched-deps.c (sched_analyze_2) <case TRAP_IF>: Also
+	force pending loads from memory.
+
+2016-05-19  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2016-05-19  Marek Polacek  <polacek@redhat.com>
+
+	PR tree-optimization/71031
+	* tree-vrp.c (extract_range_from_binary_expr_1): Turn assert into a
+	condition and adjust the code a bit.
+
+2016-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/70646
+	* ipa-prop.c (determine_locally_known_aggregate_parts): Bail out early
+	if parameter PARAM_IPA_MAX_AGG_ITEMS is zero.
+
+2016-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/70646
+	* ipa-inline.h (condition): New field size.
+	* ipa-inline-analysis.c (add_condition): New parameter SIZE, use it
+	for comaprison and store it into the new condition.
+	(evaluate_conditions_for_known_args): Use condition size to check
+	access sizes for all but CHANGED conditions.
+	(unmodified_parm_1): New parameter size_p, store access size into it.
+	(unmodified_parm): Likewise.
+	(unmodified_parm_or_parm_agg_item): Likewise.
+	(eliminated_by_inlining_prob): Pass NULL to unmodified_parm as size_p.
+	(set_cond_stmt_execution_predicate): Extract access sizes and store
+	them to conditions.
+	(set_switch_stmt_execution_predicate): Likewise.
+	(will_be_nonconstant_expr_predicate): Likewise.
+	(will_be_nonconstant_predicate): Likewise.
+	(inline_read_section): Stream condition size.
+	(inline_write_summary): Likewise.
+	* lto-streamer.h (LTO_minor_version): Bump.
+
+2016-05-18  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2016-05-18  Martin Liska  <mliska@suse.cz>
+
+	PR fortran/70856
+	* ipa-icf.c (sem_variable::merge): Set DECL_PT_UID for
+	merged variables.
+
+2016-05-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71100
+	* cgraph.c (cgraph_edge::redirect_call_stmt_to_callee): Don't drop
+	lhs if it has TREE_ADDRESSABLE type.
+
+2016-05-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/71145
+	* config/alpha/alpha.md (trap): Add (use (reg:DI 29)).
+	(*exception_receiver_1): Return "#" for TARGET_EXPLICIT_RELOCS.
+
+2016-05-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport trunk r235748:
+	PR target/70860
+	* config/nvptx/nvptx.c (nvptx_libcall_value): Handle NULL cfun.
+	(nvptx_function_value): Assert non-NULL cfun.
+
+2016-05-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-05-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70809
+	* config/aarch64/aarch64-simd.md (aarch64_vmls<mode>): Delete.
+
+2016-05-16  Martin Jambor  <mjambor@suse.cz>
+
+	* hsa-gen.c (fillup_for_decl): Increase alignment to natural one.
+	(get_symbol_for_decl): Sorry if a global symbol in under-aligned.
+
+2016-05-16  Martin Jambor  <mjambor@suse.cz>
+
+	PR hsa/70857
+	* omp-low.c (grid_expand_target_grid_body): Copy RESULT_DECL of
+	the outlined kernel function.
+
+2016-05-16  James Norris  <jnorris@codesourcery.com>
+
+	Backport from mainline r236098.
+	2016-05-10  James Norris  <jnorris@codesourcery.com>
+
+	PR driver/68463
+	* config/rs6000/sysv4.h (CRTOFFLOADBEGIN): Define. Add crtoffloadbegin.o
+	if offloading is enabled and -fopenacc or -fopenmp is specified.
+	(CRTOFFLOADEND): Likewise.
+	(STARTFILE_LINUX_SPEC): Add CRTOFFLOADBEGIN.
+	(ENDFILE_LINUX_SPEC): Add CRTOFFLOADEND.
+
+2016-05-16  Alan Modra  <amodra@gmail.com>
+
+	Apply from mainline
+	2016-05-10  Alan Modra  <amodra@gmail.com>
+	PR target/70947
+	* config/rs6000/rs6000.c (rs6000_expand_split_stack_prologue): Stop
+	regrename modifying insns saving lr before __morestack call.
+	* config/rs6000/rs6000.md (split_stack_return): Similarly for
+	insns restoring lr after __morestack call.
+
+2016-05-13  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-04-27  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/70760
+	* tree-ssa-structalias.c (find_func_aliases_for_call): Use
+	aggregate_value_p to determine if a function result is
+	returned by reference.
+
+	2016-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/70931
+	* dwarf2out.c (native_encode_initializer): Skip zero-sized fields.
+
+	2016-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/70941
+	* fold-const.c (split_tree): Always convert to the original type
+	before negating.
+
+2016-05-12  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2016-05-10  Martin Liska  <mliska@suse.cz>
+
+	* tree-inline.c (remap_dependence_clique): Do not remap
+	debugging statements.
+
+2016-05-12  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236171.
+	2016-05-12  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR tree-optimization/71006
+	* tree-vect-loop.c (vect_determine_vectorization_factor): Don't
+	consider COND_EXPR as a mask producer.
+
+2016-05-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-05-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70830
+	* config/arm/arm.c (arm_output_multireg_pop): Avoid POP instruction
+	when popping the PC and within an interrupt handler routine.
+	Add missing tab to output of "ldmfd".
+	(output_return_instruction): Output LDMFD with SP update rather
+	than POP when returning from interrupt handler.
+
+2016-05-11  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236088.
+	2016-05-10  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR middle-end/70877
+	* tree-chkp.c (chkp_add_bounds_to_call_stmt): Handle
+	calls with type casted fndecl.
+
+2016-05-11  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236086.
+	2016-05-10  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR tree-optimization/70876
+	* tree-chkp.c (chkp_find_bounds_1): Support WITH_SIZE_EXPR.
+	* gcc/calls.c (initialize_argument_information): Bind bounds
+	with corresponding args passed by reference.
+
+2016-05-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-05-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/70963
+	* config/rs6000/vsx.md (vsx_xvcvdpsxds_scale): Generate correct
+	code for a zero scale factor.
+	(vsx_xvcvdpuxds_scale): Likewise.
+
+2016-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-05-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/70916
+	* tree-vect-patterns.c (vect_recog_mask_conversion_pattern): Give up
+	if COND_EXPR rhs1 is neither SSA_NAME nor COMPARISON_CLASS_P.
+
+2016-05-10  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	Backport from mainline r235962.
+	2016-05-06  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	PR debug/70935
+	* tree-ssa-loop-unswitch.c (find_loop_guard): Reject guard edge with
+	loop latch destination.
+
+2016-05-10  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-05-10  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.md ("*vec_cmp<insn_cmp>df_cconly")
+	("*fixuns_truncdfdi2_z13")
+	("*fixuns_trunc<FP:mode><GPR:mode>2_z196")
+	("*fix_truncdfdi2_bfp_z13", "*floatunsdidf2_z13")
+	("*extendsfdf2_z13"): Replace TARGET_Z13 with TARGET_VX.
+
+2016-05-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2016-04-27  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rtems.h (LIB_SPEC): Add -latomic.
+
+2016-05-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2016-04-27  Joel Sherrill  <joel@rtems.org>
+
+	* config/microblaze/rtems.h: Redefine LINK_SPEC to avoid
+	xilink.ld and flags not relevant to RTEMS.
+
+2016-05-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (absneg splitters with general regs): Use
+	general_reg_operand predicate.
+	(btsq peephole2): Use x86_64_immediate_operand to check if new
+	value is suitable for immediate operand.  Generate emitted insn
+	using RTL expressions.
+	(btcq peephole2): Ditto.
+	(btrq peephole2): Ditto.  Generate correct immediate operand
+	for AND masking.
+
+2016-05-07  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-07  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/70956
+	* graphite-scop-detection.c (build_cross_bb_scalars_def): Handle NULL
+	def.
+
+2016-05-06  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2016-05-06  Marek Polacek  <polacek@redhat.com>
+
+	PR sanitizer/70875
+	* ubsan.c (get_ubsan_type_info_for_type): Remove assert.
+
+2016-05-06  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2016-04-29  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/70342
+	* fold-const.c (tree_single_nonzero_warnv_p): For TARGET_EXPR, use
+	TARGET_EXPR_SLOT as a base.
+
+2016-05-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-coalesce.c (gimple_can_coalesce_p): Fix reference in head
+	comment.
+	(compute_samebase_partition_bases): Fix typo.
+
+2016-05-03  Pierre-Marie de Rodat  <derodat@adacore.com>
+
+	* dwarf2out.c (resolve_args_picking_1): Replace the frame_offset
+	occurence with frame_offset_ ones.
+
+2016-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/70858
+	* config/i386/i386.c (bdesc_special_args): Add | OPTION_MASK_ISA_64BIT
+	to __builtin_ia32_lwpval64 and __builtin_ia32_lwpins64.
+	(bdesc_args): Add | OPTION_MASK_ISA_64BIT to __builtin_ia32_bextr_u64,
+	__builtin_ia32_bextri_u64, __builtin_ia32_bzhi_di,
+	__builtin_ia32_pdep_di and __builtin_ia32_pext_di.
+
+2016-04-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/70759
+	* stor-layout.h (internal_reference_types): Delete.
+	* stor-layout.c (reference_types_internal): Likewise.
+	(internal_reference_types): Likewise.
+	(layout_type) <REFERENCE_TYPE>: Adjust.
+
+2016-04-27  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-04-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def: Correct pasto error for
+	stxvd2x and stxvw4x built-in functions.
+
+2016-04-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2016-04-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/70750
+	* config/i386/predicates.md (call_insn_operand): Replace
+	sibcall_memory_operand with memory_operand.
+
+2016-04-27  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/70785
+	* tree-ssa-structalias.c (refered_from_nonlocal_fn): New
+	function cummulating used_from_other_partition, externally_visible
+	and force_output from aliases.
+	(refered_from_nonlocal_var): Likewise.
+	(ipa_pta_execute): Use call_for_symbol_and_aliases to cummulate
+	node flags properly.
+
+2016-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/70712
+	* cfgexpand.c (expand_stack_vars): Fix typo.
+
+	2016-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/70680
+	* gimplify.c (gimplify_omp_for): Call omp_notice_variable for
+	implicitly linear or lastprivate iterator on the outer context.
+
+2016-04-27  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	PR target/70728
+	* gcc/config/i386/sse.md (define_insn "<shift_insn><mode>3<mask_name>"):
+	Extract AVX-512BW constraint from AVX.
+
+2016-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 6.1.1.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
@@ -49,7 +2066,7 @@
 	constant boolean.
 
 2016-04-20  Andrew Pinski  <apinski@cavium.com>
-            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+	    Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
 
 	PR target/64971
 	* config/aarch64/aarch64.md (sibcall): Force call
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/DATESTAMP gcc-6-20160721/gcc/DATESTAMP
--- gcc-6.1.0/gcc/DATESTAMP	2016-04-27 00:16:13.000000000 +0000
+++ gcc-6-20160721/gcc/DATESTAMP	2016-07-21 00:16:15.000000000 +0000
@@ -1 +1 @@
-20160427
+20160721
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/ChangeLog gcc-6-20160721/gcc/ada/ChangeLog
--- gcc-6.1.0/gcc/ada/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/ada/ChangeLog	2016-06-13 08:02:10.000000000 +0000
@@ -1,3 +1,96 @@
+2016-06-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Deal with
+	PLUS_EXPR in the expression of a renaming.
+
+2016-06-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Case_Statement_to_gnu): Deal with characters.
+
+2016-06-11  Pierre-Marie de Rodat  <derodat@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity): Do not clobber
+	gnat_entity_name with temporary names for XUP and XUT types.
+
+2016-06-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (gnat_internal_attribute_table): Add support
+	for noinline and noclone attributes.
+	(handle_noinline_attribute): New handler.
+	(handle_noclone_attribute): Likewise.
+
+2016-06-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils2.c (build_call_alloc_dealloc): Do not substitute
+	placeholder expressions here but...
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Free_Statement>: ...here.
+	Make an exception to the protection of a CALL_EXPR result with an
+	unconstrained type only in the same cases as Call_to_gnu.
+
+2016-06-01  Simon Wright  <simon@pushface.org>
+
+	PR ada/71358
+	* g-comlin.adb (Display_Section_Help): Do not dereference
+	Config.Switches if it's null.
+	(Getopt): Likewise.
+
+2016-05-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* s-osinte-kfreebsd-gnu.ads (clock_getres): Define.
+	(Get_Page_Size): Remove duplicate and return int.
+
+2016-05-31  Jan Sommer  <soja-lists@aries.uberspace.de>
+
+	PR ada/71317
+	* s-osinte-rtems.ads (clock_getres): Define.
+	(Get_Page_Size): Remove duplicate and return int.
+
+2016-05-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/70969
+	* system-darwin-ppc64.ads: Add pragma No_Elaboration_Code_All.
+	* system-linux-armeb.ads: Likewise.
+	* system-linux-mips64el.ads: Likewise.
+	* system-linux-mips.ads: Likewise.
+	* system-linux-mipsel.ads: Likewise.
+	* system-linux-ppc64.ads: Likewise.
+	* system-linux-sparcv9.ads: Likewise.
+	* system-rtems.ads: Likewise.
+
+2016-05-04  Samuel Thibault  <samuel.thibault@ens-lyon.org>
+
+	* s-osinte-gnu.ads (Get_Page_Size): Return int and use getpagesize
+	instead of __getpagesize.
+
+2016-04-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/70900
+	Backport from mainline
+	2016-04-18  Ed Schonberg  <schonberg@adacore.com>
+
+	* sem_ch6.adb (Process_Formals): Do not set a delay freeze on
+	a subprogram that returns a class-wide type, if the subprogram
+	is a compilation unit, because otherwise gigi will treat the
+	subprogram as external, leading to link errors.
+
+2016-05-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc-interface/Makefile.in (install-gcc-specs): Use foreach.
+	Honor DESTDIR.
+
+2016-04-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/70786
+	* a-textio.adb (Get_Immediate): Add missing 'not' in expression.
+
+2016-04-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/misc.c (gnat_init): Do not call
+	internal_reference_types.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/a-textio.adb gcc-6-20160721/gcc/ada/a-textio.adb
--- gcc-6.1.0/gcc/ada/a-textio.adb	2015-10-16 12:43:21.000000000 +0000
+++ gcc-6-20160721/gcc/ada/a-textio.adb	2016-04-28 10:58:54.000000000 +0000
@@ -668,7 +668,7 @@
             Available := True;
 
             Item :=
-              (if Is_Start_Of_Encoding (Character'Val (ch), File.WC_Method)
+              (if not Is_Start_Of_Encoding (Character'Val (ch), File.WC_Method)
                then Character'Val (ch)
                else Get_Upper_Half_Char_Immed (Character'Val (ch), File));
          end if;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/g-comlin.adb gcc-6-20160721/gcc/ada/g-comlin.adb
--- gcc-6.1.0/gcc/ada/g-comlin.adb	2015-11-18 10:31:53.000000000 +0000
+++ gcc-6-20160721/gcc/ada/g-comlin.adb	2016-06-01 07:44:10.000000000 +0000
@@ -6,7 +6,7 @@
 --                                                                          --
 --                                 B o d y                                  --
 --                                                                          --
---          Copyright (C) 1999-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1999-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- GNAT is free software;  you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -3151,16 +3151,18 @@
 
          New_Line;
 
-         if Section /= "" then
+         if Section /= "" and then Config.Switches /= null then
             Put_Line ("Switches after " & Section);
          end if;
 
          --  Compute size of the switches column
 
-         for S in Config.Switches'Range loop
-            Max_Len := Natural'Max
-              (Max_Len, Switch_Name (Config.Switches (S), Section)'Length);
-         end loop;
+         if Config.Switches /= null then
+            for S in Config.Switches'Range loop
+               Max_Len := Natural'Max
+                 (Max_Len, Switch_Name (Config.Switches (S), Section)'Length);
+            end loop;
+         end if;
 
          if Config.Aliases /= null then
             for A in Config.Aliases'Range loop
@@ -3173,25 +3175,27 @@
 
          --  Display the switches
 
-         for S in Config.Switches'Range loop
-            declare
-               N : constant String :=
-                     Switch_Name (Config.Switches (S), Section);
+         if Config.Switches /= null then
+            for S in Config.Switches'Range loop
+               declare
+                  N : constant String :=
+                    Switch_Name (Config.Switches (S), Section);
 
-            begin
-               if N /= "" then
-                  Put (" ");
-                  Put (N);
-                  Put ((1 .. Max_Len - N'Length + 1 => ' '));
+               begin
+                  if N /= "" then
+                     Put (" ");
+                     Put (N);
+                     Put ((1 .. Max_Len - N'Length + 1 => ' '));
 
-                  if Config.Switches (S).Help /= null then
-                     Put (Config.Switches (S).Help.all);
-                  end if;
+                     if Config.Switches (S).Help /= null then
+                        Put (Config.Switches (S).Help.all);
+                     end if;
 
-                  New_Line;
-               end if;
-            end;
-         end loop;
+                     New_Line;
+                  end if;
+               end;
+            end loop;
+         end if;
 
          --  Display the aliases
 
@@ -3454,25 +3458,27 @@
 
       --  Initialize output values for automatically handled switches
 
-      for S in Config.Switches'Range loop
-         case Config.Switches (S).Typ is
-            when Switch_Untyped =>
-               null;   --  Nothing to do
-
-            when Switch_Boolean =>
-               Config.Switches (S).Boolean_Output.all :=
-                 not Config.Switches (S).Boolean_Value;
-
-            when Switch_Integer =>
-               Config.Switches (S).Integer_Output.all :=
-                 Config.Switches (S).Integer_Initial;
-
-            when Switch_String =>
-               if Config.Switches (S).String_Output.all = null then
-                  Config.Switches (S).String_Output.all := new String'("");
-               end if;
-         end case;
-      end loop;
+      if Config.Switches /= null then
+         for S in Config.Switches'Range loop
+            case Config.Switches (S).Typ is
+               when Switch_Untyped =>
+                  null;   --  Nothing to do
+
+               when Switch_Boolean =>
+                  Config.Switches (S).Boolean_Output.all :=
+                    not Config.Switches (S).Boolean_Value;
+
+               when Switch_Integer =>
+                  Config.Switches (S).Integer_Output.all :=
+                    Config.Switches (S).Integer_Initial;
+
+               when Switch_String =>
+                  if Config.Switches (S).String_Output.all = null then
+                     Config.Switches (S).String_Output.all := new String'("");
+                  end if;
+            end case;
+         end loop;
+      end if;
 
       --  For all sections, and all switches within those sections
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/gcc-interface/Makefile.in gcc-6-20160721/gcc/ada/gcc-interface/Makefile.in
--- gcc-6.1.0/gcc/ada/gcc-interface/Makefile.in	2016-04-27 07:39:18.000000000 +0000
+++ gcc-6-20160721/gcc/ada/gcc-interface/Makefile.in	2016-05-02 13:16:33.000000000 +0000
@@ -2670,10 +2670,9 @@
 install-gcc-specs:
 #	Install all the requested GCC spec files.
 
-	for f in $(GCC_SPEC_FILES); do \
-	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$$f \
-	    $(libsubdir)/$$(echo $$f|sed -e 's#_[a-zA-Z0-9]*##g'); \
-	done
+	$(foreach f,$(GCC_SPEC_FILES), \
+	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$(f) \
+	    $(DESTDIR)$(libsubdir)/$$(echo $(f)|sed -e 's#_[a-zA-Z0-9]*##g');)
 
 install-gnatlib: ../stamp-gnatlib-$(RTSDIR) install-gcc-specs
 	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/gcc-interface/decl.c gcc-6-20160721/gcc/ada/gcc-interface/decl.c
--- gcc-6.1.0/gcc/ada/gcc-interface/decl.c	2016-04-02 08:56:19.000000000 +0000
+++ gcc-6-20160721/gcc/ada/gcc-interface/decl.c	2016-06-13 08:02:10.000000000 +0000
@@ -966,6 +966,7 @@
 		 && !call_is_atomic_load (inner))
 		|| TREE_CODE (inner) == ADDR_EXPR
 		|| TREE_CODE (inner) == NULL_EXPR
+		|| TREE_CODE (inner) == PLUS_EXPR
 		|| TREE_CODE (inner) == CONSTRUCTOR
 		|| CONSTANT_CLASS_P (inner)
 		/* We need to detect the case where a temporary is created to
@@ -2321,10 +2322,12 @@
 	  gnat_name = Packed_Array_Impl_Type (gnat_entity);
 	else
 	  gnat_name = gnat_entity;
-	if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)
-	  gnu_entity_name = create_concat_name (gnat_name, "XUP");
-	create_type_decl (gnu_entity_name, gnu_fat_type, artificial_p,
-			  debug_info_p, gnat_entity);
+	tree xup_name
+	  = (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)
+	    ? get_entity_name (gnat_name)
+	    : create_concat_name (gnat_name, "XUP");
+	create_type_decl (xup_name, gnu_fat_type, artificial_p, debug_info_p,
+			  gnat_entity);
 
 	/* Create the type to be designated by thin pointers: a record type for
 	   the array and its template.  We used to shift the fields to have the
@@ -2334,11 +2337,11 @@
 	   Note that GDB can handle standard DWARF information for them, so we
 	   don't have to name them as a GNAT encoding, except if specifically
 	   asked to.  */
-	if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)
-	  gnu_entity_name = create_concat_name (gnat_name, "XUT");
-	else
-	  gnu_entity_name = get_entity_name (gnat_name);
-	tem = build_unc_object_type (gnu_template_type, tem, gnu_entity_name,
+	tree xut_name
+	  = (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)
+	    ? get_entity_name (gnat_name)
+	    : create_concat_name (gnat_name, "XUT");
+	tem = build_unc_object_type (gnu_template_type, tem, xut_name,
 				     debug_info_p);
 
 	SET_TYPE_UNCONSTRAINED_ARRAY (tem, gnu_type);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/gcc-interface/misc.c gcc-6-20160721/gcc/ada/gcc-interface/misc.c
--- gcc-6.1.0/gcc/ada/gcc-interface/misc.c	2016-02-16 18:01:04.000000000 +0000
+++ gcc-6-20160721/gcc/ada/gcc-interface/misc.c	2016-04-28 10:49:13.000000000 +0000
@@ -369,9 +369,6 @@
   sbitsize_one_node = sbitsize_int (1);
   sbitsize_unit_node = sbitsize_int (BITS_PER_UNIT);
 
-  /* Show that REFERENCE_TYPEs are internal and should be Pmode.  */
-  internal_reference_types ();
-
   /* Register our internal error function.  */
   global_dc->internal_error = &internal_error_function;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/gcc-interface/trans.c gcc-6-20160721/gcc/ada/gcc-interface/trans.c
--- gcc-6.1.0/gcc/ada/gcc-interface/trans.c	2016-03-07 08:46:52.000000000 +0000
+++ gcc-6-20160721/gcc/ada/gcc-interface/trans.c	2016-06-11 11:55:51.000000000 +0000
@@ -2483,13 +2483,15 @@
 static tree
 Case_Statement_to_gnu (Node_Id gnat_node)
 {
-  tree gnu_result, gnu_expr, gnu_label;
+  tree gnu_result, gnu_expr, gnu_type, gnu_label;
   Node_Id gnat_when;
   location_t end_locus;
   bool may_fallthru = false;
 
   gnu_expr = gnat_to_gnu (Expression (gnat_node));
   gnu_expr = convert (get_base_type (TREE_TYPE (gnu_expr)), gnu_expr);
+  gnu_expr = maybe_character_value (gnu_expr);
+  gnu_type = TREE_TYPE (gnu_expr);
 
   /* We build a SWITCH_EXPR that contains the code with interspersed
      CASE_LABEL_EXPRs for each label.  */
@@ -2559,6 +2561,11 @@
 	  gcc_assert (!gnu_low  || TREE_CODE (gnu_low)  == INTEGER_CST);
 	  gcc_assert (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST);
 
+	  if (gnu_low && TREE_TYPE (gnu_low) != gnu_type)
+	    gnu_low = convert (gnu_type, gnu_low);
+	  if (gnu_high && TREE_TYPE (gnu_high) != gnu_type)
+	    gnu_high = convert (gnu_type, gnu_high);
+
 	  add_stmt_with_node (build_case_label (gnu_low, gnu_high, label),
 			      gnat_choice);
 	  choices_added_p = true;
@@ -2590,8 +2597,8 @@
   /* Now emit a definition of the label the cases branch to, if any.  */
   if (may_fallthru)
     add_stmt (build1 (LABEL_EXPR, void_type_node, gnu_label));
-  gnu_result = build3 (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,
-		       end_stmt_group (), NULL_TREE);
+  gnu_result
+    = build3 (SWITCH_EXPR, gnu_type, gnu_expr, end_stmt_group (), NULL_TREE);
 
   return gnu_result;
 }
@@ -7635,10 +7642,11 @@
 	  else
 	    gnu_actual_obj_type = gnu_obj_type;
 
+	  tree gnu_size = TYPE_SIZE_UNIT (gnu_actual_obj_type);
+	  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_ptr);
+
 	  gnu_result
-	      = build_call_alloc_dealloc (gnu_ptr,
-					  TYPE_SIZE_UNIT (gnu_actual_obj_type),
-					  gnu_obj_type,
+	      = build_call_alloc_dealloc (gnu_ptr, gnu_size, gnu_obj_type,
 					  Procedure_To_Call (gnat_node),
 					  Storage_Pool (gnat_node),
 					  gnat_node);
@@ -7719,16 +7727,22 @@
 				    N_Raise_Constraint_Error));
     }
 
-  /* If the result has side-effects and is of an unconstrained type, make a
-     SAVE_EXPR so that we can be sure it will only be referenced once.  But
-     this is useless for a call to a function that returns an unconstrained
-     type with default discriminant, as we cannot compute the size of the
-     actual returned object.  We must do this before any conversions.  */
+  /* If the result has side-effects and is of an unconstrained type, protect
+     the expression in case it will be referenced multiple times, i.e. for
+     its value and to compute the size of an object.  But do it neither for
+     an object nor a renaming declaration, nor a return statement of a call
+     to a function that returns an unconstrained record type with default
+     discriminant, because there is no size to be computed in these cases
+     and this will create a useless temporary.  We must do this before any
+     conversions.  */
   if (TREE_SIDE_EFFECTS (gnu_result)
-      && !(TREE_CODE (gnu_result) == CALL_EXPR
-	   && type_is_padding_self_referential (TREE_TYPE (gnu_result)))
       && (TREE_CODE (gnu_result_type) == UNCONSTRAINED_ARRAY_TYPE
-	  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))))
+	  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type)))
+      && !(TREE_CODE (gnu_result) == CALL_EXPR
+	   && type_is_padding_self_referential (TREE_TYPE (gnu_result))
+	   && (Nkind (Parent (gnat_node)) == N_Object_Declaration
+	       || Nkind (Parent (gnat_node)) == N_Object_Renaming_Declaration
+	       || Nkind (Parent (gnat_node)) == N_Simple_Return_Statement)))
     gnu_result = gnat_protect_expr (gnu_result);
 
   /* Now convert the result to the result type, unless we are in one of the
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/gcc-interface/utils.c gcc-6-20160721/gcc/ada/gcc-interface/utils.c
--- gcc-6.1.0/gcc/ada/gcc-interface/utils.c	2016-02-29 15:30:08.000000000 +0000
+++ gcc-6-20160721/gcc/ada/gcc-interface/utils.c	2016-06-06 09:51:43.000000000 +0000
@@ -90,6 +90,8 @@
 static tree handle_nonnull_attribute (tree *, tree, tree, int, bool *);
 static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);
 static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);
+static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);
+static tree handle_noclone_attribute (tree *, tree, tree, int, bool *);
 static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);
 static tree handle_always_inline_attribute (tree *, tree, tree, int, bool *);
 static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);
@@ -121,6 +123,10 @@
     false },
   { "noreturn",     0, 0,  true,  false, false, handle_noreturn_attribute,
     false },
+  { "noinline",     0, 0,  true,  false, false, handle_noinline_attribute,
+    false },
+  { "noclone",      0, 0,  true,  false, false, handle_noclone_attribute,
+    false },
   { "leaf",         0, 0,  true,  false, false, handle_leaf_attribute,
     false },
   { "always_inline",0, 0,  true,  false, false, handle_always_inline_attribute,
@@ -5971,6 +5977,51 @@
       *no_add_attrs = true;
     }
 
+  return NULL_TREE;
+}
+
+/* Handle a "noinline" attribute; arguments as in
+   struct attribute_spec.handler.  */
+
+static tree
+handle_noinline_attribute (tree *node, tree name,
+			   tree ARG_UNUSED (args),
+			   int ARG_UNUSED (flags), bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) == FUNCTION_DECL)
+    {
+      if (lookup_attribute ("always_inline", DECL_ATTRIBUTES (*node)))
+	{
+	  warning (OPT_Wattributes, "%qE attribute ignored due to conflict "
+		   "with attribute %qs", name, "always_inline");
+	  *no_add_attrs = true;
+	}
+      else
+	DECL_UNINLINABLE (*node) = 1;
+    }
+  else
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+/* Handle a "noclone" attribute; arguments as in
+   struct attribute_spec.handler.  */
+
+static tree
+handle_noclone_attribute (tree *node, tree name,
+			  tree ARG_UNUSED (args),
+			  int ARG_UNUSED (flags), bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+
   return NULL_TREE;
 }
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/gcc-interface/utils2.c gcc-6-20160721/gcc/ada/gcc-interface/utils2.c
--- gcc-6.1.0/gcc/ada/gcc-interface/utils2.c	2016-02-29 09:02:46.000000000 +0000
+++ gcc-6-20160721/gcc/ada/gcc-interface/utils2.c	2016-06-06 09:43:59.000000000 +0000
@@ -2266,8 +2266,6 @@
                           Entity_Id gnat_proc, Entity_Id gnat_pool,
                           Node_Id gnat_node)
 {
-  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_obj);
-
   /* Explicit proc to call ?  This one is assumed to deal with the type
      alignment constraints.  */
   if (Present (gnat_proc))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/s-osinte-gnu.ads gcc-6-20160721/gcc/ada/s-osinte-gnu.ads
--- gcc-6.1.0/gcc/ada/s-osinte-gnu.ads	2016-04-27 07:39:18.000000000 +0000
+++ gcc-6-20160721/gcc/ada/s-osinte-gnu.ads	2016-05-04 19:14:17.000000000 +0000
@@ -344,10 +344,9 @@
    --  returns the stack base of the specified thread. Only call this function
    --  when Stack_Base_Available is True.
 
-   --  From: /usr/include/i386-gnu/bits/shm.h __getpagesize or getpagesize??
-   function Get_Page_Size return size_t;
-   function Get_Page_Size return Address;
-   pragma Import (C, Get_Page_Size, "__getpagesize");
+   --  From: /usr/include/i386-gnu/bits/shm.h
+   function Get_Page_Size return int;
+   pragma Import (C, Get_Page_Size, "getpagesize");
    --  Returns the size of a page
 
    --  From /usr/include/i386-gnu/bits/mman.h
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/s-osinte-kfreebsd-gnu.ads gcc-6-20160721/gcc/ada/s-osinte-kfreebsd-gnu.ads
--- gcc-6.1.0/gcc/ada/s-osinte-kfreebsd-gnu.ads	2015-12-06 15:28:16.000000000 +0000
+++ gcc-6-20160721/gcc/ada/s-osinte-kfreebsd-gnu.ads	2016-05-31 18:59:45.000000000 +0000
@@ -7,7 +7,7 @@
 --                                  S p e c                                 --
 --                                                                          --
 --               Copyright (C) 1991-1994, Florida State University          --
---            Copyright (C) 1995-2015, Free Software Foundation, Inc.       --
+--            Copyright (C) 1995-2016, Free Software Foundation, Inc.       --
 --                                                                          --
 -- GNAT is free software;  you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -216,6 +216,11 @@
       return int;
    pragma Import (C, clock_gettime, "clock_gettime");
 
+   function clock_getres
+     (clock_id : clockid_t;
+      res      : access timespec) return int;
+   pragma Import (C, clock_getres, "clock_getres");
+
    function To_Duration (TS : timespec) return Duration;
    pragma Inline (To_Duration);
 
@@ -330,8 +335,7 @@
    --  returns the stack base of the specified thread. Only call this function
    --  when Stack_Base_Available is True.
 
-   function Get_Page_Size return size_t;
-   function Get_Page_Size return Address;
+   function Get_Page_Size return int;
    pragma Import (C, Get_Page_Size, "getpagesize");
    --  Returns the size of a page
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/s-osinte-rtems.ads gcc-6-20160721/gcc/ada/s-osinte-rtems.ads
--- gcc-6.1.0/gcc/ada/s-osinte-rtems.ads	2015-12-02 07:09:41.000000000 +0000
+++ gcc-6-20160721/gcc/ada/s-osinte-rtems.ads	2016-05-31 18:59:45.000000000 +0000
@@ -6,7 +6,7 @@
 --                                                                          --
 --                                   S p e c                                --
 --                                                                          --
---          Copyright (C) 1997-2011 Free Software Foundation, Inc.          --
+--          Copyright (C) 1997-2016 Free Software Foundation, Inc.          --
 --                                                                          --
 -- GNARL is free software; you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -188,6 +188,11 @@
       tp       : access timespec) return int;
    pragma Import (C, clock_gettime, "clock_gettime");
 
+   function clock_getres
+     (clock_id : clockid_t;
+      res      : access timespec) return int;
+   pragma Import (C, clock_getres, "clock_getres");
+
    function To_Duration (TS : timespec) return Duration;
    pragma Inline (To_Duration);
 
@@ -291,8 +296,7 @@
    --  These two functions are only needed to share s-taprop.adb with
    --  FSU threads.
 
-   function Get_Page_Size return size_t;
-   function Get_Page_Size return Address;
+   function Get_Page_Size return int;
    pragma Import (C, Get_Page_Size, "getpagesize");
    --  Returns the size of a page
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/sem_ch6.adb gcc-6-20160721/gcc/ada/sem_ch6.adb
--- gcc-6.1.0/gcc/ada/sem_ch6.adb	2015-11-24 09:22:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/sem_ch6.adb	2016-05-02 20:33:47.000000000 +0000
@@ -10415,10 +10415,12 @@
          Analyze_Return_Type (Related_Nod);
 
          --  If return type is class-wide, subprogram freezing may be
-         --  delayed as well.
+         --  delayed as well, unless the declaration is a compilation unit
+         --  in which case the freeze node would appear too late.
 
          if Is_Class_Wide_Type (Etype (Current_Scope))
            and then not Is_Thunk (Current_Scope)
+           and then not Is_Compilation_Unit (Current_Scope)
            and then Nkind (Unit_Declaration_Node (Current_Scope)) =
              N_Subprogram_Declaration
          then
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-darwin-ppc64.ads gcc-6-20160721/gcc/ada/system-darwin-ppc64.ads
--- gcc-6.1.0/gcc/ada/system-darwin-ppc64.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-darwin-ppc64.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                         (Darwin/PPC64 Version)                           --
 --                                                                          --
---             Copyright (C) 2011-2015, Free Software Foundation, Inc.      --
+--             Copyright (C) 2011-2016, Free Software Foundation, Inc.      --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-linux-armeb.ads gcc-6-20160721/gcc/ada/system-linux-armeb.ads
--- gcc-6.1.0/gcc/ada/system-linux-armeb.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-linux-armeb.ads	2016-05-06 09:11:56.000000000 +0000
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-linux-mips.ads gcc-6-20160721/gcc/ada/system-linux-mips.ads
--- gcc-6.1.0/gcc/ada/system-linux-mips.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-linux-mips.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                          (GNU-Linux/MIPS Version)                        --
 --                                                                          --
---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-linux-mips64el.ads gcc-6-20160721/gcc/ada/system-linux-mips64el.ads
--- gcc-6.1.0/gcc/ada/system-linux-mips64el.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-linux-mips64el.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                       (GNU-Linux/MIPS64EL Version)                       --
 --                                                                          --
---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-linux-mipsel.ads gcc-6-20160721/gcc/ada/system-linux-mipsel.ads
--- gcc-6.1.0/gcc/ada/system-linux-mipsel.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-linux-mipsel.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                        (GNU-Linux/MIPSEL Version)                        --
 --                                                                          --
---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-linux-ppc64.ads gcc-6-20160721/gcc/ada/system-linux-ppc64.ads
--- gcc-6.1.0/gcc/ada/system-linux-ppc64.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-linux-ppc64.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                        (GNU-Linux/PPC64 Version)                         --
 --                                                                          --
---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-linux-sparcv9.ads gcc-6-20160721/gcc/ada/system-linux-sparcv9.ads
--- gcc-6.1.0/gcc/ada/system-linux-sparcv9.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-linux-sparcv9.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                         (GNU/Linux-SPARCV9 Version)                      --
 --                                                                          --
---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -40,6 +40,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ada/system-rtems.ads gcc-6-20160721/gcc/ada/system-rtems.ads
--- gcc-6.1.0/gcc/ada/system-rtems.ads	2015-11-23 11:31:24.000000000 +0000
+++ gcc-6-20160721/gcc/ada/system-rtems.ads	2016-05-06 09:11:56.000000000 +0000
@@ -7,7 +7,7 @@
 --                                 S p e c                                  --
 --                            (Compiler Version)                            --
 --                                                                          --
---          Copyright (C) 1992-2015 Free Software Foundation, Inc.          --
+--          Copyright (C) 1992-2016 Free Software Foundation, Inc.          --
 --                                                                          --
 -- This specification is derived from the Ada Reference Manual for use with --
 -- GNAT. The copyright notice above, and the license provisions that follow --
@@ -44,6 +44,9 @@
    --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
    --  2005, this is Pure in any case (AI-362).
 
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
    type Name is (SYSTEM_NAME_GNAT);
    System_Name : constant Name := SYSTEM_NAME_GNAT;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/alias.c gcc-6-20160721/gcc/alias.c
--- gcc-6.1.0/gcc/alias.c	2016-04-04 09:30:16.000000000 +0000
+++ gcc-6-20160721/gcc/alias.c	2016-05-30 14:00:18.000000000 +0000
@@ -769,6 +769,10 @@
 tree
 reference_alias_ptr_type (tree t)
 {
+  /* If the frontend assigns this alias-set zero, preserve that.  */
+  if (lang_hooks.get_alias_set (t) == 0)
+    return ptr_type_node;
+
   tree ptype = reference_alias_ptr_type_1 (&t);
   /* If there is a given pointer type for aliasing purposes, return it.  */
   if (ptype != NULL_TREE)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/asan.c gcc-6-20160721/gcc/asan.c
--- gcc-6.1.0/gcc/asan.c	2016-04-08 10:46:13.000000000 +0000
+++ gcc-6-20160721/gcc/asan.c	2016-07-21 16:18:46.000000000 +0000
@@ -2159,6 +2159,9 @@
 tree
 asan_dynamic_init_call (bool after_p)
 {
+  if (shadow_ptr_types[0] == NULL_TREE)
+    asan_init_shadow_ptr_types ();
+
   tree fn = builtin_decl_implicit (after_p
 				   ? BUILT_IN_ASAN_AFTER_DYNAMIC_INIT
 				   : BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT);
@@ -2168,8 +2171,6 @@
       pretty_printer module_name_pp;
       pp_string (&module_name_pp, main_input_filename);
 
-      if (shadow_ptr_types[0] == NULL_TREE)
-	asan_init_shadow_ptr_types ();
       module_name_cst = asan_pp_string (&module_name_pp);
       module_name_cst = fold_convert (const_ptr_type_node,
 				      module_name_cst);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c/ChangeLog gcc-6-20160721/gcc/c/ChangeLog
--- gcc-6.1.0/gcc/c/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/c/ChangeLog	2016-07-02 10:22:11.000000000 +0000
@@ -1,3 +1,44 @@
+2016-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-06-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/71685
+	* c-typeck.c (c_build_qualified_type): Don't clear
+	C_TYPE_INCOMPLETE_VARS for the main variant.
+
+2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR c/71381
+	Backport from trunk r237290:
+	* c-parser.c (c_parser_omp_variable_list) <OMP_CLAUSE__CACHE_>:
+	Loosen checking.
+
+2016-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71349
+	* c-parser.c (c_parser_omp_for): Don't disallow nowait clause
+	when combined with target construct.
+
+2016-05-19  David Malcolm  <dmalcolm@redhat.com>
+
+	Backport from trunk r236488.
+	PR c/71171
+	* c-parser.c (c_parser_generic_selection): Use c_expr::set_error
+	in error-handling.
+	(c_parser_postfix_expression): Likewise.
+	* c-tree.h (c_expr::set_error): New method.
+	* c-typeck.c (parser_build_binary_op): In error-handling, ensure
+	that result's range is initialized.
+
+2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR middle-end/70626
+	* c-parser.c (c_parser_oacc_loop): Don't augment mask with
+	OACC_LOOP_CLAUSE_MASK.
+	(c_parser_oacc_kernels_parallel): Update call to
+	c_oacc_split_loop_clauses.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c/c-parser.c gcc-6-20160721/gcc/c/c-parser.c
--- gcc-6.1.0/gcc/c/c-parser.c	2016-04-15 12:24:18.000000000 +0000
+++ gcc-6-20160721/gcc/c/c-parser.c	2016-06-10 09:46:04.000000000 +0000
@@ -7185,7 +7185,7 @@
 
   error_expr.original_code = ERROR_MARK;
   error_expr.original_type = NULL;
-  error_expr.value = error_mark_node;
+  error_expr.set_error ();
   matched_assoc.type_location = UNKNOWN_LOCATION;
   matched_assoc.type = NULL_TREE;
   matched_assoc.expression = error_expr;
@@ -7496,13 +7496,13 @@
 	    gcc_assert (c_dialect_objc ());
 	    if (!c_parser_require (parser, CPP_DOT, "expected %<.%>"))
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    if (c_parser_next_token_is_not (parser, CPP_NAME))
 	      {
 		c_parser_error (parser, "expected identifier");
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    c_token *component_tok = c_parser_peek_token (parser);
@@ -7516,7 +7516,7 @@
 	  }
 	default:
 	  c_parser_error (parser, "expected expression");
-	  expr.value = error_mark_node;
+	  expr.set_error ();
 	  break;
 	}
       break;
@@ -7538,7 +7538,7 @@
 	      parser->error = true;
 	      c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);
 	      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  stmt = c_begin_stmt_expr ();
@@ -7567,7 +7567,7 @@
 				     "expected %<)%>");
 	  if (type_name == NULL)
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	    }
 	  else
 	    expr = c_parser_postfix_expression_after_paren_type (parser,
@@ -7627,7 +7627,7 @@
 	    c_parser_consume_token (parser);
 	    if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    e1 = c_parser_expr_no_commas (parser, NULL);
@@ -7636,7 +7636,7 @@
 	    if (!c_parser_require (parser, CPP_COMMA, "expected %<,%>"))
 	      {
 		c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    loc = c_parser_peek_token (parser)->location;
@@ -7646,7 +7646,7 @@
 				       "expected %<)%>");
 	    if (t1 == NULL)
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 	      }
 	    else
 	      {
@@ -7668,7 +7668,7 @@
 	  c_parser_consume_token (parser);
 	  if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  t1 = c_parser_type_name (parser);
@@ -7679,7 +7679,7 @@
 	  if (parser->error)
 	    {
 	      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 
@@ -7768,7 +7768,7 @@
 					    &cexpr_list, true,
 					    &close_paren_loc))
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7776,7 +7776,7 @@
 	      {
 		error_at (loc, "wrong number of arguments to "
 			       "%<__builtin_choose_expr%>");
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7801,25 +7801,25 @@
 	  c_parser_consume_token (parser);
 	  if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  t1 = c_parser_type_name (parser);
 	  if (t1 == NULL)
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  if (!c_parser_require (parser, CPP_COMMA, "expected %<,%>"))
 	    {
 	      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  t2 = c_parser_type_name (parser);
 	  if (t2 == NULL)
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  {
@@ -7831,7 +7831,7 @@
 	    e2 = groktypename (t2, NULL, NULL);
 	    if (e1 == error_mark_node || e2 == error_mark_node)
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7856,14 +7856,14 @@
 					    &cexpr_list, false,
 					    &close_paren_loc))
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    if (vec_safe_length (cexpr_list) != 2)
 	      {
 		error_at (loc, "wrong number of arguments to "
 			       "%<__builtin_call_with_static_chain%>");
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7898,7 +7898,7 @@
 					    &cexpr_list, false,
 					    &close_paren_loc))
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7906,7 +7906,7 @@
 	      {
 		error_at (loc, "wrong number of arguments to "
 			       "%<__builtin_complex%>");
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7928,7 +7928,7 @@
 	      {
 		error_at (loc, "%<__builtin_complex%> operand "
 			  "not of real binary floating-point type");
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    if (TYPE_MAIN_VARIANT (TREE_TYPE (e1_p->value))
@@ -7936,7 +7936,7 @@
 	      {
 		error_at (loc,
 			  "%<__builtin_complex%> operands of different types");
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 	    pedwarn_c90 (loc, OPT_Wpedantic,
@@ -7962,7 +7962,7 @@
 					    &cexpr_list, false,
 					    &close_paren_loc))
 	      {
-		expr.value = error_mark_node;
+		expr.set_error ();
 		break;
 	      }
 
@@ -7985,7 +7985,7 @@
 	      {
 		error_at (loc, "wrong number of arguments to "
 			       "%<__builtin_shuffle%>");
-		expr.value = error_mark_node;
+		expr.set_error ();
 	      }
 	    set_c_expr_source_range (&expr, loc, close_paren_loc);
 	    break;
@@ -7995,7 +7995,7 @@
 	  c_parser_consume_token (parser);
 	  if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  {
@@ -8012,14 +8012,14 @@
 	  c_parser_consume_token (parser);
 	  if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  if (c_parser_next_token_is_not (parser, CPP_NAME))
 	    {
 	      c_parser_error (parser, "expected identifier");
 	      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  {
@@ -8038,13 +8038,13 @@
 	  c_parser_consume_token (parser);
 	  if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      break;
 	    }
 	  t1 = c_parser_type_name (parser);
 	  if (t1 == NULL)
 	    {
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
 	      break;
 	    }
@@ -8067,7 +8067,7 @@
 	      error_at (loc, "-fcilkplus must be enabled to use "
 			"%<_Cilk_spawn%>");
 	      expr = c_parser_cast_expression (parser, NULL);
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	    }
 	  else if (c_parser_peek_token (parser)->keyword == RID_CILK_SPAWN)
 	    {
@@ -8086,7 +8086,7 @@
 	  break;
 	default:
 	  c_parser_error (parser, "expected expression");
-	  expr.value = error_mark_node;
+	  expr.set_error ();
 	  break;
 	}
       break;
@@ -8107,7 +8107,7 @@
       /* Else fall through to report error.  */
     default:
       c_parser_error (parser, "expected expression");
-      expr.value = error_mark_node;
+      expr.set_error ();
       break;
     }
   return c_parser_postfix_expression_after_primary
@@ -8325,7 +8325,7 @@
 	  else
 	    {
 	      c_parser_error (parser, "expected identifier");
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      expr.original_code = ERROR_MARK;
               expr.original_type = NULL;
 	      return expr;
@@ -8357,7 +8357,7 @@
 	  else
 	    {
 	      c_parser_error (parser, "expected identifier");
-	      expr.value = error_mark_node;
+	      expr.set_error ();
 	      expr.original_code = ERROR_MARK;
 	      expr.original_type = NULL;
 	      return expr;
@@ -10595,6 +10595,8 @@
 	  switch (kind)
 	    {
 	    case OMP_CLAUSE__CACHE_:
+	      /* The OpenACC cache directive explicitly only allows "array
+		 elements or subarrays".  */
 	      if (c_parser_peek_token (parser)->type != CPP_OPEN_SQUARE)
 		{
 		  c_parser_error (parser, "expected %<[%>");
@@ -10657,25 +10659,6 @@
 		      break;
 		    }
 
-		  if (kind == OMP_CLAUSE__CACHE_)
-		    {
-		      if (TREE_CODE (low_bound) != INTEGER_CST
-			  && !TREE_READONLY (low_bound))
-			{
-			  error_at (clause_loc,
-				    "%qD is not a constant", low_bound);
-			  t = error_mark_node;
-			}
-
-		      if (TREE_CODE (length) != INTEGER_CST
-			  && !TREE_READONLY (length))
-			{
-			  error_at (clause_loc,
-				    "%qD is not a constant", length);
-			  t = error_mark_node;
-			}
-		    }
-
 		  t = tree_cons (low_bound, length, t);
 		}
 	      break;
@@ -13822,6 +13805,8 @@
 c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,
 		    omp_clause_mask mask, tree *cclauses, bool *if_p)
 {
+  bool is_parallel = ((mask >> PRAGMA_OACC_CLAUSE_REDUCTION) & 1) == 1;
+
   strcat (p_name, " loop");
   mask |= OACC_LOOP_CLAUSE_MASK;
 
@@ -13829,7 +13814,7 @@
 					    cclauses == NULL);
   if (cclauses)
     {
-      clauses = c_oacc_split_loop_clauses (clauses, cclauses);
+      clauses = c_oacc_split_loop_clauses (clauses, cclauses, is_parallel);
       if (*cclauses)
 	*cclauses = c_finish_omp_clauses (*cclauses, false);
       if (clauses)
@@ -13924,8 +13909,6 @@
       if (strcmp (p, "loop") == 0)
 	{
 	  c_parser_consume_token (parser);
-	  mask |= OACC_LOOP_CLAUSE_MASK;
-
 	  tree block = c_begin_omp_parallel ();
 	  tree clauses;
 	  c_parser_oacc_loop (loc, parser, p_name, mask, &clauses, if_p);
@@ -15094,7 +15077,9 @@
 
   strcat (p_name, " for");
   mask |= OMP_FOR_CLAUSE_MASK;
-  if (cclauses)
+  /* parallel for{, simd} disallows nowait clause, but for
+     target {teams distribute ,}parallel for{, simd} it should be accepted.  */
+  if (cclauses && (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) == 0)
     mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT);
   /* Composite distribute parallel for{, simd} disallows ordered clause.  */
   if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c/c-tree.h gcc-6-20160721/gcc/c/c-tree.h
--- gcc-6.1.0/gcc/c/c-tree.h	2016-04-13 16:00:52.000000000 +0000
+++ gcc-6-20160721/gcc/c/c-tree.h	2016-05-19 20:33:51.000000000 +0000
@@ -143,6 +143,15 @@
      of this expression.  */
   location_t get_start () const { return src_range.m_start; }
   location_t get_finish () const { return src_range.m_finish; }
+
+  /* Set the value to error_mark_node whilst ensuring that src_range
+     is initialized.  */
+  void set_error ()
+  {
+    value = error_mark_node;
+    src_range.m_start = UNKNOWN_LOCATION;
+    src_range.m_finish = UNKNOWN_LOCATION;
+  }
 };
 
 /* Type alias for struct c_expr. This allows to use the structure
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c/c-typeck.c gcc-6-20160721/gcc/c/c-typeck.c
--- gcc-6.1.0/gcc/c/c-typeck.c	2016-04-15 14:46:06.000000000 +0000
+++ gcc-6-20160721/gcc/c/c-typeck.c	2016-07-02 10:22:11.000000000 +0000
@@ -3530,7 +3530,12 @@
   result.original_type = NULL;
 
   if (TREE_CODE (result.value) == ERROR_MARK)
-    return result;
+    {
+      set_c_expr_source_range (&result,
+			       arg1.get_start (),
+			       arg2.get_finish ());
+      return result;
+    }
 
   if (location != UNKNOWN_LOCATION)
     protected_set_expr_location (result.value, location);
@@ -13533,7 +13538,8 @@
 		   : build_qualified_type (type, type_quals));
   /* A variant type does not inherit the list of incomplete vars from the
      type main variant.  */
-  if (RECORD_OR_UNION_TYPE_P (var_type))
+  if (RECORD_OR_UNION_TYPE_P (var_type)
+      && TYPE_MAIN_VARIANT (var_type) != var_type)
     C_TYPE_INCOMPLETE_VARS (var_type) = 0;
   return var_type;
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c-family/ChangeLog gcc-6-20160721/gcc/c-family/ChangeLog
--- gcc-6.1.0/gcc/c-family/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/c-family/ChangeLog	2016-07-05 17:55:36.000000000 +0000
@@ -1,3 +1,37 @@
+2016-07-05  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	PR c++/71214
+	* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_rvalue_references.
+
+2016-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-06-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/68657
+	* c.opt (Wpsabi): Add Warning flag.
+
+2016-06-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/71498
+	* c-gimplify.c (ubsan_walk_array_refs_r): Set *walk_subtrees = 0 on
+	all BIND_EXPRs, and on all BIND_EXPRs recurse also on BIND_EXPR_BODY.
+
+2016-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71349
+	* c-omp.c (c_omp_split_clauses): Put OMP_CLAUSE_DEPEND to
+	C_OMP_CLAUSE_SPLIT_TARGET.  Put OMP_CLAUSE_NOWAIT to
+	C_OMP_CLAUSE_SPLIT_TARGET if combined with target construct,
+	instead of C_OMP_CLAUSE_SPLIT_FOR.
+
+2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR middle-end/70626
+	* c-common.h (c_oacc_split_loop_clauses): Add boolean argument.
+	* c-omp.c (c_oacc_split_loop_clauses): Use it to duplicate
+	reduction clauses in acc parallel loops.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c-family/c-common.h gcc-6-20160721/gcc/c-family/c-common.h
--- gcc-6.1.0/gcc/c-family/c-common.h	2016-01-27 17:17:23.000000000 +0000
+++ gcc-6-20160721/gcc/c-family/c-common.h	2016-04-29 17:37:55.000000000 +0000
@@ -1276,7 +1276,7 @@
 extern bool c_omp_check_loop_iv_exprs (location_t, tree, tree, tree, tree,
 				       walk_tree_lh);
 extern tree c_finish_oacc_wait (location_t, tree, tree);
-extern tree c_oacc_split_loop_clauses (tree, tree *);
+extern tree c_oacc_split_loop_clauses (tree, tree *, bool);
 extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,
 				 tree, tree *);
 extern tree c_omp_declare_simd_clauses_to_numbers (tree, tree);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c-family/c-cppbuiltin.c gcc-6-20160721/gcc/c-family/c-cppbuiltin.c
--- gcc-6.1.0/gcc/c-family/c-cppbuiltin.c	2016-04-20 13:24:29.000000000 +0000
+++ gcc-6-20160721/gcc/c-family/c-cppbuiltin.c	2016-07-05 17:55:36.000000000 +0000
@@ -848,6 +848,7 @@
 	  cpp_define (pfile, "__cpp_decltype=200707");
 	  cpp_define (pfile, "__cpp_attributes=200809");
 	  cpp_define (pfile, "__cpp_rvalue_reference=200610");
+	  cpp_define (pfile, "__cpp_rvalue_references=200610");
 	  cpp_define (pfile, "__cpp_variadic_templates=200704");
 	  cpp_define (pfile, "__cpp_initializer_lists=200806");
 	  cpp_define (pfile, "__cpp_delegating_constructors=200604");
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c-family/c-gimplify.c gcc-6-20160721/gcc/c-family/c-gimplify.c
--- gcc-6.1.0/gcc/c-family/c-gimplify.c	2016-01-27 17:17:23.000000000 +0000
+++ gcc-6-20160721/gcc/c-family/c-gimplify.c	2016-06-13 21:08:36.000000000 +0000
@@ -67,23 +67,23 @@
 {
   hash_set<tree> *pset = (hash_set<tree> *) data;
 
-  /* Since walk_tree doesn't call the callback function on the decls
-     in BIND_EXPR_VARS, we have to walk them manually.  */
   if (TREE_CODE (*tp) == BIND_EXPR)
     {
+      /* Since walk_tree doesn't call the callback function on the decls
+	 in BIND_EXPR_VARS, we have to walk them manually, so we can avoid
+	 instrumenting DECL_INITIAL of TREE_STATIC vars.  */
+      *walk_subtrees = 0;
       for (tree decl = BIND_EXPR_VARS (*tp); decl; decl = DECL_CHAIN (decl))
 	{
 	  if (TREE_STATIC (decl))
-	    {
-	      *walk_subtrees = 0;
-	      continue;
-	    }
+	    continue;
 	  walk_tree (&DECL_INITIAL (decl), ubsan_walk_array_refs_r, pset,
 		     pset);
 	  walk_tree (&DECL_SIZE (decl), ubsan_walk_array_refs_r, pset, pset);
 	  walk_tree (&DECL_SIZE_UNIT (decl), ubsan_walk_array_refs_r, pset,
 		     pset);
 	}
+      walk_tree (&BIND_EXPR_BODY (*tp), ubsan_walk_array_refs_r, pset, pset);
     }
   else if (TREE_CODE (*tp) == ADDR_EXPR
 	   && TREE_CODE (TREE_OPERAND (*tp, 0)) == ARRAY_REF)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c-family/c-omp.c gcc-6-20160721/gcc/c-family/c-omp.c
--- gcc-6.1.0/gcc/c-family/c-omp.c	2016-01-18 14:48:26.000000000 +0000
+++ gcc-6-20160721/gcc/c-family/c-omp.c	2016-05-30 21:40:04.000000000 +0000
@@ -861,9 +861,10 @@
    #pragma acc parallel loop  */
 
 tree
-c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses)
+c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses,
+			   bool is_parallel)
 {
-  tree next, loop_clauses;
+  tree next, loop_clauses, nc;
 
   loop_clauses = *not_loop_clauses = NULL_TREE;
   for (; clauses ; clauses = next)
@@ -882,7 +883,23 @@
 	case OMP_CLAUSE_SEQ:
 	case OMP_CLAUSE_INDEPENDENT:
 	case OMP_CLAUSE_PRIVATE:
+	  OMP_CLAUSE_CHAIN (clauses) = loop_clauses;
+	  loop_clauses = clauses;
+	  break;
+
+	  /* Reductions must be duplicated on both constructs.  */
 	case OMP_CLAUSE_REDUCTION:
+	  if (is_parallel)
+	    {
+	      nc = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),
+				     OMP_CLAUSE_REDUCTION);
+	      OMP_CLAUSE_DECL (nc) = OMP_CLAUSE_DECL (clauses);
+	      OMP_CLAUSE_REDUCTION_CODE (nc)
+		= OMP_CLAUSE_REDUCTION_CODE (clauses);
+	      OMP_CLAUSE_CHAIN (nc) = *not_loop_clauses;
+	      *not_loop_clauses = nc;
+	    }
+
 	  OMP_CLAUSE_CHAIN (clauses) = loop_clauses;
 	  loop_clauses = clauses;
 	  break;
@@ -966,6 +983,7 @@
 	case OMP_CLAUSE_MAP:
 	case OMP_CLAUSE_IS_DEVICE_PTR:
 	case OMP_CLAUSE_DEFAULTMAP:
+	case OMP_CLAUSE_DEPEND:
 	  s = C_OMP_CLAUSE_SPLIT_TARGET;
 	  break;
 	case OMP_CLAUSE_NUM_TEAMS:
@@ -981,7 +999,6 @@
 	  s = C_OMP_CLAUSE_SPLIT_PARALLEL;
 	  break;
 	case OMP_CLAUSE_ORDERED:
-	case OMP_CLAUSE_NOWAIT:
 	  s = C_OMP_CLAUSE_SPLIT_FOR;
 	  break;
 	case OMP_CLAUSE_SCHEDULE:
@@ -1316,6 +1333,18 @@
 	  else
 	    s = C_OMP_CLAUSE_SPLIT_FOR;
 	  break;
+	case OMP_CLAUSE_NOWAIT:
+	  /* Nowait clause is allowed on target, for and sections, but
+	     is not allowed on parallel for or parallel sections.  Therefore,
+	     put it on target construct if present, because that can only
+	     be combined with parallel for{, simd} and not with for{, simd},
+	     otherwise to the worksharing construct.  */
+	  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP))
+	      != 0)
+	    s = C_OMP_CLAUSE_SPLIT_TARGET;
+	  else
+	    s = C_OMP_CLAUSE_SPLIT_FOR;
+	  break;
 	default:
 	  gcc_unreachable ();
 	}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/c-family/c.opt gcc-6-20160721/gcc/c-family/c.opt
--- gcc-6.1.0/gcc/c-family/c.opt	2016-03-23 17:51:56.000000000 +0000
+++ gcc-6-20160721/gcc/c-family/c.opt	2016-06-14 14:44:28.000000000 +0000
@@ -265,7 +265,7 @@
 Warn if a subobject has an abi_tag attribute that the complete object type does not have.
 
 Wpsabi
-C ObjC C++ ObjC++ LTO Var(warn_psabi) Init(1) Undocumented LangEnabledBy(C ObjC C++ ObjC++,Wabi)
+C ObjC C++ ObjC++ LTO Var(warn_psabi) Init(1) Warning Undocumented LangEnabledBy(C ObjC C++ ObjC++,Wabi)
 
 Waddress
 C ObjC C++ ObjC++ Var(warn_address) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/calls.c gcc-6-20160721/gcc/calls.c
--- gcc-6.1.0/gcc/calls.c	2016-03-18 15:31:18.000000000 +0000
+++ gcc-6-20160721/gcc/calls.c	2016-05-11 09:51:49.000000000 +0000
@@ -1188,6 +1188,7 @@
 	    j--;
 	  }
       }
+    argpos = 0;
     FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)
       {
 	tree argtype = TREE_TYPE (arg);
@@ -1206,6 +1207,14 @@
 		chkp_find_bound_slots (argtype, slots);
 	      }
 	  }
+	else if (CALL_WITH_BOUNDS_P (exp)
+		 && pass_by_reference (NULL, TYPE_MODE (argtype), argtype,
+				       argpos < n_named_args))
+	  {
+	    if (slots)
+	      BITMAP_FREE (slots);
+	    ptr_arg = j;
+	  }
 	else if (POINTER_BOUNDS_TYPE_P (argtype))
 	  {
 	    /* We expect bounds in instrumented calls only.
@@ -1249,6 +1258,7 @@
 	else
 	  args[j].tree_value = arg;
 	j--;
+	argpos++;
       }
 
     if (slots)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cfgexpand.c gcc-6-20160721/gcc/cfgexpand.c
--- gcc-6.1.0/gcc/cfgexpand.c	2016-04-14 16:23:06.000000000 +0000
+++ gcc-6-20160721/gcc/cfgexpand.c	2016-04-27 12:23:50.000000000 +0000
@@ -1137,7 +1137,7 @@
 	      HOST_WIDE_INT prev_offset
 		= align_base (frame_offset,
 			      MAX (alignb, ASAN_RED_ZONE_SIZE),
-			      FRAME_GROWS_DOWNWARD);
+			      !FRAME_GROWS_DOWNWARD);
 	      tree repr_decl = NULL_TREE;
 	      offset
 		= alloc_stack_frame_space (stack_vars[i].size
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cfgrtl.c gcc-6-20160721/gcc/cfgrtl.c
--- gcc-6.1.0/gcc/cfgrtl.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/cfgrtl.c	2016-07-19 19:55:54.000000000 +0000
@@ -572,8 +572,10 @@
 {
   rtx_insn *insn;
 
-  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)
-      || !single_succ_p (bb))
+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun)
+      || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)
+      || !single_succ_p (bb)
+      || (single_succ_edge (bb)->flags & EDGE_FAKE) != 0)
     return false;
 
   for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cgraph.c gcc-6-20160721/gcc/cgraph.c
--- gcc-6.1.0/gcc/cgraph.c	2016-03-18 09:17:23.000000000 +0000
+++ gcc-6-20160721/gcc/cgraph.c	2016-06-03 08:27:40.000000000 +0000
@@ -1504,10 +1504,21 @@
       update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), new_stmt);
     }
 
+  /* If changing the call to __cxa_pure_virtual or similar noreturn function,
+     adjust gimple_call_fntype too.  */
+  if (gimple_call_noreturn_p (new_stmt)
+      && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (e->callee->decl)))
+      && TYPE_ARG_TYPES (TREE_TYPE (e->callee->decl))
+      && (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (e->callee->decl)))
+	  == void_type_node))
+    gimple_call_set_fntype (new_stmt, TREE_TYPE (e->callee->decl));
+
   /* If the call becomes noreturn, remove the LHS if possible.  */
   if (lhs
       && (gimple_call_flags (new_stmt) & ECF_NORETURN)
-      && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (lhs))) == INTEGER_CST)
+      && (VOID_TYPE_P (TREE_TYPE (gimple_call_fntype (new_stmt)))
+	  || (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (lhs))) == INTEGER_CST
+	      && !TREE_ADDRESSABLE (TREE_TYPE (lhs)))))
     {
       if (TREE_CODE (lhs) == SSA_NAME)
 	{
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/aarch64/aarch64-simd-builtins.def gcc-6-20160721/gcc/config/aarch64/aarch64-simd-builtins.def
--- gcc-6.1.0/gcc/config/aarch64/aarch64-simd-builtins.def	2016-01-15 17:50:01.000000000 +0000
+++ gcc-6-20160721/gcc/config/aarch64/aarch64-simd-builtins.def	2016-07-08 15:41:31.000000000 +0000
@@ -244,13 +244,17 @@
   /* Implemented by <maxmin><mode>3.
      smax variants map to fmaxnm,
      smax_nan variants map to fmax.  */
-  BUILTIN_VDQIF (BINOP, smax, 3)
-  BUILTIN_VDQIF (BINOP, smin, 3)
+  BUILTIN_VDQ_BHSI (BINOP, smax, 3)
+  BUILTIN_VDQ_BHSI (BINOP, smin, 3)
   BUILTIN_VDQ_BHSI (BINOP, umax, 3)
   BUILTIN_VDQ_BHSI (BINOP, umin, 3)
   BUILTIN_VDQF (BINOP, smax_nan, 3)
   BUILTIN_VDQF (BINOP, smin_nan, 3)
 
+  /* Implemented by <fmaxmin><mode>3.  */
+  BUILTIN_VDQF (BINOP, fmax, 3)
+  BUILTIN_VDQF (BINOP, fmin, 3)
+
   /* Implemented by aarch64_<maxmin_uns>p<mode>.  */
   BUILTIN_VDQ_BHSI (BINOP, smaxp, 0)
   BUILTIN_VDQ_BHSI (BINOP, sminp, 0)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/aarch64/aarch64-simd.md gcc-6-20160721/gcc/config/aarch64/aarch64-simd.md
--- gcc-6.1.0/gcc/config/aarch64/aarch64-simd.md	2016-02-26 23:41:53.000000000 +0000
+++ gcc-6-20160721/gcc/config/aarch64/aarch64-simd.md	2016-05-17 13:08:01.000000000 +0000
@@ -1919,16 +1919,6 @@
   }
 )
 
-(define_insn "aarch64_vmls<mode>"
-  [(set (match_operand:VDQF 0 "register_operand" "=w")
-       (minus:VDQF (match_operand:VDQF 1 "register_operand" "0")
-		   (mult:VDQF (match_operand:VDQF 2 "register_operand" "w")
-			      (match_operand:VDQF 3 "register_operand" "w"))))]
-  "TARGET_SIMD"
- "fmls\\t%0.<Vtype>, %2.<Vtype>, %3.<Vtype>"
-  [(set_attr "type" "neon_fp_mla_<Vetype>_scalar<q>")]
-)
-
 ;; FP Max/Min
 ;; Max/Min are introduced by idiom recognition by GCC's mid-end.  An
 ;; expression like:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/aarch64/arm_neon.h gcc-6-20160721/gcc/config/aarch64/arm_neon.h
--- gcc-6.1.0/gcc/config/aarch64/arm_neon.h	2016-01-25 11:32:07.000000000 +0000
+++ gcc-6-20160721/gcc/config/aarch64/arm_neon.h	2016-07-08 15:41:31.000000000 +0000
@@ -17856,19 +17856,19 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmaxnm_f32 (float32x2_t __a, float32x2_t __b)
 {
-  return __builtin_aarch64_smaxv2sf (__a, __b);
+  return __builtin_aarch64_fmaxv2sf (__a, __b);
 }
 
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmaxnmq_f32 (float32x4_t __a, float32x4_t __b)
 {
-  return __builtin_aarch64_smaxv4sf (__a, __b);
+  return __builtin_aarch64_fmaxv4sf (__a, __b);
 }
 
 __extension__ static __inline float64x2_t __attribute__ ((__always_inline__))
 vmaxnmq_f64 (float64x2_t __a, float64x2_t __b)
 {
-  return __builtin_aarch64_smaxv2df (__a, __b);
+  return __builtin_aarch64_fmaxv2df (__a, __b);
 }
 
 /* vmaxv  */
@@ -18086,19 +18086,19 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vminnm_f32 (float32x2_t __a, float32x2_t __b)
 {
-  return __builtin_aarch64_sminv2sf (__a, __b);
+  return __builtin_aarch64_fminv2sf (__a, __b);
 }
 
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vminnmq_f32 (float32x4_t __a, float32x4_t __b)
 {
-  return __builtin_aarch64_sminv4sf (__a, __b);
+  return __builtin_aarch64_fminv4sf (__a, __b);
 }
 
 __extension__ static __inline float64x2_t __attribute__ ((__always_inline__))
 vminnmq_f64 (float64x2_t __a, float64x2_t __b)
 {
-  return __builtin_aarch64_sminv2df (__a, __b);
+  return __builtin_aarch64_fminv2df (__a, __b);
 }
 
 /* vminv  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/alpha/alpha.md gcc-6-20160721/gcc/config/alpha/alpha.md
--- gcc-6.1.0/gcc/config/alpha/alpha.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/alpha/alpha.md	2016-05-18 19:39:49.000000000 +0000
@@ -3738,7 +3738,8 @@
 
 ;; BUGCHK is documented common to OSF/1 and VMS PALcode.
 (define_insn "trap"
-  [(trap_if (const_int 1) (const_int 0))]
+  [(trap_if (const_int 1) (const_int 0))
+   (use (reg:DI 29))]
   ""
   "call_pal 0x81"
   [(set_attr "type" "callpal")])
@@ -5157,7 +5158,7 @@
   "TARGET_ABI_OSF"
 {
   if (TARGET_EXPLICIT_RELOCS)
-    return "ldah $29,0($26)\t\t!gpdisp!%*\;lda $29,0($29)\t\t!gpdisp!%*";
+    return "#";
   else
     return "ldgp $29,0($26)";
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/arm/arm-builtins.c gcc-6-20160721/gcc/config/arm/arm-builtins.c
--- gcc-6.1.0/gcc/config/arm/arm-builtins.c	2016-01-21 09:52:46.000000000 +0000
+++ gcc-6-20160721/gcc/config/arm/arm-builtins.c	2016-05-31 08:29:39.000000000 +0000
@@ -2861,6 +2861,10 @@
   int in_n, out_n;
   bool out_unsigned_p = TYPE_UNSIGNED (type_out);
 
+  /* Can't provide any vectorized builtins when we can't use NEON.  */
+  if (!TARGET_NEON)
+    return NULL_TREE;
+
   if (TREE_CODE (type_out) != VECTOR_TYPE
       || TREE_CODE (type_in) != VECTOR_TYPE)
     return NULL_TREE;
@@ -2875,7 +2879,7 @@
    NULL_TREE is returned if no such builtin is available.  */
 #undef ARM_CHECK_BUILTIN_MODE
 #define ARM_CHECK_BUILTIN_MODE(C)    \
-  (TARGET_NEON && TARGET_FPU_ARMV8   \
+  (TARGET_FPU_ARMV8   \
    && flag_unsafe_math_optimizations \
    && ARM_CHECK_BUILTIN_MODE_1 (C))
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/arm/arm.c gcc-6-20160721/gcc/config/arm/arm.c
--- gcc-6.1.0/gcc/config/arm/arm.c	2016-03-30 12:48:42.000000000 +0000
+++ gcc-6-20160721/gcc/config/arm/arm.c	2016-07-01 07:40:37.000000000 +0000
@@ -6704,7 +6704,7 @@
 
   /* The PIC register is live on entry to VxWorks PLT entries, so we
      must make the call before restoring the PIC register.  */
-  if (TARGET_VXWORKS_RTP && flag_pic && !targetm.binds_local_p (decl))
+  if (TARGET_VXWORKS_RTP && flag_pic && decl && !targetm.binds_local_p (decl))
     return false;
 
   /* If we are interworking and the function is not declared static
@@ -17755,6 +17755,7 @@
   int num_saves = XVECLEN (operands[0], 0);
   unsigned int regno;
   unsigned int regno_base = REGNO (operands[1]);
+  bool interrupt_p = IS_INTERRUPT (arm_current_func_type ());
 
   offset = 0;
   offset += update ? 1 : 0;
@@ -17772,20 +17773,16 @@
     }
 
   conditional = reverse ? "%?%D0" : "%?%d0";
-  if ((regno_base == SP_REGNUM) && update)
-    {
-      sprintf (pattern, "pop%s\t{", conditional);
-    }
+  /* Can't use POP if returning from an interrupt.  */
+  if ((regno_base == SP_REGNUM) && update && !(interrupt_p && return_pc))
+    sprintf (pattern, "pop%s\t{", conditional);
   else
     {
       /* Output ldmfd when the base register is SP, otherwise output ldmia.
          It's just a convention, their semantics are identical.  */
       if (regno_base == SP_REGNUM)
-	  /* update is never true here, hence there is no need to handle
-	     pop here.  */
-	sprintf (pattern, "ldmfd%s", conditional);
-
-      if (update)
+	sprintf (pattern, "ldmfd%s\t", conditional);
+      else if (update)
 	sprintf (pattern, "ldmia%s\t", conditional);
       else
 	sprintf (pattern, "ldm%s\t", conditional);
@@ -17811,7 +17808,7 @@
 
   strcat (pattern, "}");
 
-  if (IS_INTERRUPT (arm_current_func_type ()) && return_pc)
+  if (interrupt_p && return_pc)
     strcat (pattern, "^");
 
   output_asm_insn (pattern, &cond);
@@ -19622,8 +19619,12 @@
 		  sprintf (instr, "ldmfd%s\t%%|sp, {", conditional);
 		}
 	    }
+	  /* For interrupt returns we have to use an LDM rather than
+	     a POP so that we can use the exception return variant.  */
+	  else if (IS_INTERRUPT (func_type))
+	    sprintf (instr, "ldmfd%s\t%%|sp!, {", conditional);
 	  else
-	      sprintf (instr, "pop%s\t{", conditional);
+	    sprintf (instr, "pop%s\t{", conditional);
 
 	  p = instr + strlen (instr);
 
@@ -21461,7 +21462,11 @@
 
   /* Naked functions don't have prologues.  */
   if (IS_NAKED (func_type))
-    return;
+    {
+      if (flag_stack_usage_info)
+	current_function_static_stack_size = 0;
+      return;
+    }
 
   /* Make a copy of c_f_p_a_s as we may need to modify it locally.  */
   args_to_push = crtl->args.pretend_args_size;
@@ -24715,7 +24720,11 @@
 
   /* Naked functions don't have prologues.  */
   if (IS_NAKED (func_type))
-    return;
+    {
+      if (flag_stack_usage_info)
+	current_function_static_stack_size = 0;
+      return;
+    }
 
   if (IS_INTERRUPT (func_type))
     {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/arm/freebsd.h gcc-6-20160721/gcc/config/arm/freebsd.h
--- gcc-6.1.0/gcc/config/arm/freebsd.h	2016-01-07 20:35:53.000000000 +0000
+++ gcc-6-20160721/gcc/config/arm/freebsd.h	2016-06-15 19:17:15.000000000 +0000
@@ -120,6 +120,9 @@
 #define SUBTARGET_CPU_DEFAULT   TARGET_CPU_arm9
 #endif
 
+/* FreeBSD 10 does not support unaligned access for armv6 and up.
+   Unaligned access support was added in FreeBSD 11.  */
+#if FBSD_MAJOR < 11
 #define SUBTARGET_OVERRIDE_INTERNAL_OPTIONS				\
 do {									\
     if (opts_set->x_unaligned_access == 1)				\
@@ -127,6 +130,7 @@
     if (opts->x_unaligned_access)					\
 	opts->x_unaligned_access = 0;					\
 } while (0)
+#endif
 
 #undef MAX_SYNC_LIBFUNC_SIZE
 #define MAX_SYNC_LIBFUNC_SIZE 4 /* UNITS_PER_WORD not defined yet.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/avr/avr.c gcc-6-20160721/gcc/config/avr/avr.c
--- gcc-6.1.0/gcc/config/avr/avr.c	2016-02-02 16:01:45.000000000 +0000
+++ gcc-6-20160721/gcc/config/avr/avr.c	2016-07-06 13:53:36.000000000 +0000
@@ -9721,7 +9721,9 @@
             {
               const char *sname = ACONCAT ((new_prefix,
                                             name + strlen (old_prefix), NULL));
-              return get_section (sname, sect->common.flags, sect->named.decl);
+              return get_section (sname,
+                                  sect->common.flags & ~SECTION_DECLARED,
+                                  sect->named.decl);
             }
         }
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/avr/avr.md gcc-6-20160721/gcc/config/avr/avr.md
--- gcc-6.1.0/gcc/config/avr/avr.md	2016-03-15 16:21:49.000000000 +0000
+++ gcc-6-20160721/gcc/config/avr/avr.md	2016-06-21 10:23:08.000000000 +0000
@@ -641,6 +641,22 @@
     if (avr_mem_flash_p (dest))
       DONE;
 
+    if (QImode == <MODE>mode
+        && SUBREG_P (src)
+        && CONSTANT_ADDRESS_P (SUBREG_REG (src))
+        && can_create_pseudo_p())
+      {
+        // store_bitfield may want to store a SYMBOL_REF or CONST in a
+        // structure that's represented as PSImode.  As the upper 16 bits
+        // of PSImode cannot be expressed as an HImode subreg, the rhs is
+        // decomposed into QImode (word_mode) subregs of SYMBOL_REF,
+        // CONST or LABEL_REF; cf. PR71103.
+
+        rtx const_addr = SUBREG_REG (src);
+        operands[1] = src = copy_rtx (src);
+        SUBREG_REG (src) = copy_to_mode_reg (GET_MODE (const_addr), const_addr);
+      }
+
     /* One of the operands has to be in a register.  */
     if (!register_operand (dest, <MODE>mode)
         && !reg_or_0_operand (src, <MODE>mode))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/avr/gen-avr-mmcu-specs.c gcc-6-20160721/gcc/config/avr/gen-avr-mmcu-specs.c
--- gcc-6.1.0/gcc/config/avr/gen-avr-mmcu-specs.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/avr/gen-avr-mmcu-specs.c	2016-06-21 10:39:59.000000000 +0000
@@ -27,7 +27,7 @@
 
 #include "avr-devices.c"
 
-// Get rid of "defaults.h".  We just need tm.h for `WITH_AVRLIBS' and
+// Get rid of "defaults.h".  We just need tm.h for `WITH_AVRLIBC' and
 // and `WITH_RTEMS'.  */
 #define GCC_DEFAULTS_H
 
@@ -242,12 +242,13 @@
       fprintf (f, "*link_data_start:\n");
       if (mcu->data_section_start
           != arch->default_data_section_start)
-        fprintf (f, "\t-Tdata 0x%lX", 0x800000UL + mcu->data_section_start);
+        fprintf (f, "\t%%{!Tdata:-Tdata 0x%lX}",
+                 0x800000UL + mcu->data_section_start);
       fprintf (f, "\n\n");
 
       fprintf (f, "*link_text_start:\n");
       if (mcu->text_section_start != 0x0)
-        fprintf (f, "\t-Ttext 0x%lX", 0UL + mcu->text_section_start);
+        fprintf (f, "\t%%{!Ttext:-Ttext 0x%lX}", 0UL + mcu->text_section_start);
       fprintf (f, "\n\n");
     }
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/darwin.h gcc-6-20160721/gcc/config/darwin.h
--- gcc-6.1.0/gcc/config/darwin.h	2016-04-08 13:47:37.000000000 +0000
+++ gcc-6-20160721/gcc/config/darwin.h	2016-06-15 11:12:40.000000000 +0000
@@ -179,6 +179,7 @@
     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \
     %{fopenacc|fopenmp|%:gt(%{ftree-parallelize-loops=*:%*} 1): \
       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \
+    %{fcilkplus:%:include(libcilkrts.spec)%(link_cilkrts)} \
     %{fgnu-tm: \
       %{static|static-libgcc|static-libstdc++|static-libgfortran: libitm.a%s; : -litm } } \
     %{!nostdlib:%{!nodefaultlibs:\
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/constraints.md gcc-6-20160721/gcc/config/i386/constraints.md
--- gcc-6.1.0/gcc/config/i386/constraints.md	2016-01-29 18:47:17.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/constraints.md	2016-05-25 08:04:09.000000000 +0000
@@ -141,8 +141,12 @@
  "(ix86_fpmath & FPMATH_387) ? FLOAT_REGS : NO_REGS"
  "@internal Any x87 register when 80387 FP arithmetic is enabled.")
 
+;; Yr constraint is meant to be used in noavx contexts only, for VEX and EVEX
+;; the lower register numbers need the same instruction sizes as any other.
+;; In case Yr constraint is misused, try to limit the damage, by treating
+;; it as x constraint in avx mode, not v constraint.
 (define_register_constraint "Yr"
- "TARGET_SSE ? (X86_TUNE_AVOID_4BYTE_PREFIXES ? NO_REX_SSE_REGS : ALL_SSE_REGS) : NO_REGS"
+ "TARGET_SSE ? ((TARGET_AVOID_4BYTE_PREFIXES && !TARGET_AVX) ? NO_REX_SSE_REGS : SSE_REGS) : NO_REGS"
  "@internal Lower SSE register when avoiding REX prefix and all SSE registers otherwise.")
 
 ;; We use the B prefix to denote any number of internal operands:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/driver-i386.c gcc-6-20160721/gcc/config/i386/driver-i386.c
--- gcc-6.1.0/gcc/config/i386/driver-i386.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/driver-i386.c	2016-06-05 15:45:44.000000000 +0000
@@ -637,33 +637,27 @@
     }
   else if (vendor == signature_CENTAUR_ebx)
     {
-      if (arch)
+      processor = PROCESSOR_GENERIC;
+
+      switch (family)
 	{
-	  switch (family)
-	    {
-	    case 6:
-	      if (model > 9)
-		/* Use the default detection procedure.  */
-		processor = PROCESSOR_GENERIC;
-	      else if (model == 9)
-		cpu = "c3-2";
-	      else if (model >= 6)
-		cpu = "c3";
-	      else
-		processor = PROCESSOR_GENERIC;
-	      break;
-	    case 5:
-	      if (has_3dnow)
-		cpu = "winchip2";
-	      else if (has_mmx)
-		cpu = "winchip2-c6";
-	      else
-		processor = PROCESSOR_GENERIC;
-	      break;
-	    default:
-	      /* We have no idea.  */
-	      processor = PROCESSOR_GENERIC;
-	    }
+	default:
+	  /* We have no idea.  */
+	  break;
+
+	case 5:
+	  if (has_3dnow || has_mmx)
+	    processor = PROCESSOR_I486;
+	  break;
+
+	case 6:
+	  if (model > 9 || has_longmode)
+	    /* Use the default detection procedure.  */
+	    ;
+	  else if (model == 9)
+	    processor = PROCESSOR_PENTIUMPRO;
+	  else if (model >= 6)
+	    processor = PROCESSOR_I486;
 	}
     }
   else
@@ -694,7 +688,18 @@
       /* Default.  */
       break;
     case PROCESSOR_I486:
-      cpu = "i486";
+      if (arch && vendor == signature_CENTAUR_ebx)
+	{
+	  if (model >= 6)
+	    cpu = "c3";
+	  else if (has_3dnow)
+	    cpu = "winchip2";
+	  else
+	    /* Assume WinChip C6.  */
+	    cpu = "winchip-c6";
+	}
+      else
+	cpu = "i486";
       break;
     case PROCESSOR_PENTIUM:
       if (arch && has_mmx)
@@ -817,8 +822,13 @@
 		/* It is Pentium M.  */
 		cpu = "pentium-m";
 	      else if (has_sse)
-		/* It is Pentium III.  */
-		cpu = "pentium3";
+		{
+		  if (vendor == signature_CENTAUR_ebx)
+		    cpu = "c3-2";
+		  else
+		    /* It is Pentium III.  */
+		    cpu = "pentium3";
+		}
 	      else if (has_mmx)
 		/* It is Pentium II.  */
 		cpu = "pentium2";
@@ -902,6 +912,11 @@
 	      else
 		cpu = "prescott";
 	    }
+	  else if (has_longmode)
+	    /* Perhaps some emulator?  Assume x86-64, otherwise gcc
+	       -march=native would be unusable for 64-bit compilations,
+	       as all the CPUs below are 32-bit only.  */
+	    cpu = "x86-64";
 	  else if (has_sse2)
 	    cpu = "pentium4";
 	  else if (has_cmov)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/i386-builtin-types.def gcc-6-20160721/gcc/config/i386/i386-builtin-types.def
--- gcc-6.1.0/gcc/config/i386/i386-builtin-types.def	2015-09-04 08:54:14.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/i386-builtin-types.def	2016-06-08 13:06:24.000000000 +0000
@@ -292,6 +292,7 @@
 DEF_FUNCTION_TYPE (V8DF, V2DF)
 DEF_FUNCTION_TYPE (V16SI, V4SI)
 DEF_FUNCTION_TYPE (V16SI, V8SI)
+DEF_FUNCTION_TYPE (V16SI, V16SF)
 DEF_FUNCTION_TYPE (V16SI, V16SI, V16SI, UHI)
 DEF_FUNCTION_TYPE (V8DI, V8DI, V8DI, UQI)
 DEF_FUNCTION_TYPE (V8DI, PV8DI)
@@ -1035,14 +1036,17 @@
 
 DEF_FUNCTION_TYPE_ALIAS (V2DF_FTYPE_V2DF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V4DF_FTYPE_V4DF, ROUND)
+DEF_FUNCTION_TYPE_ALIAS (V8DF_FTYPE_V8DF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V4SF_FTYPE_V4SF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V8SF_FTYPE_V8SF, ROUND)
+DEF_FUNCTION_TYPE_ALIAS (V16SF_FTYPE_V16SF, ROUND)
 
 DEF_FUNCTION_TYPE_ALIAS (V4SI_FTYPE_V2DF_V2DF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V8SI_FTYPE_V4DF_V4DF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V16SI_FTYPE_V8DF_V8DF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V4SI_FTYPE_V4SF, ROUND)
 DEF_FUNCTION_TYPE_ALIAS (V8SI_FTYPE_V8SF, ROUND)
+DEF_FUNCTION_TYPE_ALIAS (V16SI_FTYPE_V16SF, ROUND)
 
 DEF_FUNCTION_TYPE_ALIAS (INT_FTYPE_V2DF_V2DF, PTEST)
 DEF_FUNCTION_TYPE_ALIAS (INT_FTYPE_V2DI_V2DI, PTEST)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/i386.c gcc-6-20160721/gcc/config/i386/i386.c
--- gcc-6.1.0/gcc/config/i386/i386.c	2016-04-15 13:35:12.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/i386.c	2016-07-02 10:21:24.000000000 +0000
@@ -18787,12 +18787,29 @@
      of the register, once we have that information we may be able
      to handle some of them more efficiently.  */
   if (can_create_pseudo_p ()
-      && register_operand (op0, mode)
       && (CONSTANT_P (op1)
 	  || (SUBREG_P (op1)
 	      && CONSTANT_P (SUBREG_REG (op1))))
-      && !standard_sse_constant_p (op1))
-    op1 = validize_mem (force_const_mem (mode, op1));
+      && ((register_operand (op0, mode)
+	   && !standard_sse_constant_p (op1))
+	  /* ix86_expand_vector_move_misalign() does not like constants.  */
+	  || (SSE_REG_MODE_P (mode)
+	      && MEM_P (op0)
+	      && MEM_ALIGN (op0) < align)))
+    {
+      if (SUBREG_P (op1))
+	{
+	  machine_mode imode = GET_MODE (SUBREG_REG (op1));
+	  rtx r = force_const_mem (imode, SUBREG_REG (op1));
+	  if (r)
+	    r = validize_mem (r);
+	  else
+	    r = force_reg (imode, SUBREG_REG (op1));
+	  op1 = simplify_gen_subreg (mode, r, imode, SUBREG_BYTE (op1));
+	}
+      else
+	op1 = validize_mem (force_const_mem (mode, op1));
+    }
 
   /* We need to check memory alignment for SSE mode since attribute
      can make operands unaligned.  */
@@ -18803,13 +18820,8 @@
     {
       rtx tmp[2];
 
-      /* ix86_expand_vector_move_misalign() does not like constants ... */
-      if (CONSTANT_P (op1)
-	  || (SUBREG_P (op1)
-	      && CONSTANT_P (SUBREG_REG (op1))))
-	op1 = validize_mem (force_const_mem (mode, op1));
-
-      /* ... nor both arguments in memory.  */
+      /* ix86_expand_vector_move_misalign() does not like both
+	 arguments in memory.  */
       if (!register_operand (op0, mode)
 	  && !register_operand (op1, mode))
 	op1 = force_reg (mode, op1);
@@ -18895,7 +18907,7 @@
 	  m = adjust_address (op0, mode, 0);
 	  emit_insn (extract (m, op1, const0_rtx));
 	  m = adjust_address (op0, mode, 16);
-	  emit_insn (extract (m, op1, const1_rtx));
+	  emit_insn (extract (m, copy_rtx (op1), const1_rtx));
 	}
       else
 	emit_insn (store_unaligned (op0, op1));
@@ -19203,7 +19215,7 @@
 	      m = adjust_address (op0, V2SFmode, 0);
 	      emit_insn (gen_sse_storelps (m, op1));
 	      m = adjust_address (op0, V2SFmode, 8);
-	      emit_insn (gen_sse_storehps (m, op1));
+	      emit_insn (gen_sse_storehps (m, copy_rtx (op1)));
 	    }
 	}
     }
@@ -23027,17 +23039,33 @@
   switch (code)
     {
     case EQ:
-      return 0x08;
+      return 0x00;
     case NE:
       return 0x04;
     case GT:
-      return 0x16;
+      return 0x0e;
     case LE:
-      return 0x1a;
+      return 0x02;
     case GE:
-      return 0x15;
+      return 0x0d;
     case LT:
-      return 0x19;
+      return 0x01;
+    case UNLE:
+      return 0x0a;
+    case UNLT:
+      return 0x09;
+    case UNGE:
+      return 0x05;
+    case UNGT:
+      return 0x06;
+    case UNEQ:
+      return 0x18;
+    case LTGT:
+      return 0x0c;
+    case ORDERED:
+      return 0x07;
+    case UNORDERED:
+      return 0x03;
     default:
       gcc_unreachable ();
     }
@@ -30686,7 +30714,7 @@
   IX86_BUILTIN_CVTPD2PS512,
   IX86_BUILTIN_CVTPD2UDQ512,
   IX86_BUILTIN_CVTPH2PS512,
-  IX86_BUILTIN_CVTPS2DQ512,
+  IX86_BUILTIN_CVTPS2DQ512_MASK,
   IX86_BUILTIN_CVTPS2PD512,
   IX86_BUILTIN_CVTPS2PH512,
   IX86_BUILTIN_CVTPS2UDQ512,
@@ -32126,14 +32154,25 @@
   IX86_BUILTIN_COPYSIGNQ,
 
   /* Vectorizer support builtins.  */
-  IX86_BUILTIN_CEILPD_VEC_PACK_SFIX512,
   IX86_BUILTIN_CPYSGNPS,
   IX86_BUILTIN_CPYSGNPD,
   IX86_BUILTIN_CPYSGNPS256,
   IX86_BUILTIN_CPYSGNPS512,
   IX86_BUILTIN_CPYSGNPD256,
   IX86_BUILTIN_CPYSGNPD512,
+  IX86_BUILTIN_FLOORPS512,
+  IX86_BUILTIN_FLOORPD512,
+  IX86_BUILTIN_CEILPS512,
+  IX86_BUILTIN_CEILPD512,
+  IX86_BUILTIN_TRUNCPS512,
+  IX86_BUILTIN_TRUNCPD512,
+  IX86_BUILTIN_CVTPS2DQ512,
+  IX86_BUILTIN_VEC_PACK_SFIX512,
+  IX86_BUILTIN_FLOORPS_SFIX512,
   IX86_BUILTIN_FLOORPD_VEC_PACK_SFIX512,
+  IX86_BUILTIN_CEILPS_SFIX512,
+  IX86_BUILTIN_CEILPD_VEC_PACK_SFIX512,
+  IX86_BUILTIN_ROUNDPS_AZ_SFIX512,
   IX86_BUILTIN_ROUNDPD_AZ_VEC_PACK_SFIX512,
 
 
@@ -32787,9 +32826,9 @@
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_llwpcb, "__builtin_ia32_llwpcb", IX86_BUILTIN_LLWPCB, UNKNOWN, (int) VOID_FTYPE_PVOID },
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_slwpcb, "__builtin_ia32_slwpcb", IX86_BUILTIN_SLWPCB, UNKNOWN, (int) PVOID_FTYPE_VOID },
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_lwpvalsi3, "__builtin_ia32_lwpval32", IX86_BUILTIN_LWPVAL32, UNKNOWN, (int) VOID_FTYPE_UINT_UINT_UINT },
-  { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_lwpvaldi3, "__builtin_ia32_lwpval64", IX86_BUILTIN_LWPVAL64, UNKNOWN, (int) VOID_FTYPE_UINT64_UINT_UINT },
+  { OPTION_MASK_ISA_LWP | OPTION_MASK_ISA_64BIT, CODE_FOR_lwp_lwpvaldi3, "__builtin_ia32_lwpval64", IX86_BUILTIN_LWPVAL64, UNKNOWN, (int) VOID_FTYPE_UINT64_UINT_UINT },
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_lwpinssi3, "__builtin_ia32_lwpins32", IX86_BUILTIN_LWPINS32, UNKNOWN, (int) UCHAR_FTYPE_UINT_UINT_UINT },
-  { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_lwpinsdi3, "__builtin_ia32_lwpins64", IX86_BUILTIN_LWPINS64, UNKNOWN, (int) UCHAR_FTYPE_UINT64_UINT_UINT },
+  { OPTION_MASK_ISA_LWP | OPTION_MASK_ISA_64BIT, CODE_FOR_lwp_lwpinsdi3, "__builtin_ia32_lwpins64", IX86_BUILTIN_LWPINS64, UNKNOWN, (int) UCHAR_FTYPE_UINT64_UINT_UINT },
 
   /* FSGSBASE */
   { OPTION_MASK_ISA_FSGSBASE | OPTION_MASK_ISA_64BIT, CODE_FOR_rdfsbasesi, "__builtin_ia32_rdfsbase32", IX86_BUILTIN_RDFSBASE32, UNKNOWN, (int) UNSIGNED_FTYPE_VOID },
@@ -33724,12 +33763,12 @@
 
   /* BMI */
   { OPTION_MASK_ISA_BMI, CODE_FOR_bmi_bextr_si, "__builtin_ia32_bextr_u32", IX86_BUILTIN_BEXTR32, UNKNOWN, (int) UINT_FTYPE_UINT_UINT },
-  { OPTION_MASK_ISA_BMI, CODE_FOR_bmi_bextr_di, "__builtin_ia32_bextr_u64", IX86_BUILTIN_BEXTR64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
+  { OPTION_MASK_ISA_BMI | OPTION_MASK_ISA_64BIT, CODE_FOR_bmi_bextr_di, "__builtin_ia32_bextr_u64", IX86_BUILTIN_BEXTR64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
   { OPTION_MASK_ISA_BMI, CODE_FOR_ctzhi2,       "__builtin_ctzs",           IX86_BUILTIN_CTZS,    UNKNOWN, (int) UINT16_FTYPE_UINT16 },
 
   /* TBM */
   { OPTION_MASK_ISA_TBM, CODE_FOR_tbm_bextri_si, "__builtin_ia32_bextri_u32", IX86_BUILTIN_BEXTRI32, UNKNOWN, (int) UINT_FTYPE_UINT_UINT },
-  { OPTION_MASK_ISA_TBM, CODE_FOR_tbm_bextri_di, "__builtin_ia32_bextri_u64", IX86_BUILTIN_BEXTRI64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
+  { OPTION_MASK_ISA_TBM | OPTION_MASK_ISA_64BIT, CODE_FOR_tbm_bextri_di, "__builtin_ia32_bextri_u64", IX86_BUILTIN_BEXTRI64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
 
   /* F16C */
   { OPTION_MASK_ISA_F16C, CODE_FOR_vcvtph2ps, "__builtin_ia32_vcvtph2ps", IX86_BUILTIN_CVTPH2PS, UNKNOWN, (int) V4SF_FTYPE_V8HI },
@@ -33739,11 +33778,11 @@
 
   /* BMI2 */
   { OPTION_MASK_ISA_BMI2, CODE_FOR_bmi2_bzhi_si3, "__builtin_ia32_bzhi_si", IX86_BUILTIN_BZHI32, UNKNOWN, (int) UINT_FTYPE_UINT_UINT },
-  { OPTION_MASK_ISA_BMI2, CODE_FOR_bmi2_bzhi_di3, "__builtin_ia32_bzhi_di", IX86_BUILTIN_BZHI64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
+  { OPTION_MASK_ISA_BMI2 | OPTION_MASK_ISA_64BIT, CODE_FOR_bmi2_bzhi_di3, "__builtin_ia32_bzhi_di", IX86_BUILTIN_BZHI64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
   { OPTION_MASK_ISA_BMI2, CODE_FOR_bmi2_pdep_si3, "__builtin_ia32_pdep_si", IX86_BUILTIN_PDEP32, UNKNOWN, (int) UINT_FTYPE_UINT_UINT },
-  { OPTION_MASK_ISA_BMI2, CODE_FOR_bmi2_pdep_di3, "__builtin_ia32_pdep_di", IX86_BUILTIN_PDEP64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
+  { OPTION_MASK_ISA_BMI2 | OPTION_MASK_ISA_64BIT, CODE_FOR_bmi2_pdep_di3, "__builtin_ia32_pdep_di", IX86_BUILTIN_PDEP64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
   { OPTION_MASK_ISA_BMI2, CODE_FOR_bmi2_pext_si3, "__builtin_ia32_pext_si", IX86_BUILTIN_PEXT32, UNKNOWN, (int) UINT_FTYPE_UINT_UINT },
-  { OPTION_MASK_ISA_BMI2, CODE_FOR_bmi2_pext_di3, "__builtin_ia32_pext_di", IX86_BUILTIN_PEXT64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
+  { OPTION_MASK_ISA_BMI2 | OPTION_MASK_ISA_64BIT, CODE_FOR_bmi2_pext_di3, "__builtin_ia32_pext_di", IX86_BUILTIN_PEXT64, UNKNOWN, (int) UINT64_FTYPE_UINT64_UINT64 },
 
   /* AVX512F */
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_si512_256si, "__builtin_ia32_si512_256si", IX86_BUILTIN_SI512_SI256, UNKNOWN, (int) V16SI_FTYPE_V8SI },
@@ -33948,6 +33987,17 @@
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_sqrtv8df2, "__builtin_ia32_sqrtpd512", IX86_BUILTIN_SQRTPD512, UNKNOWN, (int) V8DF_FTYPE_V8DF },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_sqrtv16sf2, "__builtin_ia32_sqrtps512", IX86_BUILTIN_SQRTPS_NR512, UNKNOWN, (int) V16SF_FTYPE_V16SF },
   { OPTION_MASK_ISA_AVX512ER, CODE_FOR_avx512er_exp2v16sf, "__builtin_ia32_exp2ps", IX86_BUILTIN_EXP2PS, UNKNOWN, (int) V16SF_FTYPE_V16SF },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundps512, "__builtin_ia32_floorps512", IX86_BUILTIN_FLOORPS512, (enum rtx_code) ROUND_FLOOR, (int) V16SF_FTYPE_V16SF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundps512, "__builtin_ia32_ceilps512", IX86_BUILTIN_CEILPS512, (enum rtx_code) ROUND_CEIL, (int) V16SF_FTYPE_V16SF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundps512, "__builtin_ia32_truncps512", IX86_BUILTIN_TRUNCPS512, (enum rtx_code) ROUND_TRUNC, (int) V16SF_FTYPE_V16SF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd512, "__builtin_ia32_floorpd512", IX86_BUILTIN_FLOORPD512, (enum rtx_code) ROUND_FLOOR, (int) V8DF_FTYPE_V8DF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd512, "__builtin_ia32_ceilpd512", IX86_BUILTIN_CEILPD512, (enum rtx_code) ROUND_CEIL, (int) V8DF_FTYPE_V8DF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd512, "__builtin_ia32_truncpd512", IX86_BUILTIN_TRUNCPD512, (enum rtx_code) ROUND_TRUNC, (int) V8DF_FTYPE_V8DF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_fix_notruncv16sfv16si, "__builtin_ia32_cvtps2dq512", IX86_BUILTIN_CVTPS2DQ512, UNKNOWN, (int) V16SI_FTYPE_V16SF },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_vec_pack_sfix_v8df, "__builtin_ia32_vec_pack_sfix512", IX86_BUILTIN_VEC_PACK_SFIX512, UNKNOWN, (int) V16SI_FTYPE_V8DF_V8DF },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_roundv16sf2_sfix, "__builtin_ia32_roundps_az_sfix512", IX86_BUILTIN_ROUNDPS_AZ_SFIX512, UNKNOWN, (int) V16SI_FTYPE_V16SF },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundps512_sfix, "__builtin_ia32_floorps_sfix512", IX86_BUILTIN_FLOORPS_SFIX512, (enum rtx_code) ROUND_FLOOR, (int) V16SI_FTYPE_V16SF_ROUND },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundps512_sfix, "__builtin_ia32_ceilps_sfix512", IX86_BUILTIN_CEILPS_SFIX512, (enum rtx_code) ROUND_CEIL, (int) V16SI_FTYPE_V16SF_ROUND },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_roundv8df2_vec_pack_sfix, "__builtin_ia32_roundpd_az_vec_pack_sfix512", IX86_BUILTIN_ROUNDPD_AZ_VEC_PACK_SFIX512, UNKNOWN, (int) V16SI_FTYPE_V8DF_V8DF },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd_vec_pack_sfix512, "__builtin_ia32_floorpd_vec_pack_sfix512", IX86_BUILTIN_FLOORPD_VEC_PACK_SFIX512, (enum rtx_code) ROUND_FLOOR, (int) V16SI_FTYPE_V8DF_V8DF_ROUND },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd_vec_pack_sfix512, "__builtin_ia32_ceilpd_vec_pack_sfix512", IX86_BUILTIN_CEILPD_VEC_PACK_SFIX512, (enum rtx_code) ROUND_CEIL, (int) V16SI_FTYPE_V8DF_V8DF_ROUND },
@@ -34864,7 +34914,7 @@
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_cvtpd2ps512_mask_round,  "__builtin_ia32_cvtpd2ps512_mask", IX86_BUILTIN_CVTPD2PS512, UNKNOWN, (int) V8SF_FTYPE_V8DF_V8SF_QI_INT },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_ufix_notruncv8dfv8si2_mask_round, "__builtin_ia32_cvtpd2udq512_mask", IX86_BUILTIN_CVTPD2UDQ512, UNKNOWN, (int) V8SI_FTYPE_V8DF_V8SI_QI_INT },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_vcvtph2ps512_mask_round,  "__builtin_ia32_vcvtph2ps512_mask", IX86_BUILTIN_CVTPH2PS512, UNKNOWN, (int) V16SF_FTYPE_V16HI_V16SF_HI_INT },
-  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_fix_notruncv16sfv16si_mask_round, "__builtin_ia32_cvtps2dq512_mask", IX86_BUILTIN_CVTPS2DQ512, UNKNOWN, (int) V16SI_FTYPE_V16SF_V16SI_HI_INT },
+  { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_fix_notruncv16sfv16si_mask_round, "__builtin_ia32_cvtps2dq512_mask", IX86_BUILTIN_CVTPS2DQ512_MASK, UNKNOWN, (int) V16SI_FTYPE_V16SF_V16SI_HI_INT },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_cvtps2pd512_mask_round, "__builtin_ia32_cvtps2pd512_mask", IX86_BUILTIN_CVTPS2PD512, UNKNOWN, (int) V8DF_FTYPE_V8SF_V8DF_QI_INT },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_ufix_notruncv16sfv16si_mask_round, "__builtin_ia32_cvtps2udq512_mask", IX86_BUILTIN_CVTPS2UDQ512, UNKNOWN, (int) V16SI_FTYPE_V16SF_V16SI_HI_INT },
   { OPTION_MASK_ISA_AVX512F, CODE_FOR_sse2_cvtsd2ss_round, "__builtin_ia32_cvtsd2ss_round", IX86_BUILTIN_CVTSD2SS_ROUND, UNKNOWN, (int) V4SF_FTYPE_V4SF_V2DF_INT },
@@ -38441,10 +38491,13 @@
     {
     case V2DF_FTYPE_V2DF_ROUND:
     case V4DF_FTYPE_V4DF_ROUND:
+    case V8DF_FTYPE_V8DF_ROUND:
     case V4SF_FTYPE_V4SF_ROUND:
     case V8SF_FTYPE_V8SF_ROUND:
+    case V16SF_FTYPE_V16SF_ROUND:
     case V4SI_FTYPE_V4SF_ROUND:
     case V8SI_FTYPE_V8SF_ROUND:
+    case V16SI_FTYPE_V16SF_ROUND:
       return ix86_expand_sse_round (d, exp, target);
     case V4SI_FTYPE_V2DF_V2DF_ROUND:
     case V8SI_FTYPE_V4DF_V4DF_ROUND:
@@ -38558,6 +38611,7 @@
     case V16SI_FTYPE_V8SI:
     case V16SF_FTYPE_V4SF:
     case V16SI_FTYPE_V4SI:
+    case V16SI_FTYPE_V16SF:
     case V16SF_FTYPE_V16SF:
     case V8DI_FTYPE_UQI:
     case V8DF_FTYPE_V4DF:
@@ -42263,6 +42317,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_FLOORPS_SFIX);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_FLOORPS_SFIX256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_FLOORPS_SFIX512);
 	}
       break;
 
@@ -42288,6 +42344,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_CEILPS_SFIX);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_CEILPS_SFIX256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_CEILPS_SFIX512);
 	}
       break;
 
@@ -42300,6 +42358,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_VEC_PACK_SFIX);
 	  else if (out_n == 8 && in_n == 4)
 	    return ix86_get_builtin (IX86_BUILTIN_VEC_PACK_SFIX256);
+	  else if (out_n == 16 && in_n == 8)
+	    return ix86_get_builtin (IX86_BUILTIN_VEC_PACK_SFIX512);
 	}
       if (out_mode == SImode && in_mode == SFmode)
 	{
@@ -42307,6 +42367,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_CVTPS2DQ);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_CVTPS2DQ256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_CVTPS2DQ512);
 	}
       break;
 
@@ -42332,6 +42394,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_ROUNDPS_AZ_SFIX);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_ROUNDPS_AZ_SFIX256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_ROUNDPS_AZ_SFIX512);
 	}
       break;
 
@@ -42346,6 +42410,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_FLOORPD);
 	  else if (out_n == 4 && in_n == 4)
 	    return ix86_get_builtin (IX86_BUILTIN_FLOORPD256);
+	  else if (out_n == 8 && in_n == 8)
+	    return ix86_get_builtin (IX86_BUILTIN_FLOORPD512);
 	}
       if (out_mode == SFmode && in_mode == SFmode)
 	{
@@ -42353,6 +42419,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_FLOORPS);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_FLOORPS256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_FLOORPS512);
 	}
       break;
 
@@ -42367,6 +42435,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_CEILPD);
 	  else if (out_n == 4 && in_n == 4)
 	    return ix86_get_builtin (IX86_BUILTIN_CEILPD256);
+	  else if (out_n == 8 && in_n == 8)
+	    return ix86_get_builtin (IX86_BUILTIN_CEILPD512);
 	}
       if (out_mode == SFmode && in_mode == SFmode)
 	{
@@ -42374,6 +42444,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_CEILPS);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_CEILPS256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_CEILPS512);
 	}
       break;
 
@@ -42388,6 +42460,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_TRUNCPD);
 	  else if (out_n == 4 && in_n == 4)
 	    return ix86_get_builtin (IX86_BUILTIN_TRUNCPD256);
+	  else if (out_n == 8 && in_n == 8)
+	    return ix86_get_builtin (IX86_BUILTIN_TRUNCPD512);
 	}
       if (out_mode == SFmode && in_mode == SFmode)
 	{
@@ -42395,6 +42469,8 @@
 	    return ix86_get_builtin (IX86_BUILTIN_TRUNCPS);
 	  else if (out_n == 8 && in_n == 8)
 	    return ix86_get_builtin (IX86_BUILTIN_TRUNCPS256);
+	  else if (out_n == 16 && in_n == 16)
+	    return ix86_get_builtin (IX86_BUILTIN_TRUNCPS512);
 	}
       break;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/i386.h gcc-6-20160721/gcc/config/i386/i386.h
--- gcc-6.1.0/gcc/config/i386/i386.h	2016-03-30 03:57:30.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/i386.h	2016-05-25 08:04:09.000000000 +0000
@@ -465,6 +465,8 @@
 	ix86_tune_features[X86_TUNE_SLOW_PSHUFB]
 #define TARGET_VECTOR_PARALLEL_EXECUTION \
 	ix86_tune_features[X86_TUNE_VECTOR_PARALLEL_EXECUTION]
+#define TARGET_AVOID_4BYTE_PREFIXES \
+	ix86_tune_features[X86_TUNE_AVOID_4BYTE_PREFIXES]
 #define TARGET_FUSE_CMP_AND_BRANCH_32 \
 	ix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH_32]
 #define TARGET_FUSE_CMP_AND_BRANCH_64 \
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/i386.md gcc-6-20160721/gcc/config/i386/i386.md
--- gcc-6.1.0/gcc/config/i386/i386.md	2016-04-15 13:35:12.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/i386.md	2016-06-16 09:29:24.000000000 +0000
@@ -9332,7 +9332,7 @@
 })
 
 (define_split
-  [(set (match_operand:SF 0 "register_operand")
+  [(set (match_operand:SF 0 "general_reg_operand")
 	(match_operator:SF 1 "absneg_operator" [(match_dup 0)]))
    (use (match_operand:V4SF 2))
    (clobber (reg:CC FLAGS_REG))]
@@ -9356,7 +9356,7 @@
 })
 
 (define_split
-  [(set (match_operand:DF 0 "register_operand")
+  [(set (match_operand:DF 0 "general_reg_operand")
 	(match_operator:DF 1 "absneg_operator" [(match_dup 0)]))
    (use (match_operand 2))
    (clobber (reg:CC FLAGS_REG))]
@@ -9394,7 +9394,7 @@
 })
 
 (define_split
-  [(set (match_operand:XF 0 "register_operand")
+  [(set (match_operand:XF 0 "general_reg_operand")
 	(match_operator:XF 1 "absneg_operator" [(match_dup 0)]))
    (use (match_operand 2))
    (clobber (reg:CC FLAGS_REG))]
@@ -11078,20 +11078,19 @@
 		   (const_int 1))
 	      (clobber (reg:CC FLAGS_REG))])]
   "TARGET_64BIT && !TARGET_USE_BT"
-  [(const_int 0)]
+  [(parallel [(set (match_dup 0)
+		   (ior:DI (match_dup 0) (match_dup 3)))
+	      (clobber (reg:CC FLAGS_REG))])]
 {
   int i = INTVAL (operands[1]);
 
-  rtx op1 = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);
+  operands[3] = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);
 
-  if (i >= 31)
+  if (!x86_64_immediate_operand (operands[3], DImode))
     {
-      emit_move_insn (operands[2], op1);
-      op1 = operands[2];
+      emit_move_insn (operands[2], operands[3]);
+      operands[3] = operands[2];
     }
-
-  emit_insn (gen_iordi3 (operands[0], operands[0], op1));
-  DONE;
 })
 
 (define_peephole2
@@ -11103,20 +11102,19 @@
 		   (const_int 0))
 	      (clobber (reg:CC FLAGS_REG))])]
   "TARGET_64BIT && !TARGET_USE_BT"
-  [(const_int 0)]
+  [(parallel [(set (match_dup 0)
+		   (and:DI (match_dup 0) (match_dup 3)))
+	      (clobber (reg:CC FLAGS_REG))])]
 {
   int i = INTVAL (operands[1]);
 
-  rtx op1 = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);
+  operands[3] = gen_int_mode (~(HOST_WIDE_INT_1U << i), DImode);
  
-  if (i >= 32)
+  if (!x86_64_immediate_operand (operands[3], DImode))
     {
-      emit_move_insn (operands[2], op1);
-      op1 = operands[2];
+      emit_move_insn (operands[2], operands[3]);
+      operands[3] = operands[2];
     }
-
-  emit_insn (gen_anddi3 (operands[0], operands[0], op1));
-  DONE;
 })
 
 (define_peephole2
@@ -11129,20 +11127,19 @@
 			(match_dup 0) (const_int 1) (match_dup 1))))
 	      (clobber (reg:CC FLAGS_REG))])]
   "TARGET_64BIT && !TARGET_USE_BT"
-  [(const_int 0)]
+  [(parallel [(set (match_dup 0)
+		   (xor:DI (match_dup 0) (match_dup 3)))
+	      (clobber (reg:CC FLAGS_REG))])]
 {
   int i = INTVAL (operands[1]);
 
-  rtx op1 = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);
+  operands[3] = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);
 
-  if (i >= 31)
+  if (!x86_64_immediate_operand (operands[3], DImode))
     {
-      emit_move_insn (operands[2], op1);
-      op1 = operands[2];
+      emit_move_insn (operands[2], operands[3]);
+      operands[3] = operands[2];
     }
-
-  emit_insn (gen_xordi3 (operands[0], operands[0], op1));
-  DONE;
 })
 
 (define_insn "*bt<mode>"
@@ -11859,8 +11856,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
-   && ! (GET_CODE (operands[4]) == CLOBBER
-	 && reg_mentioned_p (operands[3], operands[4]))"
+   && ! reg_set_p (operands[3], operands[4])"
   [(parallel [(set (match_dup 5) (match_dup 0))
 	      (match_dup 4)])
    (set (strict_low_part (match_dup 6))
@@ -11904,8 +11900,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
-   && ! (GET_CODE (operands[4]) == CLOBBER
-	 && reg_mentioned_p (operands[3], operands[4]))"
+   && ! reg_set_p (operands[3], operands[4])"
   [(parallel [(set (match_dup 5) (match_dup 0))
 	      (match_dup 4)])
    (set (strict_low_part (match_dup 6))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/predicates.md gcc-6-20160721/gcc/config/i386/predicates.md
--- gcc-6.1.0/gcc/config/i386/predicates.md	2016-01-05 20:19:16.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/predicates.md	2016-04-27 13:35:03.000000000 +0000
@@ -637,7 +637,7 @@
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "call_register_no_elim_operand")
        (ior (and (not (match_test "TARGET_X32"))
-		 (match_operand 0 "sibcall_memory_operand"))
+		 (match_operand 0 "memory_operand"))
 	    (and (match_test "TARGET_X32 && Pmode == DImode")
 		 (match_operand 0 "GOT_memory_operand")))))
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/i386/sse.md gcc-6-20160721/gcc/config/i386/sse.md
--- gcc-6.1.0/gcc/config/i386/sse.md	2016-04-15 15:53:01.000000000 +0000
+++ gcc-6-20160721/gcc/config/i386/sse.md	2016-06-08 13:06:24.000000000 +0000
@@ -4488,7 +4488,7 @@
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<sseinsnmode>")])
 
-(define_insn "<mask_codefor>avx512f_fix_notruncv16sfv16si<mask_name><round_name>"
+(define_insn "avx512f_fix_notruncv16sfv16si<mask_name><round_name>"
   [(set (match_operand:V16SI 0 "register_operand" "=v")
 	(unspec:V16SI
 	  [(match_operand:V16SF 1 "<round_nimm_predicate>" "<round_constraint>")]
@@ -5046,7 +5046,7 @@
    (set_attr "ssememalign" "64")
    (set_attr "mode" "V2DF")])
 
-(define_insn "<mask_codefor>avx512f_cvtpd2dq512<mask_name><round_name>"
+(define_insn "avx512f_cvtpd2dq512<mask_name><round_name>"
   [(set (match_operand:V8SI 0 "register_operand" "=v")
 	(unspec:V8SI
 	  [(match_operand:V8DF 1 "<round_nimm_predicate>" "<round_constraint>")]
@@ -6006,6 +6006,23 @@
   DONE;
 })
 
+(define_expand "avx512f_vec_pack_sfix_v8df"
+  [(match_operand:V16SI 0 "register_operand")
+   (match_operand:V8DF 1 "nonimmediate_operand")
+   (match_operand:V8DF 2 "nonimmediate_operand")]
+  "TARGET_AVX512F"
+{
+  rtx r1, r2;
+
+  r1 = gen_reg_rtx (V8SImode);
+  r2 = gen_reg_rtx (V8SImode);
+
+  emit_insn (gen_avx512f_cvtpd2dq512 (r1, operands[1]));
+  emit_insn (gen_avx512f_cvtpd2dq512 (r2, operands[2]));
+  emit_insn (gen_avx_vec_concatv16si (operands[0], r1, r2));
+  DONE;
+})
+
 (define_expand "vec_pack_sfix_v4df"
   [(match_operand:V8SI 0 "register_operand")
    (match_operand:V4DF 1 "nonimmediate_operand")
@@ -10566,22 +10583,23 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "<shift_insn><mode>3<mask_name>"
-  [(set (match_operand:VI48_AVX2 0 "register_operand" "=x,v")
+  [(set (match_operand:VI48_AVX2 0 "register_operand" "=x,x,v")
 	(any_lshift:VI48_AVX2
-	  (match_operand:VI48_AVX2 1 "register_operand" "0,v")
-	  (match_operand:SI 2 "nonmemory_operand" "xN,vN")))]
+	  (match_operand:VI48_AVX2 1 "register_operand" "0,x,v")
+	  (match_operand:SI 2 "nonmemory_operand" "xN,xN,vN")))]
   "TARGET_SSE2 && <mask_mode512bit_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
-   vp<vshift><ssemodesuffix>\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}"
-  [(set_attr "isa" "noavx,avx")
+   vp<vshift><ssemodesuffix>\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}
+   vp<vshift><ssemodesuffix>\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}"  
+  [(set_attr "isa" "noavx,avx,avx512bw")
    (set_attr "type" "sseishft")
    (set (attr "length_immediate")
      (if_then_else (match_operand 2 "const_int_operand")
        (const_string "1")
        (const_string "0")))
-   (set_attr "prefix_data16" "1,*")
-   (set_attr "prefix" "orig,vex")
+   (set_attr "prefix_data16" "1,*,*")
+   (set_attr "prefix" "orig,vex,evex")
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "<shift_insn><mode>3<mask_name>"
@@ -15246,13 +15264,25 @@
   DONE;
 })
 
-(define_expand "avx512f_roundpd512"
-  [(match_operand:V8DF 0 "register_operand")
-   (match_operand:V8DF 1 "nonimmediate_operand")
+(define_expand "avx512f_round<castmode>512"
+  [(match_operand:VF_512 0 "register_operand")
+   (match_operand:VF_512 1 "nonimmediate_operand")
+   (match_operand:SI 2 "const_0_to_15_operand")]
+  "TARGET_AVX512F"
+{
+  emit_insn (gen_avx512f_rndscale<mode> (operands[0], operands[1], operands[2]));
+  DONE;
+})
+
+(define_expand "avx512f_roundps512_sfix"
+  [(match_operand:V16SI 0 "register_operand")
+   (match_operand:V16SF 1 "nonimmediate_operand")
    (match_operand:SI 2 "const_0_to_15_operand")]
   "TARGET_AVX512F"
 {
-  emit_insn (gen_avx512f_rndscalev8df (operands[0], operands[1], operands[2]));
+  rtx tmp = gen_reg_rtx (V16SFmode);
+  emit_insn (gen_avx512f_rndscalev16sf (tmp, operands[1], operands[2]));
+  emit_insn (gen_fix_truncv16sfv16si2 (operands[0], tmp));
   DONE;
 })
 
@@ -15352,7 +15382,7 @@
 
 (define_expand "round<mode>2_sfix"
   [(match_operand:<sseintvecmode> 0 "register_operand")
-   (match_operand:VF1_128_256 1 "register_operand")]
+   (match_operand:VF1 1 "register_operand")]
   "TARGET_ROUND && !flag_trapping_math"
 {
   rtx tmp = gen_reg_rtx (<MODE>mode);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/microblaze/rtems.h gcc-6-20160721/gcc/config/microblaze/rtems.h
--- gcc-6.1.0/gcc/config/microblaze/rtems.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/microblaze/rtems.h	2016-05-10 07:00:22.000000000 +0000
@@ -23,3 +23,10 @@
   builtin_define( "__rtems__" );		\
   builtin_assert( "system=rtems" );		\
 } while (0)
+
+/* Redefine to include only items relevant for RTEMS */
+#undef LINK_SPEC
+#define LINK_SPEC "%{shared:-shared} -N -relax \
+  %{mbig-endian:-EB --oformat=elf32-microblaze} \
+  %{mlittle-endian:-EL --oformat=elf32-microblazeel} \
+  %{mxl-gp-opt:%{G*}} %{!mxl-gp-opt: -G 0}"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/nvptx/nvptx.c gcc-6-20160721/gcc/config/nvptx/nvptx.c
--- gcc-6.1.0/gcc/config/nvptx/nvptx.c	2016-03-21 15:31:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/nvptx/nvptx.c	2016-05-17 16:08:37.000000000 +0000
@@ -483,7 +483,7 @@
 static rtx
 nvptx_libcall_value (machine_mode mode, const_rtx)
 {
-  if (!cfun->machine->doing_call)
+  if (!cfun || !cfun->machine->doing_call)
     /* Pretend to return in a hard reg for early uses before pseudos can be
        generated.  */
     return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);
@@ -502,6 +502,7 @@
 
   if (outgoing)
     {
+      gcc_assert (cfun);
       cfun->machine->return_mode = mode;
       return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);
     }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/pa/pa.c gcc-6-20160721/gcc/config/pa/pa.c
--- gcc-6.1.0/gcc/config/pa/pa.c	2016-01-12 01:35:23.000000000 +0000
+++ gcc-6-20160721/gcc/config/pa/pa.c	2016-07-20 22:35:50.000000000 +0000
@@ -4541,63 +4541,78 @@
      lcla2 and load_offset_label_address insn patterns.  */
   rtx reg = gen_reg_rtx (SImode);
   rtx_code_label *label_rtx = gen_label_rtx ();
-  rtx begin_label_rtx;
+  rtx mcount = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, "_mcount"));
+  int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);
+  rtx arg_bytes, begin_label_rtx;
   rtx_insn *call_insn;
   char begin_label_name[16];
+  bool use_mcount_pcrel_call;
+
+  /* If we can reach _mcount with a pc-relative call, we can optimize
+     loading the address of the current function.  This requires linker
+     long branch stub support.  */
+  if (!TARGET_PORTABLE_RUNTIME
+      && !TARGET_LONG_CALLS
+      && (TARGET_SOM || flag_function_sections))
+    use_mcount_pcrel_call = TRUE;
+  else
+    use_mcount_pcrel_call = FALSE;
 
   ASM_GENERATE_INTERNAL_LABEL (begin_label_name, FUNC_BEGIN_PROLOG_LABEL,
 			       label_no);
   begin_label_rtx = gen_rtx_SYMBOL_REF (SImode, ggc_strdup (begin_label_name));
 
-  if (TARGET_64BIT)
-    emit_move_insn (arg_pointer_rtx,
-		    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,
-				  GEN_INT (64)));
-
   emit_move_insn (gen_rtx_REG (word_mode, 26), gen_rtx_REG (word_mode, 2));
 
-  /* The address of the function is loaded into %r25 with an instruction-
-     relative sequence that avoids the use of relocations.  The sequence
-     is split so that the load_offset_label_address instruction can
-     occupy the delay slot of the call to _mcount.  */
-  if (TARGET_PA_20)
-    emit_insn (gen_lcla2 (reg, label_rtx));
-  else
-    emit_insn (gen_lcla1 (reg, label_rtx));
-
-  emit_insn (gen_load_offset_label_address (gen_rtx_REG (SImode, 25), 
-					    reg, begin_label_rtx, label_rtx));
-
-#if !NO_DEFERRED_PROFILE_COUNTERS
-  {
-    rtx count_label_rtx, addr, r24;
-    char count_label_name[16];
-
-    funcdef_nos.safe_push (label_no);
-    ASM_GENERATE_INTERNAL_LABEL (count_label_name, "LP", label_no);
-    count_label_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (count_label_name));
-
-    addr = force_reg (Pmode, count_label_rtx);
-    r24 = gen_rtx_REG (Pmode, 24);
-    emit_move_insn (r24, addr);
-
-    call_insn =
-      emit_call_insn (gen_call (gen_rtx_MEM (Pmode, 
-					     gen_rtx_SYMBOL_REF (Pmode, 
-								 "_mcount")),
-				GEN_INT (TARGET_64BIT ? 24 : 12)));
-
-    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), r24);
-  }
-#else
-
-  call_insn =
-    emit_call_insn (gen_call (gen_rtx_MEM (Pmode, 
-					   gen_rtx_SYMBOL_REF (Pmode, 
-							       "_mcount")),
-			      GEN_INT (TARGET_64BIT ? 16 : 8)));
+  if (!use_mcount_pcrel_call)
+    {
+      /* The address of the function is loaded into %r25 with an instruction-
+	 relative sequence that avoids the use of relocations.  The sequence
+	 is split so that the load_offset_label_address instruction can
+	 occupy the delay slot of the call to _mcount.  */
+      if (TARGET_PA_20)
+	emit_insn (gen_lcla2 (reg, label_rtx));
+      else
+	emit_insn (gen_lcla1 (reg, label_rtx));
+
+      emit_insn (gen_load_offset_label_address (gen_rtx_REG (SImode, 25), 
+						reg,
+						begin_label_rtx,
+						label_rtx));
+    }
+
+  if (!NO_DEFERRED_PROFILE_COUNTERS)
+    {
+      rtx count_label_rtx, addr, r24;
+      char count_label_name[16];
+
+      funcdef_nos.safe_push (label_no);
+      ASM_GENERATE_INTERNAL_LABEL (count_label_name, "LP", label_no);
+      count_label_rtx = gen_rtx_SYMBOL_REF (Pmode,
+					    ggc_strdup (count_label_name));
+
+      addr = force_reg (Pmode, count_label_rtx);
+      r24 = gen_rtx_REG (Pmode, 24);
+      emit_move_insn (r24, addr);
+
+      arg_bytes = GEN_INT (TARGET_64BIT ? 24 : 12);
+      if (use_mcount_pcrel_call)
+	call_insn = emit_call_insn (gen_call_mcount (mcount, arg_bytes,
+						     begin_label_rtx));
+      else
+	call_insn = emit_call_insn (gen_call (mcount, arg_bytes));
 
-#endif
+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), r24);
+    }
+  else
+    {
+      arg_bytes = GEN_INT (TARGET_64BIT ? 16 : 8);
+      if (use_mcount_pcrel_call)
+	call_insn = emit_call_insn (gen_call_mcount (mcount, arg_bytes,
+						     begin_label_rtx));
+      else
+	call_insn = emit_call_insn (gen_call (mcount, arg_bytes));
+    }
 
   use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), gen_rtx_REG (SImode, 25));
   use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), gen_rtx_REG (SImode, 26));
@@ -4605,6 +4620,10 @@
   /* Indicate the _mcount call cannot throw, nor will it execute a
      non-local goto.  */
   make_reg_eh_region_note_nothrow_nononlocal (call_insn);
+
+  /* Allocate space for fixed arguments.  */
+  if (reg_parm_stack_space > crtl->outgoing_args_size)
+    crtl->outgoing_args_size = reg_parm_stack_space;
 }
 
 /* Fetch the return address for the frame COUNT steps up from
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/pa/pa.md gcc-6-20160721/gcc/config/pa/pa.md
--- gcc-6.1.0/gcc/config/pa/pa.md	2016-03-25 00:59:02.000000000 +0000
+++ gcc-6-20160721/gcc/config/pa/pa.md	2016-07-20 22:35:50.000000000 +0000
@@ -8216,6 +8216,170 @@
 	(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 12)]
 	      (symbol_ref "pa_attr_length_indirect_call (insn)")))])
 
+/* Expand special pc-relative call to _mcount.  */
+
+(define_expand "call_mcount"
+  [(parallel [(call (match_operand:SI 0 "" "")
+		    (match_operand 1 "" ""))
+	      (set (reg:SI 25)
+		   (plus:SI (reg:SI 2)
+			    (minus:SI (match_operand 2 "" "")
+				      (plus:SI (pc) (const_int 4)))))
+	      (clobber (reg:SI 2))])]
+  "!TARGET_PORTABLE_RUNTIME"
+  "
+{
+  rtx op = XEXP (operands[0], 0);
+  rtx nb = operands[1];
+  rtx lab = operands[2];
+
+  if (TARGET_64BIT)
+    {
+      rtx r4 = gen_rtx_REG (word_mode, 4);
+      emit_move_insn (arg_pointer_rtx,
+		      gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,
+				    GEN_INT (64)));
+      emit_call_insn (gen_call_mcount_64bit (op, nb, lab, r4));
+    }
+  else
+    {
+      if (flag_pic)
+	{
+	  rtx r4 = gen_rtx_REG (word_mode, 4);
+	  emit_call_insn (gen_call_mcount_pic (op, nb, lab, r4));
+	}
+      else
+	emit_call_insn (gen_call_mcount_nonpic (op, nb, lab));
+    }
+
+  DONE;
+}")
+
+(define_insn "call_mcount_nonpic"
+  [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+	 (match_operand 1 "" "i"))
+   (set (reg:SI 25)
+	(plus:SI (reg:SI 2)
+		 (minus:SI (match_operand 2 "" "")
+			   (plus:SI (pc) (const_int 4)))))
+   (clobber (reg:SI 2))]
+  "!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT"
+  "*
+{
+  pa_output_arg_descriptor (insn);
+  return \"{bl|b,l} %0,%%r2\;ldo %2-.-4(%%r2),%%r25\";
+}"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "call_mcount_pic"
+  [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+	 (match_operand 1 "" "i"))
+   (set (reg:SI 25)
+	(plus:SI (reg:SI 2)
+		 (minus:SI (match_operand 2 "" "")
+			   (plus:SI (pc) (const_int 4)))))
+   (clobber (reg:SI 2))
+   (clobber (match_operand 3))
+   (use (reg:SI 19))]
+  "!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT"
+  "#")
+
+(define_split
+  [(parallel [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+		    (match_operand 1 "" ""))
+	      (set (reg:SI 25)
+		   (plus:SI (reg:SI 2)
+			    (minus:SI (match_operand 2 "" "")
+				      (plus:SI (pc) (const_int 4)))))
+	      (clobber (reg:SI 2))
+	      (clobber (match_operand 3))
+	      (use (reg:SI 19))])]
+  "!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed"
+  [(set (match_dup 3) (reg:SI 19))
+   (parallel [(call (mem:SI (match_dup 0))
+		    (match_dup 1))
+	      (set (reg:SI 25)
+		   (plus:SI (reg:SI 2)
+			    (minus:SI (match_dup 2)
+				      (plus:SI (pc) (const_int 4)))))
+	      (clobber (reg:SI 2))
+	      (use (reg:SI 19))])
+   (set (reg:SI 19) (match_dup 3))]
+  "")
+
+(define_insn "*call_mcount_pic_post_reload"
+  [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+	 (match_operand 1 "" "i"))
+   (set (reg:SI 25)
+	(plus:SI (reg:SI 2)
+		 (minus:SI (match_operand 2 "" "")
+			   (plus:SI (pc) (const_int 4)))))
+   (clobber (reg:SI 2))
+   (use (reg:SI 19))]
+  "!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT"
+  "*
+{
+  pa_output_arg_descriptor (insn);
+  return \"{bl|b,l} %0,%%r2\;ldo %2-.-4(%%r2),%%r25\";
+}"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "call_mcount_64bit"
+  [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+	 (match_operand 1 "" "i"))
+   (set (reg:SI 25)
+	(plus:SI (reg:SI 2)
+		 (minus:SI (match_operand 2 "" "")
+			   (plus:SI (pc) (const_int 4)))))
+   (clobber (reg:DI 2))
+   (clobber (match_operand 3))
+   (use (reg:DI 27))
+   (use (reg:DI 29))]
+  "TARGET_64BIT"
+  "#")
+
+(define_split
+  [(parallel [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+		    (match_operand 1 "" ""))
+	      (set (reg:SI 25)
+		   (plus:SI (reg:SI 2)
+			    (minus:SI (match_operand 2 "" "")
+				      (plus:SI (pc) (const_int 4)))))
+	      (clobber (reg:DI 2))
+	      (clobber (match_operand 3))
+	      (use (reg:DI 27))
+	      (use (reg:DI 29))])]
+  "TARGET_64BIT && reload_completed"
+  [(set (match_dup 3) (reg:DI 27))
+   (parallel [(call (mem:SI (match_dup 0))
+		    (match_dup 1))
+	      (set (reg:SI 25)
+		   (plus:SI (reg:SI 2)
+			    (minus:SI (match_dup 2)
+				      (plus:SI (pc) (const_int 4)))))
+	      (clobber (reg:DI 2))
+	      (use (reg:DI 27))
+	      (use (reg:DI 29))])
+   (set (reg:DI 27) (match_dup 3))]
+  "")
+
+(define_insn "*call_mcount_64bit_post_reload"
+  [(call (mem:SI (match_operand 0 "call_operand_address" ""))
+	 (match_operand 1 "" "i"))
+   (set (reg:SI 25)
+	(plus:SI (reg:SI 2)
+		 (minus:SI (match_operand 2 "" "")
+			   (plus:SI (pc) (const_int 4)))))
+   (clobber (reg:DI 2))
+   (use (reg:DI 27))
+   (use (reg:DI 29))]
+  "TARGET_64BIT"
+  "{bl|b,l} %0,%%r2\;ldo %2-.-4(%%r2),%%r25"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
 ;; Call subroutine returning any type.
 
 (define_expand "untyped_call"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/40x.md gcc-6-20160721/gcc/config/rs6000/40x.md
--- gcc-6.1.0/gcc/config/rs6000/40x.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/40x.md	2016-07-05 19:19:42.000000000 +0000
@@ -119,6 +119,6 @@
   "bpu_40x")
 
 (define_insn_reservation "ppc405-float" 11
-  (and (eq_attr "type" "fpload,fpstore,fpcompare,fp,dmul,sdiv,ddiv")
+  (and (eq_attr "type" "fpload,fpstore,fpcompare,fp,fpsimple,dmul,sdiv,ddiv")
        (eq_attr "cpu" "ppc405"))
   "fpu_405*10")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/440.md gcc-6-20160721/gcc/config/rs6000/440.md
--- gcc-6.1.0/gcc/config/rs6000/440.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/440.md	2016-07-05 19:19:42.000000000 +0000
@@ -107,7 +107,7 @@
   "ppc440_issue,ppc440_f_pipe+ppc440_i_pipe")
 
 (define_insn_reservation "ppc440-fp" 5
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "ppc440"))
   "ppc440_issue,ppc440_f_pipe")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/476.md gcc-6-20160721/gcc/config/rs6000/476.md
--- gcc-6.1.0/gcc/config/rs6000/476.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/476.md	2016-07-05 19:19:42.000000000 +0000
@@ -124,7 +124,7 @@
    ppc476_f_pipe+ppc476_i_pipe")
 
 (define_insn_reservation "ppc476-fp" 6
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "ppc476"))
   "ppc476_issue_fp,\
    ppc476_f_pipe")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/601.md gcc-6-20160721/gcc/config/rs6000/601.md
--- gcc-6.1.0/gcc/config/rs6000/601.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/601.md	2016-07-05 19:19:42.000000000 +0000
@@ -86,7 +86,7 @@
   "(fpu_ppc601+iu_ppc601*2),nothing*2,bpu_ppc601")
 
 (define_insn_reservation "ppc601-fp" 4
-  (and (eq_attr "type" "fp")
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "ppc601"))
   "fpu_ppc601")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/603.md gcc-6-20160721/gcc/config/rs6000/603.md
--- gcc-6.1.0/gcc/config/rs6000/603.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/603.md	2016-07-05 19:19:42.000000000 +0000
@@ -105,7 +105,7 @@
   "(fpu_603+iu_603*2),bpu_603")
 
 (define_insn_reservation "ppc603-fp" 3
-  (and (eq_attr "type" "fp")
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "ppc603"))
   "fpu_603")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/6xx.md gcc-6-20160721/gcc/config/rs6000/6xx.md
--- gcc-6.1.0/gcc/config/rs6000/6xx.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/6xx.md	2016-07-05 19:19:42.000000000 +0000
@@ -160,7 +160,7 @@
   "fpu_6xx")
 
 (define_insn_reservation "ppc604-fp" 3
-  (and (eq_attr "type" "fp")
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "ppc604,ppc604e,ppc620"))
   "fpu_6xx")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/7450.md gcc-6-20160721/gcc/config/rs6000/7450.md
--- gcc-6.1.0/gcc/config/rs6000/7450.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/7450.md	2016-07-05 19:19:42.000000000 +0000
@@ -120,7 +120,7 @@
   "ppc7450_du,fpu_7450")
 
 (define_insn_reservation "ppc7450-fp" 5
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "ppc7450"))
   "ppc7450_du,fpu_7450")
 
@@ -162,7 +162,7 @@
 
 ;; Altivec
 (define_insn_reservation "ppc7450-vecsimple" 1
-  (and (eq_attr "type" "vecsimple")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove")
        (eq_attr "cpu" "ppc7450"))
   "ppc7450_du,ppc7450_vec_du,vecsmpl_7450")
 
@@ -172,7 +172,7 @@
   "ppc7450_du,ppc7450_vec_du,veccmplx_7450")
 
 (define_insn_reservation "ppc7450-veccmp" 2
-  (and (eq_attr "type" "veccmp")
+  (and (eq_attr "type" "veccmp,veccmpfx")
        (eq_attr "cpu" "ppc7450"))
   "ppc7450_du,ppc7450_vec_du,veccmplx_7450")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/7xx.md gcc-6-20160721/gcc/config/rs6000/7xx.md
--- gcc-6.1.0/gcc/config/rs6000/7xx.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/7xx.md	2016-07-05 19:19:42.000000000 +0000
@@ -113,7 +113,7 @@
   "ppc750_du,fpu_7xx")
 
 (define_insn_reservation "ppc750-fp" 3
-  (and (eq_attr "type" "fp")
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "ppc750,ppc7400"))
   "ppc750_du,fpu_7xx")
 
@@ -165,7 +165,7 @@
 
 ;; Altivec
 (define_insn_reservation "ppc7400-vecsimple" 1
-  (and (eq_attr "type" "vecsimple,veccmp")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove,veccmp,veccmpfx")
        (eq_attr "cpu" "ppc7400"))
   "ppc750_du,ppc7400_vec_du,veccmplx_7xx")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/8540.md gcc-6-20160721/gcc/config/rs6000/8540.md
--- gcc-6.1.0/gcc/config/rs6000/8540.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/8540.md	2016-07-05 19:19:42.000000000 +0000
@@ -190,7 +190,7 @@
 
 ;; Simple vector
 (define_insn_reservation "ppc8540_simple_vector" 1
-  (and (eq_attr "type" "vecsimple")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove")
        (eq_attr "cpu" "ppc8540,ppc8548"))
   "ppc8540_decode,ppc8540_issue+ppc8540_su1_stage0+ppc8540_retire")
 
@@ -202,7 +202,7 @@
 
 ;; Vector compare
 (define_insn_reservation "ppc8540_vector_compare" 1
-  (and (eq_attr "type" "veccmp")
+  (and (eq_attr "type" "veccmp,veccmpfx")
        (eq_attr "cpu" "ppc8540,ppc8548"))
   "ppc8540_decode,ppc8540_issue+ppc8540_su1_stage0+ppc8540_retire")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/a2.md gcc-6-20160721/gcc/config/rs6000/a2.md
--- gcc-6.1.0/gcc/config/rs6000/a2.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/a2.md	2016-07-05 19:19:42.000000000 +0000
@@ -81,7 +81,7 @@
 
 ;; D.8.1
 (define_insn_reservation "ppca2-fp" 6
-  (and (eq_attr "type" "fp")     	   ;; Ignore fpsimple insn types (SPE only).
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "ppca2"))
   "axu")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/altivec.h gcc-6-20160721/gcc/config/rs6000/altivec.h
--- gcc-6.1.0/gcc/config/rs6000/altivec.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/altivec.h	2016-07-01 15:08:18.000000000 +0000
@@ -327,8 +327,8 @@
 #define vec_sqrt __builtin_vec_sqrt
 #define vec_vsx_ld __builtin_vec_vsx_ld
 #define vec_vsx_st __builtin_vec_vsx_st
-#define vec_xl __builtin_vec_vsx_ld
-#define vec_xst __builtin_vec_vsx_st
+#define vec_xl __builtin_vec_xl
+#define vec_xst __builtin_vec_xst
 
 /* Note, xxsldi and xxpermdi were added as __builtin_vsx_<xxx> functions
    instead of __builtin_vec_<xxx>  */
@@ -384,6 +384,31 @@
 #define vec_vupklsw __builtin_vec_vupklsw
 #endif
 
+#ifdef _ARCH_PWR9
+/* Vector additions added in ISA 3.0.  */
+#define vec_vctz __builtin_vec_vctz
+#define vec_cntlz __builtin_vec_vctz
+#define vec_vctzb __builtin_vec_vctzb
+#define vec_vctzd __builtin_vec_vctzd
+#define vec_vctzh __builtin_vec_vctzh
+#define vec_vctzw __builtin_vec_vctzw
+#define vec_vprtyb __builtin_vec_vprtyb
+#define vec_vprtybd __builtin_vec_vprtybd
+#define vec_vprtybw __builtin_vec_vprtybw
+
+#ifdef _ARCH_PPC64
+#define vec_vprtybq __builtin_vec_vprtybq
+#endif
+
+#define vec_slv __builtin_vec_vslv
+#define vec_srv __builtin_vec_vsrv
+
+#define vec_absd __builtin_vec_vadu
+#define vec_absdb __builtin_vec_vadub
+#define vec_absdh __builtin_vec_vaduh
+#define vec_absdw __builtin_vec_vaduw
+#endif
+
 /* Predicates.
    For C++, we use templates in order to allow non-parenthesized arguments.
    For C, instead, we use macros since non-parenthesized arguments were
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/altivec.md gcc-6-20160721/gcc/config/rs6000/altivec.md
--- gcc-6.1.0/gcc/config/rs6000/altivec.md	2016-02-17 16:23:55.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/altivec.md	2016-07-12 18:12:11.000000000 +0000
@@ -58,6 +58,7 @@
    UNSPEC_VSUM2SWS
    UNSPEC_VSUMSWS
    UNSPEC_VPERM
+   UNSPEC_VPERMR
    UNSPEC_VPERM_UNS
    UNSPEC_VRFIN
    UNSPEC_VCFUX
@@ -73,6 +74,9 @@
    UNSPEC_VUNPACK_LO_SIGN_DIRECT
    UNSPEC_VUPKHPX
    UNSPEC_VUPKLPX
+   UNSPEC_DARN
+   UNSPEC_DARN_32
+   UNSPEC_DARN_RAW
    UNSPEC_DST
    UNSPEC_DSTT
    UNSPEC_DSTST
@@ -110,6 +114,9 @@
    UNSPEC_STVLXL
    UNSPEC_STVRX
    UNSPEC_STVRXL
+   UNSPEC_VSLV
+   UNSPEC_VSRV
+   UNSPEC_VADU
    UNSPEC_VMULWHUB
    UNSPEC_VMULWLUB
    UNSPEC_VMULWHSB
@@ -189,6 +196,13 @@
 			   (KF "FLOAT128_VECTOR_P (KFmode)")
 			   (TF "FLOAT128_VECTOR_P (TFmode)")])
 
+;; Specific iterator for parity which does not have a byte/half-word form, but
+;; does have a quad word form
+(define_mode_iterator VParity [V4SI
+			       V2DI
+			       V1TI
+			       (TI "TARGET_VSX_TIMODE")])
+
 (define_mode_attr VI_char [(V2DI "d") (V4SI "w") (V8HI "h") (V16QI "b")])
 (define_mode_attr VI_scalar [(V2DI "DI") (V4SI "SI") (V8HI "HI") (V16QI "QI")])
 (define_mode_attr VI_unit [(V16QI "VECTOR_UNIT_ALTIVEC_P (V16QImode)")
@@ -203,6 +217,9 @@
 (define_mode_attr VP_small_lc [(V2DI "v4si") (V4SI "v8hi") (V8HI "v16qi")])
 (define_mode_attr VU_char [(V2DI "w") (V4SI "h") (V8HI "b")])
 
+;; Vector negate
+(define_mode_iterator VNEG [V4SI V2DI])
+
 ;; Vector move instructions.
 (define_insn "*altivec_mov<mode>"
   [(set (match_operand:VM2 0 "nonimmediate_operand" "=Z,v,v,*Y,*r,*r,v,v,*r")
@@ -225,7 +242,7 @@
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "type" "vecstore,vecload,vecsimple,store,load,*,vecsimple,*,*")
+  [(set_attr "type" "vecstore,vecload,veclogical,store,load,*,veclogical,*,*")
    (set_attr "length" "4,4,4,20,20,20,4,8,32")])
 
 ;; Unlike other altivec moves, allow the GPRs, since a normal use of TImode
@@ -251,7 +268,7 @@
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "type" "vecstore,vecload,vecsimple,store,load,*,vecsimple,*")])
+  [(set_attr "type" "vecstore,vecload,veclogical,store,load,*,veclogical,*")])
 
 ;; Load up a vector with the most significant bit set by loading up -1 and
 ;; doing a shift left
@@ -586,7 +603,7 @@
 		(match_operand:VI2 2 "altivec_register_operand" "v")))]
   "<VI_unit>"
   "vcmpequ<VI_char> %0,%1,%2"
-  [(set_attr "type" "veccmp")])
+  [(set_attr "type" "veccmpfx")])
 
 (define_insn "*altivec_gt<mode>"
   [(set (match_operand:VI2 0 "altivec_register_operand" "=v")
@@ -594,7 +611,7 @@
 		(match_operand:VI2 2 "altivec_register_operand" "v")))]
   "<VI_unit>"
   "vcmpgts<VI_char> %0,%1,%2"
-  [(set_attr "type" "veccmp")])
+  [(set_attr "type" "veccmpfx")])
 
 (define_insn "*altivec_gtu<mode>"
   [(set (match_operand:VI2 0 "altivec_register_operand" "=v")
@@ -602,7 +619,7 @@
 		 (match_operand:VI2 2 "altivec_register_operand" "v")))]
   "<VI_unit>"
   "vcmpgtu<VI_char> %0,%1,%2"
-  [(set_attr "type" "veccmp")])
+  [(set_attr "type" "veccmpfx")])
 
 (define_insn "*altivec_eqv4sf"
   [(set (match_operand:V4SF 0 "altivec_register_operand" "=v")
@@ -637,7 +654,7 @@
 	 (match_operand:VM 3 "altivec_register_operand" "v")))]
   "VECTOR_MEM_ALTIVEC_P (<MODE>mode)"
   "vsel %0,%3,%2,%1"
-  [(set_attr "type" "vecperm")])
+  [(set_attr "type" "vecmove")])
 
 (define_insn "*altivec_vsel<mode>_uns"
   [(set (match_operand:VM 0 "altivec_register_operand" "=v")
@@ -648,7 +665,7 @@
 	 (match_operand:VM 3 "altivec_register_operand" "v")))]
   "VECTOR_MEM_ALTIVEC_P (<MODE>mode)"
   "vsel %0,%3,%2,%1"
-  [(set_attr "type" "vecperm")])
+  [(set_attr "type" "vecmove")])
 
 ;; Fused multiply add.
 
@@ -1617,6 +1634,24 @@
   "vslo %0,%1,%2"
   [(set_attr "type" "vecperm")])
 
+(define_insn "vslv"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+	(unspec:V16QI [(match_operand:V16QI 1 "register_operand" "v")
+		       (match_operand:V16QI 2 "register_operand" "v")]
+         UNSPEC_VSLV))]
+  "TARGET_P9_VECTOR"
+  "vslv %0,%1,%2"
+  [(set_attr "type" "vecsimple")])
+
+(define_insn "vsrv"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+	(unspec:V16QI [(match_operand:V16QI 1 "register_operand" "v")
+		       (match_operand:V16QI 2 "register_operand" "v")]
+         UNSPEC_VSRV))]
+  "TARGET_P9_VECTOR"
+  "vsrv %0,%1,%2"
+  [(set_attr "type" "vecsimple")])
+
 (define_insn "*altivec_vsl<VI_char>"
   [(set (match_operand:VI2 0 "register_operand" "=v")
         (ashift:VI2 (match_operand:VI2 1 "register_operand" "v")
@@ -1949,32 +1984,30 @@
 
 ;; Slightly prefer vperm, since the target does not overlap the source
 (define_insn "*altivec_vperm_<mode>_internal"
-  [(set (match_operand:VM 0 "register_operand" "=v,?wo,?&wo")
-	(unspec:VM [(match_operand:VM 1 "register_operand" "v,0,wo")
-		    (match_operand:VM 2 "register_operand" "v,wo,wo")
-		    (match_operand:V16QI 3 "register_operand" "v,wo,wo")]
+  [(set (match_operand:VM 0 "register_operand" "=v,?wo")
+	(unspec:VM [(match_operand:VM 1 "register_operand" "v,wo")
+		    (match_operand:VM 2 "register_operand" "v,0")
+		    (match_operand:V16QI 3 "register_operand" "v,wo")]
 		   UNSPEC_VPERM))]
   "TARGET_ALTIVEC"
   "@
    vperm %0,%1,%2,%3
-   xxperm %x0,%x2,%x3
-   xxlor %x0,%x1,%x1\t\t# xxperm fusion\;xxperm %x0,%x2,%x3"
+   xxperm %x0,%x1,%x3"
   [(set_attr "type" "vecperm")
-   (set_attr "length" "4,4,8")])
+   (set_attr "length" "4")])
 
 (define_insn "altivec_vperm_v8hiv16qi"
-  [(set (match_operand:V16QI 0 "register_operand" "=v,?wo,?&wo")
-	(unspec:V16QI [(match_operand:V8HI 1 "register_operand" "v,0,wo")
-   	               (match_operand:V8HI 2 "register_operand" "v,wo,wo")
-		       (match_operand:V16QI 3 "register_operand" "v,wo,wo")]
+  [(set (match_operand:V16QI 0 "register_operand" "=v,?wo")
+	(unspec:V16QI [(match_operand:V8HI 1 "register_operand" "v,wo")
+   	               (match_operand:V8HI 2 "register_operand" "v,0")
+		       (match_operand:V16QI 3 "register_operand" "v,wo")]
 		   UNSPEC_VPERM))]
   "TARGET_ALTIVEC"
   "@
    vperm %0,%1,%2,%3
-   xxperm %x0,%x2,%x3
-   xxlor %x0,%x1,%x1\t\t# xxperm fusion\;xxperm %x0,%x2,%x3"
+   xxperm %x0,%x1,%x3"
   [(set_attr "type" "vecperm")
-   (set_attr "length" "4,4,8")])
+   (set_attr "length" "4")])
 
 (define_expand "altivec_vperm_<mode>_uns"
   [(set (match_operand:VM 0 "register_operand" "")
@@ -1992,18 +2025,17 @@
 })
 
 (define_insn "*altivec_vperm_<mode>_uns_internal"
-  [(set (match_operand:VM 0 "register_operand" "=v,?wo,?&wo")
-	(unspec:VM [(match_operand:VM 1 "register_operand" "v,0,wo")
-		    (match_operand:VM 2 "register_operand" "v,wo,wo")
-		    (match_operand:V16QI 3 "register_operand" "v,wo,wo")]
+  [(set (match_operand:VM 0 "register_operand" "=v,?wo")
+	(unspec:VM [(match_operand:VM 1 "register_operand" "v,wo")
+		    (match_operand:VM 2 "register_operand" "v,0")
+		    (match_operand:V16QI 3 "register_operand" "v,wo")]
 		   UNSPEC_VPERM_UNS))]
   "TARGET_ALTIVEC"
   "@
    vperm %0,%1,%2,%3
-   xxperm %x0,%x2,%x3
-   xxlor %x0,%x1,%x1\t\t# xxperm fusion\;xxperm %x0,%x2,%x3"
+   xxperm %x0,%x1,%x3"
   [(set_attr "type" "vecperm")
-   (set_attr "length" "4,4,8")])
+   (set_attr "length" "4")])
 
 (define_expand "vec_permv16qi"
   [(set (match_operand:V16QI 0 "register_operand" "")
@@ -2032,6 +2064,19 @@
     FAIL;
 })
 
+(define_insn "*altivec_vpermr_<mode>_internal"
+  [(set (match_operand:VM 0 "register_operand" "=v,?wo")
+	(unspec:VM [(match_operand:VM 1 "register_operand" "v,wo")
+		    (match_operand:VM 2 "register_operand" "v,0")
+		    (match_operand:V16QI 3 "register_operand" "v,wo")]
+		   UNSPEC_VPERMR))]
+  "TARGET_P9_VECTOR"
+  "@
+   vpermr %0,%2,%1,%3
+   xxpermr %x0,%x1,%x3"
+  [(set_attr "type" "vecperm")
+   (set_attr "length" "4")])
+
 (define_insn "altivec_vrfip"		; ceil
   [(set (match_operand:V4SF 0 "register_operand" "=v")
         (unspec:V4SF [(match_operand:V4SF 1 "register_operand" "v")]
@@ -2238,7 +2283,7 @@
 		(match_dup 2)))]
   "<VI_unit>"
   "vcmpequ<VI_char>. %0,%1,%2"
-  [(set_attr "type" "veccmp")])
+  [(set_attr "type" "veccmpfx")])
 
 (define_insn "*altivec_vcmpgts<VI_char>_p"
   [(set (reg:CC 74)
@@ -2250,7 +2295,7 @@
 		(match_dup 2)))]
   "<VI_unit>"
   "vcmpgts<VI_char>. %0,%1,%2"
-  [(set_attr "type" "veccmp")])
+  [(set_attr "type" "veccmpfx")])
 
 (define_insn "*altivec_vcmpgtu<VI_char>_p"
   [(set (reg:CC 74)
@@ -2262,7 +2307,7 @@
 		 (match_dup 2)))]
   "<VI_unit>"
   "vcmpgtu<VI_char>. %0,%1,%2"
-  [(set_attr "type" "veccmp")])
+  [(set_attr "type" "veccmpfx")])
 
 (define_insn "*altivec_vcmpeqfp_p"
   [(set (reg:CC 74)
@@ -2690,20 +2735,28 @@
   DONE;
 })
 
+(define_insn "*p9_neg<mode>2"
+  [(set (match_operand:VNEG 0 "altivec_register_operand" "=v")
+	(neg:VNEG (match_operand:VNEG 1 "altivec_register_operand" "v")))]
+  "TARGET_P9_VECTOR"
+  "vneg<VI_char> %0,%1"
+  [(set_attr "type" "vecsimple")])
+
 (define_expand "neg<mode>2"
-  [(use (match_operand:VI 0 "register_operand" ""))
-   (use (match_operand:VI 1 "register_operand" ""))]
-  "TARGET_ALTIVEC"
-  "
+  [(set (match_operand:VI2 0 "register_operand" "")
+	(neg:VI2 (match_operand:VI2 1 "register_operand" "")))]
+  "<VI_unit>"
 {
-  rtx vzero;
+  if (!TARGET_P9_VECTOR || (<MODE>mode != V4SImode && <MODE>mode != V2DImode))
+    {
+      rtx vzero;
 
-  vzero = gen_reg_rtx (GET_MODE (operands[0]));
-  emit_insn (gen_altivec_vspltis<VI_char> (vzero, const0_rtx));
-  emit_insn (gen_sub<mode>3 (operands[0], vzero, operands[1])); 
-  
-  DONE;
-}")
+      vzero = gen_reg_rtx (GET_MODE (operands[0]));
+      emit_move_insn (vzero, CONST0_RTX (<MODE>mode));
+      emit_insn (gen_sub<mode>3 (operands[0], vzero, operands[1]));
+      DONE;
+    }
+})
 
 (define_expand "udot_prod<mode>"
   [(set (match_operand:V4SI 0 "register_operand" "=v")
@@ -2791,32 +2844,30 @@
   "")
 
 (define_insn "vperm_v8hiv4si"
-  [(set (match_operand:V4SI 0 "register_operand" "=v,?wo,?&wo")
-        (unspec:V4SI [(match_operand:V8HI 1 "register_operand" "v,0,wo")
-		      (match_operand:V4SI 2 "register_operand" "v,wo,wo")
-		      (match_operand:V16QI 3 "register_operand" "v,wo,wo")]
+  [(set (match_operand:V4SI 0 "register_operand" "=v,?wo")
+        (unspec:V4SI [(match_operand:V8HI 1 "register_operand" "v,wo")
+		      (match_operand:V4SI 2 "register_operand" "v,0")
+		      (match_operand:V16QI 3 "register_operand" "v,wo")]
                   UNSPEC_VPERMSI))]
   "TARGET_ALTIVEC"
   "@
    vperm %0,%1,%2,%3
-   xxperm %x0,%x2,%x3
-   xxlor %x0,%x1,%x1\t\t# xxperm fusion\;xxperm %x0,%x2,%x3"
+   xxperm %x0,%x1,%x3"
   [(set_attr "type" "vecperm")
-   (set_attr "length" "4,4,8")])
+   (set_attr "length" "4")])
 
 (define_insn "vperm_v16qiv8hi"
-  [(set (match_operand:V8HI 0 "register_operand" "=v,?wo,?&wo")
-        (unspec:V8HI [(match_operand:V16QI 1 "register_operand" "v,0,wo")
-		      (match_operand:V8HI 2 "register_operand" "v,wo,wo")
-		      (match_operand:V16QI 3 "register_operand" "v,wo,wo")]
+  [(set (match_operand:V8HI 0 "register_operand" "=v,?wo")
+        (unspec:V8HI [(match_operand:V16QI 1 "register_operand" "v,wo")
+		      (match_operand:V8HI 2 "register_operand" "v,0")
+		      (match_operand:V16QI 3 "register_operand" "v,wo")]
                   UNSPEC_VPERMHI))]
   "TARGET_ALTIVEC"
   "@
    vperm %0,%1,%2,%3
-   xxperm %x0,%x2,%x3
-   xxlor %x0,%x1,%x1\t\t# xxperm fusion\;xxperm %x0,%x2,%x3"
+   xxperm %x0,%x1,%x3"
   [(set_attr "type" "vecperm")
-   (set_attr "length" "4,4,8")])
+   (set_attr "length" "4")])
 
 
 (define_expand "vec_unpacku_hi_v16qi"
@@ -3353,7 +3404,7 @@
 }")
 
 
-;; Power8 vector instructions encoded as Altivec instructions
+;; Power8/power9 vector instructions encoded as Altivec instructions
 
 ;; Vector count leading zeros
 (define_insn "*p8v_clz<mode>2"
@@ -3364,6 +3415,33 @@
   [(set_attr "length" "4")
    (set_attr "type" "vecsimple")])
 
+;; Vector absolute difference unsigned
+(define_expand "vadu<mode>3"
+  [(set (match_operand:VI 0 "register_operand")
+        (unspec:VI [(match_operand:VI 1 "register_operand")
+		    (match_operand:VI 2 "register_operand")]
+         UNSPEC_VADU))]
+  "TARGET_P9_VECTOR")
+
+;; Vector absolute difference unsigned
+(define_insn "*p9_vadu<mode>3"
+  [(set (match_operand:VI 0 "register_operand" "=v")
+        (unspec:VI [(match_operand:VI 1 "register_operand" "v")
+		    (match_operand:VI 2 "register_operand" "v")]
+         UNSPEC_VADU))]
+  "TARGET_P9_VECTOR"
+  "vabsdu<wd> %0,%1,%2"
+  [(set_attr "type" "vecsimple")])
+
+;; Vector count trailing zeros
+(define_insn "*p9v_ctz<mode>2"
+  [(set (match_operand:VI2 0 "register_operand" "=v")
+	(ctz:VI2 (match_operand:VI2 1 "register_operand" "v")))]
+  "TARGET_P9_VECTOR"
+  "vctz<wd> %0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vecsimple")])
+
 ;; Vector population count
 (define_insn "*p8v_popcount<mode>2"
   [(set (match_operand:VI2 0 "register_operand" "=v")
@@ -3373,6 +3451,15 @@
   [(set_attr "length" "4")
    (set_attr "type" "vecsimple")])
 
+;; Vector parity
+(define_insn "*p9v_parity<mode>2"
+  [(set (match_operand:VParity 0 "register_operand" "=v")
+        (parity:VParity (match_operand:VParity 1 "register_operand" "v")))]
+  "TARGET_P9_VECTOR"
+  "vprtyb<wd> %0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vecsimple")])
+
 ;; Vector Gather Bits by Bytes by Doubleword
 (define_insn "p8v_vgbbd"
   [(set (match_operand:V16QI 0 "register_operand" "=v")
@@ -3540,6 +3627,27 @@
   [(set_attr "length" "4")
    (set_attr "type" "vecsimple")])
 
+(define_insn "darn_32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]
+  "TARGET_P9_MISC"
+  "darn %0,0"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn_raw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,2"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec:DI [(const_int 0)] UNSPEC_DARN))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,1"
+  [(set_attr "type" "integer")])
+
 (define_expand "bcd<bcd_add_sub>_<code>"
   [(parallel [(set (reg:CCFP 74)
 		   (compare:CCFP
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/cell.md gcc-6-20160721/gcc/config/rs6000/cell.md
--- gcc-6.1.0/gcc/config/rs6000/cell.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/cell.md	2016-07-05 19:19:42.000000000 +0000
@@ -306,7 +306,7 @@
 
 ; Basic FP latency is 10 cycles, thoughput is 1/cycle
 (define_insn_reservation "cell-fp" 10
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "cell"))
   "slot01,vsu1_cell,vsu1_cell*8")
 
@@ -329,7 +329,7 @@
 
 ; VMX
 (define_insn_reservation "cell-vecsimple" 4
-  (and (eq_attr "type" "vecsimple")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove")
        (eq_attr "cpu" "cell"))
   "slot01,vsu1_cell,vsu1_cell*2")
 
@@ -341,7 +341,7 @@
 
 ;; TODO: add support for recording instructions
 (define_insn_reservation "cell-veccmp" 4
-  (and (eq_attr "type" "veccmp")
+  (and (eq_attr "type" "veccmp,veccmpfx")
        (eq_attr "cpu" "cell"))
   "slot01,vsu1_cell,vsu1_cell*2")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/constraints.md gcc-6-20160721/gcc/config/rs6000/constraints.md
--- gcc-6.1.0/gcc/config/rs6000/constraints.md	2016-03-25 09:10:03.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/constraints.md	2016-06-09 23:28:23.000000000 +0000
@@ -140,6 +140,10 @@
   (and (match_code "const_int")
        (match_test "TARGET_VSX && (ival == VECTOR_ELEMENT_SCALAR_64BIT)")))
 
+(define_constraint "wE"
+  "Vector constant that can be loaded with the XXSPLTIB instruction."
+  (match_test "xxspltib_constant_nosplit (op, mode)"))
+
 ;; Extended fusion store
 (define_memory_constraint "wF"
   "Memory operand suitable for power9 fusion load/stores"
@@ -156,11 +160,26 @@
        (and (match_test "TARGET_DIRECT_MOVE_128")
 	    (match_test "(ival == VECTOR_ELEMENT_MFVSRLD_64BIT)"))))
 
+;; Generate the XXORC instruction to set a register to all 1's
+(define_constraint "wM"
+  "Match vector constant with all 1's if the XXLORC instruction is available"
+  (and (match_test "TARGET_P8_VECTOR")
+       (match_operand 0 "all_ones_constant")))
+
+;; ISA 3.0 vector d-form addresses
+(define_memory_constraint "wO"
+  "Memory operand suitable for the ISA 3.0 vector d-form instructions."
+  (match_operand 0 "vsx_quad_dform_memory_operand"))
+
 ;; Lq/stq validates the address for load/store quad
 (define_memory_constraint "wQ"
   "Memory operand suitable for the load/store quad instructions"
   (match_operand 0 "quad_memory_operand"))
 
+(define_constraint "wS"
+  "Vector constant that can be loaded with XXSPLTIB & sign extension."
+  (match_test "xxspltib_constant_split (op, mode)"))
+
 ;; Altivec style load/store that ignores the bottom bits of the address
 (define_memory_constraint "wZ"
   "Indexed or indirect memory operand, ignoring the bottom 4 bits"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/crypto.md gcc-6-20160721/gcc/config/rs6000/crypto.md
--- gcc-6.1.0/gcc/config/rs6000/crypto.md	2016-02-05 15:25:39.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/crypto.md	2016-07-06 02:31:08.000000000 +0000
@@ -107,4 +107,4 @@
 			UNSPEC_VSHASIGMA))]
   "TARGET_CRYPTO"
   "vshasigma<CR_char> %0,%1,%2,%3"
-  [(set_attr "type" "crypto")])
+  [(set_attr "type" "vecsimple")])
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/dfp.md gcc-6-20160721/gcc/config/rs6000/dfp.md
--- gcc-6.1.0/gcc/config/rs6000/dfp.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/dfp.md	2016-07-07 19:42:07.000000000 +0000
@@ -58,7 +58,7 @@
 	(float_extend:DD (match_operand:SD 1 "gpc_reg_operand" "f")))]
   "TARGET_DFP"
   "dctdp %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_expand "extendsdtd2"
   [(set (match_operand:TD 0 "gpc_reg_operand" "=d")
@@ -76,7 +76,7 @@
 	(float_truncate:SD (match_operand:DD 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "drsp %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_expand "negdd2"
   [(set (match_operand:DD 0 "gpc_reg_operand" "")
@@ -89,7 +89,7 @@
 	(neg:DD (match_operand:DD 1 "gpc_reg_operand" "d")))]
   "TARGET_HARD_FLOAT && TARGET_FPRS"
   "fneg %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "fpsimple")])
 
 (define_expand "absdd2"
   [(set (match_operand:DD 0 "gpc_reg_operand" "")
@@ -102,14 +102,14 @@
 	(abs:DD (match_operand:DD 1 "gpc_reg_operand" "d")))]
   "TARGET_HARD_FLOAT && TARGET_FPRS"
   "fabs %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "fpsimple")])
 
 (define_insn "*nabsdd2_fpr"
   [(set (match_operand:DD 0 "gpc_reg_operand" "=d")
 	(neg:DD (abs:DD (match_operand:DD 1 "gpc_reg_operand" "d"))))]
   "TARGET_HARD_FLOAT && TARGET_FPRS"
   "fnabs %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "fpsimple")])
 
 (define_expand "negtd2"
   [(set (match_operand:TD 0 "gpc_reg_operand" "")
@@ -124,7 +124,7 @@
   "@
    fneg %0,%1
    fneg %0,%1\;fmr %L0,%L1"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "length" "4,8")])
 
 (define_expand "abstd2"
@@ -140,7 +140,7 @@
   "@
    fabs %0,%1
    fabs %0,%1\;fmr %L0,%L1"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "length" "4,8")])
 
 (define_insn "*nabstd2_fpr"
@@ -150,7 +150,7 @@
   "@
    fnabs %0,%1
    fnabs %0,%1\;fmr %L0,%L1"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "length" "4,8")])
 
 ;; Hardware support for decimal floating point operations.
@@ -160,7 +160,7 @@
 	(float_extend:TD (match_operand:DD 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dctqpq %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 ;; The result of drdpq is an even/odd register pair with the converted
 ;; value in the even register and zero in the odd register.
@@ -173,7 +173,7 @@
    (clobber (match_scratch:TD 2 "=d"))]
   "TARGET_DFP"
   "drdpq %2,%1\;fmr %0,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "adddd3"
   [(set (match_operand:DD 0 "gpc_reg_operand" "=d")
@@ -181,7 +181,7 @@
 		 (match_operand:DD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dadd %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "addtd3"
   [(set (match_operand:TD 0 "gpc_reg_operand" "=d")
@@ -189,7 +189,7 @@
 		 (match_operand:TD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "daddq %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "subdd3"
   [(set (match_operand:DD 0 "gpc_reg_operand" "=d")
@@ -197,7 +197,7 @@
 		  (match_operand:DD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dsub %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "subtd3"
   [(set (match_operand:TD 0 "gpc_reg_operand" "=d")
@@ -205,7 +205,7 @@
 		  (match_operand:TD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dsubq %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "muldd3"
   [(set (match_operand:DD 0 "gpc_reg_operand" "=d")
@@ -213,7 +213,7 @@
 		 (match_operand:DD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dmul %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "multd3"
   [(set (match_operand:TD 0 "gpc_reg_operand" "=d")
@@ -221,7 +221,7 @@
 		 (match_operand:TD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dmulq %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "divdd3"
   [(set (match_operand:DD 0 "gpc_reg_operand" "=d")
@@ -229,7 +229,7 @@
 		(match_operand:DD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "ddiv %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "divtd3"
   [(set (match_operand:TD 0 "gpc_reg_operand" "=d")
@@ -237,7 +237,7 @@
 		(match_operand:TD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "ddivq %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "*cmpdd_internal1"
   [(set (match_operand:CCFP 0 "cc_reg_operand" "=y")
@@ -245,7 +245,7 @@
 		      (match_operand:DD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dcmpu %0,%1,%2"
-  [(set_attr "type" "fpcompare")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "*cmptd_internal1"
   [(set (match_operand:CCFP 0 "cc_reg_operand" "=y")
@@ -253,21 +253,21 @@
 		      (match_operand:TD 2 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dcmpuq %0,%1,%2"
-  [(set_attr "type" "fpcompare")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "floatdidd2"
   [(set (match_operand:DD 0 "gpc_reg_operand" "=d")
 	(float:DD (match_operand:DI 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP && TARGET_POPCNTD"
   "dcffix %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "floatditd2"
   [(set (match_operand:TD 0 "gpc_reg_operand" "=d")
 	(float:TD (match_operand:DI 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dcffixq %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 ;; Convert a decimal64 to a decimal64 whose value is an integer.
 ;; This is the first stage of converting it to an integer type.
@@ -277,7 +277,7 @@
 	(fix:DD (match_operand:DD 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "drintn. 0,%0,%1,1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 ;; Convert a decimal64 whose value is an integer to an actual integer.
 ;; This is the second stage of converting decimal float to integer type.
@@ -287,7 +287,7 @@
 	(fix:DI (match_operand:DD 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dctfix %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 ;; Convert a decimal128 to a decimal128 whose value is an integer.
 ;; This is the first stage of converting it to an integer type.
@@ -297,7 +297,7 @@
 	(fix:TD (match_operand:TD 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "drintnq. 0,%0,%1,1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 ;; Convert a decimal128 whose value is an integer to an actual integer.
 ;; This is the second stage of converting decimal float to integer type.
@@ -307,7 +307,7 @@
 	(fix:DI (match_operand:TD 1 "gpc_reg_operand" "d")))]
   "TARGET_DFP"
   "dctfixq %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 
 ;; Decimal builtin support
@@ -318,8 +318,11 @@
    UNSPEC_DXEX
    UNSPEC_DIEX
    UNSPEC_DSCLI
+   UNSPEC_DTSTSFI
    UNSPEC_DSCRI])
 
+(define_code_iterator DFP_TEST [eq lt gt unordered])
+
 (define_mode_iterator D64_D128 [DD TD])
 
 (define_mode_attr dfp_suffix [(DD "")
@@ -332,7 +335,7 @@
 			 UNSPEC_DDEDPD))]
   "TARGET_DFP"
   "ddedpd<dfp_suffix> %1,%0,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "dfp_denbcd_<mode>"
   [(set (match_operand:D64_D128 0 "gpc_reg_operand" "=d")
@@ -341,7 +344,7 @@
 			 UNSPEC_DENBCD))]
   "TARGET_DFP"
   "denbcd<dfp_suffix> %1,%0,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "dfp_dxex_<mode>"
   [(set (match_operand:D64_D128 0 "gpc_reg_operand" "=d")
@@ -349,7 +352,7 @@
 			 UNSPEC_DXEX))]
   "TARGET_DFP"
   "dxex<dfp_suffix> %0,%1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "dfp_diex_<mode>"
   [(set (match_operand:D64_D128 0 "gpc_reg_operand" "=d")
@@ -358,6 +361,42 @@
 			 UNSPEC_DXEX))]
   "TARGET_DFP"
   "diex<dfp_suffix> %0,%1,%2"
+  [(set_attr "type" "dfp")])
+
+(define_expand "dfptstsfi_<code>_<mode>"
+  [(set (match_dup 3)
+	(compare:CCFP
+         (unspec:D64_D128
+	  [(match_operand:SI 1 "const_int_operand" "n")
+	   (match_operand:D64_D128 2 "gpc_reg_operand" "d")]
+	  UNSPEC_DTSTSFI)
+	 (match_dup 4)))
+   (set (match_operand:SI 0 "register_operand" "")
+   	(DFP_TEST:SI (match_dup 3)
+		     (const_int 0)))
+  ]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCFPmode);
+  operands[4] = const0_rtx;
+})
+
+(define_insn "*dfp_sgnfcnc_<mode>"
+  [(set (match_operand:CCFP 0 "" "=y")
+        (compare:CCFP
+	 (unspec:D64_D128 [(match_operand:SI 1 "const_int_operand" "n")
+	 	           (match_operand:D64_D128 2 "gpc_reg_operand" "d")]
+          UNSPEC_DTSTSFI)
+	 (match_operand:SI 3 "zero_constant" "j")))]
+  "TARGET_P9_MISC"
+{
+  /* If immediate operand is greater than 63, it will behave as if
+     the value had been 63.  The code generator does not support
+     immediate operand values greater than 63.  */
+  if (!(IN_RANGE (INTVAL (operands[1]), 0, 63)))
+    operands[1] = GEN_INT (63);
+  return "dtstsfi<dfp_suffix> %0,%1,%2";
+}
   [(set_attr "type" "fp")])
 
 (define_insn "dfp_dscli_<mode>"
@@ -367,7 +406,7 @@
 			 UNSPEC_DSCLI))]
   "TARGET_DFP"
   "dscli<dfp_suffix> %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
 
 (define_insn "dfp_dscri_<mode>"
   [(set (match_operand:D64_D128 0 "gpc_reg_operand" "=d")
@@ -376,4 +415,4 @@
 			 UNSPEC_DSCRI))]
   "TARGET_DFP"
   "dscri<dfp_suffix> %0,%1,%2"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "dfp")])
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/e300c2c3.md gcc-6-20160721/gcc/config/rs6000/e300c2c3.md
--- gcc-6.1.0/gcc/config/rs6000/e300c2c3.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/e300c2c3.md	2016-07-05 19:19:42.000000000 +0000
@@ -150,7 +150,7 @@
   "ppce300c3_decode,ppce300c3_issue+ppce300c3_fpu,nothing,ppce300c3_retire")
 
 (define_insn_reservation "ppce300c3_fp" 3
-  (and (eq_attr "type" "fp")
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "ppce300c3"))
   "ppce300c3_decode,ppce300c3_issue+ppce300c3_fpu,nothing,ppce300c3_retire")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/e6500.md gcc-6-20160721/gcc/config/rs6000/e6500.md
--- gcc-6.1.0/gcc/config/rs6000/e6500.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/e6500.md	2016-07-05 19:19:42.000000000 +0000
@@ -205,7 +205,7 @@
 
 ;; VSFX.
 (define_insn_reservation "e6500_vecsimple" 1
-  (and (eq_attr "type" "vecsimple,veccmp")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove,veccmp,veccmpfx")
        (eq_attr "cpu" "ppce6500"))
   "e6500_decode,e6500_vec")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/htm.md gcc-6-20160721/gcc/config/rs6000/htm.md
--- gcc-6.1.0/gcc/config/rs6000/htm.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/htm.md	2016-07-06 02:31:08.000000000 +0000
@@ -72,7 +72,7 @@
    (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort. %0"
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_expand "tabort<wd>c"
@@ -98,7 +98,7 @@
    (set (match_operand:BLK 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort<wd>c. %0,%1,%2"
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_expand "tabort<wd>ci"
@@ -124,7 +124,7 @@
    (set (match_operand:BLK 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort<wd>ci. %0,%1,%2"
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_expand "tbegin"
@@ -208,7 +208,7 @@
    (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "trechkpt."
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_expand "treclaim"
@@ -230,7 +230,7 @@
    (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "treclaim. %0"
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_expand "tsr"
@@ -252,7 +252,7 @@
    (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tsr. %0"
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_expand "ttest"
@@ -272,7 +272,7 @@
    (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabortwci. 0,1,0"
-  [(set_attr "type" "htm")
+  [(set_attr "type" "htmsimple")
    (set_attr "length" "4")])
 
 (define_insn "htm_mfspr_<mode>"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/mpc.md gcc-6-20160721/gcc/config/rs6000/mpc.md
--- gcc-6.1.0/gcc/config/rs6000/mpc.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/mpc.md	2016-07-05 19:19:42.000000000 +0000
@@ -81,7 +81,7 @@
   "fpu_mpc,bpu_mpc")
 
 (define_insn_reservation "mpccore-fp" 4
-  (and (eq_attr "type" "fp")
+  (and (eq_attr "type" "fp,fpsimple")
        (eq_attr "cpu" "mpccore"))
   "fpu_mpc*2")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/power4.md gcc-6-20160721/gcc/config/rs6000/power4.md
--- gcc-6.1.0/gcc/config/rs6000/power4.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/power4.md	2016-07-05 19:19:42.000000000 +0000
@@ -381,7 +381,7 @@
 
 ; Basic FP latency is 6 cycles
 (define_insn_reservation "power4-fp" 6
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "power4"))
   "fpq_power4")
 
@@ -410,7 +410,7 @@
 
 ; VMX
 (define_insn_reservation "power4-vecsimple" 2
-  (and (eq_attr "type" "vecsimple")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove")
        (eq_attr "cpu" "power4"))
   "vq_power4")
 
@@ -421,7 +421,7 @@
 
 ; vecfp compare
 (define_insn_reservation "power4-veccmp" 8
-  (and (eq_attr "type" "veccmp")
+  (and (eq_attr "type" "veccmp,veccmpfx")
        (eq_attr "cpu" "power4"))
   "vq_power4")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/power5.md gcc-6-20160721/gcc/config/rs6000/power5.md
--- gcc-6.1.0/gcc/config/rs6000/power5.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/power5.md	2016-07-05 19:19:42.000000000 +0000
@@ -322,7 +322,7 @@
 
 ; Basic FP latency is 6 cycles
 (define_insn_reservation "power5-fp" 6
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "power5"))
   "fpq_power5")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/power6.md gcc-6-20160721/gcc/config/rs6000/power6.md
--- gcc-6.1.0/gcc/config/rs6000/power6.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/power6.md	2016-07-06 02:31:08.000000000 +0000
@@ -500,7 +500,7 @@
 (define_bypass 9 "power6-mtcr" "power6-branch")
 
 (define_insn_reservation "power6-fp" 6
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul,dfp")
        (eq_attr "cpu" "power6"))
   "FPU_power6")
 
@@ -556,7 +556,7 @@
   "LSF_power6")
 
 (define_insn_reservation "power6-vecsimple" 3
-  (and (eq_attr "type" "vecsimple")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove")
        (eq_attr "cpu" "power6"))
   "FPU_power6")
 
@@ -568,7 +568,7 @@
 (define_bypass 4 "power6-vecsimple" "power6-vecstore" )
 
 (define_insn_reservation "power6-veccmp" 1
-  (and (eq_attr "type" "veccmp")
+  (and (eq_attr "type" "veccmp,veccmpfx")
        (eq_attr "cpu" "power6"))
   "FPU_power6")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/power7.md gcc-6-20160721/gcc/config/rs6000/power7.md
--- gcc-6.1.0/gcc/config/rs6000/power7.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/power7.md	2016-07-06 02:31:08.000000000 +0000
@@ -292,7 +292,7 @@
 
 ; VS Unit (includes FP/VSX/VMX/DFP)
 (define_insn_reservation "power7-fp" 6
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul,dfp")
        (eq_attr "cpu" "power7"))
   "DU_power7,VSU_power7")
 
@@ -324,7 +324,7 @@
   "DU_power7,VSU_power7")
 
 (define_insn_reservation "power7-vecsimple" 2
-  (and (eq_attr "type" "vecsimple,veccmp")
+  (and (eq_attr "type" "vecsimple,veclogical,vecmove,veccmp,veccmpfx")
        (eq_attr "cpu" "power7"))
   "DU_power7,vsu1_power7")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/power8.md gcc-6-20160721/gcc/config/rs6000/power8.md
--- gcc-6.1.0/gcc/config/rs6000/power8.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/power8.md	2016-07-06 02:31:08.000000000 +0000
@@ -317,7 +317,7 @@
 
 ; VS Unit (includes FP/VSX/VMX/DFP/Crypto)
 (define_insn_reservation "power8-fp" 6
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul,dfp")
        (eq_attr "cpu" "power8"))
   "DU_any_power8,VSU_power8")
 
@@ -350,7 +350,8 @@
   "DU_any_power8,VSU_power8")
 
 (define_insn_reservation "power8-vecsimple" 2
-  (and (eq_attr "type" "vecperm,vecsimple,veccmp")
+  (and (eq_attr "type" "vecperm,vecsimple,veclogical,vecmove,veccmp,
+			veccmpfx")
        (eq_attr "cpu" "power8"))
   "DU_any_power8,VSU_power8")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/power9.md gcc-6-20160721/gcc/config/rs6000/power9.md
--- gcc-6.1.0/gcc/config/rs6000/power9.md	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/power9.md	2016-07-06 02:31:08.000000000 +0000
@@ -0,0 +1,477 @@
+;; Scheduling description for IBM POWER9 processor.
+;; Copyright (C) 2016 Free Software Foundation, Inc.
+;;
+;; Contributed by Pat Haugen (pthaugen@us.ibm.com).
+
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_automaton "power9dsp,power9lsu,power9vsu,power9misc")
+
+(define_cpu_unit "lsu0_power9,lsu1_power9,lsu2_power9,lsu3_power9" "power9lsu")
+(define_cpu_unit "vsu0_power9,vsu1_power9,vsu2_power9,vsu3_power9" "power9vsu")
+; Two vector permute units, part of vsu
+(define_cpu_unit "prm0_power9,prm1_power9" "power9vsu")
+; Two fixed point divide units, not pipelined
+(define_cpu_unit "fx_div0_power9,fx_div1_power9" "power9misc")
+(define_cpu_unit "bru_power9,cryptu_power9,dfu_power9" "power9misc")
+
+(define_cpu_unit "x0_power9,x1_power9,xa0_power9,xa1_power9,
+		  x2_power9,x3_power9,xb0_power9,xb1_power9,
+		  br0_power9,br1_power9" "power9dsp")
+
+
+; Dispatch port reservations
+;
+; Power9 can dispatch a maximum of 6 iops per cycle with the following
+; general restrictions (other restrictions also apply):
+;   1) At most 2 iops per execution slice
+;   2) At most 2 iops to the branch unit
+; Note that insn position in a dispatch group of 6 insns does not infer which
+; execution slice the insn is routed to.  The units are used to infer the
+; conflicts that exist (i.e. an 'even' requirement will preclude dispatch
+; with 2 insns with 'superslice' requirement).
+
+; The xa0/xa1 units really represent the 3rd dispatch port for a superslice but
+; are listed as separate units to allow those insns that preclude its use to
+; still be scheduled two to a superslice while reserving the 3rd slot.  The
+; same applies for xb0/xb1.
+(define_reservation "DU_xa_power9" "xa0_power9+xa1_power9")
+(define_reservation "DU_xb_power9" "xb0_power9+xb1_power9")
+
+; Any execution slice dispatch
+(define_reservation "DU_any_power9"
+		    "x0_power9|x1_power9|DU_xa_power9|x2_power9|x3_power9|
+		     DU_xb_power9")
+
+; Even slice, actually takes even/odd slots
+(define_reservation "DU_even_power9" "x0_power9+x1_power9|x2_power9+x3_power9")
+
+; Slice plus 3rd slot
+(define_reservation "DU_slice_3_power9"
+		    "x0_power9+xa0_power9|x1_power9+xa1_power9|
+		     x2_power9+xb0_power9|x3_power9+xb1_power9")
+
+; Superslice
+(define_reservation "DU_super_power9"
+		    "x0_power9+x1_power9|x2_power9+x3_power9")
+
+; 2-way cracked
+(define_reservation "DU_C2_power9" "x0_power9+x1_power9|
+				    x1_power9+DU_xa_power9|
+				    x1_power9+x2_power9|
+				    DU_xa_power9+x2_power9|
+				    x2_power9+x3_power9|
+				    x3_power9+DU_xb_power9")
+
+; 2-way cracked plus 3rd slot
+(define_reservation "DU_C2_3_power9" "x0_power9+x1_power9+xa0_power9|
+				      x1_power9+x2_power9+xa0_power9|
+				      x1_power9+x2_power9+xb0_power9|
+				      x2_power9+x3_power9+xb0_power9")
+
+; 3-way cracked (consumes whole decode/dispatch cycle)
+(define_reservation "DU_C3_power9"
+		    "x0_power9+x1_power9+xa0_power9+xa1_power9+x2_power9+
+		     x3_power9+xb0_power9+xb1_power9+br0_power9+br1_power9")
+
+; Branch ports
+(define_reservation "DU_branch_power9" "br0_power9|br1_power9")
+
+
+; Execution unit reservations
+(define_reservation "LSU_power9"
+		    "lsu0_power9|lsu1_power9|lsu2_power9|lsu3_power9")
+
+(define_reservation "LSU_pair_power9"
+		    "lsu0_power9+lsu1_power9|lsu1_power9+lsu2_power9|
+		     lsu2_power9+lsu3_power9|lsu3_power9+lsu0_power9")
+
+(define_reservation "VSU_power9"
+		    "vsu0_power9|vsu1_power9|vsu2_power9|vsu3_power9")
+
+(define_reservation "VSU_super_power9"
+		    "vsu0_power9+vsu1_power9|vsu2_power9+vsu3_power9")
+
+(define_reservation "VSU_PRM_power9" "prm0_power9|prm1_power9")
+
+
+; LS Unit
+(define_insn_reservation "power9-load" 4
+  (and (eq_attr "type" "load")
+       (eq_attr "sign_extend" "no")
+       (eq_attr "update" "no")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,LSU_power9")
+
+(define_insn_reservation "power9-load-update" 4
+  (and (eq_attr "type" "load")
+       (eq_attr "sign_extend" "no")
+       (eq_attr "update" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_power9,LSU_power9+VSU_power9")
+
+(define_insn_reservation "power9-load-ext" 6
+  (and (eq_attr "type" "load")
+       (eq_attr "sign_extend" "yes")
+       (eq_attr "update" "no")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_power9,LSU_power9")
+
+(define_insn_reservation "power9-load-ext-update" 6
+  (and (eq_attr "type" "load")
+       (eq_attr "sign_extend" "yes")
+       (eq_attr "update" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_C3_power9,LSU_power9+VSU_power9")
+
+(define_insn_reservation "power9-fpload-double" 4
+  (and (eq_attr "type" "fpload")
+       (eq_attr "update" "no")
+       (eq_attr "size" "64")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,LSU_power9")
+
+(define_insn_reservation "power9-fpload-update-double" 4
+  (and (eq_attr "type" "fpload")
+       (eq_attr "update" "yes")
+       (eq_attr "size" "64")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_3_power9,LSU_power9+VSU_power9")
+
+; SFmode loads are cracked and have additional 2 cycles over DFmode
+(define_insn_reservation "power9-fpload-single" 6
+  (and (eq_attr "type" "fpload")
+       (eq_attr "update" "no")
+       (eq_attr "size" "32")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_3_power9,LSU_power9")
+
+(define_insn_reservation "power9-fpload-update-single" 6
+  (and (eq_attr "type" "fpload")
+       (eq_attr "update" "yes")
+       (eq_attr "size" "32")
+       (eq_attr "cpu" "power9"))
+  "DU_C3_power9,LSU_power9+VSU_power9")
+
+(define_insn_reservation "power9-vecload" 5
+  (and (eq_attr "type" "vecload")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,LSU_pair_power9")
+
+; Store data can issue 2 cycles after AGEN issue, 3 cycles for vector store
+(define_insn_reservation "power9-store" 0
+  (and (eq_attr "type" "store")
+       (eq_attr "update" "no")
+       (eq_attr "indexed" "no")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,LSU_power9")
+
+(define_insn_reservation "power9-store-indexed" 0
+  (and (eq_attr "type" "store")
+       (eq_attr "update" "no")
+       (eq_attr "indexed" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,LSU_power9")
+
+; Update forms have 2 cycle latency for updated addr reg
+(define_insn_reservation "power9-store-update" 2
+  (and (eq_attr "type" "store")
+       (eq_attr "update" "yes")
+       (eq_attr "indexed" "no")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_3_power9,LSU_power9+VSU_power9")
+
+; Update forms have 2 cycle latency for updated addr reg
+(define_insn_reservation "power9-store-update-indexed" 2
+  (and (eq_attr "type" "store")
+       (eq_attr "update" "yes")
+       (eq_attr "indexed" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_3_power9,LSU_power9+VSU_power9")
+
+(define_insn_reservation "power9-fpstore" 0
+  (and (eq_attr "type" "fpstore")
+       (eq_attr "update" "no")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,LSU_power9")
+
+; Update forms have 2 cycle latency for updated addr reg
+(define_insn_reservation "power9-fpstore-update" 2
+  (and (eq_attr "type" "fpstore")
+       (eq_attr "update" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_3_power9,LSU_power9+VSU_power9")
+
+(define_insn_reservation "power9-vecstore" 0
+  (and (eq_attr "type" "vecstore")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,LSU_pair_power9")
+
+(define_insn_reservation "power9-larx" 4
+  (and (eq_attr "type" "load_l")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,LSU_power9")
+
+(define_insn_reservation "power9-stcx" 2
+  (and (eq_attr "type" "store_c")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_3_power9,LSU_power9+VSU_power9")
+
+(define_insn_reservation "power9-sync" 4
+  (and (eq_attr "type" "sync,isync")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,LSU_power9")
+
+
+; VSU Execution Unit
+
+; Fixed point ops
+
+; Most ALU insns are simple 2 cycle, including record form
+(define_insn_reservation "power9-alu" 2
+  (and (ior (eq_attr "type" "add,cmp,exts,integer,logical,isel")
+	    (and (eq_attr "type" "insert,shift")
+		 (eq_attr "dot" "no")))
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+; Record form rotate/shift are cracked
+(define_insn_reservation "power9-cracked-alu" 2
+  (and (eq_attr "type" "insert,shift")
+       (eq_attr "dot" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_power9,VSU_power9")
+; 4 cycle CR latency
+(define_bypass 4 "power9-cracked-alu"
+		 "power9-crlogical,power9-mfcr,power9-mfcrf,power9-branch")
+
+(define_insn_reservation "power9-alu2" 3
+  (and (eq_attr "type" "cntlz,popcnt,trap")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+; Treat 'two' and 'three' types as 2 or 3 way cracked
+(define_insn_reservation "power9-two" 4
+  (and (eq_attr "type" "two")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_power9,VSU_power9")
+
+(define_insn_reservation "power9-three" 6
+  (and (eq_attr "type" "three")
+       (eq_attr "cpu" "power9"))
+  "DU_C3_power9,VSU_power9")
+
+(define_insn_reservation "power9-mul" 4
+  (and (eq_attr "type" "mul")
+       (eq_attr "dot" "no")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+(define_insn_reservation "power9-mul-compare" 4
+  (and (eq_attr "type" "mul")
+       (eq_attr "dot" "yes")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_power9,VSU_power9")
+; 6 cycle CR latency
+(define_bypass 6 "power9-mul-compare"
+		 "power9-crlogical,power9-mfcr,power9-mfcrf,power9-branch")
+
+; Fixed point divides reserve the divide units for a minimum of 8 cycles
+(define_insn_reservation "power9-idiv" 16
+  (and (eq_attr "type" "div")
+       (eq_attr "size" "32")
+       (eq_attr "cpu" "power9"))
+  "DU_even_power9,fx_div0_power9*8|fx_div1_power9*8")
+
+(define_insn_reservation "power9-ldiv" 24
+  (and (eq_attr "type" "div")
+       (eq_attr "size" "64")
+       (eq_attr "cpu" "power9"))
+  "DU_even_power9,fx_div0_power9*8|fx_div1_power9*8")
+
+(define_insn_reservation "power9-crlogical" 2
+  (and (eq_attr "type" "cr_logical,delayed_cr")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+(define_insn_reservation "power9-mfcrf" 2
+  (and (eq_attr "type" "mfcrf")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+(define_insn_reservation "power9-mfcr" 6
+  (and (eq_attr "type" "mfcr")
+       (eq_attr "cpu" "power9"))
+  "DU_C3_power9,VSU_power9")
+
+; Should differentiate between 1 cr field and > 1 since target of > 1 cr
+; is cracked
+(define_insn_reservation "power9-mtcr" 2
+  (and (eq_attr "type" "mtcr")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+; Move to LR/CTR are executed in VSU
+(define_insn_reservation "power9-mtjmpr" 5
+  (and (eq_attr "type" "mtjmpr")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+; Floating point/Vector ops
+(define_insn_reservation "power9-fpsimple" 2
+  (and (eq_attr "type" "fpsimple")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-fp" 7
+  (and (eq_attr "type" "fp,dmul")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-fpcompare" 3
+  (and (eq_attr "type" "fpcompare")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+; FP div/sqrt are executed in the VSU slices.  They are not pipelined wrt other
+; divide insns, but for the most part do not block pipelined ops.
+(define_insn_reservation "power9-sdiv" 22
+  (and (eq_attr "type" "sdiv")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-ddiv" 33
+  (and (eq_attr "type" "ddiv")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-sqrt" 26
+  (and (eq_attr "type" "ssqrt")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-dsqrt" 36
+  (and (eq_attr "type" "dsqrt")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-vec-2cyc" 2
+  (and (eq_attr "type" "vecmove,veclogical,vecexts,veccmpfx")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+(define_insn_reservation "power9-veccmp" 3
+  (and (eq_attr "type" "veccmp")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+(define_insn_reservation "power9-vecsimple" 3
+  (and (eq_attr "type" "vecsimple")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+(define_insn_reservation "power9-vecnormal" 7
+  (and (eq_attr "type" "vecfloat,vecdouble")
+       (eq_attr "size" "!128")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+; Quad-precision FP ops, execute in DFU
+(define_insn_reservation "power9-qp" 12
+  (and (eq_attr "type" "vecfloat,vecdouble")
+       (eq_attr "size" "128")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,dfu_power9")
+
+(define_insn_reservation "power9-vecperm" 3
+  (and (eq_attr "type" "vecperm")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_PRM_power9")
+
+(define_insn_reservation "power9-veccomplex" 7
+  (and (eq_attr "type" "veccomplex")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+(define_insn_reservation "power9-vecfdiv" 28
+  (and (eq_attr "type" "vecfdiv")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+(define_insn_reservation "power9-vecdiv" 32
+  (and (eq_attr "type" "vecdiv")
+       (eq_attr "size" "!128")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,VSU_super_power9")
+
+(define_insn_reservation "power9-qpdiv" 56
+  (and (eq_attr "type" "vecdiv")
+       (eq_attr "size" "128")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,dfu_power9")
+
+(define_insn_reservation "power9-mffgpr" 2
+  (and (eq_attr "type" "mffgpr")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+(define_insn_reservation "power9-mftgpr" 2
+  (and (eq_attr "type" "mftgpr")
+       (eq_attr "cpu" "power9"))
+  "DU_slice_3_power9,VSU_power9")
+
+
+; Branch Unit
+; Move from LR/CTR are executed in BRU but consume a writeback port from an
+; execution slice.
+(define_insn_reservation "power9-mfjmpr" 6
+  (and (eq_attr "type" "mfjmpr")
+       (eq_attr "cpu" "power9"))
+  "DU_branch_power9,bru_power9+VSU_power9")
+
+; Branch is 2 cycles
+(define_insn_reservation "power9-branch" 2
+  (and (eq_attr "type" "jmpreg,branch")
+       (eq_attr "cpu" "power9"))
+  "DU_branch_power9,bru_power9")
+
+
+; Crypto Unit
+(define_insn_reservation "power9-crypto" 6
+  (and (eq_attr "type" "crypto")
+       (eq_attr "cpu" "power9"))
+  "DU_super_power9,cryptu_power9")
+
+
+; HTM Unit
+(define_insn_reservation "power9-htm" 4
+  (and (eq_attr "type" "htm")
+       (eq_attr "cpu" "power9"))
+  "DU_C2_power9,LSU_power9")
+
+(define_insn_reservation "power9-htm-simple" 2
+  (and (eq_attr "type" "htmsimple")
+       (eq_attr "cpu" "power9"))
+  "DU_any_power9,VSU_power9")
+
+
+; DFP Unit
+(define_insn_reservation "power9-dfp" 12
+  (and (eq_attr "type" "dfp")
+       (eq_attr "cpu" "power9"))
+  "DU_even_power9,dfu_power9")
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/predicates.md gcc-6-20160721/gcc/config/rs6000/predicates.md
--- gcc-6.1.0/gcc/config/rs6000/predicates.md	2016-03-25 09:10:03.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/predicates.md	2016-07-01 17:56:54.000000000 +0000
@@ -572,6 +572,38 @@
     }
 })
 
+;; Return 1 if the operand is a CONST_VECTOR or VEC_DUPLICATE of a constant
+;; that can loaded with a XXSPLTIB instruction and then a VUPKHSB, VECSB2W or
+;; VECSB2D instruction.
+
+(define_predicate "xxspltib_constant_split"
+  (match_code "const_vector,vec_duplicate,const_int")
+{
+  int value = 256;
+  int num_insns = -1;
+
+  if (!xxspltib_constant_p (op, mode, &num_insns, &value))
+    return false;
+
+  return num_insns > 1;
+})
+
+
+;; Return 1 if the operand is a CONST_VECTOR that can loaded directly with a
+;; XXSPLTIB instruction.
+
+(define_predicate "xxspltib_constant_nosplit"
+  (match_code "const_vector,vec_duplicate,const_int")
+{
+  int value = 256;
+  int num_insns = -1;
+
+  if (!xxspltib_constant_p (op, mode, &num_insns, &value))
+    return false;
+
+  return num_insns == 1;
+})
+
 ;; Return 1 if the operand is a CONST_VECTOR and can be loaded into a
 ;; vector register without using memory.
 (define_predicate "easy_vector_constant"
@@ -590,7 +622,14 @@
 
   if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))
     {
-      if (zero_constant (op, mode))
+      int value = 256;
+      int num_insns = -1;
+
+      if (zero_constant (op, mode) || all_ones_constant (op, mode))
+	return true;
+
+      if (TARGET_P9_VECTOR
+          && xxspltib_constant_p (op, mode, &num_insns, &value))
 	return true;
 
       return easy_altivec_constant (op, mode);
@@ -669,6 +708,11 @@
   (and (match_code "const_int,const_double,const_wide_int,const_vector")
        (match_test "op == CONST0_RTX (mode)")))
 
+;; Return 1 if operand is constant -1 (scalars and vectors).
+(define_predicate "all_ones_constant"
+  (and (match_code "const_int,const_double,const_wide_int,const_vector")
+       (match_test "op == CONSTM1_RTX (mode) && !FLOAT_MODE_P (mode)")))
+
 ;; Return 1 if operand is 0.0.
 (define_predicate "zero_fp_constant"
   (and (match_code "const_double")
@@ -698,48 +742,25 @@
 (define_predicate "quad_memory_operand"
   (match_code "mem")
 {
-  rtx addr, op0, op1;
-  int ret;
-
   if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)
-    ret = 0;
-
-  else if (!memory_operand (op, mode))
-    ret = 0;
-
-  else if (GET_MODE_SIZE (GET_MODE (op)) != 16)
-    ret = 0;
-
-  else if (MEM_ALIGN (op) < 128)
-    ret = 0;
-
-  else
-    {
-      addr = XEXP (op, 0);
-      if (int_reg_operand (addr, Pmode))
-	ret = 1;
+    return false;
 
-      else if (GET_CODE (addr) != PLUS)
-	ret = 0;
+  if (GET_MODE_SIZE (mode) != 16 || !MEM_P (op) || MEM_ALIGN (op) < 128)
+    return false;
 
-      else
-	{
-	  op0 = XEXP (addr, 0);
-	  op1 = XEXP (addr, 1);
-	  ret = (int_reg_operand (op0, Pmode)
-		 && GET_CODE (op1) == CONST_INT
-		 && IN_RANGE (INTVAL (op1), -32768, 32767)
-		 && (INTVAL (op1) & 15) == 0);
-	}
-    }
+  return quad_address_p (XEXP (op, 0), mode, false);
+})
 
-  if (TARGET_DEBUG_ADDR)
-    {
-      fprintf (stderr, "\nquad_memory_operand, ret = %s\n", ret ? "true" : "false");
-      debug_rtx (op);
-    }
+;; Return 1 if the operand is suitable for load/store to vector registers with
+;; d-form addressing (register+offset), which was added in ISA 3.0.
+;; Unlike quad_memory_operand, we do not have to check for alignment.
+(define_predicate "vsx_quad_dform_memory_operand"
+  (match_code "mem")
+{
+  if (!TARGET_P9_DFORM_VECTOR || !MEM_P (op) || GET_MODE_SIZE (mode) != 16)
+    return false;
 
-  return ret;
+  return quad_address_p (XEXP (op, 0), mode, false);
 })
 
 ;; Return 1 if the operand is an indexed or indirect memory operand.
@@ -1054,6 +1075,10 @@
 	mode = V2DFmode;
       else if (mode == DImode)
 	mode = V2DImode;
+      else if (mode == SImode && TARGET_P9_VECTOR)
+	mode = V4SImode;
+      else if (mode == SFmode && TARGET_P9_VECTOR)
+	mode = V4SFmode;
       else
 	gcc_unreachable ();
       return memory_address_addr_space_p (mode, XEXP (op, 0),
@@ -1091,10 +1116,6 @@
 (define_special_predicate "equality_operator"
   (match_code "eq,ne"))
 
-;; Return true if operand is MIN or MAX operator.
-(define_predicate "min_max_operator"
-  (match_code "smin,smax,umin,umax"))
-
 ;; Return 1 if OP is a comparison operation that is valid for a branch
 ;; instruction.  We check the opcode against the mode of the CC value.
 ;; validate_condition_mode is an assertion.
@@ -1137,6 +1158,11 @@
   (and (match_operand 0 "branch_comparison_operator")
        (match_code "ne,le,ge,leu,geu,ordered")))
 
+;; Return 1 if OP is a comparison operator suitable for vector/scalar
+;; comparisons that generate a -1/0 mask.
+(define_predicate "fpmask_comparison_operator"
+  (match_code "eq,gt,ge"))
+
 ;; Return 1 if OP is a comparison operation that is valid for a branch
 ;; insn, which is true if the corresponding bit in the CC register is set.
 (define_predicate "branch_positive_comparison_operator"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000-builtin.def gcc-6-20160721/gcc/config/rs6000/rs6000-builtin.def
--- gcc-6.1.0/gcc/config/rs6000/rs6000-builtin.def	2016-01-20 20:30:24.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000-builtin.def	2016-07-08 18:06:16.000000000 +0000
@@ -24,6 +24,7 @@
    <http://www.gnu.org/licenses/>.  */
 
 /* Before including this file, some macros must be defined:
+   RS6000_BUILTIN_0 -- 0 arg builtins
    RS6000_BUILTIN_1 -- 1 arg builtins
    RS6000_BUILTIN_2 -- 2 arg builtins
    RS6000_BUILTIN_3 -- 3 arg builtins
@@ -43,6 +44,10 @@
 	ATTR	builtin attribute information.
 	ICODE	Insn code of the function that implents the builtin.  */
 
+#ifndef RS6000_BUILTIN_0
+  #error "RS6000_BUILTIN_0 is not defined."
+#endif
+
 #ifndef RS6000_BUILTIN_1
   #error "RS6000_BUILTIN_1 is not defined."
 #endif
@@ -637,6 +642,91 @@
 		     | RS6000_BTC_TERNARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+/* Miscellaneous builtins for instructions added in ISA 3.0.  These
+   instructions don't require either the DFP or VSX options, just the basic
+   ISA 3.0 enablement since they operate on general purpose registers.  */
+#define BU_P9_MISC_0(ENUM, NAME, ATTR, ICODE)                      \
+  RS6000_BUILTIN_0 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_SPECIAL),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9_MISC_1(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_1 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_UNARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+/* Miscellaneous builtins for instructions added in ISA 3.0.  These
+   instructions don't require either the DFP or VSX options, just the basic
+   ISA 3.0 enablement since they operate on general purpose registers,
+   and they require 64-bit addressing.  */
+#define BU_P9_64BIT_MISC_0(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_0 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_P9_MISC					\
+                     | RS6000_BTM_64BIT,		/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_SPECIAL),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+/* Miscellaneous builtins for decimal floating point instructions
+   added in ISA 3.0.  These instructions don't require the VSX
+   options, just the basic ISA 3.0 enablement since they operate on
+   general purpose registers.  */
+#define BU_P9_DFP_MISC_0(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_0 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_SPECIAL),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9_DFP_MISC_1(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_1 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_SPECIAL),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9_DFP_MISC_2(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_SPECIAL),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+/* Decimal floating point overloaded functions added in ISA 3.0 */
+#define BU_P9_DFP_OVERLOAD_1(ENUM, NAME)				\
+  RS6000_BUILTIN_1 (P9_BUILTIN_DFP_ ## ENUM,		/* ENUM */	\
+		    "__builtin_dfp_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_UNARY),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
+#define BU_P9_DFP_OVERLOAD_2(ENUM, NAME)				\
+  RS6000_BUILTIN_2 (P9_BUILTIN_DFP_ ## ENUM,		/* ENUM */	\
+		    "__builtin_dfp_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_BINARY),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
+#define BU_P9_DFP_OVERLOAD_3(ENUM, NAME)				\
+  RS6000_BUILTIN_3 (P9_BUILTIN_DFP_ ## ENUM,		/* ENUM */	\
+		    "__builtin_dfp_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_MISC,			/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_TERNARY),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
 /* 128-bit long double floating point builtins.  */
 #define BU_LDBL128_2(ENUM, NAME, ATTR, ICODE)				\
   RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
@@ -647,8 +737,94 @@
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+/* IEEE 128-bit floating-point builtins.  */
+#define BU_FLOAT128_2(ENUM, NAME, ATTR, ICODE)                          \
+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,              /* ENUM */      \
+		    "__builtin_" NAME,                  /* NAME */      \
+		    RS6000_BTM_FLOAT128,                /* MASK */      \
+		    (RS6000_BTC_ ## ATTR                /* ATTR */      \
+		     | RS6000_BTC_BINARY),                              \
+		    CODE_FOR_ ## ICODE)                 /* ICODE */
+
+#define BU_FLOAT128_1(ENUM, NAME, ATTR, ICODE)                          \
+  RS6000_BUILTIN_1 (MISC_BUILTIN_ ## ENUM,              /* ENUM */      \
+		    "__builtin_" NAME,                  /* NAME */      \
+		    RS6000_BTM_FLOAT128,                /* MASK */      \
+		    (RS6000_BTC_ ## ATTR                /* ATTR */      \
+		     | RS6000_BTC_UNARY),                               \
+		    CODE_FOR_ ## ICODE)                 /* ICODE */
+
+/* ISA 3.0 (power9) vector convenience macros.  */
+/* For the instructions that are encoded as altivec instructions use
+   __builtin_altivec_ as the builtin name.  */
+#define BU_P9V_AV_1(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_1 (P9V_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_altivec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_UNARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9V_AV_2(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_2 (P9V_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_altivec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_BINARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9V_AV_3(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_3 (P9V_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_altivec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_TERNARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9V_AV_P(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_P (P9V_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_altivec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_PREDICATE),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+/* For the instructions encoded as VSX instructions use __builtin_vsx as the
+   builtin name.  */
+#define BU_P9V_VSX_1(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_1 (P9V_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_vsx_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_UNARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_P9V_OVERLOAD_1(ENUM, NAME)					\
+  RS6000_BUILTIN_1 (P9V_BUILTIN_VEC_ ## ENUM,		/* ENUM */	\
+		    "__builtin_vec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_UNARY),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
+#define BU_P9V_OVERLOAD_2(ENUM, NAME)					\
+  RS6000_BUILTIN_2 (P9V_BUILTIN_VEC_ ## ENUM,		/* ENUM */	\
+		    "__builtin_vec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_BINARY),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
+#define BU_P9V_OVERLOAD_3(ENUM, NAME)					\
+  RS6000_BUILTIN_3 (P9V_BUILTIN_VEC_ ## ENUM,		/* ENUM */	\
+		    "__builtin_vec_" NAME,		/* NAME */	\
+		    RS6000_BTM_P9_VECTOR,		/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_TERNARY),				\
+		    CODE_FOR_nothing)			/* ICODE */
 #endif
 
+
 /* Insure 0 is not a legitimate index.  */
 BU_SPECIAL_X (RS6000_BUILTIN_NONE, NULL, 0, RS6000_BTC_MISC)
 
@@ -1391,13 +1567,25 @@
 BU_VSX_X (LXVW4X_V8HI,        "lxvw4x_v8hi",	MEM)
 BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	MEM)
 BU_VSX_X (STXSDX,	      "stxsdx",		MEM)
-BU_VSX_X (STXVD2X_V1TI,	      "stxsdx_v1ti",	MEM)
-BU_VSX_X (STXVD2X_V2DF,	      "stxsdx_v2df",	MEM)
-BU_VSX_X (STXVD2X_V2DI,	      "stxsdx_v2di",	MEM)
-BU_VSX_X (STXVW4X_V4SF,	      "stxsdx_v4sf",	MEM)
-BU_VSX_X (STXVW4X_V4SI,	      "stxsdx_v4si",	MEM)
-BU_VSX_X (STXVW4X_V8HI,	      "stxsdx_v8hi",	MEM)
-BU_VSX_X (STXVW4X_V16QI,      "stxsdx_v16qi",	MEM)
+BU_VSX_X (STXVD2X_V1TI,	      "stxvd2x_v1ti",	MEM)
+BU_VSX_X (STXVD2X_V2DF,	      "stxvd2x_v2df",	MEM)
+BU_VSX_X (STXVD2X_V2DI,	      "stxvd2x_v2di",	MEM)
+BU_VSX_X (STXVW4X_V4SF,	      "stxvw4x_v4sf",	MEM)
+BU_VSX_X (STXVW4X_V4SI,	      "stxvw4x_v4si",	MEM)
+BU_VSX_X (STXVW4X_V8HI,	      "stxvw4x_v8hi",	MEM)
+BU_VSX_X (STXVW4X_V16QI,      "stxvw4x_v16qi",	MEM)
+BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  MEM)
+BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  MEM)
+BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  MEM)
+BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  MEM)
+BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  MEM)
+BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", MEM)
+BU_VSX_X (ST_ELEMREV_V2DF,    "st_elemrev_v2df",  MEM)
+BU_VSX_X (ST_ELEMREV_V2DI,    "st_elemrev_v2di",  MEM)
+BU_VSX_X (ST_ELEMREV_V4SF,    "st_elemrev_v4sf",  MEM)
+BU_VSX_X (ST_ELEMREV_V4SI,    "st_elemrev_v4si",  MEM)
+BU_VSX_X (ST_ELEMREV_V8HI,    "st_elemrev_v8hi",  MEM)
+BU_VSX_X (ST_ELEMREV_V16QI,   "st_elemrev_v16qi", MEM)
 BU_VSX_X (XSABSDP,	      "xsabsdp",	CONST)
 BU_VSX_X (XSADDDP,	      "xsadddp",	FP)
 BU_VSX_X (XSCMPODP,	      "xscmpodp",	FP)
@@ -1455,6 +1643,8 @@
 /* VSX builtins that are handled as special cases.  */
 BU_VSX_OVERLOAD_X (LD,	     "ld")
 BU_VSX_OVERLOAD_X (ST,	     "st")
+BU_VSX_OVERLOAD_X (XL,	     "xl")
+BU_VSX_OVERLOAD_X (XST,	     "xst")
 
 /* 1 argument VSX instructions added in ISA 2.07.  */
 BU_P8V_VSX_1 (XSCVSPDPN,      "xscvspdpn",	CONST,	vsx_xscvspdpn)
@@ -1589,6 +1779,25 @@
 BU_P8V_OVERLOAD_3 (VSUBECUQ,	"vsubecuq")
 BU_P8V_OVERLOAD_3 (VSUBEUQM,	"vsubeuqm")
 
+/* ISA 3.0 vector overloaded 2-argument functions. */
+BU_P9V_AV_2 (VSLV,		"vslv",			CONST, vslv)
+BU_P9V_AV_2 (VSRV,		"vsrv",			CONST, vsrv)
+
+/* ISA 3.0 vector overloaded 2-argument functions. */
+BU_P9V_OVERLOAD_2 (VSLV,	"vslv")
+BU_P9V_OVERLOAD_2 (VSRV,	"vsrv")
+
+/* 2 argument vector functions added in ISA 3.0 (power9). */
+BU_P9V_AV_2 (VADUB,		"vadub",		CONST,  vaduv16qi3)
+BU_P9V_AV_2 (VADUH,		"vaduh",		CONST,  vaduv8hi3)
+BU_P9V_AV_2 (VADUW,		"vaduw",		CONST,  vaduv4si3)
+
+/* ISA 3.0 vector overloaded 2 argument functions. */
+BU_P9V_OVERLOAD_2 (VADU,	"vadu")
+BU_P9V_OVERLOAD_2 (VADUB,	"vadub")
+BU_P9V_OVERLOAD_2 (VADUH,	"vaduh")
+BU_P9V_OVERLOAD_2 (VADUW,	"vaduw")
+
 
 /* 2 argument extended divide functions added in ISA 2.06.  */
 BU_P7_MISC_2 (DIVWE,		"divwe",	CONST,	dive_si)
@@ -1639,12 +1848,72 @@
 BU_DFP_MISC_2 (PACK_TD,		"pack_dec128",		CONST,	packtd)
 BU_DFP_MISC_2 (UNPACK_TD,	"unpack_dec128",	CONST,	unpacktd)
 
+/* 0 argument general-purpose register functions added in ISA 3.0 (power9).  */
+BU_P9_MISC_0 (DARN_32,		"darn_32", 		MISC, darn_32)
+BU_P9_64BIT_MISC_0 (DARN_RAW,	"darn_raw", 		MISC, darn_raw)
+BU_P9_64BIT_MISC_0 (DARN,	"darn",			MISC, darn)
+
 BU_LDBL128_2 (PACK_TF,		"pack_longdouble",	CONST,	packtf)
 BU_LDBL128_2 (UNPACK_TF,	"unpack_longdouble",	CONST,	unpacktf)
 
 BU_P7_MISC_2 (PACK_V1TI,	"pack_vector_int128",	CONST,	packv1ti)
 BU_P7_MISC_2 (UNPACK_V1TI,	"unpack_vector_int128",	CONST,	unpackv1ti)
 
+/* 2 argument DFP (Decimal Floating Point) functions added in ISA 3.0.  */
+BU_P9_DFP_MISC_2 (TSTSFI_LT_DD, "dtstsfi_lt_dd", CONST, dfptstsfi_lt_dd)
+BU_P9_DFP_MISC_2 (TSTSFI_LT_TD, "dtstsfi_lt_td", CONST, dfptstsfi_lt_td)
+
+BU_P9_DFP_MISC_2 (TSTSFI_EQ_DD, "dtstsfi_eq_dd", CONST, dfptstsfi_eq_dd)
+BU_P9_DFP_MISC_2 (TSTSFI_EQ_TD, "dtstsfi_eq_td", CONST, dfptstsfi_eq_td)
+
+BU_P9_DFP_MISC_2 (TSTSFI_GT_DD, "dtstsfi_gt_dd", CONST, dfptstsfi_gt_dd)
+BU_P9_DFP_MISC_2 (TSTSFI_GT_TD, "dtstsfi_gt_td", CONST, dfptstsfi_gt_td)
+
+BU_P9_DFP_MISC_2 (TSTSFI_OV_DD, "dtstsfi_ov_dd", CONST, dfptstsfi_unordered_dd)
+BU_P9_DFP_MISC_2 (TSTSFI_OV_TD, "dtstsfi_ov_td", CONST, dfptstsfi_unordered_td)
+
+/* 2 argument overloaded DFP functions added in ISA 3.0.  */
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_LT,	"dtstsfi_lt")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_LT_DD,	"dtstsfi_lt_dd")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_LT_TD,	"dtstsfi_lt_td")
+
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_EQ,	"dtstsfi_eq")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_EQ_DD,	"dtstsfi_eq_dd")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_EQ_TD,	"dtstsfi_eq_td")
+
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_GT,	"dtstsfi_gt")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_GT_DD,	"dtstsfi_gt_dd")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_GT_TD,	"dtstsfi_gt_td")
+
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_OV,	"dtstsfi_ov")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_OV_DD,	"dtstsfi_ov_dd")
+BU_P9_DFP_OVERLOAD_2 (TSTSFI_OV_TD,	"dtstsfi_ov_td")
+
+/* 1 argument vector functions added in ISA 3.0 (power9).  */
+BU_P9V_AV_1 (VCTZB,		"vctzb",		CONST,  ctzv16qi2)
+BU_P9V_AV_1 (VCTZH,		"vctzh",		CONST,  ctzv8hi2)
+BU_P9V_AV_1 (VCTZW,		"vctzw",		CONST,  ctzv4si2)
+BU_P9V_AV_1 (VCTZD,		"vctzd",		CONST,  ctzv2di2)
+BU_P9V_AV_1 (VPRTYBD,		"vprtybd",		CONST,  parityv2di2)
+BU_P9V_AV_1 (VPRTYBQ,		"vprtybq",		CONST,  parityv1ti2)
+BU_P9V_AV_1 (VPRTYBW,		"vprtybw",		CONST,  parityv4si2)
+
+/* ISA 3.0 vector overloaded 1 argument functions.  */
+BU_P9V_OVERLOAD_1 (VCTZ,	"vctz")
+BU_P9V_OVERLOAD_1 (VCTZB,	"vctzb")
+BU_P9V_OVERLOAD_1 (VCTZH,	"vctzh")
+BU_P9V_OVERLOAD_1 (VCTZW,	"vctzw")
+BU_P9V_OVERLOAD_1 (VCTZD,	"vctzd")
+BU_P9V_OVERLOAD_1 (VPRTYB,	"vprtyb")
+BU_P9V_OVERLOAD_1 (VPRTYBD,	"vprtybd")
+BU_P9V_OVERLOAD_1 (VPRTYBQ,	"vprtybq")
+BU_P9V_OVERLOAD_1 (VPRTYBW,	"vprtybw")
+
+/* 1 argument IEEE 128-bit floating-point functions.  */
+BU_FLOAT128_1 (FABSQ,		"fabsq",       CONST, abskf2)
+
+/* 2 argument IEEE 128-bit floating-point functions.  */
+BU_FLOAT128_2 (COPYSIGNQ,	"copysignq",   CONST, copysignkf3)
 
 /* 1 argument crypto functions.  */
 BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
@@ -2022,6 +2291,18 @@
 BU_SPECIAL_X (RS6000_BUILTIN_CPU_SUPPORTS, "__builtin_cpu_supports",
 	      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)
 
+BU_SPECIAL_X (RS6000_BUILTIN_NANQ, "__builtin_nanq",
+	      RS6000_BTM_FLOAT128, RS6000_BTC_CONST)
+
+BU_SPECIAL_X (RS6000_BUILTIN_NANSQ, "__builtin_nansq",
+	      RS6000_BTM_FLOAT128, RS6000_BTC_CONST)
+
+BU_SPECIAL_X (RS6000_BUILTIN_INFQ, "__builtin_infq",
+	      RS6000_BTM_FLOAT128, RS6000_BTC_CONST)
+
+BU_SPECIAL_X (RS6000_BUILTIN_HUGE_VALQ, "__builtin_huge_valq",
+	      RS6000_BTM_FLOAT128, RS6000_BTC_CONST)
+
 /* Darwin CfString builtin.  */
 BU_SPECIAL_X (RS6000_BUILTIN_CFSTRING, "__builtin_cfstring", RS6000_BTM_ALWAYS,
 	      RS6000_BTC_MISC)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000-c.c gcc-6-20160721/gcc/config/rs6000/rs6000-c.c
--- gcc-6.1.0/gcc/config/rs6000/rs6000-c.c	2016-03-21 15:41:13.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000-c.c	2016-07-07 19:42:07.000000000 +0000
@@ -2726,6 +2726,49 @@
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_SUMS, ALTIVEC_BUILTIN_VSUMSWS,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V4SF,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V4SF,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V4SI,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V4SI,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V4SI,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V4SI,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V8HI,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V8HI,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V8HI,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V8HI,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V16QI,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V16QI,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V16QI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V16QI, 0 },
+  { VSX_BUILTIN_VEC_XL, VSX_BUILTIN_LD_ELEMREV_V16QI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
@@ -3475,6 +3518,55 @@
     RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_STVRXL, ALTIVEC_BUILTIN_STVRXL,
     RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V2DI,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V2DI,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_long_long },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V2DI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V2DI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V4SF,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V4SF,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V4SI,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V4SI,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V4SI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V4SI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V4SI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTSI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V8HI,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V8HI,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V8HI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V8HI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V8HI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTHI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V16QI,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V16QI,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V16QI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V16QI },
+  { VSX_BUILTIN_VEC_XST, VSX_BUILTIN_ST_ELEMREV_V16QI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTQI },
   { VSX_BUILTIN_VEC_XXSLDWI, VSX_BUILTIN_XXSLDWI_16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_NOT_OPAQUE },
   { VSX_BUILTIN_VEC_XXSLDWI, VSX_BUILTIN_XXSLDWI_16QI,
@@ -4123,6 +4215,105 @@
   { P8V_BUILTIN_VEC_VCLZD, P8V_BUILTIN_VCLZD,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },
 
+  { P9_BUILTIN_DFP_TSTSFI_LT, MISC_BUILTIN_TSTSFI_LT_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_LT, MISC_BUILTIN_TSTSFI_LT_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_LT_TD, MISC_BUILTIN_TSTSFI_LT_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_LT_DD, MISC_BUILTIN_TSTSFI_LT_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_EQ, MISC_BUILTIN_TSTSFI_EQ_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_EQ, MISC_BUILTIN_TSTSFI_EQ_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_EQ_TD, MISC_BUILTIN_TSTSFI_EQ_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_EQ_DD, MISC_BUILTIN_TSTSFI_EQ_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_GT, MISC_BUILTIN_TSTSFI_GT_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_GT, MISC_BUILTIN_TSTSFI_GT_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_GT_TD, MISC_BUILTIN_TSTSFI_GT_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_GT_DD, MISC_BUILTIN_TSTSFI_GT_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_OV, MISC_BUILTIN_TSTSFI_OV_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_OV, MISC_BUILTIN_TSTSFI_OV_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9_BUILTIN_DFP_TSTSFI_OV_TD, MISC_BUILTIN_TSTSFI_OV_TD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat128, 0 },
+  { P9_BUILTIN_DFP_TSTSFI_OV_DD, MISC_BUILTIN_TSTSFI_OV_DD,
+    RS6000_BTI_INTSI, RS6000_BTI_UINTSI, RS6000_BTI_dfloat64, 0 },
+
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZB,
+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZH,
+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZW,
+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZD,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZ, P9V_BUILTIN_VCTZD,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VCTZB, P9V_BUILTIN_VCTZB,
+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZB, P9V_BUILTIN_VCTZB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VCTZH, P9V_BUILTIN_VCTZH,
+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZH, P9V_BUILTIN_VCTZH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VCTZW, P9V_BUILTIN_VCTZW,
+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZW, P9V_BUILTIN_VCTZW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VCTZD, P9V_BUILTIN_VCTZD,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },
+  { P9V_BUILTIN_VEC_VCTZD, P9V_BUILTIN_VCTZD,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VADU, P9V_BUILTIN_VADUB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
+    RS6000_BTI_unsigned_V16QI, 0 },
+  { P9V_BUILTIN_VEC_VADU, P9V_BUILTIN_VADUH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
+    RS6000_BTI_unsigned_V8HI, 0 },
+  { P9V_BUILTIN_VEC_VADU, P9V_BUILTIN_VADUW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
+    RS6000_BTI_unsigned_V4SI, 0 },
+
+  { P9V_BUILTIN_VEC_VADUB, P9V_BUILTIN_VADUB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
+    RS6000_BTI_unsigned_V16QI, 0 },
+
+  { P9V_BUILTIN_VEC_VADUH, P9V_BUILTIN_VADUH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
+    RS6000_BTI_unsigned_V8HI, 0 },
+
+  { P9V_BUILTIN_VEC_VADUW, P9V_BUILTIN_VADUW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
+    RS6000_BTI_unsigned_V4SI, 0 },
+
   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },
   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,
@@ -4252,6 +4443,42 @@
   { P8V_BUILTIN_VEC_VPOPCNTD, P8V_BUILTIN_VPOPCNTD,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },
 
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBW,
+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBD,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBD,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_INTTI, RS6000_BTI_INTTI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYB, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_UINTTI, RS6000_BTI_UINTTI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VPRTYBW, P9V_BUILTIN_VPRTYBW,
+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYBW, P9V_BUILTIN_VPRTYBW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VPRTYBD, P9V_BUILTIN_VPRTYBD,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYBD, P9V_BUILTIN_VPRTYBD,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },
+
+  { P9V_BUILTIN_VEC_VPRTYBQ, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYBQ, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYBQ, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_INTTI, RS6000_BTI_INTTI, 0, 0 },
+  { P9V_BUILTIN_VEC_VPRTYBQ, P9V_BUILTIN_VPRTYBQ,
+    RS6000_BTI_UINTTI, RS6000_BTI_UINTTI, 0, 0 },
+
   { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,
     RS6000_BTI_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
   { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,
@@ -4328,6 +4555,13 @@
   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,
     RS6000_BTI_unsigned_V16QI, 0, 0, 0 },
 
+  { P9V_BUILTIN_VEC_VSLV, P9V_BUILTIN_VSLV,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
+    RS6000_BTI_unsigned_V16QI, 0 },
+  { P9V_BUILTIN_VEC_VSRV, P9V_BUILTIN_VSRV,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
+    RS6000_BTI_unsigned_V16QI, 0 },
+
   /* Crypto builtins.  */
   { CRYPTO_BUILTIN_VPERMXOR, CRYPTO_BUILTIN_VPERMXOR_V16QI,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000-cpus.def gcc-6-20160721/gcc/config/rs6000/rs6000-cpus.def
--- gcc-6.1.0/gcc/config/rs6000/rs6000-cpus.def	2016-03-23 20:33:28.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000-cpus.def	2016-07-08 14:51:44.000000000 +0000
@@ -60,15 +60,26 @@
 				 | OPTION_MASK_UPPER_REGS_SF)
 
 /* Add ISEL back into ISA 3.0, since it is supposed to be a win.  Do not add
-   P9_DFORM or P9_MINMAX until they are fully debugged.  */
+   P9_MINMAX until the hardware that supports it is available.  Do not add
+   FLOAT128_HW here until we are ready to make -mfloat128 on by default.  */
 #define ISA_3_0_MASKS_SERVER	(ISA_2_7_MASKS_SERVER			\
-				 | OPTION_MASK_FLOAT128_HW		\
 				 | OPTION_MASK_ISEL			\
 				 | OPTION_MASK_MODULO			\
 				 | OPTION_MASK_P9_FUSION		\
-				 | OPTION_MASK_P9_DFORM			\
+				 | OPTION_MASK_P9_DFORM_SCALAR		\
+				 | OPTION_MASK_P9_DFORM_VECTOR		\
+				 | OPTION_MASK_P9_MISC			\
 				 | OPTION_MASK_P9_VECTOR)
 
+/* Support for the IEEE 128-bit floating point hardware requires a lot of the
+   VSX instructions that are part of ISA 3.0.  */
+#define ISA_3_0_MASKS_IEEE	(OPTION_MASK_VSX			\
+				 | OPTION_MASK_P8_VECTOR		\
+				 | OPTION_MASK_P9_VECTOR		\
+				 | OPTION_MASK_DIRECT_MOVE		\
+				 | OPTION_MASK_UPPER_REGS_DF		\
+				 | OPTION_MASK_UPPER_REGS_SF)
+
 #define POWERPC_7400_MASK	(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)
 
 /* Deal with ports that do not have -mstrict-align.  */
@@ -94,6 +105,7 @@
 				 | OPTION_MASK_FPRND			\
 				 | OPTION_MASK_HTM			\
 				 | OPTION_MASK_ISEL			\
+				 | OPTION_MASK_LRA			\
 				 | OPTION_MASK_MFCRF			\
 				 | OPTION_MASK_MFPGPR			\
 				 | OPTION_MASK_MODULO			\
@@ -101,9 +113,11 @@
 				 | OPTION_MASK_NO_UPDATE		\
 				 | OPTION_MASK_P8_FUSION		\
 				 | OPTION_MASK_P8_VECTOR		\
-				 | OPTION_MASK_P9_DFORM			\
+				 | OPTION_MASK_P9_DFORM_SCALAR		\
+				 | OPTION_MASK_P9_DFORM_VECTOR		\
 				 | OPTION_MASK_P9_FUSION		\
 				 | OPTION_MASK_P9_MINMAX		\
+				 | OPTION_MASK_P9_MISC			\
 				 | OPTION_MASK_P9_VECTOR		\
 				 | OPTION_MASK_POPCNTB			\
 				 | OPTION_MASK_POPCNTD			\
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000-protos.h gcc-6-20160721/gcc/config/rs6000/rs6000-protos.h
--- gcc-6.1.0/gcc/config/rs6000/rs6000-protos.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000-protos.h	2016-07-12 19:51:09.000000000 +0000
@@ -31,6 +31,7 @@
 #endif /* TREE_CODE */
 
 extern bool easy_altivec_constant (rtx, machine_mode);
+extern bool xxspltib_constant_p (rtx, machine_mode, int *, int *);
 extern int vspltis_shifted (rtx);
 extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);
 extern bool macho_lo_sum_memory_operand (rtx, machine_mode);
@@ -86,6 +87,7 @@
 extern int mems_ok_for_quad_peep (rtx, rtx);
 extern bool gpr_or_gpr_p (rtx, rtx);
 extern bool direct_move_p (rtx, rtx);
+extern bool quad_address_p (rtx, machine_mode, bool);
 extern bool quad_load_store_p (rtx, rtx);
 extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx);
 extern void expand_fusion_gpr_load (rtx *);
@@ -133,6 +135,7 @@
 extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);
 extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);
 extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);
+extern void rs6000_split_signbit (rtx, rtx);
 extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);
 extern void rs6000_expand_atomic_exchange (rtx op[]);
 extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000.c gcc-6-20160721/gcc/config/rs6000/rs6000.c
--- gcc-6.1.0/gcc/config/rs6000/rs6000.c	2016-04-14 23:21:30.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000.c	2016-07-19 03:39:34.000000000 +0000
@@ -452,6 +452,7 @@
 #define RELOAD_REG_PRE_INCDEC	0x10	/* PRE_INC/PRE_DEC valid.  */
 #define RELOAD_REG_PRE_MODIFY	0x20	/* PRE_MODIFY valid.  */
 #define RELOAD_REG_AND_M16	0x40	/* AND -16 addressing.  */
+#define RELOAD_REG_QUAD_OFFSET	0x80	/* quad offset is limited.  */
 
 /* Register type masks based on the type, of valid addressing modes.  */
 struct rs6000_reg_addr {
@@ -499,6 +500,16 @@
   return ((reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_OFFSET) != 0);
 }
 
+/* Return true if we have D-form addressing in VSX registers.  This addressing
+   is more limited than normal d-form addressing in that the offset must be
+   aligned on a 16-byte boundary.  */
+static inline bool
+mode_supports_vsx_dform_quad (machine_mode mode)
+{
+  return ((reg_addr[mode].addr_mask[RELOAD_REG_ANY] & RELOAD_REG_QUAD_OFFSET)
+	  != 0);
+}
+
 
 /* Target cpu costs.  */
 
@@ -1093,16 +1104,16 @@
   COSTS_N_INSNS (3),	/* mulsi_const */
   COSTS_N_INSNS (3),	/* mulsi_const9 */
   COSTS_N_INSNS (3),	/* muldi */
-  COSTS_N_INSNS (19),	/* divsi */
-  COSTS_N_INSNS (35),	/* divdi */
+  COSTS_N_INSNS (8),	/* divsi */
+  COSTS_N_INSNS (12),	/* divdi */
   COSTS_N_INSNS (3),	/* fp */
   COSTS_N_INSNS (3),	/* dmul */
-  COSTS_N_INSNS (14),	/* sdiv */
-  COSTS_N_INSNS (17),	/* ddiv */
+  COSTS_N_INSNS (13),	/* sdiv */
+  COSTS_N_INSNS (18),	/* ddiv */
   128,			/* cache line size */
   32,			/* l1 cache */
-  256,			/* l2 cache */
-  12,			/* prefetch streams */
+  512,			/* l2 cache */
+  8,			/* prefetch streams */
   COSTS_N_INSNS (3),	/* SF->DF convert */
 };
 
@@ -1128,6 +1139,7 @@
 
 
 /* Table that classifies rs6000 builtin functions (pure, const, etc.).  */
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -1140,6 +1152,9 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) \
+  { NAME, ICODE, MASK, ATTR },
+
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE) \
   { NAME, ICODE, MASK, ATTR },
 
@@ -1185,6 +1200,7 @@
 #include "rs6000-builtin.def"
 };
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -1312,6 +1328,7 @@
 					  bool);
 rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);
 static bool rs6000_keep_leaf_when_profiled () __attribute__ ((unused));
+static tree rs6000_fold_builtin (tree, int, tree *, bool);
 
 /* Hash table stuff for keeping track of TOC entries.  */
 
@@ -1586,6 +1603,9 @@
 #undef TARGET_BUILTIN_DECL
 #define TARGET_BUILTIN_DECL rs6000_builtin_decl
 
+#undef TARGET_FOLD_BUILTIN
+#define TARGET_FOLD_BUILTIN rs6000_fold_builtin
+
 #undef TARGET_EXPAND_BUILTIN
 #define TARGET_EXPAND_BUILTIN rs6000_expand_builtin
 
@@ -1866,7 +1886,7 @@
      128-bit floating point that can go in vector registers, which has VSX
      memory addressing.  */
   if (FP_REGNO_P (regno))
-    reg_size = (VECTOR_MEM_VSX_P (mode)
+    reg_size = (VECTOR_MEM_VSX_P (mode) || FLOAT128_VECTOR_P (mode)
 		? UNITS_PER_VSX_WORD
 		: UNITS_PER_FP_WORD);
 
@@ -1898,6 +1918,9 @@
 {
   int last_regno = regno + rs6000_hard_regno_nregs[mode][regno] - 1;
 
+  if (COMPLEX_MODE_P (mode))
+    mode = GET_MODE_INNER (mode);
+
   /* PTImode can only go in GPRs.  Quad word memory operations require even/odd
      register combinations, and use PTImode where we need to deal with quad
      word memory operations.  Don't allow quad words in the argument or frame
@@ -2105,7 +2128,9 @@
   else if (keep_spaces)
     *p++ = ' ';
 
-  if ((mask & RELOAD_REG_OFFSET) != 0)
+  if ((mask & RELOAD_REG_QUAD_OFFSET) != 0)
+    *p++ = 'O';
+  else if ((mask & RELOAD_REG_OFFSET) != 0)
     *p++ = 'o';
   else if (keep_spaces)
     *p++ = ' ';
@@ -2642,8 +2667,7 @@
   if (TARGET_LINK_STACK)
     fprintf (stderr, DEBUG_FMT_S, "link_stack", "true");
 
-  if (targetm.lra_p ())
-    fprintf (stderr, DEBUG_FMT_S, "lra", "true");
+  fprintf (stderr, DEBUG_FMT_S, "lra", TARGET_LRA ? "true" : "false");
 
   if (TARGET_P8_FUSION)
     {
@@ -2699,8 +2723,17 @@
 
   for (m = 0; m < NUM_MACHINE_MODES; ++m)
     {
-      machine_mode m2 = (machine_mode)m;
-      unsigned short msize = GET_MODE_SIZE (m2);
+      machine_mode m2 = (machine_mode) m;
+      bool complex_p = false;
+      size_t msize;
+
+      if (COMPLEX_MODE_P (m2))
+	{
+	  complex_p = true;
+	  m2 = GET_MODE_INNER (m2);
+	}
+
+      msize = GET_MODE_SIZE (m2);
 
       /* SDmode is special in that we want to access it only via REG+REG
 	 addressing on power7 and above, since we want to use the LFIWZX and
@@ -2722,7 +2755,7 @@
 	      /* Indicate if the mode takes more than 1 physical register.  If
 		 it takes a single register, indicate it can do REG+REG
 		 addressing.  */
-	      if (nregs > 1 || m == BLKmode)
+	      if (nregs > 1 || m == BLKmode || complex_p)
 		addr_mask |= RELOAD_REG_MULTIPLE;
 	      else
 		addr_mask |= RELOAD_REG_INDEXED;
@@ -2738,7 +2771,7 @@
 		  && msize <= 8
 		  && !VECTOR_MODE_P (m2)
 		  && !FLOAT128_VECTOR_P (m2)
-		  && !COMPLEX_MODE_P (m2)
+		  && !complex_p
 		  && (m2 != DFmode || !TARGET_UPPER_REGS_DF)
 		  && (m2 != SFmode || !TARGET_UPPER_REGS_SF)
 		  && !(TARGET_E500_DOUBLE && msize == 8))
@@ -2769,17 +2802,31 @@
 	    }
 
 	  /* GPR and FPR registers can do REG+OFFSET addressing, except
-	     possibly for SDmode.  ISA 3.0 (i.e. power9) adds D-form
-	     addressing for scalars to altivec registers.  */
+	     possibly for SDmode.  ISA 3.0 (i.e. power9) adds D-form addressing
+	     for 64-bit scalars and 32-bit SFmode to altivec registers.  */
 	  if ((addr_mask != 0) && !indexed_only_p
 	      && msize <= 8
 	      && (rc == RELOAD_REG_GPR
-		  || rc == RELOAD_REG_FPR
-		  || (rc == RELOAD_REG_VMX
-		      && TARGET_P9_DFORM
-		      && (m2 == DFmode || m2 == SFmode))))
+		  || ((msize == 8 || m2 == SFmode)
+		      && (rc == RELOAD_REG_FPR
+			  || (rc == RELOAD_REG_VMX
+			      && TARGET_P9_DFORM_SCALAR)))))
 	    addr_mask |= RELOAD_REG_OFFSET;
 
+	  /* VSX registers can do REG+OFFSET addresssing if ISA 3.0
+	     instructions are enabled.  The offset for 128-bit VSX registers is
+	     only 12-bits.  While GPRs can handle the full offset range, VSX
+	     registers can only handle the restricted range.  */
+	  else if ((addr_mask != 0) && !indexed_only_p
+		   && msize == 16 && TARGET_P9_DFORM_VECTOR
+		   && (ALTIVEC_OR_VSX_VECTOR_MODE (m2)
+		       || (m2 == TImode && TARGET_VSX_TIMODE)))
+	    {
+	      addr_mask |= RELOAD_REG_OFFSET;
+	      if (rc == RELOAD_REG_FPR || rc == RELOAD_REG_VMX)
+		addr_mask |= RELOAD_REG_QUAD_OFFSET;
+	    }
+
 	  /* VMX registers can do (REG & -16) and ((REG+REG) & -16)
 	     addressing on 128-bit types.  */
 	  if (rc == RELOAD_REG_VMX && msize == 16
@@ -3102,7 +3149,7 @@
     }
 
   /* Support for new D-form instructions.  */
-  if (TARGET_P9_DFORM)
+  if (TARGET_P9_DFORM_SCALAR)
     rs6000_constraints[RS6000_CONSTRAINT_wb] = ALTIVEC_REGS;
 
   /* Support for ISA 3.0 (power9) vectors.  */
@@ -3621,11 +3668,16 @@
 	  | ((TARGET_POPCNTD)		    ? RS6000_BTM_POPCNTD   : 0)
 	  | ((rs6000_cpu == PROCESSOR_CELL) ? RS6000_BTM_CELL      : 0)
 	  | ((TARGET_P8_VECTOR)		    ? RS6000_BTM_P8_VECTOR : 0)
+	  | ((TARGET_P9_VECTOR)		    ? RS6000_BTM_P9_VECTOR : 0)
+	  | ((TARGET_P9_MISC)		    ? RS6000_BTM_P9_MISC   : 0)
+	  | ((TARGET_MODULO)		    ? RS6000_BTM_MODULO    : 0)
+	  | ((TARGET_64BIT)		    ? RS6000_BTM_64BIT     : 0)
 	  | ((TARGET_CRYPTO)		    ? RS6000_BTM_CRYPTO	   : 0)
 	  | ((TARGET_HTM)		    ? RS6000_BTM_HTM	   : 0)
 	  | ((TARGET_DFP)		    ? RS6000_BTM_DFP	   : 0)
 	  | ((TARGET_HARD_FLOAT)	    ? RS6000_BTM_HARD_FLOAT : 0)
-	  | ((TARGET_LONG_DOUBLE_128)	    ? RS6000_BTM_LDBL128 : 0));
+	  | ((TARGET_LONG_DOUBLE_128)	    ? RS6000_BTM_LDBL128   : 0)
+	  | ((TARGET_FLOAT128)		    ? RS6000_BTM_FLOAT128  : 0));
 }
 
 /* Implement TARGET_MD_ASM_ADJUST.  All asm statements are considered
@@ -3784,22 +3836,7 @@
   if (rs6000_tune_index >= 0)
     tune_index = rs6000_tune_index;
   else if (have_cpu)
-    {
-      /* Until power9 tuning is available, use power8 tuning if -mcpu=power9.  */
-      if (processor_target_table[cpu_index].processor != PROCESSOR_POWER9)
-	rs6000_tune_index = tune_index = cpu_index;
-      else
-	{
-	  size_t i;
-	  tune_index = -1;
-	  for (i = 0; i < ARRAY_SIZE (processor_target_table); i++)
-	    if (processor_target_table[i].processor == PROCESSOR_POWER8)
-	      {
-		rs6000_tune_index = tune_index = i;
-		break;
-	      }
-	}
-    }
+    rs6000_tune_index = tune_index = cpu_index;
   else
     {
       size_t i;
@@ -3974,7 +4011,8 @@
 
   /* For the newer switches (vsx, dfp, etc.) set some of the older options,
      unless the user explicitly used the -mno-<option> to disable the code.  */
-  if (TARGET_P9_VECTOR || TARGET_MODULO || TARGET_P9_DFORM || TARGET_P9_MINMAX)
+  if (TARGET_P9_VECTOR || TARGET_MODULO || TARGET_P9_DFORM_SCALAR
+      || TARGET_P9_DFORM_VECTOR || TARGET_P9_DFORM_BOTH > 0 || TARGET_P9_MINMAX)
     rs6000_isa_flags |= (ISA_3_0_MASKS_SERVER & ~rs6000_isa_flags_explicit);
   else if (TARGET_P8_VECTOR || TARGET_DIRECT_MOVE || TARGET_CRYPTO)
     rs6000_isa_flags |= (ISA_2_7_MASKS_SERVER & ~rs6000_isa_flags_explicit);
@@ -4188,34 +4226,80 @@
       && !(rs6000_isa_flags_explicit & OPTION_MASK_TOC_FUSION))
     rs6000_isa_flags |= OPTION_MASK_TOC_FUSION;
 
+  /* ISA 3.0 vector instructions include ISA 2.07.  */
+  if (TARGET_P9_VECTOR && !TARGET_P8_VECTOR)
+    {
+      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)
+	error ("-mpower9-vector requires -mpower8-vector");
+      rs6000_isa_flags &= ~OPTION_MASK_P9_VECTOR;
+    }
+
+  /* -mpower9-dform turns on both -mpower9-dform-scalar and
+      -mpower9-dform-vector.  */
+  if (TARGET_P9_DFORM_BOTH > 0)
+    {
+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR))
+	rs6000_isa_flags |= OPTION_MASK_P9_DFORM_VECTOR;
+
+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_SCALAR))
+	rs6000_isa_flags |= OPTION_MASK_P9_DFORM_SCALAR;
+    }
+  else if (TARGET_P9_DFORM_BOTH == 0)
+    {
+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR))
+	rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_VECTOR;
+
+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_SCALAR))
+	rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_SCALAR;
+    }
+
   /* ISA 3.0 D-form instructions require p9-vector and upper-regs.  */
-  if (TARGET_P9_DFORM && !TARGET_P9_VECTOR)
+  if ((TARGET_P9_DFORM_SCALAR || TARGET_P9_DFORM_VECTOR) && !TARGET_P9_VECTOR)
     {
       if (rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR)
 	error ("-mpower9-dform requires -mpower9-vector");
-      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM;
+      rs6000_isa_flags &= ~(OPTION_MASK_P9_DFORM_SCALAR
+			    | OPTION_MASK_P9_DFORM_VECTOR);
     }
 
-  if (TARGET_P9_DFORM && !TARGET_UPPER_REGS_DF)
+  if (TARGET_P9_DFORM_SCALAR && !TARGET_UPPER_REGS_DF)
     {
       if (rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_DF)
 	error ("-mpower9-dform requires -mupper-regs-df");
-      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM;
+      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_SCALAR;
     }
 
-  if (TARGET_P9_DFORM && !TARGET_UPPER_REGS_SF)
+  if (TARGET_P9_DFORM_SCALAR && !TARGET_UPPER_REGS_SF)
     {
       if (rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_SF)
 	error ("-mpower9-dform requires -mupper-regs-sf");
-      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM;
+      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_SCALAR;
     }
 
-  /* ISA 3.0 vector instructions include ISA 2.07.  */
-  if (TARGET_P9_VECTOR && !TARGET_P8_VECTOR)
+  /* There have been bugs with -mvsx-timode that don't show up with -mlra,
+     but do show up with -mno-lra.  Given -mlra will become the default once
+     PR 69847 is fixed, turn off the options with problems by default if
+     -mno-lra was used, and warn if the user explicitly asked for the option.
+
+     Enable -mpower9-dform-vector by default if LRA and other power9 options.
+     Enable -mvsx-timode by default if LRA and VSX.  */
+  if (!TARGET_LRA)
     {
-      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)
-	error ("-mpower9-vector requires -mpower8-vector");
-      rs6000_isa_flags &= ~OPTION_MASK_P9_VECTOR;
+      if (TARGET_VSX_TIMODE)
+	{
+	  if ((rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE) != 0)
+	    warning (0, "-mvsx-timode might need -mlra");
+
+	  else
+	    rs6000_isa_flags &= ~OPTION_MASK_VSX_TIMODE;
+	}
+    }
+
+  else
+    {
+      if (TARGET_VSX && !TARGET_VSX_TIMODE
+	  && (rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE) == 0)
+	rs6000_isa_flags |= OPTION_MASK_VSX_TIMODE;
     }
 
   /* Set -mallow-movmisalign to explicitly on if we have full ISA 2.07
@@ -4267,13 +4351,21 @@
       rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128 | OPTION_MASK_FLOAT128_HW);
     }
 
+  /* If we have -mfloat128 and full ISA 3.0 support, enable -mfloat128-hardware
+     by default.  */
+  if (TARGET_FLOAT128 && !TARGET_FLOAT128_HW
+      && (rs6000_isa_flags & ISA_3_0_MASKS_IEEE) == ISA_3_0_MASKS_IEEE
+      && !(rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW))
+    {
+      rs6000_isa_flags |= OPTION_MASK_FLOAT128_HW;
+      if ((rs6000_isa_flags & OPTION_MASK_FLOAT128) != 0)
+	rs6000_isa_flags_explicit |= OPTION_MASK_FLOAT128_HW;
+    }
+
   /* IEEE 128-bit floating point hardware instructions imply enabling
      __float128.  */
   if (TARGET_FLOAT128_HW
-      && (rs6000_isa_flags & (OPTION_MASK_P9_VECTOR
-			      | OPTION_MASK_DIRECT_MOVE
-			      | OPTION_MASK_UPPER_REGS_DF
-			      | OPTION_MASK_UPPER_REGS_SF)) == 0)
+      && (rs6000_isa_flags & ISA_3_0_MASKS_IEEE) != ISA_3_0_MASKS_IEEE)
     {
       if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW) != 0)
 	error ("-mfloat128-hardware requires full ISA 3.0 support");
@@ -4281,10 +4373,6 @@
       rs6000_isa_flags &= ~OPTION_MASK_FLOAT128_HW;
     }
 
-  else if (TARGET_P9_VECTOR && !TARGET_FLOAT128_HW
-	   && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW) == 0)
-    rs6000_isa_flags |= OPTION_MASK_FLOAT128_HW;
-
   if (TARGET_FLOAT128_HW
       && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128) == 0)
     rs6000_isa_flags |= OPTION_MASK_FLOAT128;
@@ -4494,8 +4582,7 @@
   rs6000_sched_groups = (rs6000_cpu == PROCESSOR_POWER4
 			 || rs6000_cpu == PROCESSOR_POWER5
 			 || rs6000_cpu == PROCESSOR_POWER7
-			 || rs6000_cpu == PROCESSOR_POWER8
-			 || rs6000_cpu == PROCESSOR_POWER9);
+			 || rs6000_cpu == PROCESSOR_POWER8);
   rs6000_align_branch_targets = (rs6000_cpu == PROCESSOR_POWER4
 				 || rs6000_cpu == PROCESSOR_POWER5
 				 || rs6000_cpu == PROCESSOR_POWER6
@@ -6134,6 +6221,128 @@
   gcc_unreachable ();
 }
 
+/* Return true if OP is of the given MODE and can be synthesized with ISA 3.0
+   instructions (xxspltib, vupkhsb/vextsb2w/vextb2d).
+
+   Return the number of instructions needed (1 or 2) into the address pointed
+   via NUM_INSNS_PTR.
+
+   If NOSPLIT_P, only return true for constants that only generate the XXSPLTIB
+   instruction and can go in any VSX register.  If !NOSPLIT_P, only return true
+   for constants that generate XXSPLTIB and need a sign extend operation, which
+   restricts us to the Altivec registers.
+
+   Allow either (vec_const [...]) or (vec_duplicate <const>).  If OP is a valid
+   XXSPLTIB constant, return the constant being set via the CONST_PTR
+   pointer.  */
+
+bool
+xxspltib_constant_p (rtx op,
+		     machine_mode mode,
+		     int *num_insns_ptr,
+		     int *constant_ptr)
+{
+  size_t nunits = GET_MODE_NUNITS (mode);
+  size_t i;
+  HOST_WIDE_INT value;
+  rtx element;
+
+  /* Set the returned values to out of bound values.  */
+  *num_insns_ptr = -1;
+  *constant_ptr = 256;
+
+  if (!TARGET_P9_VECTOR)
+    return false;
+
+  if (mode == VOIDmode)
+    mode = GET_MODE (op);
+
+  else if (mode != GET_MODE (op))
+    return false;
+
+  /* Handle (vec_duplicate <constant>).  */
+  if (GET_CODE (op) == VEC_DUPLICATE)
+    {
+      if (mode != V16QImode && mode != V8HImode && mode != V4SImode
+	  && mode != V2DImode)
+	return false;
+
+      element = XEXP (op, 0);
+      if (!CONST_INT_P (element))
+	return false;
+
+      value = INTVAL (element);
+      if (!IN_RANGE (value, -128, 127))
+	return false;
+    }
+
+  /* Handle (const_vector [...]).  */
+  else if (GET_CODE (op) == CONST_VECTOR)
+    {
+      if (mode != V16QImode && mode != V8HImode && mode != V4SImode
+	  && mode != V2DImode)
+	return false;
+
+      element = CONST_VECTOR_ELT (op, 0);
+      if (!CONST_INT_P (element))
+	return false;
+
+      value = INTVAL (element);
+      if (!IN_RANGE (value, -128, 127))
+	return false;
+
+      for (i = 1; i < nunits; i++)
+	{
+	  element = CONST_VECTOR_ELT (op, i);
+	  if (!CONST_INT_P (element))
+	    return false;
+
+	  if (value != INTVAL (element))
+	    return false;
+	}
+
+      /* See if we could generate vspltisw/vspltish directly instead of
+	 xxspltib + sign extend.  Special case 0/-1 to allow getting
+         any VSX register instead of an Altivec register.  */
+      if (!IN_RANGE (value, -1, 0) && EASY_VECTOR_15 (value)
+	  && (mode == V4SImode || mode == V8HImode))
+	return false;
+    }
+
+  /* Handle integer constants being loaded into the upper part of the VSX
+     register as a scalar.  If the value isn't 0/-1, only allow it if
+     the mode can go in Altivec registers.  */
+  else if (CONST_INT_P (op))
+    {
+      if (!SCALAR_INT_MODE_P (mode))
+	return false;
+
+      value = INTVAL (op);
+      if (!IN_RANGE (value, -128, 127))
+	return false;
+
+      if (!IN_RANGE (value, -1, 0)
+	  && (reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_VALID) == 0)
+	return false;
+    }
+
+  else
+    return false;
+
+  /* Return # of instructions and the constant byte for XXSPLTIB.  */
+  if (mode == V16QImode)
+    *num_insns_ptr = 1;
+
+  else if (IN_RANGE (value, -1, 0))
+    *num_insns_ptr = 1;
+
+  else
+    *num_insns_ptr = 2;
+
+  *constant_ptr = (int) value;
+  return true;
+}
+
 const char *
 output_vec_const_move (rtx *operands)
 {
@@ -6147,23 +6356,60 @@
 
   if (TARGET_VSX)
     {
+      bool dest_vmx_p = ALTIVEC_REGNO_P (REGNO (dest));
+      int xxspltib_value = 256;
+      int num_insns = -1;
+
       if (zero_constant (vec, mode))
-	return "xxlxor %x0,%x0,%x0";
+	{
+	  if (TARGET_P9_VECTOR)
+	    return "xxspltib %x0,0";
 
-      if (TARGET_P8_VECTOR && vec == CONSTM1_RTX (mode))
-	return "xxlorc %x0,%x0,%x0";
+	  else if (dest_vmx_p)
+	    return "vspltisw %0,0";
 
-      if ((mode == V2DImode || mode == V1TImode)
-	  && INTVAL (CONST_VECTOR_ELT (vec, 0)) == -1
-	  && INTVAL (CONST_VECTOR_ELT (vec, 1)) == -1)
-	return (TARGET_P8_VECTOR) ? "xxlorc %x0,%x0,%x0" : "vspltisw %0,-1";
+	  else
+	    return "xxlxor %x0,%x0,%x0";
+	}
+
+      if (all_ones_constant (vec, mode))
+	{
+	  if (TARGET_P9_VECTOR)
+	    return "xxspltib %x0,255";
+
+	  else if (dest_vmx_p)
+	    return "vspltisw %0,-1";
+
+	  else if (TARGET_P8_VECTOR)
+	    return "xxlorc %x0,%x0,%x0";
+
+	  else
+	    gcc_unreachable ();
+	}
+
+      if (TARGET_P9_VECTOR
+	  && xxspltib_constant_p (vec, mode, &num_insns, &xxspltib_value))
+	{
+	  if (num_insns == 1)
+	    {
+	      operands[2] = GEN_INT (xxspltib_value & 0xff);
+	      return "xxspltib %x0,%2";
+	    }
+
+	  return "#";
+	}
     }
 
   if (TARGET_ALTIVEC)
     {
       rtx splat_vec;
+
+      gcc_assert (ALTIVEC_REGNO_P (REGNO (dest)));
       if (zero_constant (vec, mode))
-	return "vxor %0,%0,%0";
+	return "vspltisw %0,0";
+
+      if (all_ones_constant (vec, mode))
+	return "vspltisw %0,-1";
 
       /* Do we need to construct a value using VSLDOI?  */
       shift = vspltis_shifted (vec);
@@ -6436,6 +6682,15 @@
       return;
     }
 
+  /* Word values on ISA 3.0 can use mtvsrws, lxvwsx, or vspltisw.  V4SF is
+     complicated since scalars are stored as doubles in the registers.  */
+  if (TARGET_P9_VECTOR && mode == V4SImode && all_same
+      && VECTOR_MEM_VSX_P (mode))
+    {
+      emit_insn (gen_vsx_splat_v4si (target, XVECEXP (vals, 0, 0)));
+      return;
+    }
+
   /* With single precision floating point on VSX, know that internally single
      precision is actually represented as a double, and either make 2 V2DF
      vectors, and convert these vectors to single precision, or do one
@@ -6444,14 +6699,23 @@
     {
       if (all_same)
 	{
-	  rtx freg = gen_reg_rtx (V4SFmode);
-	  rtx sreg = force_reg (SFmode, XVECEXP (vals, 0, 0));
-	  rtx cvt  = ((TARGET_XSCVDPSPN)
-		      ? gen_vsx_xscvdpspn_scalar (freg, sreg)
-		      : gen_vsx_xscvdpsp_scalar (freg, sreg));
+	  rtx op0 = XVECEXP (vals, 0, 0);
+
+	  if (TARGET_P9_VECTOR)
+	    emit_insn (gen_vsx_splat_v4sf (target, op0));
+
+	  else
+	    {
+	      rtx freg = gen_reg_rtx (V4SFmode);
+	      rtx sreg = force_reg (SFmode, op0);
+	      rtx cvt  = (TARGET_XSCVDPSPN
+			  ? gen_vsx_xscvdpspn_scalar (freg, sreg)
+			  : gen_vsx_xscvdpsp_scalar (freg, sreg));
 
-	  emit_insn (cvt);
-	  emit_insn (gen_vsx_xxspltw_v4sf_direct (target, freg, const0_rtx));
+	      emit_insn (cvt);
+	      emit_insn (gen_vsx_xxspltw_v4sf_direct (target, freg,
+						      const0_rtx));
+	    }
 	}
       else
 	{
@@ -6572,21 +6836,29 @@
 			gen_rtvec (3, target, reg,
 				   force_reg (V16QImode, x)),
 			UNSPEC_VPERM);
-  else 
+  else
     {
-      /* Invert selector.  We prefer to generate VNAND on P8 so
-         that future fusion opportunities can kick in, but must
-         generate VNOR elsewhere.  */
-      rtx notx = gen_rtx_NOT (V16QImode, force_reg (V16QImode, x));
-      rtx iorx = (TARGET_P8_VECTOR
-		  ? gen_rtx_IOR (V16QImode, notx, notx)
-		  : gen_rtx_AND (V16QImode, notx, notx));
-      rtx tmp = gen_reg_rtx (V16QImode);
-      emit_insn (gen_rtx_SET (tmp, iorx));
-
-      /* Permute with operands reversed and adjusted selector.  */
-      x = gen_rtx_UNSPEC (mode, gen_rtvec (3, reg, target, tmp),
-			  UNSPEC_VPERM);
+      if (TARGET_P9_VECTOR)
+	x = gen_rtx_UNSPEC (mode,
+			    gen_rtvec (3, target, reg,
+				       force_reg (V16QImode, x)),
+			    UNSPEC_VPERMR);
+      else
+	{
+	  /* Invert selector.  We prefer to generate VNAND on P8 so
+	     that future fusion opportunities can kick in, but must
+	     generate VNOR elsewhere.  */
+	  rtx notx = gen_rtx_NOT (V16QImode, force_reg (V16QImode, x));
+	  rtx iorx = (TARGET_P8_VECTOR
+		      ? gen_rtx_IOR (V16QImode, notx, notx)
+		      : gen_rtx_AND (V16QImode, notx, notx));
+	  rtx tmp = gen_reg_rtx (V16QImode);
+	  emit_insn (gen_rtx_SET (tmp, iorx));
+
+	  /* Permute with operands reversed and adjusted selector.  */
+	  x = gen_rtx_UNSPEC (mode, gen_rtvec (3, reg, target, tmp),
+			      UNSPEC_VPERM);
+	}
     }
 
   emit_insn (gen_rtx_SET (target, x));
@@ -6902,6 +7174,49 @@
   return false;
 }
 
+/* Return true if the OFFSET is valid for the quad address instructions that
+   use d-form (register + offset) addressing.  */
+
+static inline bool
+quad_address_offset_p (HOST_WIDE_INT offset)
+{
+  return (IN_RANGE (offset, -32768, 32767) && ((offset) & 0xf) == 0);
+}
+
+/* Return true if the ADDR is an acceptable address for a quad memory
+   operation of mode MODE (either LQ/STQ for general purpose registers, or
+   LXV/STXV for vector registers under ISA 3.0.  GPR_P is true if this address
+   is intended for LQ/STQ.  If it is false, the address is intended for the ISA
+   3.0 LXV/STXV instruction.  */
+
+bool
+quad_address_p (rtx addr, machine_mode mode, bool strict)
+{
+  rtx op0, op1;
+
+  if (GET_MODE_SIZE (mode) != 16)
+    return false;
+
+  if (legitimate_indirect_address_p (addr, strict))
+    return true;
+
+  if (VECTOR_MODE_P (mode) && !mode_supports_vsx_dform_quad (mode))
+    return false;
+
+  if (GET_CODE (addr) != PLUS)
+    return false;
+
+  op0 = XEXP (addr, 0);
+  if (!REG_P (op0) || !INT_REG_OK_FOR_BASE_P (op0, strict))
+    return false;
+
+  op1 = XEXP (addr, 1);
+  if (!CONST_INT_P (op1))
+    return false;
+
+  return quad_address_offset_p (INTVAL (op1));
+}
+
 /* Return true if this is a load or store quad operation.  This function does
    not handle the atomic quad memory instructions.  */
 
@@ -6994,6 +7309,10 @@
   if (TARGET_POWERPC64 && (offset & 3) != 0)
     return false;
 
+  if (mode_supports_vsx_dform_quad (mode)
+      && !quad_address_offset_p (offset))
+    return false;
+
   extra = GET_MODE_SIZE (mode) - UNITS_PER_WORD;
   if (extra < 0)
     extra = 0;
@@ -7023,13 +7342,14 @@
     case TImode:
     case TFmode:
     case KFmode:
-      /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  While
-	 TImode is not a vector mode, if we want to use the VSX registers to
-	 move it around, we need to restrict ourselves to reg+reg addressing.
-	 Similarly for IEEE 128-bit floating point that is passed in a single
-	 vector register.  */
+      /* AltiVec/VSX vector modes.  Only reg+reg addressing was valid until the
+	 ISA 3.0 vector d-form addressing mode was added.  While TImode is not
+	 a vector mode, if we want to use the VSX registers to move it around,
+	 we need to restrict ourselves to reg+reg addressing.  Similarly for
+	 IEEE 128-bit floating point that is passed in a single vector
+	 register.  */
       if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))
-	return false;
+	return mode_supports_vsx_dform_quad (mode);
       break;
 
     case V4HImode:
@@ -7096,6 +7416,11 @@
   if (GET_CODE (op) != SYMBOL_REF)
     return false;
 
+  /* ISA 3.0 vector d-form addressing is restricted, don't allow
+     SYMBOL_REF.  */
+  if (mode_supports_vsx_dform_quad (mode))
+    return false;
+
   dsize = GET_MODE_SIZE (mode);
   decl = SYMBOL_REF_DECL (op);
   if (!decl)
@@ -7250,6 +7575,8 @@
     return false;
   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))
     return false;
+  if (mode_supports_vsx_dform_quad (mode))
+    return quad_address_p (x, mode, strict);
   if (!reg_offset_addressing_ok_p (mode))
     return virtual_stack_registers_memory_p (x);
   if (legitimate_constant_pool_address_p (x, mode, strict || lra_in_progress))
@@ -7388,6 +7715,9 @@
     return false;
   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))
     return false;
+  /* quad word addresses are restricted, and we can't use LO_SUM.  */
+  if (mode_supports_vsx_dform_quad (mode))
+    return false;
   /* Restrict addressing for DI because of our SUBREG hackery.  */
   if (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)
     return false;
@@ -7399,7 +7729,7 @@
 
       if (DEFAULT_ABI == ABI_V4 && flag_pic)
 	return false;
-      /* LRA don't use LEGITIMIZE_RELOAD_ADDRESS as it usually calls
+      /* LRA doesn't use LEGITIMIZE_RELOAD_ADDRESS as it usually calls
 	 push_reload from reload pass code.  LEGITIMIZE_RELOAD_ADDRESS
 	 recognizes some LO_SUM addresses as valid although this
 	 function says opposite.  In most cases, LRA through different
@@ -7453,7 +7783,8 @@
 {
   unsigned int extra;
 
-  if (!reg_offset_addressing_ok_p (mode))
+  if (!reg_offset_addressing_ok_p (mode)
+      || mode_supports_vsx_dform_quad (mode))
     {
       if (virtual_stack_registers_memory_p (x))
 	return x;
@@ -8148,13 +8479,18 @@
 				  int ind_levels ATTRIBUTE_UNUSED, int *win)
 {
   bool reg_offset_p = reg_offset_addressing_ok_p (mode);
+  bool quad_offset_p = mode_supports_vsx_dform_quad (mode);
 
-  /* Nasty hack for vsx_splat_V2DF/V2DI load from mem, which takes a
-     DFmode/DImode MEM.  */
+  /* Nasty hack for vsx_splat_v2df/v2di load from mem, which takes a
+     DFmode/DImode MEM.  Ditto for ISA 3.0 vsx_splat_v4sf/v4si.  */
   if (reg_offset_p
       && opnum == 1
       && ((mode == DFmode && recog_data.operand_mode[0] == V2DFmode)
-	  || (mode == DImode && recog_data.operand_mode[0] == V2DImode)))
+	  || (mode == DImode && recog_data.operand_mode[0] == V2DImode)
+	  || (mode == SFmode && recog_data.operand_mode[0] == V4SFmode
+	      && TARGET_P9_VECTOR)
+	  || (mode == SImode && recog_data.operand_mode[0] == V4SImode
+	      && TARGET_P9_VECTOR)))
     reg_offset_p = false;
 
   /* We must recognize output that we have already generated ourselves.  */
@@ -8164,6 +8500,11 @@
       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
       && GET_CODE (XEXP (x, 1)) == CONST_INT)
     {
+      if (TARGET_DEBUG_ADDR)
+	{
+	  fprintf (stderr, "\nlegitimize_reload_address push_reload #1:\n");
+	  debug_rtx (x);
+	}
       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
 		   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,
 		   opnum, (enum reload_type) type);
@@ -8175,6 +8516,11 @@
   if (GET_CODE (x) == LO_SUM
       && GET_CODE (XEXP (x, 0)) == HIGH)
     {
+      if (TARGET_DEBUG_ADDR)
+	{
+	  fprintf (stderr, "\nlegitimize_reload_address push_reload #2:\n");
+	  debug_rtx (x);
+	}
       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
 		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,
 		   opnum, (enum reload_type) type);
@@ -8203,10 +8549,16 @@
 
   if (TARGET_CMODEL != CMODEL_SMALL
       && reg_offset_p
+      && !quad_offset_p
       && small_toc_ref (x, VOIDmode))
     {
       rtx hi = gen_rtx_HIGH (Pmode, copy_rtx (x));
       x = gen_rtx_LO_SUM (Pmode, hi, x);
+      if (TARGET_DEBUG_ADDR)
+	{
+	  fprintf (stderr, "\nlegitimize_reload_address push_reload #3:\n");
+	  debug_rtx (x);
+	}
       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
 		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,
 		   opnum, (enum reload_type) type);
@@ -8215,22 +8567,24 @@
     }
 
   if (GET_CODE (x) == PLUS
-      && GET_CODE (XEXP (x, 0)) == REG
+      && REG_P (XEXP (x, 0))
       && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER
       && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)
-      && GET_CODE (XEXP (x, 1)) == CONST_INT
+      && CONST_INT_P (XEXP (x, 1))
       && reg_offset_p
       && !SPE_VECTOR_MODE (mode)
       && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)
-      && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))
+      && (quad_offset_p || !VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))
     {
       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));
       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;
       HOST_WIDE_INT high
 	= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;
 
-      /* Check for 32-bit overflow.  */
-      if (high + low != val)
+      /* Check for 32-bit overflow or quad addresses with one of the
+	 four least significant bits set.  */
+      if (high + low != val
+	  || (quad_offset_p && (low & 0xf)))
 	{
 	  *win = 0;
 	  return x;
@@ -8244,6 +8598,11 @@
 				      GEN_INT (high)),
 			GEN_INT (low));
 
+      if (TARGET_DEBUG_ADDR)
+	{
+	  fprintf (stderr, "\nlegitimize_reload_address push_reload #4:\n");
+	  debug_rtx (x);
+	}
       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
 		   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,
 		   opnum, (enum reload_type) type);
@@ -8253,6 +8612,7 @@
 
   if (GET_CODE (x) == SYMBOL_REF
       && reg_offset_p
+      && !quad_offset_p
       && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode))
       && !SPE_VECTOR_MODE (mode)
 #if TARGET_MACHO
@@ -8304,6 +8664,11 @@
 	x = gen_rtx_LO_SUM (GET_MODE (x),
 	      gen_rtx_HIGH (Pmode, x), x);
 
+      if (TARGET_DEBUG_ADDR)
+	{
+	  fprintf (stderr, "\nlegitimize_reload_address push_reload #5:\n");
+	  debug_rtx (x);
+	}
       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
 		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,
 		   opnum, (enum reload_type) type);
@@ -8332,14 +8697,22 @@
 
   if (TARGET_TOC
       && reg_offset_p
+      && !quad_offset_p
       && GET_CODE (x) == SYMBOL_REF
       && use_toc_relative_ref (x, mode))
     {
       x = create_TOC_reference (x, NULL_RTX);
       if (TARGET_CMODEL != CMODEL_SMALL)
-	push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
-		     BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,
-		     opnum, (enum reload_type) type);
+	{
+	  if (TARGET_DEBUG_ADDR)
+	    {
+	      fprintf (stderr, "\nlegitimize_reload_address push_reload #6:\n");
+	      debug_rtx (x);
+	    }
+	  push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,
+		       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,
+		       opnum, (enum reload_type) type);
+	}
       *win = 1;
       return x;
     }
@@ -8395,6 +8768,7 @@
 rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)
 {
   bool reg_offset_p = reg_offset_addressing_ok_p (mode);
+  bool quad_offset_p = mode_supports_vsx_dform_quad (mode);
 
   /* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */
   if (VECTOR_MEM_ALTIVEC_P (mode)
@@ -8412,17 +8786,27 @@
       && mode_supports_pre_incdec_p (mode)
       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))
     return 1;
-  if (virtual_stack_registers_memory_p (x))
-    return 1;
-  if (reg_offset_p && legitimate_small_data_p (mode, x))
+  /* Handle restricted vector d-form offsets in ISA 3.0.  */
+  if (quad_offset_p)
+    {
+      if (quad_address_p (x, mode, reg_ok_strict))
+	return 1;
+    }
+  else if (virtual_stack_registers_memory_p (x))
     return 1;
-  if (reg_offset_p
-      && legitimate_constant_pool_address_p (x, mode,
+
+  else if (reg_offset_p)
+    {
+      if (legitimate_small_data_p (mode, x))
+	return 1;
+      if (legitimate_constant_pool_address_p (x, mode,
 					     reg_ok_strict || lra_in_progress))
-    return 1;
-  if (reg_offset_p && reg_addr[mode].fused_toc && GET_CODE (x) == UNSPEC
-      && XINT (x, 1) == UNSPEC_FUSION_ADDIS)
-    return 1;
+	return 1;
+      if (reg_addr[mode].fused_toc && GET_CODE (x) == UNSPEC
+	  && XINT (x, 1) == UNSPEC_FUSION_ADDIS)
+	return 1;
+    }
+
   /* For TImode, if we have load/store quad and TImode in VSX registers, only
      allow register indirect addresses.  This will allow the values to go in
      either GPRs or VSX registers without reloading.  The vector types would
@@ -8461,7 +8845,8 @@
 	      && legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict)))
       && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))
     return 1;
-  if (reg_offset_p && legitimate_lo_sum_address_p (mode, x, reg_ok_strict))
+  if (reg_offset_p && !quad_offset_p
+      && legitimate_lo_sum_address_p (mode, x, reg_ok_strict))
     return 1;
   return 0;
 }
@@ -10044,6 +10429,35 @@
     return must_pass_in_stack_var_size_or_pad (mode, type);
 }
 
+static inline bool
+is_complex_IBM_long_double (machine_mode mode)
+{
+  return mode == ICmode || (!TARGET_IEEEQUAD && mode == TCmode);
+}
+
+/* Whether ABI_V4 passes MODE args to a function in floating point
+   registers.  */
+
+static bool
+abi_v4_pass_in_fpr (machine_mode mode)
+{
+  if (!TARGET_FPRS || !TARGET_HARD_FLOAT)
+    return false;
+  if (TARGET_SINGLE_FLOAT && mode == SFmode)
+    return true;
+  if (TARGET_DOUBLE_FLOAT && mode == DFmode)
+    return true;
+  /* ABI_V4 passes complex IBM long double in 8 gprs.
+     Stupid, but we can't change the ABI now.  */
+  if (is_complex_IBM_long_double (mode))
+    return false;
+  if (FLOAT128_2REG_P (mode))
+    return true;
+  if (DECIMAL_FLOAT_MODE_P (mode))
+    return true;
+  return false;
+}
+
 /* If defined, a C expression which determines whether, and in which
    direction, to pad out an argument with extra space.  The value
    should be of type `enum direction': either `upward' to pad above
@@ -10128,6 +10542,7 @@
       && (GET_MODE_SIZE (mode) == 8
 	  || (TARGET_HARD_FLOAT
 	      && TARGET_FPRS
+	      && !is_complex_IBM_long_double (mode)
 	      && FLOAT128_2REG_P (mode))))
     return 64;
   else if (FLOAT128_VECTOR_P (mode))
@@ -10507,11 +10922,7 @@
     }
   else if (DEFAULT_ABI == ABI_V4)
     {
-      if (TARGET_HARD_FLOAT && TARGET_FPRS
-	  && ((TARGET_SINGLE_FLOAT && mode == SFmode)
-	      || (TARGET_DOUBLE_FLOAT && mode == DFmode)
-	      || FLOAT128_2REG_P (mode)
-	      || DECIMAL_FLOAT_MODE_P (mode)))
+      if (abi_v4_pass_in_fpr (mode))
 	{
 	  /* _Decimal128 must use an even/odd register pair.  This assumes
 	     that the register number is odd when fregno is odd.  */
@@ -11168,11 +11579,7 @@
 
   else if (abi == ABI_V4)
     {
-      if (TARGET_HARD_FLOAT && TARGET_FPRS
-	  && ((TARGET_SINGLE_FLOAT && mode == SFmode)
-	      || (TARGET_DOUBLE_FLOAT && mode == DFmode)
-	      || FLOAT128_2REG_P (mode)
-	      || DECIMAL_FLOAT_MODE_P (mode)))
+      if (abi_v4_pass_in_fpr (mode))
 	{
 	  /* _Decimal128 must use an even/odd register pair.  This assumes
 	     that the register number is odd when fregno is odd.  */
@@ -12093,19 +12500,15 @@
   rsize = (size + 3) / 4;
   align = 1;
 
-  if (TARGET_HARD_FLOAT && TARGET_FPRS
-      && ((TARGET_SINGLE_FLOAT && TYPE_MODE (type) == SFmode)
-          || (TARGET_DOUBLE_FLOAT 
-              && (TYPE_MODE (type) == DFmode 
-		  || FLOAT128_2REG_P (TYPE_MODE (type))
-		  || DECIMAL_FLOAT_MODE_P (TYPE_MODE (type))))))
+  machine_mode mode = TYPE_MODE (type);
+  if (abi_v4_pass_in_fpr (mode))
     {
       /* FP args go in FP registers, if present.  */
       reg = fpr;
       n_reg = (size + 7) / 8;
       sav_ofs = ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? 8 : 4) * 4;
       sav_scale = ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? 8 : 4);
-      if (TYPE_MODE (type) != SFmode && TYPE_MODE (type) != SDmode)
+      if (mode != SFmode && mode != SDmode)
 	align = 8;
     }
   else
@@ -12125,7 +12528,7 @@
   addr = create_tmp_var (ptr_type_node, "addr");
 
   /*  AltiVec vectors never go in registers when -mabi=altivec.  */
-  if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type)))
+  if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))
     align = 16;
   else
     {
@@ -12146,7 +12549,7 @@
 	}
       /* _Decimal128 is passed in even/odd fpr pairs; the stored
 	 reg number is 0 for f1, so we want to make it odd.  */
-      else if (reg == fpr && TYPE_MODE (type) == TDmode)
+      else if (reg == fpr && mode == TDmode)
 	{
 	  t = build2 (BIT_IOR_EXPR, TREE_TYPE (reg), unshare_expr (reg),
 		      build_int_cst (TREE_TYPE (reg), 1));
@@ -12173,7 +12576,7 @@
 	 FP register for 32-bit binaries.  */
       if (TARGET_32BIT
 	  && TARGET_HARD_FLOAT && TARGET_FPRS
-	  && TYPE_MODE (type) == SDmode)
+	  && mode == SDmode)
 	t = fold_build_pointer_plus_hwi (t, size);
 
       gimplify_assign (addr, t, pre_p);
@@ -12260,7 +12663,7 @@
       /* const function, function only depends on the inputs.  */
       TREE_READONLY (t) = 1;
       TREE_NOTHROW (t) = 1;
-      attr_string = ", pure";
+      attr_string = ", const";
     }
   else if ((classify & RS6000_BTC_PURE) != 0)
     {
@@ -12268,7 +12671,7 @@
 	 external state.  */
       DECL_PURE_P (t) = 1;
       TREE_NOTHROW (t) = 1;
-      attr_string = ", const";
+      attr_string = ", pure";
     }
   else if ((classify & RS6000_BTC_FP) != 0)
     {
@@ -12300,6 +12703,7 @@
 
 /* Simple ternary operations: VECd = foo (VECa, VECb, VECc).  */
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12312,6 +12716,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE) \
@@ -12333,6 +12738,7 @@
 
 /* DST operations: void foo (void *, const int, const char).  */
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12345,6 +12751,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12366,6 +12773,7 @@
 
 /* Simple binary operations: VECc = foo (VECa, VECb).  */
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12378,6 +12786,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE) \
   { MASK, ICODE, NAME, ENUM },
@@ -12397,6 +12806,7 @@
 #include "rs6000-builtin.def"
 };
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12409,6 +12819,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12431,6 +12842,7 @@
 };
 
 /* SPE predicates.  */
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12443,6 +12855,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12463,6 +12876,7 @@
 };
 
 /* SPE evsel predicates.  */
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12475,6 +12889,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12495,6 +12910,7 @@
 };
 
 /* PAIRED predicates.  */
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12507,6 +12923,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12528,6 +12945,7 @@
 
 /* ABS* operations.  */
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12540,6 +12958,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12562,6 +12981,7 @@
 /* Simple unary operations: VECb = foo (unsigned literal) or VECb =
    foo (VECa).  */
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12574,6 +12994,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE) \
   { MASK, ICODE, NAME, ENUM },
 
@@ -12593,7 +13014,43 @@
 #include "rs6000-builtin.def"
 };
 
+/* Simple no-argument operations: result = __builtin_darn_32 () */
+
+#undef RS6000_BUILTIN_0
+#undef RS6000_BUILTIN_1
+#undef RS6000_BUILTIN_2
+#undef RS6000_BUILTIN_3
+#undef RS6000_BUILTIN_A
+#undef RS6000_BUILTIN_D
+#undef RS6000_BUILTIN_E
+#undef RS6000_BUILTIN_H
+#undef RS6000_BUILTIN_P
+#undef RS6000_BUILTIN_Q
+#undef RS6000_BUILTIN_S
+#undef RS6000_BUILTIN_X
+
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) \
+  { MASK, ICODE, NAME, ENUM },
+
+#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)
+#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)
+
+static const struct builtin_description bdesc_0arg[] =
+{
+#include "rs6000-builtin.def"
+};
+
 /* HTM builtins.  */
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12606,6 +13063,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)
@@ -12625,6 +13083,7 @@
 #include "rs6000-builtin.def"
 };
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -12845,6 +13304,24 @@
 	  return const0_rtx;
 	}
     }
+  else if (icode == CODE_FOR_dfptstsfi_eq_dd
+      || icode == CODE_FOR_dfptstsfi_lt_dd
+      || icode == CODE_FOR_dfptstsfi_gt_dd
+      || icode == CODE_FOR_dfptstsfi_unordered_dd
+      || icode == CODE_FOR_dfptstsfi_eq_td
+      || icode == CODE_FOR_dfptstsfi_lt_td
+      || icode == CODE_FOR_dfptstsfi_gt_td
+      || icode == CODE_FOR_dfptstsfi_unordered_td)
+    {
+      /* Only allow 6-bit unsigned literals.  */
+      STRIP_NOPS (arg0);
+      if (TREE_CODE (arg0) != INTEGER_CST
+	  || !IN_RANGE (TREE_INT_CST_LOW (arg0), 0, 63))
+	{
+	  error ("argument 1 must be a 6-bit unsigned literal");
+	  return CONST0_RTX (tmode);
+	}
+    }
 
   if (target == 0
       || GET_MODE (target) != tmode
@@ -14129,6 +14606,47 @@
     case VSX_BUILTIN_STXVW4X_V16QI:
       return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v16qi, exp);
 
+    /* For the following on big endian, it's ok to use any appropriate
+       unaligned-supporting store, so use a generic expander.  For
+       little-endian, the exact element-reversing instruction must
+       be used.  */
+    case VSX_BUILTIN_ST_ELEMREV_V2DF:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_store_v2df
+			       : CODE_FOR_vsx_st_elemrev_v2df);
+	return altivec_expand_stv_builtin (code, exp);
+      }
+    case VSX_BUILTIN_ST_ELEMREV_V2DI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_store_v2di
+			       : CODE_FOR_vsx_st_elemrev_v2di);
+	return altivec_expand_stv_builtin (code, exp);
+      }
+    case VSX_BUILTIN_ST_ELEMREV_V4SF:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_store_v4sf
+			       : CODE_FOR_vsx_st_elemrev_v4sf);
+	return altivec_expand_stv_builtin (code, exp);
+      }
+    case VSX_BUILTIN_ST_ELEMREV_V4SI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_store_v4si
+			       : CODE_FOR_vsx_st_elemrev_v4si);
+	return altivec_expand_stv_builtin (code, exp);
+      }
+    case VSX_BUILTIN_ST_ELEMREV_V8HI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_store_v8hi
+			       : CODE_FOR_vsx_st_elemrev_v8hi);
+	return altivec_expand_stv_builtin (code, exp);
+      }
+    case VSX_BUILTIN_ST_ELEMREV_V16QI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_store_v16qi
+			       : CODE_FOR_vsx_st_elemrev_v16qi);
+	return altivec_expand_stv_builtin (code, exp);
+      }
+
     case ALTIVEC_BUILTIN_MFVSCR:
       icode = CODE_FOR_altivec_mfvscr;
       tmode = insn_data[icode].operand[0].mode;
@@ -14323,6 +14841,46 @@
     case VSX_BUILTIN_LXVW4X_V16QI:
       return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v16qi,
 					exp, target, false);
+    /* For the following on big endian, it's ok to use any appropriate
+       unaligned-supporting load, so use a generic expander.  For
+       little-endian, the exact element-reversing instruction must
+       be used.  */
+    case VSX_BUILTIN_LD_ELEMREV_V2DF:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_load_v2df
+			       : CODE_FOR_vsx_ld_elemrev_v2df);
+	return altivec_expand_lv_builtin (code, exp, target, false);
+      }
+    case VSX_BUILTIN_LD_ELEMREV_V2DI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_load_v2di
+			       : CODE_FOR_vsx_ld_elemrev_v2di);
+	return altivec_expand_lv_builtin (code, exp, target, false);
+      }
+    case VSX_BUILTIN_LD_ELEMREV_V4SF:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_load_v4sf
+			       : CODE_FOR_vsx_ld_elemrev_v4sf);
+	return altivec_expand_lv_builtin (code, exp, target, false);
+      }
+    case VSX_BUILTIN_LD_ELEMREV_V4SI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_load_v4si
+			       : CODE_FOR_vsx_ld_elemrev_v4si);
+	return altivec_expand_lv_builtin (code, exp, target, false);
+      }
+    case VSX_BUILTIN_LD_ELEMREV_V8HI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_load_v8hi
+			       : CODE_FOR_vsx_ld_elemrev_v8hi);
+	return altivec_expand_lv_builtin (code, exp, target, false);
+      }
+    case VSX_BUILTIN_LD_ELEMREV_V16QI:
+      {
+	enum insn_code code = (BYTES_BIG_ENDIAN ? CODE_FOR_vsx_load_v16qi
+			       : CODE_FOR_vsx_ld_elemrev_v16qi);
+	return altivec_expand_lv_builtin (code, exp, target, false);
+      }
       break;
     default:
       break;
@@ -14792,17 +15350,71 @@
     error ("Builtin function %s requires the -mhard-dfp option", name);
   else if ((fnmask & RS6000_BTM_P8_VECTOR) != 0)
     error ("Builtin function %s requires the -mpower8-vector option", name);
+  else if ((fnmask & RS6000_BTM_P9_VECTOR) != 0)
+    error ("Builtin function %s requires the -mpower9-vector option", name);
+  else if ((fnmask & (RS6000_BTM_P9_MISC | RS6000_BTM_64BIT))
+	   == (RS6000_BTM_P9_MISC | RS6000_BTM_64BIT))
+    error ("Builtin function %s requires the -mpower9-misc and"
+	   " -m64 options", name);
+  else if ((fnmask & RS6000_BTM_P9_MISC) == RS6000_BTM_P9_MISC)
+    error ("Builtin function %s requires the -mpower9-misc option", name);
   else if ((fnmask & (RS6000_BTM_HARD_FLOAT | RS6000_BTM_LDBL128))
 	   == (RS6000_BTM_HARD_FLOAT | RS6000_BTM_LDBL128))
     error ("Builtin function %s requires the -mhard-float and"
 	   " -mlong-double-128 options", name);
   else if ((fnmask & RS6000_BTM_HARD_FLOAT) != 0)
     error ("Builtin function %s requires the -mhard-float option", name);
+  else if ((fnmask & RS6000_BTM_FLOAT128) != 0)
+    error ("Builtin function %s requires the -mfloat128 option", name);
   else
     error ("Builtin function %s is not supported with the current options",
 	   name);
 }
 
+/* Target hook for early folding of built-ins, shamelessly stolen
+   from ia64.c.  */
+
+static tree
+rs6000_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,
+		     tree *args, bool ignore ATTRIBUTE_UNUSED)
+{
+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)
+    {
+      enum rs6000_builtins fn_code
+	= (enum rs6000_builtins) DECL_FUNCTION_CODE (fndecl);
+      switch (fn_code)
+	{
+	case RS6000_BUILTIN_NANQ:
+	case RS6000_BUILTIN_NANSQ:
+	  {
+	    tree type = TREE_TYPE (TREE_TYPE (fndecl));
+	    const char *str = c_getstr (*args);
+	    int quiet = fn_code == RS6000_BUILTIN_NANQ;
+	    REAL_VALUE_TYPE real;
+
+	    if (str && real_nan (&real, str, quiet, TYPE_MODE (type)))
+	      return build_real (type, real);
+	    return NULL_TREE;
+	  }
+	case RS6000_BUILTIN_INFQ:
+	case RS6000_BUILTIN_HUGE_VALQ:
+	  {
+	    tree type = TREE_TYPE (TREE_TYPE (fndecl));
+	    REAL_VALUE_TYPE inf;
+	    real_inf (&inf);
+	    return build_real (type, inf);
+	  }
+	default:
+	  break;
+	}
+    }
+#ifdef SUBTARGET_FOLD_BUILTIN
+  return SUBTARGET_FOLD_BUILTIN (fndecl, n_args, args, ignore);
+#else
+  return NULL_TREE;
+#endif
+}
+
 /* Expand an expression EXP that calls a built-in function,
    with result going to TARGET if that's convenient
    (and in mode MODE if that's convenient).
@@ -14990,9 +15602,11 @@
     }  
 
   unsigned attr = rs6000_builtin_info[uns_fcode].attr & RS6000_BTC_TYPE_MASK;
+  /* RS6000_BTC_SPECIAL represents no-operand operators.  */
   gcc_assert (attr == RS6000_BTC_UNARY
 	      || attr == RS6000_BTC_BINARY
-	      || attr == RS6000_BTC_TERNARY);
+	      || attr == RS6000_BTC_TERNARY
+	      || attr == RS6000_BTC_SPECIAL);
 
   /* Handle simple unary operations.  */
   d = bdesc_1arg;
@@ -15012,6 +15626,12 @@
     if (d->code == fcode)
       return rs6000_expand_ternop_builtin (d->icode, exp, target);
 
+  /* Handle simple no-argument operations. */
+  d = bdesc_0arg;
+  for (i = 0; i < ARRAY_SIZE (bdesc_0arg); i++, d++)
+    if (d->code == fcode)
+      return rs6000_expand_zeroop_builtin (d->icode, target);
+
   gcc_unreachable ();
 }
 
@@ -15049,6 +15669,10 @@
   opaque_p_V2SI_type_node = build_pointer_type (opaque_V2SI_type_node);
   opaque_V4SI_type_node = build_opaque_vector_type (intSI_type_node, 4);
 
+  const_str_type_node
+    = build_pointer_type (build_qualified_type (char_type_node,
+						TYPE_QUAL_CONST));
+
   /* We use V1TI mode as a special container to hold __int128_t items that
      must live in VSX registers.  */
   if (intTI_type_node)
@@ -15111,6 +15735,12 @@
       lang_hooks.types.register_builtin_type (ibm128_float_type_node,
 					      "__ibm128");
     }
+  else
+    {
+      /* All types must be nonzero, or self-test barfs during bootstrap.  */
+      ieee128_float_type_node = long_double_type_node;
+      ibm128_float_type_node = long_double_type_node;
+    }
 
   /* Initialize the modes for builtin_function_type, mapping a machine mode to
      tree type node.  */
@@ -15252,6 +15882,15 @@
   if (TARGET_EXTRA_BUILTINS || TARGET_SPE || TARGET_PAIRED_FLOAT)
     rs6000_common_init_builtins ();
 
+  ftype = build_function_type_list (ieee128_float_type_node,
+				    const_str_type_node, NULL_TREE);
+  def_builtin ("__builtin_nanq", ftype, RS6000_BUILTIN_NANQ);
+  def_builtin ("__builtin_nansq", ftype, RS6000_BUILTIN_NANSQ);
+
+  ftype = build_function_type_list (ieee128_float_type_node, NULL_TREE);
+  def_builtin ("__builtin_infq", ftype, RS6000_BUILTIN_INFQ);
+  def_builtin ("__builtin_huge_valq", ftype, RS6000_BUILTIN_HUGE_VALQ);
+
   ftype = builtin_function_type (DFmode, DFmode, DFmode, VOIDmode,
 				 RS6000_BUILTIN_RECIP, "__builtin_recipdiv");
   def_builtin ("__builtin_recipdiv", ftype, RS6000_BUILTIN_RECIP);
@@ -15816,10 +16455,44 @@
 	       VSX_BUILTIN_STXVW4X_V8HI);
   def_builtin ("__builtin_vsx_stxvw4x_v16qi", void_ftype_v16qi_long_pvoid,
 	       VSX_BUILTIN_STXVW4X_V16QI);
+
+  def_builtin ("__builtin_vsx_ld_elemrev_v2df", v2df_ftype_long_pcvoid,
+	       VSX_BUILTIN_LD_ELEMREV_V2DF);
+  def_builtin ("__builtin_vsx_ld_elemrev_v2di", v2di_ftype_long_pcvoid,
+	       VSX_BUILTIN_LD_ELEMREV_V2DI);
+  def_builtin ("__builtin_vsx_ld_elemrev_v4sf", v4sf_ftype_long_pcvoid,
+	       VSX_BUILTIN_LD_ELEMREV_V4SF);
+  def_builtin ("__builtin_vsx_ld_elemrev_v4si", v4si_ftype_long_pcvoid,
+	       VSX_BUILTIN_LD_ELEMREV_V4SI);
+  def_builtin ("__builtin_vsx_st_elemrev_v2df", void_ftype_v2df_long_pvoid,
+	       VSX_BUILTIN_ST_ELEMREV_V2DF);
+  def_builtin ("__builtin_vsx_st_elemrev_v2di", void_ftype_v2di_long_pvoid,
+	       VSX_BUILTIN_ST_ELEMREV_V2DI);
+  def_builtin ("__builtin_vsx_st_elemrev_v4sf", void_ftype_v4sf_long_pvoid,
+	       VSX_BUILTIN_ST_ELEMREV_V4SF);
+  def_builtin ("__builtin_vsx_st_elemrev_v4si", void_ftype_v4si_long_pvoid,
+	       VSX_BUILTIN_ST_ELEMREV_V4SI);
+
+  if (TARGET_P9_VECTOR)
+    {
+      def_builtin ("__builtin_vsx_ld_elemrev_v8hi", v8hi_ftype_long_pcvoid,
+		   VSX_BUILTIN_LD_ELEMREV_V8HI);
+      def_builtin ("__builtin_vsx_ld_elemrev_v16qi", v16qi_ftype_long_pcvoid,
+		   VSX_BUILTIN_LD_ELEMREV_V16QI);
+      def_builtin ("__builtin_vsx_st_elemrev_v8hi",
+		   void_ftype_v8hi_long_pvoid, VSX_BUILTIN_ST_ELEMREV_V8HI);
+      def_builtin ("__builtin_vsx_st_elemrev_v16qi",
+		   void_ftype_v16qi_long_pvoid, VSX_BUILTIN_ST_ELEMREV_V16QI);
+    }
+
   def_builtin ("__builtin_vec_vsx_ld", opaque_ftype_long_pcvoid,
 	       VSX_BUILTIN_VEC_LD);
   def_builtin ("__builtin_vec_vsx_st", void_ftype_opaque_long_pvoid,
 	       VSX_BUILTIN_VEC_ST);
+  def_builtin ("__builtin_vec_xl", opaque_ftype_long_pcvoid,
+	       VSX_BUILTIN_VEC_XL);
+  def_builtin ("__builtin_vec_xst", void_ftype_opaque_long_pvoid,
+	       VSX_BUILTIN_VEC_XST);
 
   def_builtin ("__builtin_vec_step", int_ftype_opaque, ALTIVEC_BUILTIN_VEC_STEP);
   def_builtin ("__builtin_vec_splats", opaque_ftype_opaque, ALTIVEC_BUILTIN_VEC_SPLATS);
@@ -16351,10 +17024,6 @@
   while (num_args > 0 && h.mode[num_args] == VOIDmode)
     num_args--;
 
-  if (num_args == 0)
-    fatal_error (input_location,
-		 "internal error: builtin function %s had no type", name);
-
   ret_type = builtin_mode_to_type[h.mode[0]][h.uns_p[0]];
   if (!ret_type && h.uns_p[0])
     ret_type = builtin_mode_to_type[h.mode[0]][0];
@@ -16406,6 +17075,7 @@
   tree opaque_ftype_opaque = NULL_TREE;
   tree opaque_ftype_opaque_opaque = NULL_TREE;
   tree opaque_ftype_opaque_opaque_opaque = NULL_TREE;
+  tree v2si_ftype = NULL_TREE;
   tree v2si_ftype_qi = NULL_TREE;
   tree v2si_ftype_v2si_qi = NULL_TREE;
   tree v2si_ftype_int_qi = NULL_TREE;
@@ -16622,6 +17292,64 @@
 
       def_builtin (d->name, type, d->code);
     }
+
+  /* Add the simple no-argument operators.  */
+  d = bdesc_0arg;
+  for (i = 0; i < ARRAY_SIZE (bdesc_0arg); i++, d++)
+    {
+      machine_mode mode0;
+      tree type;
+      HOST_WIDE_INT mask = d->mask;
+
+      if ((mask & builtin_mask) != mask)
+	{
+	  if (TARGET_DEBUG_BUILTIN)
+	    fprintf (stderr, "rs6000_builtin, skip no-argument %s\n", d->name);
+	  continue;
+	}
+      if (rs6000_overloaded_builtin_p (d->code))
+	{
+	  if (!opaque_ftype_opaque)
+	    opaque_ftype_opaque
+	      = build_function_type_list (opaque_V4SI_type_node, NULL_TREE);
+	  type = opaque_ftype_opaque;
+	}
+      else
+	{
+	  enum insn_code icode = d->icode;
+	  if (d->name == 0)
+	    {
+	      if (TARGET_DEBUG_BUILTIN)
+		fprintf (stderr, "rs6000_builtin, bdesc_0arg[%lu] no name\n",
+			 (long unsigned) i);
+	      continue;
+	    }
+	  if (icode == CODE_FOR_nothing)
+	    {
+	      if (TARGET_DEBUG_BUILTIN)
+		fprintf (stderr,
+			 "rs6000_builtin, skip no-argument %s (no code)\n",
+			 d->name);
+	      continue;
+	    }
+	  mode0 = insn_data[icode].operand[0].mode;
+	  if (mode0 == V2SImode)
+	    {
+	      /* code for SPE */
+	      if (! (type = v2si_ftype))
+		{
+		  v2si_ftype
+		    = build_function_type_list (opaque_V2SI_type_node, 
+						NULL_TREE);
+		  type = v2si_ftype;
+		}
+	    }
+	  else
+	    type = builtin_function_type (mode0, VOIDmode, VOIDmode, VOIDmode,
+					  d->code, d->name);
+	}
+      def_builtin (d->name, type, d->code);
+    }
 }
 
 /* Set up AIX/Darwin/64-bit Linux quad floating point routines.  */
@@ -18006,25 +18734,33 @@
     addr_mask = (reg_addr[mode].addr_mask[RELOAD_REG_VMX]
 		 & ~RELOAD_REG_AND_M16);
 
-  else
+  /* If the register allocator hasn't made up its mind yet on the register
+     class to use, settle on defaults to use.  */
+  else if (rclass == NO_REGS)
     {
-      if (TARGET_DEBUG_ADDR)
-	fprintf (stderr,
-		 "rs6000_secondary_reload_memory: mode = %s, class = %s, "
-		 "class is not GPR, FPR, VMX\n",
-		 GET_MODE_NAME (mode), reg_class_names[rclass]);
+      addr_mask = (reg_addr[mode].addr_mask[RELOAD_REG_ANY]
+		   & ~RELOAD_REG_AND_M16);
 
-      return -1;
+      if ((addr_mask & RELOAD_REG_MULTIPLE) != 0)
+	addr_mask &= ~(RELOAD_REG_INDEXED
+		       | RELOAD_REG_PRE_INCDEC
+		       | RELOAD_REG_PRE_MODIFY);
     }
 
+  else
+    addr_mask = 0;
+
   /* If the register isn't valid in this register class, just return now.  */
   if ((addr_mask & RELOAD_REG_VALID) == 0)
     {
       if (TARGET_DEBUG_ADDR)
-	fprintf (stderr,
-		 "rs6000_secondary_reload_memory: mode = %s, class = %s, "
-		 "not valid in class\n",
-		 GET_MODE_NAME (mode), reg_class_names[rclass]);
+	{
+	  fprintf (stderr,
+		   "rs6000_secondary_reload_memory: mode = %s, class = %s, "
+		   "not valid in class\n",
+		   GET_MODE_NAME (mode), reg_class_names[rclass]);
+	  debug_rtx (addr);
+	}
 
       return -1;
     }
@@ -18152,13 +18888,23 @@
 	    }
 	}
 
+      else if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0
+	       && CONST_INT_P (plus_arg1))
+	{
+	  if (!quad_address_offset_p (INTVAL (plus_arg1)))
+	    {
+	      extra_cost = 1;
+	      type = "vector d-form offset";
+	    }
+	}
+
       /* Make sure the register class can handle offset addresses.  */
       else if (rs6000_legitimate_offset_address_p (mode, addr, false, true))
 	{
 	  if ((addr_mask & RELOAD_REG_OFFSET) == 0)
 	    {
 	      extra_cost = 1;
-	      type = "offset";
+	      type = "offset #2";
 	    }
 	}
 
@@ -18171,7 +18917,14 @@
       break;
 
     case LO_SUM:
-      if (!legitimate_lo_sum_address_p (mode, addr, false))
+      /* Quad offsets are restricted and can't handle normal addresses.  */
+      if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0)
+	{
+	  extra_cost = -1;
+	  type = "vector d-form lo_sum";
+	}
+
+      else if (!legitimate_lo_sum_address_p (mode, addr, false))
 	{
 	  fail_msg = "bad LO_SUM";
 	  extra_cost = -1;
@@ -18188,8 +18941,17 @@
     case CONST:
     case SYMBOL_REF:
     case LABEL_REF:
-      type = "address";
-      extra_cost = rs6000_secondary_reload_toc_costs (addr_mask);
+      if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0)
+	{
+	  extra_cost = -1;
+	  type = "vector d-form lo_sum #2";
+	}
+
+      else
+	{
+	  type = "address";
+	  extra_cost = rs6000_secondary_reload_toc_costs (addr_mask);
+	}
       break;
 
       /* TOC references look like offsetable memory.  */
@@ -18200,6 +18962,12 @@
 	  extra_cost = -1;
 	}
 
+      else if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0)
+	{
+	  extra_cost = -1;
+	  type = "vector d-form lo_sum #3";
+	}
+
       else if ((addr_mask & RELOAD_REG_OFFSET) == 0)
 	{
 	  extra_cost = 1;
@@ -18256,7 +19024,8 @@
      simple move insns are issued.  At present, 32-bit integers are not allowed
      in FPR/VSX registers.  Single precision binary floating is not a simple
      move because we need to convert to the single precision memory layout.
-     The 4-byte SDmode can be moved.  */
+     The 4-byte SDmode can be moved.  TDmode values are disallowed since they
+     need special direct move handling, which we do not support yet.  */
   size = GET_MODE_SIZE (mode);
   if (TARGET_DIRECT_MOVE
       && ((mode == SDmode) || (TARGET_POWERPC64 && size == 8))
@@ -18264,7 +19033,7 @@
 	  || (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)))
     return true;
 
-  else if (TARGET_DIRECT_MOVE_128 && size == 16
+  else if (TARGET_DIRECT_MOVE_128 && size == 16 && mode != TDmode
 	   && ((to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)
 	       || (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)))
     return true;
@@ -18653,6 +19422,9 @@
 	fprintf (stderr, ", reload func = %s, extra cost = %d",
 		 insn_data[sri->icode].name, sri->extra_cost);
 
+      else if (sri->extra_cost > 0)
+	fprintf (stderr, ", extra cost = %d", sri->extra_cost);
+
       fputs ("\n", stderr);
       debug_rtx (x);
     }
@@ -18827,6 +19599,16 @@
 	    }
 	}
 
+      else if (mode_supports_vsx_dform_quad (mode) && CONST_INT_P (op1))
+	{
+	  if (((addr_mask & RELOAD_REG_QUAD_OFFSET) == 0)
+	      || !quad_address_p (addr, mode, false))
+	    {
+	      emit_insn (gen_rtx_SET (scratch, addr));
+	      new_addr = scratch;
+	    }
+	}
+
       /* Make sure the register class can handle offset addresses.  */
       else if (rs6000_legitimate_offset_address_p (mode, addr, false, true))
 	{
@@ -18857,6 +19639,13 @@
 	    }
 	}
 
+      /* Quad offsets are restricted and can't handle normal addresses.  */
+      else if (mode_supports_vsx_dform_quad (mode))
+	{
+	  emit_insn (gen_rtx_SET (scratch, addr));
+	  new_addr = scratch;
+	}
+
       /* Make sure the register class can handle offset addresses.  */
       else if (legitimate_lo_sum_address_p (mode, addr, false))
 	{
@@ -19046,6 +19835,16 @@
   machine_mode mode = GET_MODE (x);
   bool is_constant = CONSTANT_P (x);
 
+  /* If a mode can't go in FPR/ALTIVEC/VSX registers, don't return a preferred
+     reload class for it.  */
+  if ((rclass == ALTIVEC_REGS || rclass == VSX_REGS)
+      && (reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_VALID) == 0)
+    return NO_REGS;
+
+  if ((rclass == FLOAT_REGS || rclass == VSX_REGS)
+      && (reg_addr[mode].addr_mask[RELOAD_REG_FPR] & RELOAD_REG_VALID) == 0)
+    return NO_REGS;
+
   /* For VSX, see if we should prefer FLOAT_REGS or ALTIVEC_REGS.  Do not allow
      the reloading of address expressions using PLUS into floating point
      registers.  */
@@ -19067,7 +19866,8 @@
 	}
 
       /* D-form addressing can easily reload the value.  */
-      if (mode_supports_vmx_dform (mode))
+      if (mode_supports_vmx_dform (mode)
+	  || mode_supports_vsx_dform_quad (mode))
 	return rclass;
 
       /* If this is a scalar floating point value and we don't have D-form
@@ -19095,6 +19895,25 @@
       return NO_REGS;
     }
 
+  /* If we haven't picked a register class, and the type is a vector or
+     floating point type, prefer to use the VSX, FPR, or Altivec register
+     classes.  */
+  if (rclass == NO_REGS)
+    {
+      if (TARGET_VSX && VECTOR_MEM_VSX_OR_P8_VECTOR_P (mode))
+	return VSX_REGS;
+
+      if (TARGET_ALTIVEC && VECTOR_MEM_ALTIVEC_P (mode))
+	return ALTIVEC_REGS;
+
+      if (DECIMAL_FLOAT_MODE_P (mode))
+	return TARGET_DFP ? FLOAT_REGS : NO_REGS;
+
+      if (TARGET_FPRS && TARGET_HARD_FLOAT && FLOAT_MODE_P (mode)
+	  && (reg_addr[mode].addr_mask[RELOAD_REG_FPR] & RELOAD_REG_VALID) == 0)
+	return FLOAT_REGS;
+    }
+
   if (GET_MODE_CLASS (mode) == MODE_INT && rclass == NON_SPECIAL_REGS)
     return GENERAL_REGS;
 
@@ -19483,8 +20302,16 @@
 
       else if (TARGET_VSX && dest_vsx_p)
 	{
-	  if (mode == V16QImode || mode == V8HImode || mode == V4SImode)
+	  if (mode_supports_vsx_dform_quad (mode)
+	      && quad_address_p (XEXP (src, 0), mode, true))
+	    return "lxv %x0,%1";
+
+	  else if (TARGET_P9_VECTOR)
+	    return "lxvx %x0,%y1";
+
+	  else if (mode == V16QImode || mode == V8HImode || mode == V4SImode)
 	    return "lxvw4x %x0,%y1";
+
 	  else
 	    return "lxvd2x %x0,%y1";
 	}
@@ -19513,8 +20340,16 @@
 
       else if (TARGET_VSX && src_vsx_p)
 	{
-	  if (mode == V16QImode || mode == V8HImode || mode == V4SImode)
+	  if (mode_supports_vsx_dform_quad (mode)
+	      && quad_address_p (XEXP (dest, 0), mode, true))
+	    return "stxv %x1,%0";
+
+	  else if (TARGET_P9_VECTOR)
+	    return "stxvx %x1,%y0";
+
+	  else if (mode == V16QImode || mode == V8HImode || mode == V4SImode)
 	    return "stxvw4x %x1,%y0";
+
 	  else
 	    return "stxvd2x %x1,%y0";
 	}
@@ -19536,10 +20371,8 @@
       if (dest_gpr_p)
 	return "#";
 
-      else if (TARGET_VSX && dest_vsx_p && zero_constant (src, mode))
-	return "xxlxor %x0,%x0,%x0";
-
-      else if (TARGET_ALTIVEC && dest_vmx_p)
+      else if ((dest_vmx_p && TARGET_ALTIVEC)
+	       || (dest_vsx_p && TARGET_VSX))
 	return output_vec_const_move (operands);
     }
 
@@ -21747,6 +22580,101 @@
   return 1;
 }
 
+/* ISA 3.0 (power9) minmax subcase to emit a XSMAXCDP or XSMINCDP instruction
+   for SF/DF scalars.  Move TRUE_COND to DEST if OP of the operands of the last
+   comparison is nonzero/true, FALSE_COND if it is zero/false.  Return 0 if the
+   hardware has no such operation.  */
+
+static int
+rs6000_emit_p9_fp_minmax (rtx dest, rtx op, rtx true_cond, rtx false_cond)
+{
+  enum rtx_code code = GET_CODE (op);
+  rtx op0 = XEXP (op, 0);
+  rtx op1 = XEXP (op, 1);
+  machine_mode compare_mode = GET_MODE (op0);
+  machine_mode result_mode = GET_MODE (dest);
+  bool max_p = false;
+
+  if (result_mode != compare_mode)
+    return 0;
+
+  if (code == GE || code == GT)
+    max_p = true;
+  else if (code == LE || code == LT)
+    max_p = false;
+  else
+    return 0;
+
+  if (rtx_equal_p (op0, true_cond) && rtx_equal_p (op1, false_cond))
+    ;
+
+  else if (rtx_equal_p (op1, true_cond) && rtx_equal_p (op0, false_cond))
+    max_p = !max_p;
+
+  else
+    return 0;
+
+  rs6000_emit_minmax (dest, max_p ? SMAX : SMIN, op0, op1);
+  return 1;
+}
+
+/* ISA 3.0 (power9) conditional move subcase to emit XSCMP{EQ,GE,GT,NE}DP and
+   XXSEL instructions for SF/DF scalars.  Move TRUE_COND to DEST if OP of the
+   operands of the last comparison is nonzero/true, FALSE_COND if it is
+   zero/false.  Return 0 if the hardware has no such operation.  */
+
+static int
+rs6000_emit_p9_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)
+{
+  enum rtx_code code = GET_CODE (op);
+  rtx op0 = XEXP (op, 0);
+  rtx op1 = XEXP (op, 1);
+  machine_mode result_mode = GET_MODE (dest);
+  rtx compare_rtx;
+  rtx cmove_rtx;
+  rtx clobber_rtx;
+
+  if (!can_create_pseudo_p ())
+    return 0;
+
+  switch (code)
+    {
+    case EQ:
+    case GE:
+    case GT:
+      break;
+
+    case NE:
+    case LT:
+    case LE:
+      code = swap_condition (code);
+      std::swap (op0, op1);
+      break;
+
+    default:
+      return 0;
+    }
+
+  /* Generate:	[(parallel [(set (dest)
+				 (if_then_else (op (cmp1) (cmp2))
+					       (true)
+					       (false)))
+			    (clobber (scratch))])].  */
+
+  compare_rtx = gen_rtx_fmt_ee (code, CCFPmode, op0, op1);
+  cmove_rtx = gen_rtx_SET (dest,
+			   gen_rtx_IF_THEN_ELSE (result_mode,
+						 compare_rtx,
+						 true_cond,
+						 false_cond));
+
+  clobber_rtx = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (V2DImode));
+  emit_insn (gen_rtx_PARALLEL (VOIDmode,
+			       gen_rtvec (2, cmove_rtx, clobber_rtx)));
+
+  return 1;
+}
+
 /* Emit a conditional move: move TRUE_COND to DEST if OP of the
    operands of the last comparison is nonzero/true, FALSE_COND if it
    is zero/false.  Return 0 if the hardware has no such operation.  */
@@ -21773,6 +22701,18 @@
   if (GET_MODE (false_cond) != result_mode)
     return 0;
 
+  /* See if we can use the ISA 3.0 (power9) min/max/compare functions.  */
+  if (TARGET_P9_MINMAX
+      && (compare_mode == SFmode || compare_mode == DFmode)
+      && (result_mode == SFmode || result_mode == DFmode))
+    {
+      if (rs6000_emit_p9_fp_minmax (dest, op, true_cond, false_cond))
+	return 1;
+
+      if (rs6000_emit_p9_fp_cmove (dest, op, true_cond, false_cond))
+	return 1;
+    }
+
   /* Don't allow using floating point comparisons for integer results for
      now.  */
   if (FLOAT_MODE_P (compare_mode) && !FLOAT_MODE_P (result_mode))
@@ -22034,6 +22974,48 @@
     emit_move_insn (dest, target);
 }
 
+/* Split a signbit operation on 64-bit machines with direct move.  Also allow
+   for the value to come from memory or if it is already loaded into a GPR.  */
+
+void
+rs6000_split_signbit (rtx dest, rtx src)
+{
+  machine_mode d_mode = GET_MODE (dest);
+  machine_mode s_mode = GET_MODE (src);
+  rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);
+  rtx shift_reg = dest_di;
+
+  gcc_assert (REG_P (dest));
+  gcc_assert (REG_P (src) || MEM_P (src));
+  gcc_assert (s_mode == KFmode || s_mode == TFmode);
+
+  if (MEM_P (src))
+    {
+      rtx mem = (WORDS_BIG_ENDIAN
+		 ? adjust_address (src, DImode, 0)
+		 : adjust_address (src, DImode, 8));
+      emit_insn (gen_rtx_SET (dest_di, mem));
+    }
+
+  else
+    {
+      unsigned int r = REGNO (src);
+
+      /* If this is a VSX register, generate the special mfvsrd instruction
+	 to get it in a GPR.  Until we support SF and DF modes, that will
+	 always be true.  */
+      gcc_assert (VSX_REGNO_P (r));
+
+      if (s_mode == KFmode)
+	emit_insn (gen_signbitkf2_dm2 (dest_di, src));
+      else
+	emit_insn (gen_signbittf2_dm2 (dest_di, src));
+    }
+
+  emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));
+  return;
+}
+
 /* A subroutine of the atomic operation splitters.  Jump to LABEL if
    COND is true.  Mark the jump as unlikely to be taken.  */
 
@@ -25949,25 +26931,37 @@
 	if (info->vrsave_mask & ALTIVEC_REG_BIT (i))
 	  {
 	    rtx areg, savereg, mem;
-	    int offset;
+	    HOST_WIDE_INT offset;
 
 	    offset = (info->altivec_save_offset + frame_off
 		      + 16 * (i - info->first_altivec_reg_save));
 
 	    savereg = gen_rtx_REG (V4SImode, i);
 
-	    NOT_INUSE (0);
-	    areg = gen_rtx_REG (Pmode, 0);
-	    emit_move_insn (areg, GEN_INT (offset));
-
-	    /* AltiVec addressing mode is [reg+reg].  */
-	    mem = gen_frame_mem (V4SImode,
-				 gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));
-
-	    /* Rather than emitting a generic move, force use of the stvx
-	       instruction, which we always want.  In particular we don't
-	       want xxpermdi/stxvd2x for little endian.  */
-	    insn = emit_insn (gen_altivec_stvx_v4si_internal (mem, savereg));
+	    if (TARGET_P9_DFORM_VECTOR && quad_address_offset_p (offset))
+	      {
+		mem = gen_frame_mem (V4SImode,
+				     gen_rtx_PLUS (Pmode, frame_reg_rtx,
+						   GEN_INT (offset)));
+		insn = emit_insn (gen_rtx_SET (mem, savereg));
+		areg = NULL_RTX;
+	      }
+	    else
+	      {
+		NOT_INUSE (0);
+		areg = gen_rtx_REG (Pmode, 0);
+		emit_move_insn (areg, GEN_INT (offset));
+
+		/* AltiVec addressing mode is [reg+reg].  */
+		mem = gen_frame_mem (V4SImode,
+				     gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));
+
+		/* Rather than emitting a generic move, force use of the stvx
+		   instruction, which we always want on ISA 2.07 (power8) systems.
+		   In particular we don't want xxpermdi/stxvd2x for little
+		   endian.  */
+		insn = emit_insn (gen_altivec_stvx_v4si_internal (mem, savereg));
+	      }
 
 	    rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,
 				  areg, GEN_INT (offset));
@@ -26687,23 +27681,35 @@
 	  for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)
 	    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))
 	      {
-		rtx addr, areg, mem, reg;
+		rtx addr, areg, mem, insn;
+		rtx reg = gen_rtx_REG (V4SImode, i);
+		HOST_WIDE_INT offset
+		  = (info->altivec_save_offset + frame_off
+		     + 16 * (i - info->first_altivec_reg_save));
 
-		areg = gen_rtx_REG (Pmode, 0);
-		emit_move_insn
-		  (areg, GEN_INT (info->altivec_save_offset
-				  + frame_off
-				  + 16 * (i - info->first_altivec_reg_save)));
+		if (TARGET_P9_DFORM_VECTOR && quad_address_offset_p (offset))
+		  {
+		    mem = gen_frame_mem (V4SImode,
+					 gen_rtx_PLUS (Pmode, frame_reg_rtx,
+						       GEN_INT (offset)));
+		    insn = gen_rtx_SET (reg, mem);
+		  }
+		else
+		  {
+		    areg = gen_rtx_REG (Pmode, 0);
+		    emit_move_insn (areg, GEN_INT (offset));
 
-		/* AltiVec addressing mode is [reg+reg].  */
-		addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);
-		mem = gen_frame_mem (V4SImode, addr);
+		    /* AltiVec addressing mode is [reg+reg].  */
+		    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);
+		    mem = gen_frame_mem (V4SImode, addr);
+
+		    /* Rather than emitting a generic move, force use of the
+		       lvx instruction, which we always want.  In particular we
+		       don't want lxvd2x/xxpermdi for little endian.  */
+		    insn = gen_altivec_lvx_v4si_internal (reg, mem);
+		  }
 
-		reg = gen_rtx_REG (V4SImode, i);
-		/* Rather than emitting a generic move, force use of the
-		   lvx instruction, which we always want.  In particular
-		   we don't want lxvd2x/xxpermdi for little endian.  */
-		(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));
+		(void) emit_insn (insn);
 	      }
 	}
 
@@ -26890,23 +27896,35 @@
 	  for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)
 	    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))
 	      {
-		rtx addr, areg, mem, reg;
+		rtx addr, areg, mem, insn;
+		rtx reg = gen_rtx_REG (V4SImode, i);
+		HOST_WIDE_INT offset
+		  = (info->altivec_save_offset + frame_off
+		     + 16 * (i - info->first_altivec_reg_save));
 
-		areg = gen_rtx_REG (Pmode, 0);
-		emit_move_insn
-		  (areg, GEN_INT (info->altivec_save_offset
-				  + frame_off
-				  + 16 * (i - info->first_altivec_reg_save)));
+		if (TARGET_P9_DFORM_VECTOR && quad_address_offset_p (offset))
+		  {
+		    mem = gen_frame_mem (V4SImode,
+					 gen_rtx_PLUS (Pmode, frame_reg_rtx,
+						       GEN_INT (offset)));
+		    insn = gen_rtx_SET (reg, mem);
+		  }
+		else
+		  {
+		    areg = gen_rtx_REG (Pmode, 0);
+		    emit_move_insn (areg, GEN_INT (offset));
 
-		/* AltiVec addressing mode is [reg+reg].  */
-		addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);
-		mem = gen_frame_mem (V4SImode, addr);
+		    /* AltiVec addressing mode is [reg+reg].  */
+		    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);
+		    mem = gen_frame_mem (V4SImode, addr);
+
+		    /* Rather than emitting a generic move, force use of the
+		       lvx instruction, which we always want.  In particular we
+		       don't want lxvd2x/xxpermdi for little endian.  */
+		    insn = gen_altivec_lvx_v4si_internal (reg, mem);
+		  }
 
-		reg = gen_rtx_REG (V4SImode, i);
-		/* Rather than emitting a generic move, force use of the
-		   lvx instruction, which we always want.  In particular
-		   we don't want lxvd2x/xxpermdi for little endian.  */
-		(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));
+		(void) emit_insn (insn);
 	      }
 	}
 
@@ -27724,6 +28742,11 @@
 				   const0_rtx, const0_rtx));
   call_fusage = NULL_RTX;
   use_reg (&call_fusage, r12);
+  /* Say the call uses r0, even though it doesn't, to stop regrename
+     from twiddling with the insns saving lr, trashing args for cfun.
+     The insns restoring lr are similarly protected by making
+     split_stack_return use r0.  */
+  use_reg (&call_fusage, r0);
   add_function_usage_to (insn, call_fusage);
   emit_insn (gen_frame_load (r0, r1, info->lr_save_offset));
   insn = emit_move_insn (lr, r0);
@@ -28763,13 +29786,20 @@
 
 /* The following variable value is the last issued insn.  */
 
-static rtx last_scheduled_insn;
+static rtx_insn *last_scheduled_insn;
 
 /* The following variable helps to balance issuing of load and
    store instructions */
 
 static int load_store_pendulum;
 
+/* The following variable helps pair divide insns during scheduling.  */
+static int divide_cnt;
+/* The following variable helps pair and alternate vector and vector load
+   insns during scheduling.  */
+static int vec_load_pendulum;
+
+
 /* Power4 load update and store update instructions are cracked into a
    load or store and an integer insn which are executed in the same cycle.
    Branches have their own dispatch slot which does not count against the
@@ -28844,7 +29874,7 @@
 	   some cycles later.  */
 
 	/* Separate a load from a narrower, dependent store.  */
-	if (rs6000_sched_groups
+	if ((rs6000_sched_groups || rs6000_cpu_attr == CPU_POWER9)
 	    && GET_CODE (PATTERN (insn)) == SET
 	    && GET_CODE (PATTERN (dep_insn)) == SET
 	    && GET_CODE (XEXP (PATTERN (insn), 1)) == MEM
@@ -29070,7 +30100,9 @@
           switch (attr_type)
             {
             case TYPE_FP:
-              if (get_attr_type (dep_insn) == TYPE_FP)
+            case TYPE_FPSIMPLE:
+              if (get_attr_type (dep_insn) == TYPE_FP
+		  || get_attr_type (dep_insn) == TYPE_FPSIMPLE)
                 return 1;
               break;
             case TYPE_FPLOAD:
@@ -29082,6 +30114,8 @@
               break;
             }
         }
+      /* Fall through, no cost for output dependency.  */
+
     case REG_DEP_ANTI:
       /* Anti dependency; DEP_INSN reads a register that INSN writes some
 	 cycles later.  */
@@ -29454,8 +30488,9 @@
   case CPU_POWER7:
     return 5;
   case CPU_POWER8:
-  case CPU_POWER9:
     return 7;
+  case CPU_POWER9:
+    return 6;
   default:
     return 1;
   }
@@ -29613,6 +30648,28 @@
   return is_store_insn1 (PATTERN (insn), str_mem);
 }
 
+/* Return whether TYPE is a Power9 pairable vector instruction type.  */
+
+static bool
+is_power9_pairable_vec_type (enum attr_type type)
+{
+  switch (type)
+    {
+      case TYPE_VECSIMPLE:
+      case TYPE_VECCOMPLEX:
+      case TYPE_VECDIV:
+      case TYPE_VECCMP:
+      case TYPE_VECPERM:
+      case TYPE_VECFLOAT:
+      case TYPE_VECFDIV:
+      case TYPE_VECDOUBLE:
+	return true;
+      default:
+	break;
+    }
+  return false;
+}
+
 /* Returns whether the dependence between INSN and NEXT is considered
    costly by the given target.  */
 
@@ -29689,6 +30746,229 @@
   return insn;
 }
 
+/* Do Power9 specific sched_reorder2 reordering of ready list.  */
+
+static int
+power9_sched_reorder2 (rtx_insn **ready, int lastpos)
+{
+  int pos;
+  int i;
+  rtx_insn *tmp;
+  enum attr_type type;
+
+  type = get_attr_type (last_scheduled_insn);
+
+  /* Try to issue fixed point divides back-to-back in pairs so they will be
+     routed to separate execution units and execute in parallel.  */
+  if (type == TYPE_DIV && divide_cnt == 0)
+    {
+      /* First divide has been scheduled.  */
+      divide_cnt = 1;
+
+      /* Scan the ready list looking for another divide, if found move it
+	 to the end of the list so it is chosen next.  */
+      pos = lastpos;
+      while (pos >= 0)
+	{
+	  if (recog_memoized (ready[pos]) >= 0
+	      && get_attr_type (ready[pos]) == TYPE_DIV)
+	    {
+	      tmp = ready[pos];
+	      for (i = pos; i < lastpos; i++)
+		ready[i] = ready[i + 1];
+	      ready[lastpos] = tmp;
+	      break;
+	    }
+	  pos--;
+	}
+    }
+  else
+    {
+      /* Last insn was the 2nd divide or not a divide, reset the counter.  */
+      divide_cnt = 0;
+
+      /* Power9 can execute 2 vector operations and 2 vector loads in a single
+	 cycle.  So try to pair up and alternate groups of vector and vector
+	 load instructions.
+
+	 To aid this formation, a counter is maintained to keep track of
+	 vec/vecload insns issued.  The value of vec_load_pendulum maintains
+	 the current state with the following values:
+
+	     0  : Initial state, no vec/vecload group has been started.
+
+	     -1 : 1 vector load has been issued and another has been found on
+		  the ready list and moved to the end.
+
+	     -2 : 2 vector loads have been issued and a vector operation has
+		  been found and moved to the end of the ready list.
+
+	     -3 : 2 vector loads and a vector insn have been issued and a
+		  vector operation has been found and moved to the end of the
+		  ready list.
+
+	     1  : 1 vector insn has been issued and another has been found and
+		  moved to the end of the ready list.
+
+	     2  : 2 vector insns have been issued and a vector load has been
+		  found and moved to the end of the ready list.
+
+	     3  : 2 vector insns and a vector load have been issued and another
+		  vector load has been found and moved to the end of the ready
+		  list.	 */
+      if (type == TYPE_VECLOAD)
+	{
+	  /* Issued a vecload.  */
+	  if (vec_load_pendulum == 0)
+	    {
+	      /* We issued a single vecload, look for another and move it to
+		 the end of the ready list so it will be scheduled next.
+		 Set pendulum if found.  */
+	      pos = lastpos;
+	      while (pos >= 0)
+		{
+		  if (recog_memoized (ready[pos]) >= 0
+		      && get_attr_type (ready[pos]) == TYPE_VECLOAD)
+		    {
+		      tmp = ready[pos];
+		      for (i = pos; i < lastpos; i++)
+			ready[i] = ready[i + 1];
+		      ready[lastpos] = tmp;
+		      vec_load_pendulum = -1;
+		      return cached_can_issue_more;
+		    }
+		  pos--;
+		}
+	    }
+	  else if (vec_load_pendulum == -1)
+	    {
+	      /* This is the second vecload we've issued, search the ready
+	         list for a vector operation so we can try to schedule a
+	         pair of those next.  If found move to the end of the ready
+	         list so it is scheduled next and set the pendulum.  */
+	      pos = lastpos;
+	      while (pos >= 0)
+		{
+		  if (recog_memoized (ready[pos]) >= 0
+		      && is_power9_pairable_vec_type (
+			   get_attr_type (ready[pos])))
+		    {
+		      tmp = ready[pos];
+		      for (i = pos; i < lastpos; i++)
+			ready[i] = ready[i + 1];
+		      ready[lastpos] = tmp;
+		      vec_load_pendulum = -2;
+		      return cached_can_issue_more;
+		    }
+		  pos--;
+		}
+	    }
+	  else if (vec_load_pendulum == 2)
+	    {
+	      /* Two vector ops have been issued and we've just issued a
+		 vecload, look for another vecload and move to end of ready
+		 list if found.  */
+	      pos = lastpos;
+	      while (pos >= 0)
+	        {
+		  if (recog_memoized (ready[pos]) >= 0
+		      && get_attr_type (ready[pos]) == TYPE_VECLOAD)
+		    {
+		      tmp = ready[pos];
+		      for (i = pos; i < lastpos; i++)
+			ready[i] = ready[i + 1];
+		      ready[lastpos] = tmp;
+		      /* Set pendulum so that next vecload will be seen as
+			 finishing a group, not start of one.  */
+		      vec_load_pendulum = 3;
+		      return cached_can_issue_more;
+		    }
+		  pos--;
+		}
+	    }
+	}
+      else if (is_power9_pairable_vec_type (type))
+	{
+	  /* Issued a vector operation.  */
+	  if (vec_load_pendulum == 0)
+	    /* We issued a single vec op, look for another and move it
+	       to the end of the ready list so it will be scheduled next.
+	       Set pendulum if found.  */
+	    {
+	      pos = lastpos;
+	      while (pos >= 0)
+		{
+		  if (recog_memoized (ready[pos]) >= 0
+		      && is_power9_pairable_vec_type (
+			   get_attr_type (ready[pos])))
+		    {
+		      tmp = ready[pos];
+		      for (i = pos; i < lastpos; i++)
+			ready[i] = ready[i + 1];
+		      ready[lastpos] = tmp;
+		      vec_load_pendulum = 1;
+		      return cached_can_issue_more;
+		    }
+		  pos--;
+		}
+	    }
+	  else if (vec_load_pendulum == 1)
+	    {
+	      /* This is the second vec op we've issued, search the ready
+		 list for a vecload operation so we can try to schedule a
+		 pair of those next.  If found move to the end of the ready
+		 list so it is scheduled next and set the pendulum.  */
+	      pos = lastpos;
+	      while (pos >= 0)
+		{
+		  if (recog_memoized (ready[pos]) >= 0
+		      && get_attr_type (ready[pos]) == TYPE_VECLOAD)
+		    {
+		      tmp = ready[pos];
+		      for (i = pos; i < lastpos; i++)
+			ready[i] = ready[i + 1];
+		      ready[lastpos] = tmp;
+		      vec_load_pendulum = 2;
+		      return cached_can_issue_more;
+		    }
+		  pos--;
+		}
+	    }
+	  else if (vec_load_pendulum == -2)
+	    {
+	      /* Two vecload ops have been issued and we've just issued a
+		 vec op, look for another vec op and move to end of ready
+	  	 list if found.  */
+	      pos = lastpos;
+	      while (pos >= 0)
+		{
+		  if (recog_memoized (ready[pos]) >= 0
+		      && is_power9_pairable_vec_type (
+			   get_attr_type (ready[pos])))
+		    {
+		      tmp = ready[pos];
+		      for (i = pos; i < lastpos; i++)
+			ready[i] = ready[i + 1];
+		      ready[lastpos] = tmp;
+		      /* Set pendulum so that next vec op will be seen as
+			 finishing a group, not start of one.  */
+		      vec_load_pendulum = -3;
+		      return cached_can_issue_more;
+		    }
+		  pos--;
+		}
+	    }
+	}
+
+      /* We've either finished a vec/vecload group, couldn't find an insn to
+	 continue the current group, or the last insn had nothing to do with
+	 with a group.  In any case, reset the pendulum.  */
+      vec_load_pendulum = 0;
+    }
+
+  return cached_can_issue_more;
+}
+
 /* We are about to begin issuing insns for this clock cycle. */
 
 static int
@@ -29920,6 +31200,11 @@
         }
     }
 
+  /* Do Power9 dependent reordering if necessary.  */
+  if (rs6000_cpu == PROCESSOR_POWER9 && last_scheduled_insn
+      && recog_memoized (last_scheduled_insn) >= 0)
+    return power9_sched_reorder2 (ready, *pn_ready - 1);
+
   return cached_can_issue_more;
 }
 
@@ -30088,7 +31373,6 @@
         }
       break;
     case PROCESSOR_POWER8:
-    case PROCESSOR_POWER9:
       type = get_attr_type (insn);
 
       switch (type)
@@ -30219,7 +31503,6 @@
     }
     break;
   case PROCESSOR_POWER8:
-  case PROCESSOR_POWER9:
     type = get_attr_type (insn);
 
     switch (type)
@@ -30338,7 +31621,7 @@
 
       /* Do we have a special group ending nop? */
       if (rs6000_cpu_attr == CPU_POWER6 || rs6000_cpu_attr == CPU_POWER7
-	  || rs6000_cpu_attr == CPU_POWER8 || rs6000_cpu_attr == CPU_POWER9)
+	  || rs6000_cpu_attr == CPU_POWER8)
 	{
 	  nop = gen_group_ending_nop ();
 	  emit_insn_before (nop, next_insn);
@@ -30592,8 +31875,10 @@
 		     int sched_verbose ATTRIBUTE_UNUSED,
 		     int max_ready ATTRIBUTE_UNUSED)
 {
-  last_scheduled_insn = NULL_RTX;
+  last_scheduled_insn = NULL;
   load_store_pendulum = 0;
+  divide_cnt = 0;
+  vec_load_pendulum = 0;
 }
 
 /* The following function is called at the end of scheduling BB.
@@ -30634,14 +31919,16 @@
     }
 }
 
-struct _rs6000_sched_context
+struct rs6000_sched_context
 {
   short cached_can_issue_more;
-  rtx last_scheduled_insn;
+  rtx_insn *last_scheduled_insn;
   int load_store_pendulum;
+  int divide_cnt;
+  int vec_load_pendulum;
 };
 
-typedef struct _rs6000_sched_context rs6000_sched_context_def;
+typedef struct rs6000_sched_context rs6000_sched_context_def;
 typedef rs6000_sched_context_def *rs6000_sched_context_t;
 
 /* Allocate store for new scheduling context.  */
@@ -30661,14 +31948,18 @@
   if (clean_p)
     {
       sc->cached_can_issue_more = 0;
-      sc->last_scheduled_insn = NULL_RTX;
+      sc->last_scheduled_insn = NULL;
       sc->load_store_pendulum = 0;
+      sc->divide_cnt = 0;
+      sc->vec_load_pendulum = 0;
     }
   else
     {
       sc->cached_can_issue_more = cached_can_issue_more;
       sc->last_scheduled_insn = last_scheduled_insn;
       sc->load_store_pendulum = load_store_pendulum;
+      sc->divide_cnt = divide_cnt;
+      sc->vec_load_pendulum = vec_load_pendulum;
     }
 }
 
@@ -30683,6 +31974,8 @@
   cached_can_issue_more = sc->cached_can_issue_more;
   last_scheduled_insn = sc->last_scheduled_insn;
   load_store_pendulum = sc->load_store_pendulum;
+  divide_cnt = sc->divide_cnt;
+  vec_load_pendulum = sc->vec_load_pendulum;
 }
 
 /* Free _SC.  */
@@ -33448,17 +34741,25 @@
   if (!REG_P (target))
     tmp = gen_reg_rtx (mode);
 
-  /* Invert the selector with a VNAND if available, else a VNOR.
-     The VNAND is preferred for future fusion opportunities.  */
-  notx = gen_rtx_NOT (V16QImode, sel);
-  iorx = (TARGET_P8_VECTOR
-	  ? gen_rtx_IOR (V16QImode, notx, notx)
-	  : gen_rtx_AND (V16QImode, notx, notx));
-  emit_insn (gen_rtx_SET (norreg, iorx));
+  if (TARGET_P9_VECTOR)
+    {
+      unspec = gen_rtx_UNSPEC (mode, gen_rtvec (3, op0, op1, sel),
+			       UNSPEC_VPERMR);
+    }
+  else
+    {
+      /* Invert the selector with a VNAND if available, else a VNOR.
+	 The VNAND is preferred for future fusion opportunities.  */
+      notx = gen_rtx_NOT (V16QImode, sel);
+      iorx = (TARGET_P8_VECTOR
+	      ? gen_rtx_IOR (V16QImode, notx, notx)
+	      : gen_rtx_AND (V16QImode, notx, notx));
+      emit_insn (gen_rtx_SET (norreg, iorx));
 
-  /* Permute with operands reversed and adjusted selector.  */
-  unspec = gen_rtx_UNSPEC (mode, gen_rtvec (3, op1, op0, norreg),
-			   UNSPEC_VPERM);
+      /* Permute with operands reversed and adjusted selector.  */
+      unspec = gen_rtx_UNSPEC (mode, gen_rtvec (3, op1, op0, norreg),
+			       UNSPEC_VPERM);
+    }
 
   /* Copy into target, possibly by way of a register.  */
   if (!REG_P (target))
@@ -33869,8 +35170,14 @@
   machine_mode inner = GET_MODE_INNER (mode);
   unsigned int inner_bytes = GET_MODE_UNIT_SIZE (mode);
 
-  if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)
+  if (TARGET_FLOAT128
+      && (mode == KCmode
+	  || (mode == TCmode && TARGET_IEEEQUAD)))
+    regno = ALTIVEC_ARG_RETURN;
+
+  else if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)
     regno = FP_ARG_RETURN;
+
   else
     {
       regno = GP_ARG_RETURN;
@@ -33992,7 +35299,8 @@
   if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)
     /* _Decimal128 must use an even/odd register pair.  */
     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;
-  else if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS
+  else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS
+	   && !FLOAT128_VECTOR_P (mode)
 	   && ((TARGET_SINGLE_FLOAT && (mode == SFmode)) || TARGET_DOUBLE_FLOAT))
     regno = FP_ARG_RETURN;
   else if (TREE_CODE (valtype) == COMPLEX_TYPE
@@ -34056,7 +35364,7 @@
 static bool
 rs6000_lra_p (void)
 {
-  return rs6000_lra_flag;
+  return TARGET_LRA;
 }
 
 /* Given FROM and TO register numbers, say whether this elimination is allowed.
@@ -34417,9 +35725,11 @@
   { "power8-fusion",		OPTION_MASK_P8_FUSION,		false, true  },
   { "power8-fusion-sign",	OPTION_MASK_P8_FUSION_SIGN,	false, true  },
   { "power8-vector",		OPTION_MASK_P8_VECTOR,		false, true  },
-  { "power9-dform",		OPTION_MASK_P9_DFORM,		false, true  },
+  { "power9-dform-scalar",	OPTION_MASK_P9_DFORM_SCALAR,	false, true  },
+  { "power9-dform-vector",	OPTION_MASK_P9_DFORM_VECTOR,	false, true  },
   { "power9-fusion",		OPTION_MASK_P9_FUSION,		false, true  },
   { "power9-minmax",		OPTION_MASK_P9_MINMAX,		false, true  },
+  { "power9-misc",		OPTION_MASK_P9_MISC,		false, true  },
   { "power9-vector",		OPTION_MASK_P9_VECTOR,		false, true  },
   { "powerpc-gfxopt",		OPTION_MASK_PPC_GFXOPT,		false, true  },
   { "powerpc-gpopt",		OPTION_MASK_PPC_GPOPT,		false, true  },
@@ -34474,11 +35784,14 @@
   { "popcntd",		 RS6000_BTM_POPCNTD,	false, false },
   { "cell",		 RS6000_BTM_CELL,	false, false },
   { "power8-vector",	 RS6000_BTM_P8_VECTOR,	false, false },
+  { "power9-vector",	 RS6000_BTM_P9_VECTOR,	false, false },
+  { "power9-misc",	 RS6000_BTM_P9_MISC,	false, false },
   { "crypto",		 RS6000_BTM_CRYPTO,	false, false },
   { "htm",		 RS6000_BTM_HTM,	false, false },
   { "hard-dfp",		 RS6000_BTM_DFP,	false, false },
   { "hard-float",	 RS6000_BTM_HARD_FLOAT,	false, false },
   { "long-double-128",	 RS6000_BTM_LDBL128,	false, false },
+  { "float128",		 RS6000_BTM_FLOAT128,   false, false },
 };
 
 /* Option variables that we want to support inside attribute((target)) and
@@ -35049,7 +36362,9 @@
   size_t i;
   size_t start_column = 0;
   size_t cur_column;
-  size_t max_column = 76;
+  size_t max_column = 120;
+  size_t prefix_len = strlen (prefix);
+  size_t comma_len = 0;
   const char *comma = "";
 
   if (indent)
@@ -35067,27 +36382,45 @@
   cur_column = start_column;
   for (i = 0; i < num_elements; i++)
     {
-      if ((flags & opts[i].mask) != 0)
+      bool invert = opts[i].invert;
+      const char *name = opts[i].name;
+      const char *no_str = "";
+      HOST_WIDE_INT mask = opts[i].mask;
+      size_t len = comma_len + prefix_len + strlen (name);
+
+      if (!invert)
 	{
-	  const char *no_str = rs6000_opt_masks[i].invert ? "no-" : "";
-	  size_t len = (strlen (comma)
-			+ strlen (prefix)
-			+ strlen (no_str)
-			+ strlen (rs6000_opt_masks[i].name));
+	  if ((flags & mask) == 0)
+	    {
+	      no_str = "no-";
+	      len += sizeof ("no-") - 1;
+	    }
+
+	  flags &= ~mask;
+	}
 
-	  cur_column += len;
-	  if (cur_column > max_column)
+      else
+	{
+	  if ((flags & mask) != 0)
 	    {
-	      fprintf (stderr, ", \\\n%*s", (int)start_column, "");
-	      cur_column = start_column + len;
-	      comma = "";
+	      no_str = "no-";
+	      len += sizeof ("no-") - 1;
 	    }
 
-	  fprintf (file, "%s%s%s%s", comma, prefix, no_str,
-		   rs6000_opt_masks[i].name);
-	  flags &= ~ opts[i].mask;
-	  comma = ", ";
+	  flags |= mask;
+	}
+
+      cur_column += len;
+      if (cur_column > max_column)
+	{
+	  fprintf (stderr, ", \\\n%*s", (int)start_column, "");
+	  cur_column = start_column + len;
+	  comma = "";
 	}
+
+      fprintf (file, "%s%s%s%s", comma, prefix, no_str, name);
+      comma = ", ";
+      comma_len = sizeof (", ") - 1;
     }
 
   fputs ("\n", file);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000.h gcc-6-20160721/gcc/config/rs6000/rs6000.h
--- gcc-6.1.0/gcc/config/rs6000/rs6000.h	2016-01-20 20:30:24.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000.h	2016-07-07 19:42:07.000000000 +0000
@@ -302,6 +302,28 @@
 #define TARGET_P8_VECTOR 0
 #endif
 
+/* Define the ISA 3.0 flags as 0 if the target assembler does not support
+   Power9 instructions.  Allow -mpower9-fusion, since it does not add new
+   instructions.  Allow -misel, since it predates ISA 3.0 and does
+   not require any Power9 features.  */
+
+#ifndef HAVE_AS_POWER9
+#undef  TARGET_FLOAT128_HW
+#undef  TARGET_MODULO
+#undef  TARGET_P9_VECTOR
+#undef  TARGET_P9_MINMAX
+#undef  TARGET_P9_DFORM_SCALAR
+#undef  TARGET_P9_DFORM_VECTOR
+#undef  TARGET_P9_MISC
+#define TARGET_FLOAT128_HW 0
+#define TARGET_MODULO 0
+#define TARGET_P9_VECTOR 0
+#define TARGET_P9_MINMAX 0
+#define TARGET_P9_DFORM_SCALAR 0
+#define TARGET_P9_DFORM_VECTOR 0
+#define TARGET_P9_MISC 0
+#endif
+
 /* Define TARGET_LWSYNC_INSTRUCTION if the assembler knows about lwsync.  If
    not, generate the lwsync code as an integer constant.  */
 #ifdef HAVE_AS_LWSYNC
@@ -418,12 +440,12 @@
    Similarly IFmode is the IBM long double format even if the default is IEEE
    128-bit.  */
 #define FLOAT128_IEEE_P(MODE)						\
-  (((MODE) == TFmode && TARGET_IEEEQUAD)				\
-   || ((MODE) == KFmode))
+  ((TARGET_IEEEQUAD && ((MODE) == TFmode || (MODE) == TCmode))		\
+   || ((MODE) == KFmode) || ((MODE) == KCmode))
 
 #define FLOAT128_IBM_P(MODE)						\
-  (((MODE) == TFmode && !TARGET_IEEEQUAD)				\
-   || ((MODE) == IFmode))
+  ((!TARGET_IEEEQUAD && ((MODE) == TFmode || (MODE) == TCmode))		\
+   || ((MODE) == IFmode) || ((MODE) == ICmode))
 
 /* Helper macros to say whether a 128-bit floating point type can go in a
    single vector register, or whether it needs paired scalar values.  */
@@ -594,6 +616,15 @@
    in the register.  */
 #define TARGET_NO_SDMODE_STACK	(TARGET_LFIWZX && TARGET_STFIWX && TARGET_DFP)
 
+/* ISA 3.0 has new min/max functions that don't need fast math that are being
+   phased in.  Min/max using FSEL or XSMAXDP/XSMINDP do not return the correct
+   answers if the arguments are not in the normal range.  */
+#define TARGET_MINMAX_SF	(TARGET_SF_FPR && TARGET_PPC_GFXOPT	\
+				 && (TARGET_P9_MINMAX || !flag_trapping_math))
+
+#define TARGET_MINMAX_DF	(TARGET_DF_FPR && TARGET_PPC_GFXOPT	\
+				 && (TARGET_P9_MINMAX || !flag_trapping_math))
+
 /* In switching from using target_flags to using rs6000_isa_flags, the options
    machinery creates OPTION_MASK_<xxx> instead of MASK_<xxx>.  For now map
    OPTION_MASK_<xxx> back into MASK_<xxx>.  */
@@ -615,6 +646,8 @@
 #define MASK_MULTIPLE			OPTION_MASK_MULTIPLE
 #define MASK_NO_UPDATE			OPTION_MASK_NO_UPDATE
 #define MASK_P8_VECTOR			OPTION_MASK_P8_VECTOR
+#define MASK_P9_VECTOR			OPTION_MASK_P9_VECTOR
+#define MASK_P9_MISC			OPTION_MASK_P9_MISC
 #define MASK_POPCNTB			OPTION_MASK_POPCNTB
 #define MASK_POPCNTD			OPTION_MASK_POPCNTD
 #define MASK_PPC_GFXOPT			OPTION_MASK_PPC_GFXOPT
@@ -655,6 +688,11 @@
 #define MASK_PROTOTYPE			OPTION_MASK_PROTOTYPE
 #endif
 
+#ifdef TARGET_MODULO
+#define RS6000_BTM_MODULO		OPTION_MASK_MODULO
+#endif
+
+
 /* For power systems, we want to enable Altivec and VSX builtins even if the
    user did not use -maltivec or -mvsx to allow the builtins to be used inside
    of #pragma GCC target or the target attribute to change the code level for a
@@ -1774,7 +1812,9 @@
 #define ALTIVEC_ARG_RETURN (FIRST_ALTIVEC_REGNO + 2)
 #define FP_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? FP_ARG_RETURN	\
 			   : (FP_ARG_RETURN + AGGR_ARG_NUM_REG - 1))
-#define ALTIVEC_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? ALTIVEC_ARG_RETURN \
+#define ALTIVEC_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2		\
+				? (ALTIVEC_ARG_RETURN			\
+				   + (TARGET_FLOAT128 ? 1 : 0))		\
 			        : (ALTIVEC_ARG_RETURN + AGGR_ARG_NUM_REG - 1))
 
 /* Flags for the call/call_value rtl operations set up by function_arg */
@@ -2638,7 +2678,9 @@
 
 #define RS6000_BTC_MISC		0x00000000	/* No special attributes.  */
 #define RS6000_BTC_CONST	0x00000100	/* uses no global state.  */
-#define RS6000_BTC_PURE		0x00000200	/* reads global state/mem.  */
+#define RS6000_BTC_PURE		0x00000200	/* reads global
+						   state/mem and does
+						   not modify global state.  */
 #define RS6000_BTC_FP		0x00000400	/* depends on rounding mode.  */
 #define RS6000_BTC_ATTR_MASK	0x00000700	/* Mask of the attributes.  */
 
@@ -2660,6 +2702,8 @@
 #define RS6000_BTM_ALTIVEC	MASK_ALTIVEC	/* VMX/altivec vectors.  */
 #define RS6000_BTM_VSX		MASK_VSX	/* VSX (vector/scalar).  */
 #define RS6000_BTM_P8_VECTOR	MASK_P8_VECTOR	/* ISA 2.07 vector.  */
+#define RS6000_BTM_P9_VECTOR	MASK_P9_VECTOR	/* ISA 3.00 vector.  */
+#define RS6000_BTM_P9_MISC	MASK_P9_MISC	/* ISA 3.0 misc. non-vector.  */
 #define RS6000_BTM_CRYPTO	MASK_CRYPTO	/* crypto funcs.  */
 #define RS6000_BTM_HTM		MASK_HTM	/* hardware TM funcs.  */
 #define RS6000_BTM_SPE		MASK_STRING	/* E500 */
@@ -2673,10 +2717,15 @@
 #define RS6000_BTM_DFP		MASK_DFP	/* Decimal floating point.  */
 #define RS6000_BTM_HARD_FLOAT	MASK_SOFT_FLOAT	/* Hardware floating point.  */
 #define RS6000_BTM_LDBL128	MASK_MULTIPLE	/* 128-bit long double.  */
+#define RS6000_BTM_64BIT	MASK_64BIT	/* 64-bit addressing.  */
+#define RS6000_BTM_FLOAT128	MASK_P9_VECTOR	/* IEEE 128-bit float.  */
 
 #define RS6000_BTM_COMMON	(RS6000_BTM_ALTIVEC			\
 				 | RS6000_BTM_VSX			\
 				 | RS6000_BTM_P8_VECTOR			\
+				 | RS6000_BTM_P9_VECTOR			\
+				 | RS6000_BTM_P9_MISC			\
+				 | RS6000_BTM_MODULO                    \
 				 | RS6000_BTM_CRYPTO			\
 				 | RS6000_BTM_FRE			\
 				 | RS6000_BTM_FRES			\
@@ -2687,10 +2736,12 @@
 				 | RS6000_BTM_CELL			\
 				 | RS6000_BTM_DFP			\
 				 | RS6000_BTM_HARD_FLOAT		\
-				 | RS6000_BTM_LDBL128)
+				 | RS6000_BTM_LDBL128			\
+				 | RS6000_BTM_FLOAT128)
 
 /* Define builtin enum index.  */
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -2703,6 +2754,7 @@
 #undef RS6000_BUILTIN_S
 #undef RS6000_BUILTIN_X
 
+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) ENUM,
 #define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE) ENUM,
 #define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE) ENUM,
 #define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE) ENUM,
@@ -2722,6 +2774,7 @@
   RS6000_BUILTIN_COUNT
 };
 
+#undef RS6000_BUILTIN_0
 #undef RS6000_BUILTIN_1
 #undef RS6000_BUILTIN_2
 #undef RS6000_BUILTIN_3
@@ -2788,6 +2841,7 @@
   RS6000_BTI_void,	         /* void_type_node */
   RS6000_BTI_ieee128_float,	 /* ieee 128-bit floating point */
   RS6000_BTI_ibm128_float,	 /* IBM 128-bit floating point */
+  RS6000_BTI_const_str,		 /* pointer to const char * */
   RS6000_BTI_MAX
 };
 
@@ -2844,6 +2898,7 @@
 #define void_type_internal_node		 (rs6000_builtin_types[RS6000_BTI_void])
 #define ieee128_float_type_node		 (rs6000_builtin_types[RS6000_BTI_ieee128_float])
 #define ibm128_float_type_node		 (rs6000_builtin_types[RS6000_BTI_ibm128_float])
+#define const_str_type_node		 (rs6000_builtin_types[RS6000_BTI_const_str])
 
 extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];
 extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000.md gcc-6-20160721/gcc/config/rs6000/rs6000.md
--- gcc-6.1.0/gcc/config/rs6000/rs6000.md	2016-04-12 19:25:56.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000.md	2016-07-15 04:47:30.000000000 +0000
@@ -147,6 +147,8 @@
    UNSPEC_ROUND_TO_ODD
    UNSPEC_IEEE128_MOVE
    UNSPEC_IEEE128_CONVERT
+   UNSPEC_SIGNBIT
+   UNSPEC_DOLOOP
   ])
 
 ;;
@@ -183,12 +185,13 @@
    brinc,
    vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,
    vecfloat,vecfdiv,vecdouble,mffgpr,mftgpr,crypto,
-   htm"
+   veclogical,veccmpfx,vecexts,vecmove,
+   htm,htmsimple,dfp"
   (const_string "integer"))
 
 ;; What data size does this instruction work on?
-;; This is used for insert, mul.
-(define_attr "size" "8,16,32,64" (const_string "32"))
+;; This is used for insert, mul and others as necessary.
+(define_attr "size" "8,16,32,64,128" (const_string "32"))
 
 ;; Is this instruction record form ("dot", signed compare to 0, writing CR0)?
 ;; This is used for add, logical, shift, exts, mul.
@@ -298,6 +301,7 @@
 (include "power6.md")
 (include "power7.md")
 (include "power8.md")
+(include "power9.md")
 (include "cell.md")
 (include "xfpu.md")
 (include "a2.md")
@@ -489,6 +493,10 @@
 ; Iterator for just SF/DF
 (define_mode_iterator SFDF [SF DF])
 
+; Like SFDF, but a different name to match conditional move where the
+; comparison operands may be a different mode than the input operands.
+(define_mode_iterator SFDF2 [SF DF])
+
 ; Iterator for 128-bit floating point that uses the IBM double-double format
 (define_mode_iterator IBM128 [(IF "FLOAT128_IBM_P (IFmode)")
 			      (TF "FLOAT128_IBM_P (TFmode)")])
@@ -502,6 +510,13 @@
 				(IF "TARGET_FLOAT128")
 				(TF "TARGET_LONG_DOUBLE_128")])
 
+; Iterator for signbit on 64-bit machines with direct move
+(define_mode_iterator SIGNBIT [(KF "FLOAT128_VECTOR_P (KFmode)")
+			       (TF "FLOAT128_VECTOR_P (TFmode)")])
+
+(define_mode_attr Fsignbit	[(KF "wa")
+				 (TF "wa")])
+
 ; SF/DF suffix for traditional floating instructions
 (define_mode_attr Ftrad		[(SF "s") (DF "")])
 
@@ -577,7 +592,9 @@
 		      (V16QI "b")
 		      (V8HI  "h")
 		      (V4SI  "w")
-		      (V2DI  "d")])
+		      (V2DI  "d")
+		      (V1TI  "q")
+		      (TI    "q")])
 
 ;; How many bits in this mode?
 (define_mode_attr bits [(QI "8") (HI "16") (SI "32") (DI "64")])
@@ -698,6 +715,15 @@
 (define_mode_iterator RELOAD [V16QI V8HI V4SI V2DI V4SF V2DF V1TI
 			      SF SD SI DF DD DI TI PTI KF IF TF])
 
+;; Iterate over smin, smax
+(define_code_iterator fp_minmax	[smin smax])
+
+(define_code_attr     minmax	[(smin "min")
+				 (smax "max")])
+
+(define_code_attr     SMINMAX	[(smin "SMIN")
+				 (smax "SMAX")])
+
 
 ;; Start with fixed-point load and store insns.  Here we put only the more
 ;; complex forms.  Basic data transfer is done later.
@@ -4044,7 +4070,7 @@
 
   if (REGNO (cr) == CR0_REGNO)
     {
-      emit_insn (gen_ashdi3_extswsli_dot (dest, src2, shift, cr));
+      emit_insn (gen_ashdi3_extswsli_dot2 (dest, src2, shift, cr));
       DONE;
     }
 
@@ -4305,7 +4331,7 @@
   "@
    fabs %0,%1
    xsabsdp %x0,%x1"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "fp_type" "fp_addsub_<Fs>")])
 
 (define_insn "*nabs<mode>2_fpr"
@@ -4317,7 +4343,7 @@
   "@
    fnabs %0,%1
    xsnabsdp %x0,%x1"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "fp_type" "fp_addsub_<Fs>")])
 
 (define_expand "neg<mode>2"
@@ -4333,7 +4359,7 @@
   "@
    fneg %0,%1
    xsnegdp %x0,%x1"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "fp_type" "fp_addsub_<Fs>")])
 
 (define_expand "add<mode>3"
@@ -4494,7 +4520,7 @@
   emit_note (NOTE_INSN_DELETED);
   DONE;
 }
-  [(set_attr "type" "fp,fp,fpload,fp,fp,fpload,fpload")])
+  [(set_attr "type" "fp,fpsimple,fpload,fp,fpsimple,fpload,fpload")])
 
 (define_expand "truncdfsf2"
   [(set (match_operand:SF 0 "gpc_reg_operand" "")
@@ -4516,7 +4542,7 @@
 ;; when little-endian.
 (define_expand "signbit<mode>2"
   [(set (match_dup 2)
-	(float_truncate:DF (match_operand:IBM128 1 "gpc_reg_operand" "")))
+	(float_truncate:DF (match_operand:FLOAT128 1 "gpc_reg_operand" "")))
    (set (match_dup 3)
    	(subreg:DI (match_dup 2) 0))
    (set (match_dup 4)
@@ -4524,8 +4550,20 @@
    (set (match_operand:SI 0 "gpc_reg_operand" "")
   	(match_dup 6))]
   "TARGET_HARD_FLOAT
-   && (TARGET_FPRS || TARGET_E500_DOUBLE)"
+   && (TARGET_FPRS || TARGET_E500_DOUBLE)
+   && (!FLOAT128_IEEE_P (<MODE>mode)
+       || (TARGET_POWERPC64 && TARGET_DIRECT_MOVE))"
 {
+  if (FLOAT128_IEEE_P (<MODE>mode))
+    {
+      if (<MODE>mode == KFmode)
+	emit_insn (gen_signbitkf2_dm (operands[0], operands[1]));
+      else if (<MODE>mode == TFmode)
+	emit_insn (gen_signbittf2_dm (operands[0], operands[1]));
+      else
+	gcc_unreachable ();
+      DONE;
+    }
   operands[2] = gen_reg_rtx (DFmode);
   operands[3] = gen_reg_rtx (DImode);
   if (TARGET_POWERPC64)
@@ -4573,6 +4611,37 @@
    operands[5] = CONST0_RTX (<MODE>mode);
   })
 
+;; Optimize signbit on 64-bit systems with direct move to avoid doing the store
+;; and load.
+(define_insn_and_split "signbit<mode>2_dm"
+  [(set (match_operand:SI 0 "gpc_reg_operand" "=r,r,r")
+	(unspec:SI
+	 [(match_operand:SIGNBIT 1 "input_operand" "<Fsignbit>,m,r")]
+	 UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+{
+  rs6000_split_signbit (operands[0], operands[1]);
+  DONE;
+}
+ [(set_attr "length" "8,8,12")
+  (set_attr "type" "mftgpr,load,integer")])
+
+;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating
+;; point types, which makes normal SUBREG's problematical. Instead use a
+;; special pattern to avoid using a normal movdi.
+(define_insn "signbit<mode>2_dm2"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r")
+	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "<Fsignbit>")
+		    (const_int 0)]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "mfvsrd %0,%x1"
+ [(set_attr "type" "mftgpr")])
+
+
 ;; Use an unspec rather providing an if-then-else in RTL, to prevent the
 ;; compiler from optimizing -0.0
 (define_insn "copysign<mode>3_fcpsgn"
@@ -4584,7 +4653,7 @@
   "@
    fcpsgn %0,%2,%1
    xscpsgndp %x0,%x2,%x1"
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "fpsimple")])
 
 ;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a
 ;; fsel instruction and some auxiliary computations.  Then we just have a
@@ -4599,74 +4668,45 @@
 ;; On VSX, we only check for TARGET_VSX instead of checking for a vsx/p8 vector
 ;; to allow either DF/SF to use only traditional registers.
 
-(define_expand "smax<mode>3"
+(define_expand "s<minmax><mode>3"
   [(set (match_operand:SFDF 0 "gpc_reg_operand" "")
-	(if_then_else:SFDF (ge (match_operand:SFDF 1 "gpc_reg_operand" "")
-			       (match_operand:SFDF 2 "gpc_reg_operand" ""))
-			   (match_dup 1)
-			   (match_dup 2)))]
-  "TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math"
+	(fp_minmax:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "")
+			(match_operand:SFDF 2 "gpc_reg_operand" "")))]
+  "TARGET_MINMAX_<MODE>"
 {
-  rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]);
+  rs6000_emit_minmax (operands[0], <SMINMAX>, operands[1], operands[2]);
   DONE;
 })
 
-(define_insn "*smax<mode>3_vsx"
-  [(set (match_operand:SFDF 0 "gpc_reg_operand" "=<Ff>,<Fv>")
-	(smax:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "%<Ff>,<Fv>")
-		   (match_operand:SFDF 2 "gpc_reg_operand" "<Ff>,<Fv>")))]
-  "TARGET_<MODE>_FPR && TARGET_VSX"
-  "xsmaxdp %x0,%x1,%x2"
-  [(set_attr "type" "fp")])
-
-(define_expand "smin<mode>3"
-  [(set (match_operand:SFDF 0 "gpc_reg_operand" "")
-	(if_then_else:SFDF (ge (match_operand:SFDF 1 "gpc_reg_operand" "")
-			       (match_operand:SFDF 2 "gpc_reg_operand" ""))
-			   (match_dup 2)
-			   (match_dup 1)))]
-  "TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math"
+(define_insn "*s<minmax><mode>3_vsx"
+  [(set (match_operand:SFDF 0 "vsx_register_operand" "=<Fv>")
+	(fp_minmax:SFDF (match_operand:SFDF 1 "vsx_register_operand" "<Fv>")
+			(match_operand:SFDF 2 "vsx_register_operand" "<Fv>")))]
+  "TARGET_VSX && TARGET_<MODE>_FPR"
 {
-  rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]);
-  DONE;
-})
-
-(define_insn "*smin<mode>3_vsx"
-  [(set (match_operand:SFDF 0 "gpc_reg_operand" "=<Ff>,<Fv>")
-	(smin:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "%<Ff>,<Fv>")
-		   (match_operand:SFDF 2 "gpc_reg_operand" "<Ff>,<Fv>")))]
-  "TARGET_<MODE>_FPR && TARGET_VSX"
-  "xsmindp %x0,%x1,%x2"
+  return (TARGET_P9_MINMAX
+	  ? "xs<minmax>cdp %x0,%x1,%x2"
+	  : "xs<minmax>dp %x0,%x1,%x2");
+}
   [(set_attr "type" "fp")])
 
-(define_split
+;; The conditional move instructions allow us to perform max and min operations
+;; even when we don't have the appropriate max/min instruction using the FSEL
+;; instruction.
+
+(define_insn_and_split "*s<minmax><mode>3_fpr"
   [(set (match_operand:SFDF 0 "gpc_reg_operand" "")
-	(match_operator:SFDF 3 "min_max_operator"
-	 [(match_operand:SFDF 1 "gpc_reg_operand" "")
-	  (match_operand:SFDF 2 "gpc_reg_operand" "")]))]
-  "TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math
-   && !TARGET_VSX"
+	(fp_minmax:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "")
+			(match_operand:SFDF 2 "gpc_reg_operand" "")))]
+  "!TARGET_VSX && TARGET_MINMAX_<MODE>"
+  "#"
+  "&& 1"
   [(const_int 0)]
 {
-  rs6000_emit_minmax (operands[0], GET_CODE (operands[3]), operands[1],
-		      operands[2]);
+  rs6000_emit_minmax (operands[0], <SMINMAX>, operands[1], operands[2]);
   DONE;
 })
 
-(define_split
-  [(set (match_operand:SF 0 "gpc_reg_operand" "")
-	(match_operator:SF 3 "min_max_operator"
-	 [(match_operand:SF 1 "gpc_reg_operand" "")
-	  (match_operand:SF 2 "gpc_reg_operand" "")]))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS 
-   && TARGET_SINGLE_FLOAT && !flag_trapping_math"
-  [(const_int 0)]
-  "
-{ rs6000_emit_minmax (operands[0], GET_CODE (operands[3]),
-		      operands[1], operands[2]);
-  DONE;
-}")
-
 (define_expand "mov<mode>cc"
    [(set (match_operand:GPR 0 "gpc_reg_operand" "")
 	 (if_then_else:GPR (match_operand 1 "comparison_operator" "")
@@ -4749,12 +4789,13 @@
   [(set_attr "type" "isel")
    (set_attr "length" "4")])
 
-(define_expand "movsfcc"
-   [(set (match_operand:SF 0 "gpc_reg_operand" "")
-	 (if_then_else:SF (match_operand 1 "comparison_operator" "")
-			  (match_operand:SF 2 "gpc_reg_operand" "")
-			  (match_operand:SF 3 "gpc_reg_operand" "")))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT"
+;; Floating point conditional move
+(define_expand "mov<mode>cc"
+   [(set (match_operand:SFDF 0 "gpc_reg_operand" "")
+	 (if_then_else:SFDF (match_operand 1 "comparison_operator" "")
+			    (match_operand:SFDF 2 "gpc_reg_operand" "")
+			    (match_operand:SFDF 3 "gpc_reg_operand" "")))]
+  "TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT"
   "
 {
   if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))
@@ -4763,76 +4804,70 @@
     FAIL;
 }")
 
-(define_insn "*fselsfsf4"
-  [(set (match_operand:SF 0 "gpc_reg_operand" "=f")
-	(if_then_else:SF (ge (match_operand:SF 1 "gpc_reg_operand" "f")
-			     (match_operand:SF 4 "zero_fp_constant" "F"))
-			 (match_operand:SF 2 "gpc_reg_operand" "f")
-			 (match_operand:SF 3 "gpc_reg_operand" "f")))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT"
-  "fsel %0,%1,%2,%3"
-  [(set_attr "type" "fp")])
-
-(define_insn "*fseldfsf4"
-  [(set (match_operand:SF 0 "gpc_reg_operand" "=f")
-	(if_then_else:SF (ge (match_operand:DF 1 "gpc_reg_operand" "d")
-			     (match_operand:DF 4 "zero_fp_constant" "F"))
-			 (match_operand:SF 2 "gpc_reg_operand" "f")
-			 (match_operand:SF 3 "gpc_reg_operand" "f")))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_SINGLE_FLOAT"
+(define_insn "*fsel<SFDF:mode><SFDF2:mode>4"
+  [(set (match_operand:SFDF 0 "fpr_reg_operand" "=&<SFDF:rreg2>")
+	(if_then_else:SFDF
+	 (ge (match_operand:SFDF2 1 "fpr_reg_operand" "<SFDF2:rreg2>")
+	     (match_operand:SFDF2 4 "zero_fp_constant" "F"))
+	 (match_operand:SFDF 2 "fpr_reg_operand" "<SFDF:rreg2>")
+	 (match_operand:SFDF 3 "fpr_reg_operand" "<SFDF:rreg2>")))]
+  "TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT"
   "fsel %0,%1,%2,%3"
   [(set_attr "type" "fp")])
 
-;; The conditional move instructions allow us to perform max and min
-;; operations even when
-
-(define_split
-  [(set (match_operand:DF 0 "gpc_reg_operand" "")
-	(match_operator:DF 3 "min_max_operator"
-	 [(match_operand:DF 1 "gpc_reg_operand" "")
-	  (match_operand:DF 2 "gpc_reg_operand" "")]))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT 
-   && !flag_trapping_math"
-  [(const_int 0)]
-  "
-{ rs6000_emit_minmax (operands[0], GET_CODE (operands[3]),
-		      operands[1], operands[2]);
-  DONE;
-}")
-
-(define_expand "movdfcc"
-   [(set (match_operand:DF 0 "gpc_reg_operand" "")
-	 (if_then_else:DF (match_operand 1 "comparison_operator" "")
-			  (match_operand:DF 2 "gpc_reg_operand" "")
-			  (match_operand:DF 3 "gpc_reg_operand" "")))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT"
-  "
-{
-  if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))
-    DONE;
-  else
-    FAIL;
-}")
+(define_insn_and_split "*mov<SFDF:mode><SFDF2:mode>cc_p9"
+  [(set (match_operand:SFDF 0 "vsx_register_operand" "=&<SFDF:Fv>,<SFDF:Fv>")
+	(if_then_else:SFDF
+	 (match_operator:CCFP 1 "fpmask_comparison_operator"
+		[(match_operand:SFDF2 2 "vsx_register_operand" "<SFDF2:Fv>,<SFDF2:Fv>")
+		 (match_operand:SFDF2 3 "vsx_register_operand" "<SFDF2:Fv>,<SFDF2:Fv>")])
+	 (match_operand:SFDF 4 "vsx_register_operand" "<SFDF:Fv>,<SFDF:Fv>")
+	 (match_operand:SFDF 5 "vsx_register_operand" "<SFDF:Fv>,<SFDF:Fv>")))
+   (clobber (match_scratch:V2DI 6 "=0,&wa"))]
+  "TARGET_P9_MINMAX"
+  "#"
+  ""
+  [(set (match_dup 6)
+	(if_then_else:V2DI (match_dup 1)
+			   (match_dup 7)
+			   (match_dup 8)))
+   (set (match_dup 0)
+	(if_then_else:SFDF (ne (match_dup 6)
+			       (match_dup 8))
+			   (match_dup 4)
+			   (match_dup 5)))]
+{
+  if (GET_CODE (operands[6]) == SCRATCH)
+    operands[6] = gen_reg_rtx (V2DImode);
+
+  operands[7] = CONSTM1_RTX (V2DImode);
+  operands[8] = CONST0_RTX (V2DImode);
+}
+ [(set_attr "length" "8")
+  (set_attr "type" "vecperm")])
+
+(define_insn "*fpmask<mode>"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+	(if_then_else:V2DI
+	 (match_operator:CCFP 1 "fpmask_comparison_operator"
+		[(match_operand:SFDF 2 "vsx_register_operand" "<Fv>")
+		 (match_operand:SFDF 3 "vsx_register_operand" "<Fv>")])
+	 (match_operand:V2DI 4 "all_ones_constant" "")
+	 (match_operand:V2DI 5 "zero_constant" "")))]
+  "TARGET_P9_MINMAX"
+  "xscmp%V1dp %x0,%x2,%x3"
+  [(set_attr "type" "fpcompare")])
 
-(define_insn "*fseldfdf4"
-  [(set (match_operand:DF 0 "gpc_reg_operand" "=d")
-	(if_then_else:DF (ge (match_operand:DF 1 "gpc_reg_operand" "d")
-			     (match_operand:DF 4 "zero_fp_constant" "F"))
-			 (match_operand:DF 2 "gpc_reg_operand" "d")
-			 (match_operand:DF 3 "gpc_reg_operand" "d")))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT"
-  "fsel %0,%1,%2,%3"
-  [(set_attr "type" "fp")])
+(define_insn "*xxsel<mode>"
+  [(set (match_operand:SFDF 0 "vsx_register_operand" "=<Fv>")
+	(if_then_else:SFDF (ne (match_operand:V2DI 1 "vsx_register_operand" "wa")
+			       (match_operand:V2DI 2 "zero_constant" ""))
+			   (match_operand:SFDF 3 "vsx_register_operand" "<Fv>")
+			   (match_operand:SFDF 4 "vsx_register_operand" "<Fv>")))]
+  "TARGET_P9_MINMAX"
+  "xxsel %x0,%x1,%x3,%x4"
+  [(set_attr "type" "vecmove")])
 
-(define_insn "*fselsfdf4"
-  [(set (match_operand:DF 0 "gpc_reg_operand" "=d")
-	(if_then_else:DF (ge (match_operand:SF 1 "gpc_reg_operand" "f")
-			     (match_operand:SF 4 "zero_fp_constant" "F"))
-			 (match_operand:DF 2 "gpc_reg_operand" "d")
-			 (match_operand:DF 3 "gpc_reg_operand" "d")))]
-  "TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_SINGLE_FLOAT"
-  "fsel %0,%1,%2,%3"
-  [(set_attr "type" "fp")])
 
 ;; Conversions to and from floating-point.
 
@@ -5942,7 +5977,7 @@
   [(set (attr "type")
       (if_then_else
 	(match_test "vsx_register_operand (operands[0], <MODE>mode)")
-	(const_string "vecsimple")
+	(const_string "veclogical")
 	(const_string "integer")))
    (set (attr "length")
       (if_then_else
@@ -5978,7 +6013,7 @@
   [(set (attr "type")
       (if_then_else
 	(match_test "vsx_register_operand (operands[0], <MODE>mode)")
-	(const_string "vecsimple")
+	(const_string "veclogical")
 	(const_string "integer")))
    (set (attr "length")
       (if_then_else
@@ -6016,7 +6051,7 @@
   [(set (attr "type")
       (if_then_else
 	(match_test "vsx_register_operand (operands[0], <MODE>mode)")
-	(const_string "vecsimple")
+	(const_string "veclogical")
 	(const_string "integer")))
    (set (attr "length")
       (if_then_else
@@ -6076,7 +6111,7 @@
   [(set (attr "type")
       (if_then_else
 	(match_test "vsx_register_operand (operands[0], <MODE>mode)")
-	(const_string "vecsimple")
+	(const_string "veclogical")
 	(const_string "integer")))
    (set (attr "length")
       (if_then_else
@@ -6134,7 +6169,7 @@
   [(set (attr "type")
       (if_then_else
 	(match_test "vsx_register_operand (operands[0], <MODE>mode)")
-	(const_string "vecsimple")
+	(const_string "veclogical")
 	(const_string "integer")))
    (set (attr "length")
       (if_then_else
@@ -6190,7 +6225,7 @@
   [(set (attr "type")
       (if_then_else
 	(match_test "vsx_register_operand (operands[0], <MODE>mode)")
-	(const_string "vecsimple")
+	(const_string "veclogical")
 	(const_string "integer")))
    (set (attr "length")
       (if_then_else
@@ -6505,7 +6540,7 @@
    mt%0 %1
    mf%1 %0
    nop"
-  [(set_attr "type" "*,load,store,fp,fp,vecsimple,integer,fpload,fpload,fpstore,fpstore,fpload,fpstore,mffgpr,mftgpr,mtjmpr,mfjmpr,*")
+  [(set_attr "type" "*,load,store,fpsimple,fpsimple,veclogical,integer,fpload,fpload,fpstore,fpstore,fpload,fpstore,mffgpr,mftgpr,mtjmpr,mfjmpr,*")
    (set_attr "length" "4")])
 
 (define_insn "*mov<mode>_softfloat"
@@ -6640,7 +6675,8 @@
    #
    #
    #"
-  [(set_attr "type" "fpstore,fpload,fp,fpload,fpstore,fpload,fpstore,vecsimple,vecsimple,two,store,load,two")
+  [(set_attr "type" "fpstore,fpload,fpsimple,fpload,fpstore,fpload,fpstore,veclogical,veclogical,two,store,load,two")
+   (set_attr "size" "64")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,8,8,8,8")])
 
 (define_insn "*mov<mode>_softfloat32"
@@ -6685,7 +6721,8 @@
    mffgpr %0,%1
    mfvsrd %0,%x1
    mtvsrd %x0,%1"
-  [(set_attr "type" "fpstore,fpload,fp,fpload,fpstore,fpload,fpstore,vecsimple,vecsimple,integer,store,load,*,mtjmpr,mfjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr")
+  [(set_attr "type" "fpstore,fpload,fpsimple,fpload,fpstore,fpload,fpstore,veclogical,veclogical,integer,store,load,*,mtjmpr,mfjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr")
+   (set_attr "size" "64")
    (set_attr "length" "4")])
 
 (define_insn "*mov<mode>_softfloat64"
@@ -6896,7 +6933,7 @@
   emit_note (NOTE_INSN_DELETED);
   DONE;
 }
-  [(set_attr "type" "fp")])
+  [(set_attr "type" "fpsimple")])
 
 (define_insn "trunc<mode>df2_internal2"
   [(set (match_operand:DF 0 "gpc_reg_operand" "=d")
@@ -7129,7 +7166,7 @@
   else
     return \"fneg %0,%1\;fneg %L0,%L1\";
 }"
-  [(set_attr "type" "fp")
+  [(set_attr "type" "fpsimple")
    (set_attr "length" "8")])
 
 (define_expand "abs<mode>2"
@@ -7264,7 +7301,7 @@
    (use (match_operand:V16QI 2 "register_operand" "v"))]
   "TARGET_FLOAT128 && !TARGET_FLOAT128_HW"
   "xxlxor %x0,%x1,%x2"
-  [(set_attr "type" "vecsimple")])
+  [(set_attr "type" "veclogical")])
 
 ;; IEEE 128-bit absolute value
 (define_insn_and_split "ieee_128bit_vsx_abs<mode>2"
@@ -7293,7 +7330,7 @@
    (use (match_operand:V16QI 2 "register_operand" "v"))]
   "TARGET_FLOAT128 && !TARGET_FLOAT128_HW"
   "xxlandc %x0,%x1,%x2"
-  [(set_attr "type" "vecsimple")])
+  [(set_attr "type" "veclogical")])
 
 ;; IEEE 128-bit negative absolute value
 (define_insn_and_split "*ieee_128bit_vsx_nabs<mode>2"
@@ -7326,7 +7363,7 @@
    (use (match_operand:V16QI 2 "register_operand" "v"))]
   "TARGET_FLOAT128 && !TARGET_FLOAT128_HW"
   "xxlor %x0,%x1,%x2"
-  [(set_attr "type" "vecsimple")])
+  [(set_attr "type" "veclogical")])
 
 ;; Float128 conversion functions.  These expand to library function calls.
 ;; We use expand to convert from IBM double double to IEEE 128-bit
@@ -7482,7 +7519,7 @@
 			 UNSPEC_P8V_FMRGOW))]
   "!TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
   "fmrgow %0,%1,%2"
-  [(set_attr "type" "vecperm")])
+  [(set_attr "type" "fpsimple")])
 
 (define_insn "p8_mtvsrwz"
   [(set (match_operand:DF 0 "register_operand" "=d")
@@ -7705,7 +7742,8 @@
    lfd%U1%X1 %0,%1
    fmr %0,%1
    #"
-  [(set_attr "type" "store,load,*,fpstore,fpload,fp,*")])
+  [(set_attr "type" "store,load,*,fpstore,fpload,fpsimple,*")
+   (set_attr "size" "64")])
 
 (define_split
   [(set (match_operand:DI 0 "gpc_reg_operand" "")
@@ -7759,7 +7797,8 @@
    mfvsrd %0,%x1
    mtvsrd %x0,%1
    xxlxor %x0,%x0,%x0"
-  [(set_attr "type" "store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr,vecsimple")
+  [(set_attr "type" "store,load,*,*,*,*,fpstore,fpload,fpsimple,mfjmpr,mtjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr,veclogical")
+   (set_attr "size" "64")
    (set_attr "length" "4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4")])
 
 ; Some DImode loads are best done as a load of -1 followed by a mask
@@ -8767,7 +8806,8 @@
    lfdu %3,%2(%0)"
   [(set_attr "type" "fpload")
    (set_attr "update" "yes")
-   (set_attr "indexed" "yes,no")])
+   (set_attr "indexed" "yes,no")
+   (set_attr "size" "64")])
 
 (define_insn "*movdf_update2"
   [(set (mem:DF (plus:SI (match_operand:SI 1 "gpc_reg_operand" "0,0")
@@ -11902,6 +11942,7 @@
 	      (set (match_dup 0)
 		   (plus:P (match_dup 0)
 			    (const_int -1)))
+	      (unspec [(const_int 0)] UNSPEC_DOLOOP)
 	      (clobber (match_scratch:CC 2 ""))
 	      (clobber (match_scratch:P 3 ""))])]
   ""
@@ -11912,6 +11953,7 @@
 ;; JUMP_INSNs.
 ;; For the length attribute to be calculated correctly, the
 ;; label MUST be operand 0.
+;; The UNSPEC is present to prevent combine creating this pattern.
 
 (define_insn "*ctr<mode>_internal1"
   [(set (pc)
@@ -11919,9 +11961,10 @@
 			  (const_int 1))
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))
-   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*c*l")
+   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*wi*c*l")
 	(plus:P (match_dup 1)
 		 (const_int -1)))
+   (unspec [(const_int 0)] UNSPEC_DOLOOP)
    (clobber (match_scratch:CC 3 "=X,&x,&x,&x"))
    (clobber (match_scratch:P 4 "=X,X,&r,r"))]
   ""
@@ -11943,9 +11986,10 @@
 			  (const_int 1))
 		      (pc)
 		      (label_ref (match_operand 0 "" ""))))
-   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*c*l")
+   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*wi*c*l")
 	(plus:P (match_dup 1)
 		 (const_int -1)))
+   (unspec [(const_int 0)] UNSPEC_DOLOOP)
    (clobber (match_scratch:CC 3 "=X,&x,&x,&x"))
    (clobber (match_scratch:P 4 "=X,X,&r,r"))]
   ""
@@ -11969,9 +12013,10 @@
 			  (const_int 1))
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))
-   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*c*l")
+   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*wi*c*l")
 	(plus:P (match_dup 1)
 		 (const_int -1)))
+   (unspec [(const_int 0)] UNSPEC_DOLOOP)
    (clobber (match_scratch:CC 3 "=X,&x,&x,&x"))
    (clobber (match_scratch:P 4 "=X,X,&r,r"))]
   ""
@@ -11993,9 +12038,10 @@
 			  (const_int 1))
 		      (pc)
 		      (label_ref (match_operand 0 "" ""))))
-   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*c*l")
+   (set (match_operand:P 2 "nonimmediate_operand" "=1,*r,m,*d*wi*c*l")
 	(plus:P (match_dup 1)
 		 (const_int -1)))
+   (unspec [(const_int 0)] UNSPEC_DOLOOP)
    (clobber (match_scratch:CC 3 "=X,&x,&x,&x"))
    (clobber (match_scratch:P 4 "=X,X,&r,r"))]
   ""
@@ -12022,6 +12068,7 @@
 		      (match_operand 6 "" "")))
    (set (match_operand:P 0 "int_reg_operand" "")
 	(plus:P (match_dup 1) (const_int -1)))
+   (unspec [(const_int 0)] UNSPEC_DOLOOP)
    (clobber (match_scratch:CC 3 ""))
    (clobber (match_scratch:P 4 ""))]
   "reload_completed"
@@ -12047,6 +12094,7 @@
 		      (match_operand 6 "" "")))
    (set (match_operand:P 0 "nonimmediate_operand" "")
 	(plus:P (match_dup 1) (const_int -1)))
+   (unspec [(const_int 0)] UNSPEC_DOLOOP)
    (clobber (match_scratch:CC 3 ""))
    (clobber (match_scratch:P 4 ""))]
   "reload_completed && ! gpc_reg_operand (operands[0], SImode)"
@@ -12563,8 +12611,10 @@
    (set_attr "indexed" "no")])
 
 ;; A return instruction which the middle-end doesn't see.
+;; Use r0 to stop regrename twiddling with lr restore insns emitted
+;; after the call to __morestack.
 (define_insn "split_stack_return"
-  [(unspec_volatile [(const_int 0)] UNSPECV_SPLIT_STACK_RETURN)]
+  [(unspec_volatile [(use (reg:SI 0))] UNSPECV_SPLIT_STACK_RETURN)]
   ""
   "blr"
   [(set_attr "type" "jmpreg")])
@@ -13166,7 +13216,7 @@
   operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);
   operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);
 }
-  [(set_attr "type" "fp,fp")
+  [(set_attr "type" "fpsimple,fp")
    (set_attr "length" "4,8")])
 
 (define_insn "unpack<mode>"
@@ -13205,7 +13255,8 @@
 	 (match_operand:IEEE128 2 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsaddqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "sub<mode>3"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13214,7 +13265,8 @@
 	 (match_operand:IEEE128 2 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xssubqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "mul<mode>3"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13223,7 +13275,8 @@
 	 (match_operand:IEEE128 2 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsmulqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "div<mode>3"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13232,7 +13285,8 @@
 	 (match_operand:IEEE128 2 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsdivqp %0,%1,%2"
-  [(set_attr "type" "vecdiv")])
+  [(set_attr "type" "vecdiv")
+   (set_attr "size" "128")])
 
 (define_insn "sqrt<mode>2"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13240,9 +13294,28 @@
 	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
    "xssqrtqp %0,%1"
-  [(set_attr "type" "vecdiv")])
+  [(set_attr "type" "vecdiv")
+   (set_attr "size" "128")])
 
-(define_insn "copysign<mode>3"
+(define_expand "copysign<mode>3"
+  [(use (match_operand:IEEE128 0 "altivec_register_operand"))
+   (use (match_operand:IEEE128 1 "altivec_register_operand"))
+   (use (match_operand:IEEE128 2 "altivec_register_operand"))]
+  "FLOAT128_IEEE_P (<MODE>mode)"
+{
+  if (TARGET_FLOAT128_HW)
+    emit_insn (gen_copysign<mode>3_hard (operands[0], operands[1],
+					 operands[2]));
+  else
+    {
+      rtx tmp = gen_reg_rtx (<MODE>mode);
+      emit_insn (gen_copysign<mode>3_soft (operands[0], operands[1],
+					   operands[2], tmp));
+    }
+  DONE;
+})
+
+(define_insn "copysign<mode>3_hard"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
 	(unspec:IEEE128
 	 [(match_operand:IEEE128 1 "altivec_register_operand" "v")
@@ -13250,7 +13323,20 @@
 	 UNSPEC_COPYSIGN))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
    "xscpsgnqp %0,%2,%1"
-  [(set_attr "type" "vecsimple")])
+  [(set_attr "type" "vecmove")
+   (set_attr "size" "128")])
+
+(define_insn "copysign<mode>3_soft"
+  [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
+	(unspec:IEEE128
+	 [(match_operand:IEEE128 1 "altivec_register_operand" "v")
+	  (match_operand:IEEE128 2 "altivec_register_operand" "v")
+	  (match_operand:IEEE128 3 "altivec_register_operand" "+v")]
+	 UNSPEC_COPYSIGN))]
+  "!TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
+   "xscpsgndp %x3,%x2,%x1\;xxpermdi %x0,%x3,%x1,1"
+  [(set_attr "type" "veccomplex")
+   (set_attr "length" "8")])
 
 (define_insn "neg<mode>2_hw"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13258,7 +13344,8 @@
 	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsnegqp %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecmove")
+   (set_attr "size" "128")])
 
 
 (define_insn "abs<mode>2_hw"
@@ -13267,7 +13354,8 @@
 	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsabsqp %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecmove")
+   (set_attr "size" "128")])
 
 
 (define_insn "*nabs<mode>2_hw"
@@ -13277,7 +13365,8 @@
 	  (match_operand:IEEE128 1 "altivec_register_operand" "v"))))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsnabsqp %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecmove")
+   (set_attr "size" "128")])
 
 ;; Initially don't worry about doing fusion
 (define_insn "*fma<mode>4_hw"
@@ -13288,7 +13377,8 @@
 	 (match_operand:IEEE128 3 "altivec_register_operand" "0")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsmaddqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "*fms<mode>4_hw"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13299,7 +13389,8 @@
 	  (match_operand:IEEE128 3 "altivec_register_operand" "0"))))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsmsubqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "*nfma<mode>4_hw"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13310,7 +13401,8 @@
 	  (match_operand:IEEE128 3 "altivec_register_operand" "0"))))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsnmaddqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "*nfms<mode>4_hw"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13322,7 +13414,8 @@
 	   (match_operand:IEEE128 3 "altivec_register_operand" "0")))))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xsnmsubqp %0,%1,%2"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "extend<SFDF:mode><IEEE128:mode>2_hw"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13330,7 +13423,8 @@
 	 (match_operand:SFDF 1 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
   "xscvdpqp %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 ;; Conversion between KFmode and TFmode if TFmode is ieee 128-bit floating
 ;; point is a simple copy.
@@ -13347,7 +13441,7 @@
   emit_note (NOTE_INSN_DELETED);
   DONE;
 }
-  [(set_attr "type" "*,vecsimple")
+  [(set_attr "type" "*,veclogical")
    (set_attr "length" "0,4")])
 
 (define_insn_and_split "trunctfkf2"
@@ -13363,7 +13457,7 @@
   emit_note (NOTE_INSN_DELETED);
   DONE;
 }
-  [(set_attr "type" "*,vecsimple")
+  [(set_attr "type" "*,veclogical")
    (set_attr "length" "0,4")])
 
 (define_insn "trunc<mode>df2_hw"
@@ -13372,7 +13466,8 @@
 	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xscvqpdp %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 ;; There is no KFmode -> SFmode instruction. Preserve the accuracy by doing
 ;; the KFmode -> DFmode conversion using round to odd rather than the normal
@@ -13469,7 +13564,8 @@
 	 UNSPEC_IEEE128_CONVERT))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xscvqp<su>wz %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "*xscvqp<su>dz_<mode>"
   [(set (match_operand:V2DI 0 "altivec_register_operand" "=v")
@@ -13479,7 +13575,8 @@
 	 UNSPEC_IEEE128_CONVERT))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xscvqp<su>dz %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "*xscv<su>dqp_<mode>"
   [(set (match_operand:IEEE128 0 "altivec_register_operand" "=v")
@@ -13488,7 +13585,8 @@
 		    UNSPEC_IEEE128_CONVERT)))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xscv<su>dqp %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 (define_insn "*ieee128_mfvsrd_64bit"
   [(set (match_operand:DI 0 "reg_or_indexed_operand" "=wr,Z,wi")
@@ -13499,7 +13597,7 @@
    mfvsrd %0,%x1
    stxsdx %x1,%y0
    xxlor %x0,%x1,%x1"
-  [(set_attr "type" "mftgpr,fpstore,vecsimple")])
+  [(set_attr "type" "mftgpr,fpstore,veclogical")])
 
 
 (define_insn "*ieee128_mfvsrd_32bit"
@@ -13510,7 +13608,7 @@
   "@
    stxsdx %x1,%y0
    xxlor %x0,%x1,%x1"
-  [(set_attr "type" "fpstore,vecsimple")])
+  [(set_attr "type" "fpstore,veclogical")])
 
 (define_insn "*ieee128_mfvsrwz"
   [(set (match_operand:SI 0 "reg_or_indexed_operand" "=r,Z")
@@ -13546,7 +13644,7 @@
    mtvsrd %x0,%1
    lxsdx %x0,%y1
    xxlor %x0,%x1,%x1"
-  [(set_attr "type" "mffgpr,fpload,vecsimple")])
+  [(set_attr "type" "mffgpr,fpload,veclogical")])
 
 (define_insn "*ieee128_mtvsrd_32bit"
   [(set (match_operand:V2DI 0 "altivec_register_operand" "=v,v")
@@ -13556,7 +13654,7 @@
   "@
    lxsdx %x0,%y1
    xxlor %x0,%x1,%x1"
-  [(set_attr "type" "fpload,vecsimple")])
+  [(set_attr "type" "fpload,veclogical")])
 
 ;; IEEE 128-bit instructions with round to odd semantics
 (define_insn "*trunc<mode>df2_odd"
@@ -13565,7 +13663,8 @@
 		   UNSPEC_ROUND_TO_ODD))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "xscvqpdpo %0,%1"
-  [(set_attr "type" "vecfloat")])
+  [(set_attr "type" "vecfloat")
+   (set_attr "size" "128")])
 
 ;; IEEE 128-bit comparisons
 (define_insn "*cmp<mode>_hw"
@@ -13574,7 +13673,8 @@
 		      (match_operand:IEEE128 2 "altivec_register_operand" "v")))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
    "xscmpuqp %0,%1,%2"
-  [(set_attr "type" "fpcompare")])
+  [(set_attr "type" "veccmp")
+   (set_attr "size" "128")])
 
 
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs6000.opt gcc-6-20160721/gcc/config/rs6000/rs6000.opt
--- gcc-6.1.0/gcc/config/rs6000/rs6000.opt	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs6000.opt	2016-07-07 19:42:07.000000000 +0000
@@ -470,8 +470,8 @@
 -mlong-double-<n>	Specify size of long double (64 or 128 bits).
 
 mlra
-Target Report Var(rs6000_lra_flag) Init(0) Save
-Use LRA instead of reload.
+Target Report Mask(LRA) Var(rs6000_isa_flags)
+Enable Local Register Allocation.
 
 msched-costly-dep=
 Target RejectNegative Joined Var(rs6000_sched_costly_dep_str)
@@ -605,13 +605,25 @@
 Target Report Mask(P9_FUSION) Var(rs6000_isa_flags)
 Fuse certain operations together for better performance on power9.
 
+mpower9-misc
+Target Undocumented Report Mask(P9_MISC) Var(rs6000_isa_flags)
+Use/do not use certain scalar instructions added in ISA 3.0.
+
 mpower9-vector
 Target Report Mask(P9_VECTOR) Var(rs6000_isa_flags)
-Use/do not use vector and scalar instructions added in ISA 3.0.
+Use/do not use vector instructions added in ISA 3.0.
+
+mpower9-dform-scalar
+Target Undocumented Mask(P9_DFORM_SCALAR) Var(rs6000_isa_flags)
+Use/do not use scalar register+offset memory instructions added in ISA 3.0.
+
+mpower9-dform-vector
+Target Undocumented Mask(P9_DFORM_VECTOR) Var(rs6000_isa_flags)
+Use/do not use vector register+offset memory instructions added in ISA 3.0.
 
 mpower9-dform
-Target Undocumented Mask(P9_DFORM) Var(rs6000_isa_flags)
-Use/do not use vector and scalar instructions added in ISA 3.0.
+Target Report Var(TARGET_P9_DFORM_BOTH) Init(-1) Save
+Use/do not use register+offset memory instructions added in ISA 3.0.
 
 mpower9-minmax
 Target Undocumented Mask(P9_MINMAX) Var(rs6000_isa_flags)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/rs64.md gcc-6-20160721/gcc/config/rs6000/rs64.md
--- gcc-6.1.0/gcc/config/rs6000/rs64.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/rs64.md	2016-07-05 19:19:42.000000000 +0000
@@ -111,7 +111,7 @@
   "mciu_rs64,fpu_rs64,bpu_rs64")
 
 (define_insn_reservation "rs64a-fp" 4
-  (and (eq_attr "type" "fp,dmul")
+  (and (eq_attr "type" "fp,fpsimple,dmul")
        (eq_attr "cpu" "rs64a"))
   "mciu_rs64,fpu_rs64")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/sysv4.h gcc-6-20160721/gcc/config/rs6000/sysv4.h
--- gcc-6.1.0/gcc/config/rs6000/sysv4.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/sysv4.h	2016-05-16 13:47:47.000000000 +0000
@@ -744,21 +744,32 @@
 %{!mnewlib: %{pthread:-lpthread} %{shared:-lc} \
 %{!shared: %{profile:-lc_p} %{!profile:-lc}}}"
 
+#if ENABLE_OFFLOADING == 1
+#define CRTOFFLOADBEGIN "%{fopenacc|fopenmp:crtoffloadbegin%O%s}"
+#define CRTOFFLOADEND "%{fopenacc|fopenmp:crtoffloadend%O%s}"
+#else
+#define CRTOFFLOADBEGIN ""
+#define CRTOFFLOADEND ""
+#endif
+
 #ifdef HAVE_LD_PIE
 #define	STARTFILE_LINUX_SPEC "\
 %{!shared: %{pg|p|profile:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}} \
 %{mnewlib:ecrti.o%s;:crti.o%s} \
-%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \
+" CRTOFFLOADBEGIN
 #else
 #define	STARTFILE_LINUX_SPEC "\
 %{!shared: %{pg|p|profile:gcrt1.o%s;:crt1.o%s}} \
 %{mnewlib:ecrti.o%s;:crti.o%s} \
-%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \
+" CRTOFFLOADBEGIN
 #endif
 
 #define	ENDFILE_LINUX_SPEC "\
 %{shared|pie:crtendS.o%s;:crtend.o%s} \
-%{mnewlib:ecrtn.o%s;:crtn.o%s}"
+%{mnewlib:ecrtn.o%s;:crtn.o%s} \
+" CRTOFFLOADEND
 
 #define LINK_START_LINUX_SPEC ""
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/t-rs6000 gcc-6-20160721/gcc/config/rs6000/t-rs6000
--- gcc-6.1.0/gcc/config/rs6000/t-rs6000	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/t-rs6000	2016-07-06 02:31:08.000000000 +0000
@@ -50,6 +50,7 @@
 	$(srcdir)/config/rs6000/power6.md \
 	$(srcdir)/config/rs6000/power7.md \
 	$(srcdir)/config/rs6000/power8.md \
+	$(srcdir)/config/rs6000/power9.md \
 	$(srcdir)/config/rs6000/cell.md \
 	$(srcdir)/config/rs6000/xfpu.md \
 	$(srcdir)/config/rs6000/a2.md \
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/titan.md gcc-6-20160721/gcc/config/rs6000/titan.md
--- gcc-6.1.0/gcc/config/rs6000/titan.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/titan.md	2016-07-05 19:19:42.000000000 +0000
@@ -156,7 +156,7 @@
 ;; Make sure the "titan_fp" rule stays last, as it's a catch all for
 ;; double-precision and unclassified (e.g. fsel) FP-instructions
 (define_insn_reservation "titan_fp" 10
-  (and (eq_attr "type" "fpcompare,fp,dmul")
+  (and (eq_attr "type" "fpcompare,fp,fpsimple,dmul")
        (eq_attr "cpu" "titan"))
   "titan_issue,titan_fp0*2,nothing*8,titan_fpwb")
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/vector.md gcc-6-20160721/gcc/config/rs6000/vector.md
--- gcc-6.1.0/gcc/config/rs6000/vector.md	2016-01-20 19:39:08.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/vector.md	2016-06-01 23:23:42.000000000 +0000
@@ -26,6 +26,13 @@
 ;; Vector int modes
 (define_mode_iterator VEC_I [V16QI V8HI V4SI V2DI])
 
+;; Vector int modes for parity
+(define_mode_iterator VEC_IP [V8HI
+			      V4SI
+			      V2DI
+			      V1TI
+			      (TI "TARGET_VSX_TIMODE")])
+
 ;; Vector float modes
 (define_mode_iterator VEC_F [V4SF V2DF])
 
@@ -738,12 +745,24 @@
 	(clz:VEC_I (match_operand:VEC_I 1 "register_operand" "")))]
   "TARGET_P8_VECTOR")
 
+;; Vector count trailing zeros
+(define_expand "ctz<mode>2"
+  [(set (match_operand:VEC_I 0 "register_operand" "")
+	(ctz:VEC_I (match_operand:VEC_I 1 "register_operand" "")))]
+  "TARGET_P9_VECTOR")
+
 ;; Vector population count
 (define_expand "popcount<mode>2"
   [(set (match_operand:VEC_I 0 "register_operand" "")
         (popcount:VEC_I (match_operand:VEC_I 1 "register_operand" "")))]
   "TARGET_P8_VECTOR")
 
+;; Vector parity
+(define_expand "parity<mode>2"
+  [(set (match_operand:VEC_IP 0 "register_operand" "")
+	(parity:VEC_IP (match_operand:VEC_IP 1 "register_operand" "")))]
+  "TARGET_P9_VECTOR")
+
 
 ;; Same size conversions
 (define_expand "float<VEC_int><mode>2"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/vsx.md gcc-6-20160721/gcc/config/rs6000/vsx.md
--- gcc-6.1.0/gcc/config/rs6000/vsx.md	2016-02-15 23:29:17.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/vsx.md	2016-07-07 22:44:15.000000000 +0000
@@ -55,8 +55,7 @@
 			     (KF	"FLOAT128_VECTOR_P (KFmode)")
 			     (TF	"FLOAT128_VECTOR_P (TFmode)")])
 
-;; Iterator for memory move.  Handle TImode specially to allow
-;; it to use gprs as well as vsx registers.
+;; Iterator for memory moves.
 (define_mode_iterator VSX_M [V16QI
 			     V8HI
 			     V4SI
@@ -65,18 +64,8 @@
 			     V2DF
 			     V1TI
 			     (KF	"FLOAT128_VECTOR_P (KFmode)")
-			     (TF	"FLOAT128_VECTOR_P (TFmode)")])
-
-(define_mode_iterator VSX_M2 [V16QI
-			      V8HI
-			      V4SI
-			      V2DI
-			      V4SF
-			      V2DF
-			      V1TI
-			      (KF	"FLOAT128_VECTOR_P (KFmode)")
-			      (TF	"FLOAT128_VECTOR_P (TFmode)")
-			      (TI	"TARGET_VSX_TIMODE")])
+			     (TF	"FLOAT128_VECTOR_P (TFmode)")
+			     (TI	"TARGET_VSX_TIMODE")])
 
 ;; Map into the appropriate load/store name based on the type
 (define_mode_attr VSm  [(V16QI "vw4")
@@ -270,6 +259,10 @@
 (define_mode_attr VS_64reg [(V2DF	"ws")
 			    (V2DI	"wi")])
 
+;; Iterators for loading constants with xxspltib
+(define_mode_iterator VSINT_84  [V4SI V2DI])
+(define_mode_iterator VSINT_842 [V8HI V4SI V2DI])
+
 ;; Constants for creating unspecs
 (define_c_enum "unspec"
   [UNSPEC_VSX_CONCAT
@@ -299,26 +292,9 @@
    UNSPEC_VSX_XVCVUXDDP
    UNSPEC_VSX_XVCVDPSXDS
    UNSPEC_VSX_XVCVDPUXDS
+   UNSPEC_VSX_SIGN_EXTEND
   ])
 
-;; VSX (P9) moves
-
-(define_insn "*p9_vecload_<mode>"
-  [(set (match_operand:VSX_M2 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_M2 1 "memory_operand" "Z"))]
-  "TARGET_P9_VECTOR"
-  "lxvx %x0,%y1"
-  [(set_attr "type" "vecload")
-   (set_attr "length" "4")])
-
-(define_insn "*p9_vecstore_<mode>"
-  [(set (match_operand:VSX_M2 0 "memory_operand" "=Z")
-        (match_operand:VSX_M2 1 "vsx_register_operand" "<VSa>"))]
-  "TARGET_P9_VECTOR"
-  "stxvx %x1,%y0"
-  [(set_attr "type" "vecstore")
-   (set_attr "length" "4")])
-
 ;; VSX moves
 
 ;; The patterns for LE permuted loads and stores come before the general
@@ -709,7 +685,7 @@
     }
 }
   [(set_attr "length" "0,4")
-   (set_attr "type" "vecsimple")])
+   (set_attr "type" "veclogical")])
 
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_LE_128 0 "vsx_register_operand" "=<VSa>")
@@ -787,92 +763,141 @@
 			   (const_int 64)))]
   "")
 
-(define_insn "*vsx_mov<mode>"
-  [(set (match_operand:VSX_M 0 "nonimmediate_operand" "=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,r,we,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ,v")
-	(match_operand:VSX_M 1 "input_operand" "<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,we,b,r,wQ,r,Y,r,j,j,j,W,v,wZ"))]
-  "VECTOR_MEM_VSX_P (<MODE>mode)
-   && (register_operand (operands[0], <MODE>mode) 
-       || register_operand (operands[1], <MODE>mode))"
+;; Vector constants that can be generated with XXSPLTIB that was added in ISA
+;; 3.0.  Both (const_vector [..]) and (vec_duplicate ...) forms are recognized.
+(define_insn "xxspltib_v16qi"
+  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
+	(vec_duplicate:V16QI (match_operand:SI 1 "s8bit_cint_operand" "n")))]
+  "TARGET_P9_VECTOR"
 {
-  return rs6000_output_move_128bit (operands);
+  operands[2] = GEN_INT (INTVAL (operands[1]) & 0xff);
+  return "xxspltib %x0,%2";
 }
-  [(set_attr "type" "vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,mffgpr,mftgpr,load,store,store,load, *,vecsimple,vecsimple,*, *,vecstore,vecload")
-   (set_attr "length" "4,4,4,4,4,4,8,4,12,12,12,12,16,4,4,*,16,4,4")])
+  [(set_attr "type" "vecperm")])
 
-;; Unlike other VSX moves, allow the GPRs even for reloading, since a normal
-;; use of TImode is for unions.  However for plain data movement, slightly
-;; favor the vector loads
-(define_insn "*vsx_movti_64bit"
-  [(set (match_operand:TI 0 "nonimmediate_operand" "=Z,wa,wa,wa,r,we,v,v,wZ,wQ,&r,Y,r,r,?r")
-	(match_operand:TI 1 "input_operand" "wa,Z,wa,O,we,b,W,wZ,v,r,wQ,r,Y,r,n"))]
-  "TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)
-   && (register_operand (operands[0], TImode) 
-       || register_operand (operands[1], TImode))"
+(define_insn "xxspltib_<mode>_nosplit"
+  [(set (match_operand:VSINT_842 0 "vsx_register_operand" "=wa,wa")
+	(match_operand:VSINT_842 1 "xxspltib_constant_nosplit" "jwM,wE"))]
+  "TARGET_P9_VECTOR"
 {
-  return rs6000_output_move_128bit (operands);
+  rtx op1 = operands[1];
+  int value = 256;
+  int num_insns = -1;
+
+  if (!xxspltib_constant_p (op1, <MODE>mode, &num_insns, &value)
+      || num_insns != 1)
+    gcc_unreachable ();
+
+  operands[2] = GEN_INT (value & 0xff);
+  return "xxspltib %x0,%2";
 }
-  [(set_attr "type" "vecstore,vecload,vecsimple,vecsimple,mffgpr,mftgpr,vecsimple,vecstore,vecload,store,load,store,load,*,*")
-   (set_attr "length" "4,4,4,4,8,4,16,4,4,8,8,8,8,8,8")])
+  [(set_attr "type" "vecperm")])
 
-(define_insn "*vsx_movti_32bit"
-  [(set (match_operand:TI 0 "nonimmediate_operand" "=Z,wa,wa,wa,v, v,wZ,Q,Y,????r,????r,????r,r")
-	(match_operand:TI 1 "input_operand"        "wa, Z,wa, O,W,wZ, v,r,r,    Q,    Y,    r,n"))]
-  "! TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)
-   && (register_operand (operands[0], TImode)
-       || register_operand (operands[1], TImode))"
+(define_insn_and_split "*xxspltib_<mode>_split"
+  [(set (match_operand:VSINT_842 0 "altivec_register_operand" "=v")
+	(match_operand:VSINT_842 1 "xxspltib_constant_split" "wS"))]
+  "TARGET_P9_VECTOR"
+  "#"
+  "&& 1"
+  [(const_int 0)]
 {
-  switch (which_alternative)
-    {
-    case 0:
-      return "stxvd2x %x1,%y0";
+  int value = 256;
+  int num_insns = -1;
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx tmp = ((can_create_pseudo_p ())
+	     ? gen_reg_rtx (V16QImode)
+	     : gen_lowpart (V16QImode, op0));
 
-    case 1:
-      return "lxvd2x %x0,%y1";
+  if (!xxspltib_constant_p (op1, <MODE>mode, &num_insns, &value)
+      || num_insns != 2)
+    gcc_unreachable ();
 
-    case 2:
-      return "xxlor %x0,%x1,%x1";
+  emit_insn (gen_xxspltib_v16qi (tmp, GEN_INT (value)));
 
-    case 3:
-      return "xxlxor %x0,%x0,%x0";
+  if (<MODE>mode == V2DImode)
+    emit_insn (gen_vsx_sign_extend_qi_v2di (op0, tmp));
 
-    case 4:
-      return output_vec_const_move (operands);
+  else if (<MODE>mode == V4SImode)
+    emit_insn (gen_vsx_sign_extend_qi_v4si (op0, tmp));
 
-    case 5:
-      return "stvx %1,%y0";
+  else if (<MODE>mode == V8HImode)
+    emit_insn (gen_altivec_vupkhsb  (op0, tmp));
 
-    case 6:
-      return "lvx %0,%y1";
-
-    case 7:
-      if (TARGET_STRING)
-        return \"stswi %1,%P0,16\";
-
-    case 8:
-      return \"#\";
-
-    case 9:
-      /* If the address is not used in the output, we can use lsi.  Otherwise,
-	 fall through to generating four loads.  */
-      if (TARGET_STRING
-          && ! reg_overlap_mentioned_p (operands[0], operands[1]))
-	return \"lswi %0,%P1,16\";
-      /* ... fall through ...  */
-
-    case 10:
-    case 11:
-    case 12:
-      return \"#\";
-    default:
-      gcc_unreachable ();
-    }
+  else
+    gcc_unreachable ();
+
+  DONE;
 }
-  [(set_attr "type" "vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,store,store,load,load, *, *")
-   (set_attr "update" "     *,      *,        *,       *,         *,       *,      *,  yes,  yes, yes, yes, *, *")
-   (set_attr "length" "     4,      4,        4,       4,         8,       4,      4,   16,   16,  16,  16,16,16")
-   (set (attr "cell_micro") (if_then_else (match_test "TARGET_STRING")
-   			                  (const_string "always")
-					  (const_string "conditional")))])
+  [(set_attr "type" "vecperm")
+   (set_attr "length" "8")])
+
+
+;; Prefer using vector registers over GPRs.  Prefer using ISA 3.0's XXSPLTISB
+;; or Altivec VSPLITW 0/-1 over XXLXOR/XXLORC to set a register to all 0's or
+;; all 1's, since the machine does not have to wait for the previous
+;; instruction using the register being set (such as a store waiting on a slow
+;; instruction). But generate XXLXOR/XXLORC if it will avoid a register move.
+
+;;              VSX store  VSX load   VSX move  VSX->GPR   GPR->VSX    LQ (GPR)
+;;              STQ (GPR)  GPR load   GPR store GPR move   XXSPLTIB    VSPLTISW
+;;              VSX 0/-1   GPR 0/-1   VMX const GPR const  LVX (VMX)   STVX (VMX)
+(define_insn "*vsx_mov<mode>_64bit"
+  [(set (match_operand:VSX_M 0 "nonimmediate_operand"
+               "=ZwO,      <VSa>,     <VSa>,     r,         we,        ?wQ,
+                ?&r,       ??r,       ??Y,       ??r,       wo,        v,
+                ?<VSa>,    *r,        v,         ??r,       wZ,        v")
+
+	(match_operand:VSX_M 1 "input_operand" 
+               "<VSa>,     ZwO,       <VSa>,     we,        r,         r,
+                wQ,        Y,         r,         r,         wE,        jwM,
+                ?jwM,      jwM,       W,         W,         v,         wZ"))]
+
+  "TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)
+   && (register_operand (operands[0], <MODE>mode) 
+       || register_operand (operands[1], <MODE>mode))"
+{
+  return rs6000_output_move_128bit (operands);
+}
+  [(set_attr "type"
+               "vecstore,  vecload,   vecsimple, mffgpr,    mftgpr,    load,
+                store,     load,      store,     *,         vecsimple, vecsimple,
+                vecsimple, *,         *,         *,         vecstore,  vecload")
+
+   (set_attr "length"
+               "4,         4,         4,         8,         4,         8,
+                8,         8,         8,         8,         4,         4,
+                4,         8,         20,        20,        4,         4")])
+
+;;              VSX store  VSX load   VSX move   GPR load   GPR store  GPR move
+;;              XXSPLTIB   VSPLTISW   VSX 0/-1   GPR 0/-1   VMX const  GPR const
+;;              LVX (VMX)  STVX (VMX)
+(define_insn "*vsx_mov<mode>_32bit"
+  [(set (match_operand:VSX_M 0 "nonimmediate_operand"
+               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       ??r,
+                wo,        v,         ?<VSa>,    *r,        v,         ??r,
+                wZ,        v")
+
+	(match_operand:VSX_M 1 "input_operand" 
+               "<VSa>,     ZwO,       <VSa>,     Y,         r,         r,
+                wE,        jwM,       ?jwM,      jwM,       W,         W,
+                v,         wZ"))]
+
+  "!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)
+   && (register_operand (operands[0], <MODE>mode) 
+       || register_operand (operands[1], <MODE>mode))"
+{
+  return rs6000_output_move_128bit (operands);
+}
+  [(set_attr "type"
+               "vecstore,  vecload,   vecsimple, load,      store,    *,
+                vecsimple, vecsimple, vecsimple, *,         *,        *,
+                vecstore,  vecload")
+
+   (set_attr "length"
+               "4,         4,         4,         16,        16,        16,
+                4,         4,         4,         16,        20,        32,
+                4,         4")])
 
 ;; Explicit  load/store expanders for the builtin functions
 (define_expand "vsx_load_<mode>"
@@ -887,6 +912,140 @@
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "")
 
+;; Explicit load/store expanders for the builtin functions for lxvd2x, etc.,
+;; when you really want their element-reversing behavior.
+(define_insn "vsx_ld_elemrev_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (vec_select:V2DI
+	  (match_operand:V2DI 1 "memory_operand" "Z")
+	  (parallel [(const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V2DImode) && !BYTES_BIG_ENDIAN"
+  "lxvd2x %x0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "vsx_ld_elemrev_v2df"
+  [(set (match_operand:V2DF 0 "vsx_register_operand" "=wa")
+        (vec_select:V2DF
+	  (match_operand:V2DF 1 "memory_operand" "Z")
+	  (parallel [(const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V2DFmode) && !BYTES_BIG_ENDIAN"
+  "lxvd2x %x0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "vsx_ld_elemrev_v4si"
+  [(set (match_operand:V4SI 0 "vsx_register_operand" "=wa")
+        (vec_select:V4SI
+	  (match_operand:V4SI 1 "memory_operand" "Z")
+	  (parallel [(const_int 3) (const_int 2)
+	             (const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V4SImode) && !BYTES_BIG_ENDIAN"
+  "lxvw4x %x0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "vsx_ld_elemrev_v4sf"
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa")
+        (vec_select:V4SF
+	  (match_operand:V4SF 1 "memory_operand" "Z")
+	  (parallel [(const_int 3) (const_int 2)
+	             (const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V4SFmode) && !BYTES_BIG_ENDIAN"
+  "lxvw4x %x0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "vsx_ld_elemrev_v8hi"
+  [(set (match_operand:V8HI 0 "vsx_register_operand" "=wa")
+        (vec_select:V8HI
+	  (match_operand:V8HI 1 "memory_operand" "Z")
+	  (parallel [(const_int 7) (const_int 6)
+	             (const_int 5) (const_int 4)
+		     (const_int 3) (const_int 2)
+	             (const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V8HImode) && !BYTES_BIG_ENDIAN && TARGET_P9_VECTOR"
+  "lxvh8x %x0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "vsx_ld_elemrev_v16qi"
+  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
+        (vec_select:V16QI
+	  (match_operand:V16QI 1 "memory_operand" "Z")
+	  (parallel [(const_int 15) (const_int 14)
+	             (const_int 13) (const_int 12)
+		     (const_int 11) (const_int 10)
+		     (const_int  9) (const_int  8)
+		     (const_int  7) (const_int  6)
+	             (const_int  5) (const_int  4)
+		     (const_int  3) (const_int  2)
+	             (const_int  1) (const_int  0)])))]
+  "VECTOR_MEM_VSX_P (V16QImode) && !BYTES_BIG_ENDIAN && TARGET_P9_VECTOR"
+  "lxvb16x %x0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "vsx_st_elemrev_v2df"
+  [(set (match_operand:V2DF 0 "memory_operand" "=Z")
+        (vec_select:V2DF
+	  (match_operand:V2DF 1 "vsx_register_operand" "wa")
+	  (parallel [(const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V2DFmode) && !BYTES_BIG_ENDIAN"
+  "stxvd2x %x1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "vsx_st_elemrev_v2di"
+  [(set (match_operand:V2DI 0 "memory_operand" "=Z")
+        (vec_select:V2DI
+	  (match_operand:V2DI 1 "vsx_register_operand" "wa")
+	  (parallel [(const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V2DImode) && !BYTES_BIG_ENDIAN"
+  "stxvd2x %x1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "vsx_st_elemrev_v4sf"
+  [(set (match_operand:V4SF 0 "memory_operand" "=Z")
+        (vec_select:V4SF
+	  (match_operand:V4SF 1 "vsx_register_operand" "wa")
+	  (parallel [(const_int 3) (const_int 2)
+	             (const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V4SFmode) && !BYTES_BIG_ENDIAN"
+  "stxvw4x %x1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "vsx_st_elemrev_v4si"
+  [(set (match_operand:V4SI 0 "memory_operand" "=Z")
+        (vec_select:V4SI
+	  (match_operand:V4SI 1 "vsx_register_operand" "wa")
+	  (parallel [(const_int 3) (const_int 2)
+	             (const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V4SImode) && !BYTES_BIG_ENDIAN"
+  "stxvw4x %x1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "vsx_st_elemrev_v8hi"
+  [(set (match_operand:V8HI 0 "memory_operand" "=Z")
+        (vec_select:V8HI
+	  (match_operand:V8HI 1 "vsx_register_operand" "wa")
+	  (parallel [(const_int 7) (const_int 6)
+	             (const_int 5) (const_int 4)
+		     (const_int 3) (const_int 2)
+	             (const_int 1) (const_int 0)])))]
+  "VECTOR_MEM_VSX_P (V8HImode) && !BYTES_BIG_ENDIAN && TARGET_P9_VECTOR"
+  "stxvh8x %x1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "vsx_st_elemrev_v16qi"
+  [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+        (vec_select:V16QI
+	  (match_operand:V16QI 1 "vsx_register_operand" "wa")
+	  (parallel [(const_int 15) (const_int 14)
+	             (const_int 13) (const_int 12)
+		     (const_int 11) (const_int 10)
+		     (const_int  9) (const_int  8)
+	             (const_int  7) (const_int  6)
+	             (const_int  5) (const_int  4)
+		     (const_int  3) (const_int  2)
+	             (const_int  1) (const_int  0)])))]
+  "VECTOR_MEM_VSX_P (V16QImode) && !BYTES_BIG_ENDIAN && TARGET_P9_VECTOR"
+  "stxvb16x %x1,%y0"
+  [(set_attr "type" "vecstore")])
+
 
 ;; VSX vector floating point arithmetic instructions.  The VSX scalar
 ;; instructions are now combined with the insn for the traditional floating
@@ -1333,7 +1492,7 @@
 	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxsel %x0,%x3,%x2,%x1"
-  [(set_attr "type" "vecperm")])
+  [(set_attr "type" "vecmove")])
 
 (define_insn "*vsx_xxsel<mode>_uns"
   [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?<VSa>")
@@ -1344,7 +1503,7 @@
 	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxsel %x0,%x3,%x2,%x1"
-  [(set_attr "type" "vecperm")])
+  [(set_attr "type" "vecmove")])
 
 ;; Copy sign
 (define_insn "vsx_copysign<mode>3"
@@ -1583,10 +1742,15 @@
 {
   rtx op0 = operands[0];
   rtx op1 = operands[1];
-  rtx tmp = gen_reg_rtx (V2DFmode);
-  int scale = INTVAL(operands[2]);
-  if (scale != 0)
-    rs6000_scale_v2df (tmp, op1, scale);
+  rtx tmp;
+  int scale = INTVAL (operands[2]);
+  if (scale == 0)
+    tmp = op1;
+  else
+    {
+      tmp  = gen_reg_rtx (V2DFmode);
+      rs6000_scale_v2df (tmp, op1, scale);
+    }
   emit_insn (gen_vsx_xvcvdpsxds (op0, tmp));
   DONE;
 })
@@ -1607,10 +1771,15 @@
 {
   rtx op0 = operands[0];
   rtx op1 = operands[1];
-  rtx tmp = gen_reg_rtx (V2DFmode);
-  int scale = INTVAL(operands[2]);
-  if (scale != 0)
-    rs6000_scale_v2df (tmp, op1, scale);
+  rtx tmp;
+  int scale = INTVAL (operands[2]);
+  if (scale == 0)
+    tmp = op1;
+  else
+    {
+      tmp = gen_reg_rtx (V2DFmode);
+      rs6000_scale_v2df (tmp, op1, scale);
+    }
   emit_insn (gen_vsx_xvcvdpuxds (op0, tmp));
   DONE;
 })
@@ -1960,7 +2129,7 @@
 
   return "xxlor %x0,%x1,%x1";
 }
-  [(set_attr "type" "fp,vecsimple,mftgpr,mftgpr")
+  [(set_attr "type" "fpsimple,veclogical,mftgpr,mftgpr")
    (set_attr "length" "4")])
 
 (define_insn "*vsx_extract_<mode>_internal2"
@@ -1995,7 +2164,7 @@
   operands[3] = GEN_INT (fldDM);
   return "xxpermdi %x0,%x1,%x1,%3";
 }
-  [(set_attr "type" "fp,vecsimple,vecperm")
+  [(set_attr "type" "fpsimple,veclogical,vecperm")
    (set_attr "length" "4")])
 
 ;; Optimize extracting a single scalar element from memory if the scalar is in
@@ -2215,20 +2384,61 @@
 
 ;; V2DF/V2DI splat
 (define_insn "vsx_splat_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,wd,wd,?<VSa>,?<VSa>,?<VSa>")
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>,<VSa>,we")
 	(vec_duplicate:VSX_D
-	 (match_operand:<VS_scalar> 1 "splat_input_operand" "<VS_64reg>,f,Z,<VSa>,<VSa>,Z")))]
+	 (match_operand:<VS_scalar> 1 "splat_input_operand" "<VS_64reg>,Z,b")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "@
    xxpermdi %x0,%x1,%x1,0
-   xxpermdi %x0,%x1,%x1,0
    lxvdsx %x0,%y1
-   xxpermdi %x0,%x1,%x1,0
-   xxpermdi %x0,%x1,%x1,0
-   lxvdsx %x0,%y1"
-  [(set_attr "type" "vecperm,vecperm,vecload,vecperm,vecperm,vecload")])
+   mtvsrdd %x0,%1,%1"
+  [(set_attr "type" "vecperm,vecload,mftgpr")])
+
+;; V4SI splat (ISA 3.0)
+;; When SI's are allowed in VSX registers, add XXSPLTW support
+(define_expand "vsx_splat_<mode>"
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "")
+	(vec_duplicate:VSX_W
+	 (match_operand:<VS_scalar> 1 "splat_input_operand" "")))]
+  "TARGET_P9_VECTOR"
+{
+  if (MEM_P (operands[1]))
+    operands[1] = rs6000_address_for_fpconvert (operands[1]);
+  else if (!REG_P (operands[1]))
+    operands[1] = force_reg (<VS_scalar>mode, operands[1]);
+})
 
-;; V4SF/V4SI splat
+(define_insn "*vsx_splat_v4si_internal"
+  [(set (match_operand:V4SI 0 "vsx_register_operand" "=wa,wa")
+	(vec_duplicate:V4SI
+	 (match_operand:SI 1 "splat_input_operand" "r,Z")))]
+  "TARGET_P9_VECTOR"
+  "@
+   mtvsrws %x0,%1
+   lxvwsx %x0,%y1"
+  [(set_attr "type" "mftgpr,vecload")])
+
+;; V4SF splat (ISA 3.0)
+(define_insn_and_split "*vsx_splat_v4sf_internal"
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa,wa,wa")
+	(vec_duplicate:V4SF
+	 (match_operand:SF 1 "splat_input_operand" "Z,wy,r")))]
+  "TARGET_P9_VECTOR"
+  "@
+   lxvwsx %x0,%y1
+   #
+   mtvsrws %x0,%1"
+  "&& reload_completed && vsx_register_operand (operands[1], SFmode)"
+  [(set (match_dup 0)
+	(unspec:V4SF [(match_dup 1)] UNSPEC_VSX_CVDPSPN))
+   (set (match_dup 0)
+	(unspec:V4SF [(match_dup 0)
+		      (const_int 0)] UNSPEC_VSX_XXSPLTW))]
+  ""
+  [(set_attr "type" "vecload,vecperm,mftgpr")
+   (set_attr "length" "4,8,4")])
+
+;; V4SF/V4SI splat from a vector element
 (define_insn "vsx_xxspltw_<mode>"
   [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
 	(vec_duplicate:VSX_W
@@ -2471,21 +2681,50 @@
 (define_peephole
   [(set (match_operand:P 0 "base_reg_operand" "")
 	(match_operand:P 1 "short_cint_operand" ""))
-   (set (match_operand:VSX_M2 2 "vsx_register_operand" "")
-	(mem:VSX_M2 (plus:P (match_dup 0)
-			    (match_operand:P 3 "int_reg_operand" ""))))]
+   (set (match_operand:VSX_M 2 "vsx_register_operand" "")
+	(mem:VSX_M (plus:P (match_dup 0)
+			   (match_operand:P 3 "int_reg_operand" ""))))]
   "TARGET_VSX && TARGET_P8_FUSION && !TARGET_P9_VECTOR"
-  "li %0,%1\t\t\t# vector load fusion\;lx<VSX_M2:VSm>x %x2,%0,%3"  
+  "li %0,%1\t\t\t# vector load fusion\;lx<VSX_M:VSm>x %x2,%0,%3"  
   [(set_attr "length" "8")
    (set_attr "type" "vecload")])
 
 (define_peephole
   [(set (match_operand:P 0 "base_reg_operand" "")
 	(match_operand:P 1 "short_cint_operand" ""))
-   (set (match_operand:VSX_M2 2 "vsx_register_operand" "")
-	(mem:VSX_M2 (plus:P (match_operand:P 3 "int_reg_operand" "")
-			    (match_dup 0))))]
+   (set (match_operand:VSX_M 2 "vsx_register_operand" "")
+	(mem:VSX_M (plus:P (match_operand:P 3 "int_reg_operand" "")
+			   (match_dup 0))))]
   "TARGET_VSX && TARGET_P8_FUSION && !TARGET_P9_VECTOR"
-  "li %0,%1\t\t\t# vector load fusion\;lx<VSX_M2:VSm>x %x2,%0,%3"  
+  "li %0,%1\t\t\t# vector load fusion\;lx<VSX_M:VSm>x %x2,%0,%3"  
   [(set_attr "length" "8")
    (set_attr "type" "vecload")])
+
+
+;; ISA 3.0 vector extend sign support
+
+(define_insn "vsx_sign_extend_qi_<mode>"
+  [(set (match_operand:VSINT_84 0 "vsx_register_operand" "=v")
+	(unspec:VSINT_84
+	 [(match_operand:V16QI 1 "vsx_register_operand" "v")]
+	 UNSPEC_VSX_SIGN_EXTEND))]
+  "TARGET_P9_VECTOR"
+  "vextsb2<wd> %0,%1"
+  [(set_attr "type" "vecexts")])
+
+(define_insn "*vsx_sign_extend_hi_<mode>"
+  [(set (match_operand:VSINT_84 0 "vsx_register_operand" "=v")
+	(unspec:VSINT_84
+	 [(match_operand:V8HI 1 "vsx_register_operand" "v")]
+	 UNSPEC_VSX_SIGN_EXTEND))]
+  "TARGET_P9_VECTOR"
+  "vextsh2<wd> %0,%1"
+  [(set_attr "type" "vecexts")])
+
+(define_insn "*vsx_sign_extend_si_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=v")
+	(unspec:V2DI [(match_operand:V4SI 1 "vsx_register_operand" "v")]
+		     UNSPEC_VSX_SIGN_EXTEND))]
+  "TARGET_P9_VECTOR"
+  "vextsw2d %0,%1"
+  [(set_attr "type" "vecexts")])
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rs6000/xfpu.md gcc-6-20160721/gcc/config/rs6000/xfpu.md
--- gcc-6.1.0/gcc/config/rs6000/xfpu.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rs6000/xfpu.md	2016-07-05 19:19:42.000000000 +0000
@@ -55,7 +55,7 @@
 
 (define_insn_reservation "fp-default" 2
   (and (and 
-        (eq_attr "type" "fp")
+        (eq_attr "type" "fp,fpsimple")
         (eq_attr "fp_type" "fp_default"))
        (eq_attr "cpu" "ppc405"))
   "Xfpu_issue*2")
@@ -67,14 +67,14 @@
 
 (define_insn_reservation "fp-addsub-s" 14
   (and (and
-        (eq_attr "type" "fp")
+        (eq_attr "type" "fp,fpsimple")
         (eq_attr "fp_type" "fp_addsub_s"))
        (eq_attr "cpu" "ppc405"))
   "Xfpu_issue*2,Xfpu_addsub")
 
 (define_insn_reservation "fp-addsub-d" 18
   (and (and
-        (eq_attr "type" "fp")
+        (eq_attr "type" "fp,fpsimple")
         (eq_attr "fp_type" "fp_addsub_d"))
        (eq_attr "cpu" "ppc405"))
   "Xfpu_issue*2,Xfpu_addsub")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/rtems.h gcc-6-20160721/gcc/config/rtems.h
--- gcc-6.1.0/gcc/config/rtems.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/rtems.h	2016-05-10 07:03:07.000000000 +0000
@@ -45,6 +45,6 @@
 #define LIB_SPEC "%{!qrtems: " STD_LIB_SPEC "} " \
 "%{!nostdlib: %{qrtems: --start-group \
  -lrtemsbsp -lrtemscpu \
- -lc -lgcc --end-group %{!qnolinkcmds: -T linkcmds%s}}}"
+ -latomic -lc -lgcc --end-group %{!qnolinkcmds: -T linkcmds%s}}}"
 
 #define TARGET_POSIX_IO
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/s390/s390.c gcc-6-20160721/gcc/config/s390/s390.c
--- gcc-6.1.0/gcc/config/s390/s390.c	2016-04-20 07:16:03.000000000 +0000
+++ gcc-6-20160721/gcc/config/s390/s390.c	2016-07-20 18:35:04.000000000 +0000
@@ -791,7 +791,7 @@
 		     machine_mode mode ATTRIBUTE_UNUSED,
 		     int ignore ATTRIBUTE_UNUSED)
 {
-#define MAX_ARGS 5
+#define MAX_ARGS 6
 
   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);
@@ -12405,17 +12405,13 @@
     {
       /* Store the alignment to be able to check if we can use
 	 a larl/load-relative instruction.  We only handle the cases
-	 that can go wrong (i.e. no FUNC_DECLs).  If a symref does
-	 not have any flag we assume it to be correctly aligned.  */
-
-      if (DECL_ALIGN (decl) % 64)
-	SYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));
-
-      if (DECL_ALIGN (decl) % 32)
-	SYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));
-
+	 that can go wrong (i.e. no FUNC_DECLs).  */
       if (DECL_ALIGN (decl) == 0 || DECL_ALIGN (decl) % 16)
 	SYMBOL_FLAG_SET_NOTALIGN2 (XEXP (rtl, 0));
+      else if (DECL_ALIGN (decl) % 32)
+	SYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));
+      else if (DECL_ALIGN (decl) % 64)
+	SYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));
     }
 
   /* Literal pool references don't have a decl so they are handled
@@ -12423,18 +12419,14 @@
      entry to decide upon the alignment.  */
   if (MEM_P (rtl)
       && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF
-      && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0))
-      && MEM_ALIGN (rtl) != 0
-      && GET_MODE_BITSIZE (GET_MODE (rtl)) != 0)
+      && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0)))
     {
-      if (MEM_ALIGN (rtl) % 64)
-	SYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));
-
-      if (MEM_ALIGN (rtl) % 32)
-	SYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));
-
       if (MEM_ALIGN (rtl) == 0 || MEM_ALIGN (rtl) % 16)
 	SYMBOL_FLAG_SET_NOTALIGN2 (XEXP (rtl, 0));
+      else if (MEM_ALIGN (rtl) % 32)
+	SYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));
+      else if (MEM_ALIGN (rtl) % 64)
+	SYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));
     }
 }
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/s390/s390.md gcc-6-20160721/gcc/config/s390/s390.md
--- gcc-6.1.0/gcc/config/s390/s390.md	2016-04-20 07:16:03.000000000 +0000
+++ gcc-6-20160721/gcc/config/s390/s390.md	2016-05-10 09:02:37.000000000 +0000
@@ -1295,7 +1295,7 @@
 	(compare:VFCMP (match_operand:DF 0 "register_operand" "v")
 		       (match_operand:DF 1 "register_operand" "v")))
    (clobber (match_scratch:V2DI 2 "=v"))]
-  "TARGET_Z13 && TARGET_HARD_FLOAT"
+  "TARGET_VX && TARGET_HARD_FLOAT"
   "wfc<asm_fcmp>dbs\t%v2,%v0,%v1"
   [(set_attr "op_type" "VRR")])
 
@@ -4649,7 +4649,7 @@
 	(unsigned_fix:DI (match_operand:DF 1 "register_operand"  "f,v")))
    (unspec:DI [(match_operand:DI           2 "immediate_operand" "K,K")] UNSPEC_ROUND)
    (clobber (reg:CC CC_REGNUM))]
-   "TARGET_Z13 && TARGET_HARD_FLOAT"
+   "TARGET_VX && TARGET_HARD_FLOAT"
    "@
     clgdbr\t%0,%h2,%1,0
     wclgdb\t%v0,%v1,0,%h2"
@@ -4664,7 +4664,7 @@
    (unspec:GPR [(match_operand:GPR          2 "immediate_operand" "K")] UNSPEC_ROUND)
    (clobber (reg:CC CC_REGNUM))]
    "TARGET_Z196 && TARGET_HARD_FLOAT
-    && (!TARGET_Z13 || <GPR:MODE>mode != DImode || <FP:MODE>mode != DFmode)"
+    && (!TARGET_VX || <GPR:MODE>mode != DImode || <FP:MODE>mode != DFmode)"
    "cl<GPR:gf><FP:xde><FP:bt>r\t%0,%h2,%1,0"
    [(set_attr "op_type" "RRF")
     (set_attr "type"    "ftoi")])
@@ -4684,7 +4684,7 @@
         (fix:DI (match_operand:DF 1 "register_operand"  "f,v")))
    (unspec:DI [(match_operand:DI  2 "immediate_operand" "K,K")] UNSPEC_ROUND)
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_Z13 && TARGET_HARD_FLOAT"
+  "TARGET_VX && TARGET_HARD_FLOAT"
   "@
    cgdbr\t%0,%h2,%1
    wcgdb\t%v0,%v1,0,%h2"
@@ -4792,7 +4792,7 @@
 (define_insn "*floatunsdidf2_z13"
   [(set (match_operand:DF                    0 "register_operand" "=f,v")
         (unsigned_float:DF (match_operand:DI 1 "register_operand"  "d,v")))]
-  "TARGET_Z13 && TARGET_HARD_FLOAT"
+  "TARGET_VX && TARGET_HARD_FLOAT"
   "@
    cdlgbr\t%0,0,%1,0
    wcdlgb\t%v0,%v1,0,0"
@@ -4896,7 +4896,7 @@
 (define_insn "*extendsfdf2_z13"
   [(set (match_operand:DF                  0 "register_operand"     "=f,f,v")
         (float_extend:DF (match_operand:SF 1 "nonimmediate_operand"  "f,R,v")))]
-  "TARGET_Z13 && TARGET_HARD_FLOAT"
+  "TARGET_VX && TARGET_HARD_FLOAT"
   "@
    ldebr\t%0,%1
    ldeb\t%0,%1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/driver-sparc.c gcc-6-20160721/gcc/config/sparc/driver-sparc.c
--- gcc-6.1.0/gcc/config/sparc/driver-sparc.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/driver-sparc.c	2016-06-08 19:13:37.000000000 +0000
@@ -75,6 +75,8 @@
   { "UltraSparc T4",	"niagara4" },
   { "LEON",		"leon3" },
 #endif
+  { "SPARC-M7",		"niagara7" },
+  { "SPARC-S7",		"niagara7" },
   { NULL,	NULL }
   };
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/linux64.h gcc-6-20160721/gcc/config/sparc/linux64.h
--- gcc-6.1.0/gcc/config/sparc/linux64.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/linux64.h	2016-06-08 13:34:25.000000000 +0000
@@ -164,22 +164,42 @@
 #endif
 
 /* Support for a compile-time default CPU, et cetera.  The rules are:
-   --with-cpu is ignored if -mcpu is specified.
-   --with-tune is ignored if -mtune is specified.
+   --with-cpu is ignored if -mcpu is specified; likewise --with-cpu-32
+     and --with-cpu-64.
+   --with-tune is ignored if -mtune is specified; likewise --with-tune-32
+     and --with-tune-64.
    --with-float is ignored if -mhard-float, -msoft-float, -mfpu, or -mno-fpu
      are specified.
    In the SPARC_BI_ARCH compiler we cannot pass %{!mcpu=*:-mcpu=%(VALUE)}
    here, otherwise say -mcpu=v7 would be passed even when -m64.
-   CC1_SPEC above takes care of this instead.  */
+   CC1_SPEC above takes care of this instead.
+
+   Note that the order of the cpu* and tune* options matters: the
+   config.gcc file always sets with_cpu to some value, even if the
+   user didn't use --with-cpu when invoking the configure script.
+   This value is based on the target name.  Therefore we have to make
+   sure that --with-cpu-32 takes precedence to --with-cpu in < v9
+   systems, and that --with-cpu-64 takes precedence to --with-cpu in
+   >= v9 systems.  As for the tune* options, in some platforms
+   config.gcc also sets a default value for it if the user didn't use
+   --with-tune when invoking the configure script.  */
 #undef OPTION_DEFAULT_SPECS
 #if DEFAULT_ARCH32_P
 #define OPTION_DEFAULT_SPECS \
+  {"cpu_32", "%{!m64:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"cpu_64", "%{m64:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
   {"cpu", "%{!m64:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"tune_32", "%{!m64:%{!mtune=*:-mtune=%(VALUE)}}" }, \
+  {"tune_64", "%{m64:%{!mtune=*:-mtune=%(VALUE)}}" }, \
   {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:%{!mfpu:%{!mno-fpu:-m%(VALUE)-float}}}}" }
 #else
 #define OPTION_DEFAULT_SPECS \
+  {"cpu_32", "%{m32:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"cpu_64", "%{!m32:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
   {"cpu", "%{!m32:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"tune_32", "%{m32:%{!mtune=*:-mtune=%(VALUE)}}" },	\
+  {"tune_64", "%{!m32:%{!mtune=*:-mtune=%(VALUE)}}" },	\
   {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:%{!mfpu:%{!mno-fpu:-m%(VALUE)-float}}}}" }
 #endif
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/niagara4.md gcc-6-20160721/gcc/config/sparc/niagara4.md
--- gcc-6.1.0/gcc/config/sparc/niagara4.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/niagara4.md	2016-06-08 13:34:25.000000000 +0000
@@ -75,6 +75,13 @@
       (eq_attr "fptype" "double")))
   "n4_slot1")
 
+;; The latency numbers for VIS instructions in the reservations below
+;; reflect empirical results, and don't match with the documented
+;; latency numbers in the T4 Processor Supplement.  This is because
+;; the HW chaps didn't feel it necessary to document the complexity in
+;; the PRM, and just assigned a latency of 11 to all/most of the VIS
+;; instructions.
+
 (define_insn_reservation "n4_vis_move_11cycle" 11
   (and (eq_attr "cpu" "niagara4")
     (and (eq_attr "type" "vismv")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/niagara7.md gcc-6-20160721/gcc/config/sparc/niagara7.md
--- gcc-6.1.0/gcc/config/sparc/niagara7.md	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/niagara7.md	2016-06-08 13:34:25.000000000 +0000
@@ -0,0 +1,136 @@
+;; Scheduling description for Niagara-7
+;;   Copyright (C) 2016 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_automaton "niagara7_0")
+
+(define_cpu_unit "n7_slot0,n7_slot1,n7_slot2" "niagara7_0")
+(define_reservation "n7_single_issue" "n7_slot0 + n7_slot1 + n7_slot2")
+
+(define_cpu_unit "n7_load_store" "niagara7_0")
+
+(define_insn_reservation "n7_single" 1
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "multi,savew,flushw,trap"))
+  "n7_single_issue")
+
+(define_insn_reservation "n7_iflush" 27
+  (and (eq_attr "cpu" "niagara7")
+       (eq_attr "type" "iflush"))
+  "(n7_slot0 | n7_slot1), nothing*26")
+
+(define_insn_reservation "n7_integer" 1
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "ialu,ialuX,shift,cmove,compare"))
+  "(n7_slot0 | n7_slot1)")
+
+(define_insn_reservation "n7_imul" 12
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "imul"))
+  "n7_slot1, nothing*11")
+
+(define_insn_reservation "n7_idiv" 35
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "idiv"))
+  "n7_slot1, nothing*34")
+
+(define_insn_reservation "n7_load" 5
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "load,fpload,sload"))
+  "(n7_slot0 + n7_load_store), nothing*4")
+
+(define_insn_reservation "n7_store" 1
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "store,fpstore"))
+  "(n7_slot0 | n7_slot2) + n7_load_store")
+
+(define_insn_reservation "n7_cti" 1
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "cbcond,uncond_cbcond,branch,call,sibcall,call_no_delay_slot,uncond_branch,return"))
+  "n7_slot1")
+
+(define_insn_reservation "n7_fp" 11
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "fpmove,fpcmove,fpcrmove,fp,fpcmp,fpmul"))
+  "n7_slot1, nothing*10")
+
+(define_insn_reservation "n7_array" 12
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "array,edge,edgen"))
+  "n7_slot1, nothing*11")
+
+(define_insn_reservation "n7_fpdivs" 24
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "fpdivs,fpsqrts"))
+  "n7_slot1, nothing*23")
+
+(define_insn_reservation "n7_fpdivd" 37
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "fpdivd,fpsqrtd"))
+  "n7_slot1, nothing*36")
+
+(define_insn_reservation "n7_lzd" 12
+  (and (eq_attr "cpu" "niagara7")
+       (eq_attr "type" "lzd"))
+  "(n7_slot0 | n7_slot1), nothing*11")
+
+;; There is an internal unit called the "V3 pipe", that was originally
+;; intended to process some of the short cryptographic instructions.
+;; However, as soon as in the T4 several of the VIS instructions
+;; (notably non-FP instructions) have been moved to the V3 pipe.
+;; Consequently, these instructions feature a latency of 3 instead of
+;; 11 or 12 cycles, provided their consumers also execute in the V3
+;; pipe.
+;;
+;; This is modelled here with a bypass.
+
+(define_insn_reservation "n7_vis_fga" 11
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "fga,gsr"))
+  "n7_slot1, nothing*10")
+
+(define_insn_reservation "n7_vis_fgm" 11
+  (and (eq_attr "cpu" "niagara7")
+    (eq_attr "type" "fgm_pack,fgm_mul,pdist"))
+  "n7_slot1, nothing*10")
+
+(define_insn_reservation "n7_vis_move_v3pipe" 11
+  (and (eq_attr "cpu" "niagara7")
+    (and (eq_attr "type" "vismv")
+         (eq_attr "v3pipe" "true")))
+  "n7_slot1")
+
+(define_insn_reservation "n7_vis_move_11cycle" 11
+  (and (eq_attr "cpu" "niagara7")
+    (and (eq_attr "type" "vismv")
+         (eq_attr "v3pipe" "false")))
+  "n7_slot1, nothing*10")
+
+(define_insn_reservation "n7_vis_logical_v3pipe" 11
+  (and (eq_attr "cpu" "niagara7")
+    (and (eq_attr "type" "visl,pdistn")
+         (eq_attr "v3pipe" "true")))
+  "n7_slot1, nothing*2")
+
+(define_insn_reservation "n7_vis_logical_11cycle" 11
+  (and (eq_attr "cpu" "niagara7")
+    (and (eq_attr "type" "visl")
+      (eq_attr "v3pipe" "false")))
+  "n7_slot1, nothing*10")
+
+(define_bypass 3 "*_v3pipe" "*_v3pipe")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sol2.h gcc-6-20160721/gcc/config/sparc/sol2.h
--- gcc-6.1.0/gcc/config/sparc/sol2.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sol2.h	2016-06-08 13:34:25.000000000 +0000
@@ -165,13 +165,22 @@
 #define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA4_FLAG
 #endif
 
+#if TARGET_CPU_DEFAULT == TARGET_CPU_niagara7
+#undef CPP_CPU64_DEFAULT_SPEC
+#define CPP_CPU64_DEFAULT_SPEC ""
+#undef ASM_CPU32_DEFAULT_SPEC
+#define ASM_CPU32_DEFAUILT_SPEC AS_SPARC32_FLAG AS_NIAGARA7_FLAG
+#undef ASM_CPU64_DEFAULT_SPEC
+#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA7_FLAG
+#endif
+
 #undef CPP_CPU_SPEC
 #define CPP_CPU_SPEC "\
 %{mcpu=sparclet|mcpu=tsc701:-D__sparclet__} \
 %{mcpu=sparclite|mcpu-f930|mcpu=f934:-D__sparclite__} \
 %{mcpu=v8:" DEF_ARCH32_SPEC("-D__sparcv8") "} \
 %{mcpu=supersparc:-D__supersparc__ " DEF_ARCH32_SPEC("-D__sparcv8") "} \
-%{mcpu=v9|mcpu=ultrasparc|mcpu=ultrasparc3|mcpu=niagara|mcpu=niagara2|mcpu=niagara3|mcpu=niagara4:" DEF_ARCH32_SPEC("-D__sparcv8") "} \
+%{mcpu=v9|mcpu=ultrasparc|mcpu=ultrasparc3|mcpu=niagara|mcpu=niagara2|mcpu=niagara3|mcpu=niagara4|mcpu=niagara7:" DEF_ARCH32_SPEC("-D__sparcv8") "} \
 %{!mcpu*:%(cpp_cpu_default)} \
 "
 
@@ -231,22 +240,42 @@
 #endif
 
 /* Support for a compile-time default CPU, et cetera.  The rules are:
-   --with-cpu is ignored if -mcpu is specified.
-   --with-tune is ignored if -mtune is specified.
+   --with-cpu is ignored if -mcpu is specified; likewise --with-cpu-32
+     and --with-cpu-64.
+   --with-tune is ignored if -mtune is specified; likewise --with-tune-32
+     and --with-tune-64.
    --with-float is ignored if -mhard-float, -msoft-float, -mfpu, or -mno-fpu
      are specified.
    In the SPARC_BI_ARCH compiler we cannot pass %{!mcpu=*:-mcpu=%(VALUE)}
    here, otherwise say -mcpu=v7 would be passed even when -m64.
-   CC1_SPEC above takes care of this instead.  */
+   CC1_SPEC above takes care of this instead.
+
+   Note that the order of the cpu* and tune* options matters: the
+   config.gcc file always sets with_cpu to some value, even if the
+   user didn't use --with-cpu when invoking the configure script.
+   This value is based on the target name.  Therefore we have to make
+   sure that --with-cpu-32 takes precedence to --with-cpu in < v9
+   systems, and that --with-cpu-64 takes precedence to --with-cpu in
+   >= v9 systems.  As for the tune* options, in some platforms
+   config.gcc also sets a default value for it if the user didn't use
+   --with-tune when invoking the configure script.  */
 #undef OPTION_DEFAULT_SPECS
 #if DEFAULT_ARCH32_P
 #define OPTION_DEFAULT_SPECS \
+  {"cpu_32", "%{!m64:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"cpu_64", "%{m64:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
   {"cpu", "%{!m64:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"tune_32", "%{!m64:%{!mtune=*:-mtune=%(VALUE)}}" }, \
+  {"tune_64", "%{m64:%{!mtune=*:-mtune=%(VALUE)}}" }, \
   {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:%{!mfpu:%{!mno-fpu:-m%(VALUE)-float}}}}" }
 #else
 #define OPTION_DEFAULT_SPECS \
+  {"cpu_32", "%{m32:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"cpu_64", "%{!m32:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
   {"cpu", "%{!m32:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"tune_32", "%{m32:%{!mtune=*:-mtune=%(VALUE)}}" },	\
+  {"tune_64", "%{!m32:%{!mtune=*:-mtune=%(VALUE)}}" },	\
   {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:%{!mfpu:%{!mno-fpu:-m%(VALUE)-float}}}}" }
 #endif
@@ -260,7 +289,8 @@
 %{mcpu=niagara2:" DEF_ARCH32_SPEC("-xarch=v8plusb") DEF_ARCH64_SPEC("-xarch=v9b") "} \
 %{mcpu=niagara3:" DEF_ARCH32_SPEC("-xarch=v8plus" AS_NIAGARA3_FLAG) DEF_ARCH64_SPEC("-xarch=v9" AS_NIAGARA3_FLAG) "} \
 %{mcpu=niagara4:" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA4_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA4_FLAG) "} \
-%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:" DEF_ARCH32_SPEC("-xarch=v8") DEF_ARCH64_SPEC("-xarch=v9") "}}}}}}}} \
+%{mcpu=niagara7:" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA7_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA7_FLAG) "} \
+%{!mcpu=niagara7:%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:" DEF_ARCH32_SPEC("-xarch=v8") DEF_ARCH64_SPEC("-xarch=v9") "}}}}}}}}} \
 %{!mcpu*:%(asm_cpu_default)} \
 "
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sparc-c.c gcc-6-20160721/gcc/config/sparc/sparc-c.c
--- gcc-6.1.0/gcc/config/sparc/sparc-c.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sparc-c.c	2016-06-08 13:34:25.000000000 +0000
@@ -40,7 +40,12 @@
       cpp_assert (parse_in, "machine=sparc");
     }
 
-  if (TARGET_VIS3)
+  if (TARGET_VIS4)
+    {
+      cpp_define (parse_in, "__VIS__=0x400");
+      cpp_define (parse_in, "__VIS__=0x400");
+    }
+  else if (TARGET_VIS3)
     {
       cpp_define (parse_in, "__VIS__=0x300");
       cpp_define (parse_in, "__VIS=0x300");
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sparc-opts.h gcc-6-20160721/gcc/config/sparc/sparc-opts.h
--- gcc-6.1.0/gcc/config/sparc/sparc-opts.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sparc-opts.h	2016-06-08 13:34:25.000000000 +0000
@@ -45,6 +45,7 @@
   PROCESSOR_NIAGARA2,
   PROCESSOR_NIAGARA3,
   PROCESSOR_NIAGARA4,
+  PROCESSOR_NIAGARA7,
   PROCESSOR_NATIVE
 };
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sparc.c gcc-6-20160721/gcc/config/sparc/sparc.c
--- gcc-6.1.0/gcc/config/sparc/sparc.c	2016-04-12 20:55:05.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sparc.c	2016-06-08 13:34:25.000000000 +0000
@@ -423,6 +423,30 @@
   0, /* shift penalty */
 };
 
+static const
+struct processor_costs niagara7_costs = {
+  COSTS_N_INSNS (5), /* int load */
+  COSTS_N_INSNS (5), /* int signed load */
+  COSTS_N_INSNS (5), /* int zeroed load */
+  COSTS_N_INSNS (5), /* float load */
+  COSTS_N_INSNS (11), /* fmov, fneg, fabs */
+  COSTS_N_INSNS (11), /* fadd, fsub */
+  COSTS_N_INSNS (11), /* fcmp */
+  COSTS_N_INSNS (11), /* fmov, fmovr */
+  COSTS_N_INSNS (11), /* fmul */
+  COSTS_N_INSNS (24), /* fdivs */
+  COSTS_N_INSNS (37), /* fdivd */
+  COSTS_N_INSNS (24), /* fsqrts */
+  COSTS_N_INSNS (37), /* fsqrtd */
+  COSTS_N_INSNS (12), /* imul */
+  COSTS_N_INSNS (12), /* imulX */
+  0, /* imul bit factor */
+  COSTS_N_INSNS (51), /* idiv, average of 42 - 61 cycle range */
+  COSTS_N_INSNS (35), /* idivX, average of 26 - 44 cycle range */
+  COSTS_N_INSNS (1), /* movcc/movr */
+  0, /* shift penalty */
+};
+
 static const struct processor_costs *sparc_costs = &cypress_costs;
 
 #ifdef HAVE_AS_RELAX_OPTION
@@ -1175,6 +1199,8 @@
     fprintf (stderr, "VIS2 ");
   if (flags & MASK_VIS3)
     fprintf (stderr, "VIS3 ");
+  if (flags & MASK_VIS4)
+    fprintf (stderr, "VIS4 ");
   if (flags & MASK_CBCOND)
     fprintf (stderr, "CBCOND ");
   if (flags & MASK_DEPRECATED_V8_INSNS)
@@ -1238,6 +1264,7 @@
     { TARGET_CPU_niagara2, PROCESSOR_NIAGARA2 },
     { TARGET_CPU_niagara3, PROCESSOR_NIAGARA3 },
     { TARGET_CPU_niagara4, PROCESSOR_NIAGARA4 },
+    { TARGET_CPU_niagara7, PROCESSOR_NIAGARA7 },
     { -1, PROCESSOR_V7 }
   };
   const struct cpu_default *def;
@@ -1287,6 +1314,9 @@
     /* UltraSPARC T4 */
     { "niagara4",	MASK_ISA,
       MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF|MASK_CBCOND },
+    /* UltraSPARC M7 */
+    { "niagara7",	MASK_ISA,
+      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_VIS4|MASK_FMAF|MASK_CBCOND },
   };
   const struct cpu_table *cpu;
   unsigned int i;
@@ -1416,6 +1446,9 @@
 #ifndef HAVE_AS_SPARC4
 		   & ~MASK_CBCOND
 #endif
+#ifndef HAVE_AS_SPARC5_VIS4
+		   & ~MASK_VIS4
+#endif
 #ifndef HAVE_AS_LEON
 		   & ~(MASK_LEON | MASK_LEON3)
 #endif
@@ -1434,10 +1467,15 @@
   if (TARGET_VIS3)
     target_flags |= MASK_VIS2 | MASK_VIS;
 
-  /* Don't allow -mvis, -mvis2, -mvis3, or -mfmaf if FPU is
+  /* -mvis4 implies -mvis3, -mvis2 and -mvis */
+  if (TARGET_VIS4)
+    target_flags |= MASK_VIS3 | MASK_VIS2 | MASK_VIS;
+
+  /* Don't allow -mvis, -mvis2, -mvis3, -mvis4 or -mfmaf if FPU is
      disabled.  */
   if (! TARGET_FPU)
-    target_flags &= ~(MASK_VIS | MASK_VIS2 | MASK_VIS3 | MASK_FMAF);
+    target_flags &= ~(MASK_VIS | MASK_VIS2 | MASK_VIS3 | MASK_VIS4
+		      | MASK_FMAF);
 
   /* -mvis assumes UltraSPARC+, so we are sure v9 instructions
      are available.
@@ -1471,7 +1509,8 @@
 	  || sparc_cpu == PROCESSOR_NIAGARA
 	  || sparc_cpu == PROCESSOR_NIAGARA2
 	  || sparc_cpu == PROCESSOR_NIAGARA3
-	  || sparc_cpu == PROCESSOR_NIAGARA4))
+	  || sparc_cpu == PROCESSOR_NIAGARA4
+	  || sparc_cpu == PROCESSOR_NIAGARA7))
     align_functions = 32;
 
   /* Validate PCC_STRUCT_RETURN.  */
@@ -1535,6 +1574,9 @@
     case PROCESSOR_NIAGARA4:
       sparc_costs = &niagara4_costs;
       break;
+    case PROCESSOR_NIAGARA7:
+      sparc_costs = &niagara7_costs;
+      break;
     case PROCESSOR_NATIVE:
       gcc_unreachable ();
     };
@@ -1566,6 +1608,29 @@
   if (TARGET_DEBUG_OPTIONS)
     dump_target_flags ("Final target_flags", target_flags);
 
+  /* PARAM_SIMULTANEOUS_PREFETCHES is the number of prefetches that
+     can run at the same time.  More important, it is the threshold
+     defining when additional prefetches will be dropped by the
+     hardware.
+
+     The UltraSPARC-III features a documented prefetch queue with a
+     size of 8.  Additional prefetches issued in the cpu are
+     dropped.
+
+     Niagara processors are different.  In these processors prefetches
+     are handled much like regular loads.  The L1 miss buffer is 32
+     entries, but prefetches start getting affected when 30 entries
+     become occupied.  That occupation could be a mix of regular loads
+     and prefetches though.  And that buffer is shared by all threads.
+     Once the threshold is reached, if the core is running a single
+     thread the prefetch will retry.  If more than one thread is
+     running, the prefetch will be dropped.
+
+     All this makes it very difficult to determine how many
+     simultaneous prefetches can be issued simultaneously, even in a
+     single-threaded program.  Experimental results show that setting
+     this parameter to 32 works well when the number of threads is not
+     high.  */
   maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,
 			 ((sparc_cpu == PROCESSOR_ULTRASPARC
 			   || sparc_cpu == PROCESSOR_NIAGARA
@@ -1574,20 +1639,55 @@
 			   || sparc_cpu == PROCESSOR_NIAGARA4)
 			  ? 2
 			  : (sparc_cpu == PROCESSOR_ULTRASPARC3
-			     ? 8 : 3)),
+			     ? 8 : (sparc_cpu == PROCESSOR_NIAGARA7
+				    ? 32 : 3))),
 			 global_options.x_param_values,
 			 global_options_set.x_param_values);
-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,
+
+  /* For PARAM_L1_CACHE_LINE_SIZE we use the default 32 bytes (see
+     params.def), so no maybe_set_param_value is needed.
+
+     The Oracle SPARC Architecture (previously the UltraSPARC
+     Architecture) specification states that when a PREFETCH[A]
+     instruction is executed an implementation-specific amount of data
+     is prefetched, and that it is at least 64 bytes long (aligned to
+     at least 64 bytes).
+
+     However, this is not correct.  The M7 (and implementations prior
+     to that) does not guarantee a 64B prefetch into a cache if the
+     line size is smaller.  A single cache line is all that is ever
+     prefetched.  So for the M7, where the L1D$ has 32B lines and the
+     L2D$ and L3 have 64B lines, a prefetch will prefetch 64B into the
+     L2 and L3, but only 32B are brought into the L1D$. (Assuming it
+     is a read_n prefetch, which is the only type which allocates to
+     the L1.)  */
+
+  /* PARAM_L1_CACHE_SIZE is the size of the L1D$ (most SPARC chips use
+     Hardvard level-1 caches) in kilobytes.  Both UltraSPARC and
+     Niagara processors feature a L1D$ of 16KB.  */
+  maybe_set_param_value (PARAM_L1_CACHE_SIZE,
 			 ((sparc_cpu == PROCESSOR_ULTRASPARC
 			   || sparc_cpu == PROCESSOR_ULTRASPARC3
 			   || sparc_cpu == PROCESSOR_NIAGARA
 			   || sparc_cpu == PROCESSOR_NIAGARA2
 			   || sparc_cpu == PROCESSOR_NIAGARA3
-			   || sparc_cpu == PROCESSOR_NIAGARA4)
-			  ? 64 : 32),
+			   || sparc_cpu == PROCESSOR_NIAGARA4
+			   || sparc_cpu == PROCESSOR_NIAGARA7)
+			  ? 16 : 64),
 			 global_options.x_param_values,
 			 global_options_set.x_param_values);
 
+
+  /* PARAM_L2_CACHE_SIZE is the size fo the L2 in kilobytes.  Note
+     that 512 is the default in params.def.  */
+  maybe_set_param_value (PARAM_L2_CACHE_SIZE,
+			 (sparc_cpu == PROCESSOR_NIAGARA4
+			  ? 128 : (sparc_cpu == PROCESSOR_NIAGARA7
+				   ? 256 : 512)),
+			 global_options.x_param_values,
+			 global_options_set.x_param_values);
+  
+
   /* Disable save slot sharing for call-clobbered registers by default.
      The IRA sharing algorithm works on single registers only and this
      pessimizes for double floating-point registers.  */
@@ -9178,7 +9278,8 @@
       && sparc_cpu != PROCESSOR_NIAGARA
       && sparc_cpu != PROCESSOR_NIAGARA2
       && sparc_cpu != PROCESSOR_NIAGARA3
-      && sparc_cpu != PROCESSOR_NIAGARA4)
+      && sparc_cpu != PROCESSOR_NIAGARA4
+      && sparc_cpu != PROCESSOR_NIAGARA7)
     emit_insn (gen_flushsi (validize_mem (adjust_address (m_tramp, SImode, 8))));
 
   /* Call __enable_execute_stack after writing onto the stack to make sure
@@ -9223,7 +9324,8 @@
       && sparc_cpu != PROCESSOR_NIAGARA
       && sparc_cpu != PROCESSOR_NIAGARA2
       && sparc_cpu != PROCESSOR_NIAGARA3
-      && sparc_cpu != PROCESSOR_NIAGARA4)
+      && sparc_cpu != PROCESSOR_NIAGARA4
+      && sparc_cpu != PROCESSOR_NIAGARA7)
     emit_insn (gen_flushdi (validize_mem (adjust_address (m_tramp, DImode, 8))));
 
   /* Call __enable_execute_stack after writing onto the stack to make sure
@@ -9419,7 +9521,8 @@
       || sparc_cpu == PROCESSOR_NIAGARA2
       || sparc_cpu == PROCESSOR_NIAGARA3)
     return 0;
-  if (sparc_cpu == PROCESSOR_NIAGARA4)
+  if (sparc_cpu == PROCESSOR_NIAGARA4
+      || sparc_cpu == PROCESSOR_NIAGARA7)
     return 2;
   if (sparc_cpu == PROCESSOR_ULTRASPARC
       || sparc_cpu == PROCESSOR_ULTRASPARC3)
@@ -9442,6 +9545,7 @@
     default:
       return 1;
     case PROCESSOR_NIAGARA4:
+    case PROCESSOR_NIAGARA7:
     case PROCESSOR_V9:
       /* Assume V9 processors are capable of at least dual-issue.  */
       return 2;
@@ -10007,6 +10111,34 @@
   SPARC_BUILTIN_XMULX,
   SPARC_BUILTIN_XMULXHI,
 
+  /* VIS 4.0 builtins.  */
+  SPARC_BUILTIN_FPADD8,
+  SPARC_BUILTIN_FPADDS8,
+  SPARC_BUILTIN_FPADDUS8,
+  SPARC_BUILTIN_FPADDUS16,
+  SPARC_BUILTIN_FPCMPLE8,
+  SPARC_BUILTIN_FPCMPGT8,
+  SPARC_BUILTIN_FPCMPULE16,
+  SPARC_BUILTIN_FPCMPUGT16,
+  SPARC_BUILTIN_FPCMPULE32,
+  SPARC_BUILTIN_FPCMPUGT32,
+  SPARC_BUILTIN_FPMAX8,
+  SPARC_BUILTIN_FPMAX16,
+  SPARC_BUILTIN_FPMAX32,
+  SPARC_BUILTIN_FPMAXU8,
+  SPARC_BUILTIN_FPMAXU16,
+  SPARC_BUILTIN_FPMAXU32,
+  SPARC_BUILTIN_FPMIN8,
+  SPARC_BUILTIN_FPMIN16,
+  SPARC_BUILTIN_FPMIN32,
+  SPARC_BUILTIN_FPMINU8,
+  SPARC_BUILTIN_FPMINU16,
+  SPARC_BUILTIN_FPMINU32,
+  SPARC_BUILTIN_FPSUB8,
+  SPARC_BUILTIN_FPSUBS8,
+  SPARC_BUILTIN_FPSUBUS8,
+  SPARC_BUILTIN_FPSUBUS16,
+  
   SPARC_BUILTIN_MAX
 };
 
@@ -10483,6 +10615,83 @@
       def_builtin_const ("__builtin_vis_xmulxhi", CODE_FOR_xmulxhi_vis,
 			 SPARC_BUILTIN_XMULXHI, di_ftype_di_di);
     }
+
+  if (TARGET_VIS4)
+    {
+      def_builtin_const ("__builtin_vis_fpadd8", CODE_FOR_addv8qi3,
+			 SPARC_BUILTIN_FPADD8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpadds8", CODE_FOR_ssaddv8qi3,
+			 SPARC_BUILTIN_FPADDS8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpaddus8", CODE_FOR_usaddv8qi3,
+			 SPARC_BUILTIN_FPADDUS8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpaddus16", CODE_FOR_usaddv4hi3,
+			 SPARC_BUILTIN_FPADDUS16, v4hi_ftype_v4hi_v4hi);
+
+
+      if (TARGET_ARCH64)
+	{
+	  def_builtin_const ("__builtin_vis_fpcmple8", CODE_FOR_fpcmple8di_vis,
+			     SPARC_BUILTIN_FPCMPLE8, di_ftype_v8qi_v8qi);
+	  def_builtin_const ("__builtin_vis_fpcmpgt8", CODE_FOR_fpcmpgt8di_vis,
+			     SPARC_BUILTIN_FPCMPGT8, di_ftype_v8qi_v8qi);
+	  def_builtin_const ("__builtin_vis_fpcmpule16", CODE_FOR_fpcmpule16di_vis,
+			     SPARC_BUILTIN_FPCMPULE16, di_ftype_v4hi_v4hi);
+	  def_builtin_const ("__builtin_vis_fpcmpugt16", CODE_FOR_fpcmpugt16di_vis,
+			     SPARC_BUILTIN_FPCMPUGT16, di_ftype_v4hi_v4hi);
+	  def_builtin_const ("__builtin_vis_fpcmpule32", CODE_FOR_fpcmpule32di_vis,
+			     SPARC_BUILTIN_FPCMPULE32, di_ftype_v2si_v2si);
+	  def_builtin_const ("__builtin_vis_fpcmpugt32", CODE_FOR_fpcmpugt32di_vis,
+			     SPARC_BUILTIN_FPCMPUGT32, di_ftype_v2si_v2si);
+	}
+      else
+	{
+	  def_builtin_const ("__builtin_vis_fpcmple8", CODE_FOR_fpcmple8si_vis,
+			     SPARC_BUILTIN_FPCMPLE8, si_ftype_v8qi_v8qi);
+	  def_builtin_const ("__builtin_vis_fpcmpgt8", CODE_FOR_fpcmpgt8si_vis,
+			     SPARC_BUILTIN_FPCMPGT8, si_ftype_v8qi_v8qi);
+	  def_builtin_const ("__builtin_vis_fpcmpule16", CODE_FOR_fpcmpule16si_vis,
+			     SPARC_BUILTIN_FPCMPULE16, si_ftype_v4hi_v4hi);
+	  def_builtin_const ("__builtin_vis_fpcmpugt16", CODE_FOR_fpcmpugt16si_vis,
+			     SPARC_BUILTIN_FPCMPUGT16, si_ftype_v4hi_v4hi);
+	  def_builtin_const ("__builtin_vis_fpcmpule32", CODE_FOR_fpcmpule32si_vis,
+			     SPARC_BUILTIN_FPCMPULE32, di_ftype_v2si_v2si);
+	  def_builtin_const ("__builtin_vis_fpcmpugt32", CODE_FOR_fpcmpugt32si_vis,
+			     SPARC_BUILTIN_FPCMPUGT32, di_ftype_v2si_v2si);
+	}
+      
+      def_builtin_const ("__builtin_vis_fpmax8", CODE_FOR_maxv8qi3,
+			 SPARC_BUILTIN_FPMAX8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpmax16", CODE_FOR_maxv4hi3,
+			 SPARC_BUILTIN_FPMAX16, v4hi_ftype_v4hi_v4hi);
+      def_builtin_const ("__builtin_vis_fpmax32", CODE_FOR_maxv2si3,
+			 SPARC_BUILTIN_FPMAX32, v2si_ftype_v2si_v2si);
+      def_builtin_const ("__builtin_vis_fpmaxu8", CODE_FOR_maxuv8qi3,
+			 SPARC_BUILTIN_FPMAXU8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpmaxu16", CODE_FOR_maxuv4hi3,
+			 SPARC_BUILTIN_FPMAXU16, v4hi_ftype_v4hi_v4hi);
+      def_builtin_const ("__builtin_vis_fpmaxu32", CODE_FOR_maxuv2si3,
+			 SPARC_BUILTIN_FPMAXU32, v2si_ftype_v2si_v2si);
+      def_builtin_const ("__builtin_vis_fpmin8", CODE_FOR_minv8qi3,
+			 SPARC_BUILTIN_FPMIN8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpmin16", CODE_FOR_minv4hi3,
+			 SPARC_BUILTIN_FPMIN16, v4hi_ftype_v4hi_v4hi);
+      def_builtin_const ("__builtin_vis_fpmin32", CODE_FOR_minv2si3,
+			 SPARC_BUILTIN_FPMIN32, v2si_ftype_v2si_v2si);
+      def_builtin_const ("__builtin_vis_fpminu8", CODE_FOR_minuv8qi3,
+			 SPARC_BUILTIN_FPMINU8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpminu16", CODE_FOR_minuv4hi3,
+			 SPARC_BUILTIN_FPMINU16, v4hi_ftype_v4hi_v4hi);
+      def_builtin_const ("__builtin_vis_fpminu32", CODE_FOR_minuv2si3,
+			 SPARC_BUILTIN_FPMINU32, v2si_ftype_v2si_v2si);
+      def_builtin_const ("__builtin_vis_fpsub8", CODE_FOR_subv8qi3,
+			 SPARC_BUILTIN_FPSUB8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpsubs8", CODE_FOR_sssubv8qi3,
+			 SPARC_BUILTIN_FPSUBS8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpsubus8", CODE_FOR_ussubv8qi3,
+			 SPARC_BUILTIN_FPSUBUS8, v8qi_ftype_v8qi_v8qi);
+      def_builtin_const ("__builtin_vis_fpsubus16", CODE_FOR_ussubv4hi3,
+			 SPARC_BUILTIN_FPSUBUS16, v4hi_ftype_v4hi_v4hi);
+    }
 }
 
 /* Implement TARGET_BUILTIN_DECL hook.  */
@@ -11042,7 +11251,8 @@
 	  || sparc_cpu == PROCESSOR_NIAGARA
 	  || sparc_cpu == PROCESSOR_NIAGARA2
 	  || sparc_cpu == PROCESSOR_NIAGARA3
-	  || sparc_cpu == PROCESSOR_NIAGARA4)
+	  || sparc_cpu == PROCESSOR_NIAGARA4
+	  || sparc_cpu == PROCESSOR_NIAGARA7)
 	return 12;
 
       return 6;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sparc.h gcc-6-20160721/gcc/config/sparc/sparc.h
--- gcc-6.1.0/gcc/config/sparc/sparc.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sparc.h	2016-06-08 13:34:25.000000000 +0000
@@ -142,6 +142,7 @@
 #define TARGET_CPU_niagara2	14
 #define TARGET_CPU_niagara3	15
 #define TARGET_CPU_niagara4	16
+#define TARGET_CPU_niagara7	19
 
 #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \
  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \
@@ -149,7 +150,8 @@
  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara \
  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara2 \
  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara3 \
- || TARGET_CPU_DEFAULT == TARGET_CPU_niagara4
+ || TARGET_CPU_DEFAULT == TARGET_CPU_niagara4 \
+ || TARGET_CPU_DEFAULT == TARGET_CPU_niagara7
 
 #define CPP_CPU32_DEFAULT_SPEC ""
 #define ASM_CPU32_DEFAULT_SPEC ""
@@ -186,6 +188,10 @@
 #define CPP_CPU64_DEFAULT_SPEC "-D__sparc_v9__"
 #define ASM_CPU64_DEFAULT_SPEC AS_NIAGARA4_FLAG
 #endif
+#if TARGET_CPU_DEFAULT == TARGET_CPU_niagara7
+#define CPP_CPU64_DEFAULT_SPEC "-D__sparc_v9__"
+#define ASM_CPU64_DEFAULT_SPEC AS_NIAGARA7_FLAG
+#endif
 
 #else
 
@@ -288,6 +294,7 @@
 %{mcpu=niagara2:-D__sparc_v9__} \
 %{mcpu=niagara3:-D__sparc_v9__} \
 %{mcpu=niagara4:-D__sparc_v9__} \
+%{mcpu=niagara7:-D__sparc_v9__} \
 %{!mcpu*:%(cpp_cpu_default)} \
 "
 #define CPP_ARCH32_SPEC ""
@@ -339,6 +346,7 @@
 %{mcpu=niagara2:%{!mv8plus:-Av9b}} \
 %{mcpu=niagara3:%{!mv8plus:-Av9" AS_NIAGARA3_FLAG "}} \
 %{mcpu=niagara4:%{!mv8plus:" AS_NIAGARA4_FLAG "}} \
+%{mcpu=niagara7:%{!mv8plus:" AS_NIAGARA7_FLAG "}} \
 %{!mcpu*:%(asm_cpu_default)} \
 "
 
@@ -1777,6 +1785,12 @@
 #define AS_NIAGARA4_FLAG "-Av9" AS_NIAGARA3_FLAG
 #endif
 
+#ifdef HAVE_AS_SPARC5_VIS4
+#define AS_NIAGARA7_FLAG "-xarch=sparc5"
+#else
+#define AS_NIAGARA7_FLAG AS_NIAGARA4_FLAG
+#endif
+
 #ifdef HAVE_AS_LEON
 #define AS_LEON_FLAG "-Aleon"
 #define AS_LEONV7_FLAG "-Aleon"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sparc.md gcc-6-20160721/gcc/config/sparc/sparc.md
--- gcc-6.1.0/gcc/config/sparc/sparc.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sparc.md	2016-06-08 13:34:25.000000000 +0000
@@ -234,7 +234,8 @@
    niagara,
    niagara2,
    niagara3,
-   niagara4"
+   niagara4,
+   niagara7"
   (const (symbol_ref "sparc_cpu_attr")))
 
 ;; Attribute for the instruction set.
@@ -247,7 +248,7 @@
 	 (symbol_ref "TARGET_SPARCLET") (const_string "sparclet")]
 	(const_string "v7"))))
 
-(define_attr "cpu_feature" "none,fpu,fpunotv9,v9,vis,vis3" (const_string "none"))
+(define_attr "cpu_feature" "none,fpu,fpunotv9,v9,vis,vis3,vis4" (const_string "none"))
 
 (define_attr "enabled" ""
   (cond [(eq_attr "cpu_feature" "none") (const_int 1)
@@ -255,7 +256,8 @@
 	 (eq_attr "cpu_feature" "fpunotv9") (symbol_ref "TARGET_FPU && ! TARGET_V9")
          (eq_attr "cpu_feature" "v9") (symbol_ref "TARGET_V9")
          (eq_attr "cpu_feature" "vis") (symbol_ref "TARGET_VIS")
-         (eq_attr "cpu_feature" "vis3") (symbol_ref "TARGET_VIS3")]
+         (eq_attr "cpu_feature" "vis3") (symbol_ref "TARGET_VIS3")
+         (eq_attr "cpu_feature" "vis4") (symbol_ref "TARGET_VIS4")]
         (const_int 0)))
 
 ;; Insn type.
@@ -274,7 +276,7 @@
    fga,visl,vismv,fgm_pack,fgm_mul,pdist,pdistn,edge,edgen,gsr,array,
    cmove,
    ialuX,
-   multi,savew,flushw,iflush,trap"
+   multi,savew,flushw,iflush,trap,lzd"
   (const_string "ialu"))
 
 ;; True if branch/call has empty delay slot and will emit a nop in it
@@ -476,6 +478,10 @@
 	   (const_string "true")
 	] (const_string "false")))
 
+;; True if the instruction executes in the V3 pipeline, in M7 and
+;; later processors.
+(define_attr "v3pipe" "false,true" (const_string "false"))
+
 (define_delay (eq_attr "type" "call")
   [(eq_attr "in_call_delay" "true") (nil) (nil)])
 
@@ -504,6 +510,7 @@
 (include "niagara.md")
 (include "niagara2.md")
 (include "niagara4.md")
+(include "niagara7.md")
 
 
 ;; Operand and operator predicates and constraints
@@ -1457,6 +1464,7 @@
    fzeros\t%0
    fones\t%0"
   [(set_attr "type" "*,*,load,store,vismv,vismv,fpmove,fpload,fpstore,visl,visl")
+   (set_attr "v3pipe" "*,*,*,*,true,true,*,*,*,true,true")
    (set_attr "cpu_feature" "*,*,*,*,vis3,vis3,*,*,*,vis,vis")])
 
 (define_insn "*movsi_lo_sum"
@@ -1622,6 +1630,7 @@
    fzero\t%0
    fone\t%0"
   [(set_attr "type" "store,store,store,load,*,*,*,*,fpstore,fpload,*,*,fpmove,*,*,*,fpload,fpstore,visl,visl")
+   (set_attr "v3pipe" "false, false, false, false,false,false,false,false,false,false,false,false,false,false,false,false,false,false, true, true")
    (set_attr "length" "*,2,*,*,2,2,2,2,*,*,2,2,*,2,2,2,*,*,*,*")
    (set_attr "fptype" "*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,*,*,*,double,double")
    (set_attr "cpu_feature" "v9,*,*,*,*,*,*,*,fpu,fpu,fpu,fpu,v9,fpunotv9,vis3,vis3,fpu,fpu,vis,vis")])
@@ -1645,6 +1654,7 @@
    fzero\t%0
    fone\t%0"
   [(set_attr "type" "*,*,load,store,vismv,vismv,fpmove,fpload,fpstore,visl,visl")
+   (set_attr "v3pipe" "*, *, *, *, *, *, *, *, *, true, true")
    (set_attr "fptype" "*,*,*,*,*,*,double,*,*,double,double")
    (set_attr "cpu_feature" "*,*,*,*,vis3,vis3,*,*,*,vis,vis")])
 
@@ -2208,6 +2218,7 @@
     }
 }
   [(set_attr "type" "visl,visl,fpmove,*,*,*,vismv,vismv,fpload,load,fpstore,store")
+   (set_attr "v3pipe" "true, true, *, *, *, *, true, true, *, *, *, *")
    (set_attr "cpu_feature" "vis,vis,fpu,*,*,*,vis3,vis3,fpu,*,fpu,*")])
 
 ;; The following 3 patterns build SFmode constants in integer registers.
@@ -2276,6 +2287,7 @@
   #
   #"
   [(set_attr "type" "visl,visl,fpmove,*,*,*,fpload,store,fpstore,load,store,*,*,*,*")
+   (set_attr "v3pipe" "true, true, *, *, *, *, *, *, *, *, *, *, *, *, *")
    (set_attr "length" "*,*,*,2,2,2,*,*,*,*,*,2,2,2,2")
    (set_attr "fptype" "double,double,double,*,*,*,*,*,*,*,*,*,*,*,*")
    (set_attr "cpu_feature" "vis,vis,v9,fpunotv9,vis3,vis3,fpu,v9,fpu,*,*,fpu,*,*,fpu")])
@@ -2299,6 +2311,7 @@
   stx\t%r1, %0
   #"
   [(set_attr "type" "visl,visl,fpmove,vismv,vismv,load,store,*,load,store,*")
+   (set_attr "v3pipe" "true, true, *, *, *, *, *, *, *, *, *")
    (set_attr "length" "*,*,*,*,*,*,*,*,*,*,2")
    (set_attr "fptype" "double,double,double,double,double,*,*,*,*,*,*")
    (set_attr "cpu_feature" "vis,vis,fpu,vis3,vis3,fpu,fpu,*,*,*,*")])
@@ -2980,6 +2993,7 @@
    lduw\t%1, %0
    movstouw\t%1, %0"
   [(set_attr "type" "shift,load,*")
+   (set_attr "v3pipe" "*,*,true")
    (set_attr "cpu_feature" "*,*,vis3")])
 
 (define_insn_and_split "*zero_extendsidi2_insn_sp32"
@@ -3294,6 +3308,7 @@
   ldsw\t%1, %0
   movstosw\t%1, %0"
   [(set_attr "type" "shift,sload,*")
+   (set_attr "v3pipe" "*,*,true")
    (set_attr "us3load_type" "*,3cycle,*")
    (set_attr "cpu_feature" "*,*,vis3")])
 
@@ -6770,7 +6785,8 @@
   [(set (match_operand:DI 0 "register_operand" "=r")
         (clz:DI (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_VIS3 && TARGET_ARCH64"
-  "lzd\t%1, %0")
+  "lzd\t%1, %0"
+  [(set_attr "type" "lzd")])
 
 (define_insn "clzdi_v8plus"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -6811,7 +6827,8 @@
         (truncate:SI
           (clz:DI (match_operand:DI 1 "register_operand" "r"))))]
   "TARGET_VIS3 && TARGET_ARCH64"
-  "lzd\t%1, %0")
+  "lzd\t%1, %0"
+  [(set_attr "type" "lzd")])
 
 (define_insn "clzsi_v8plus"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -7777,7 +7794,7 @@
 (define_mode_iterator VM64 [V1DI V2SI V4HI V8QI])
 (define_mode_iterator VMALL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])
 
-(define_mode_attr vbits [(V2SI "32") (V4HI "16") (V1SI "32s") (V2HI "16s")])
+(define_mode_attr vbits [(V2SI "32") (V4HI "16") (V1SI "32s") (V2HI "16s") (V8QI "8")])
 (define_mode_attr vconstr [(V1SI "f") (V2HI "f") (V4QI "f")
 			   (V1DI "e") (V2SI "e") (V4HI "e") (V8QI "e")])
 (define_mode_attr vfptype [(V1SI "single") (V2HI "single") (V4QI "single")
@@ -7812,6 +7829,7 @@
   movstouw\t%1, %0
   movwtos\t%1, %0"
   [(set_attr "type" "visl,visl,vismv,fpload,fpstore,store,load,store,*,vismv,vismv")
+   (set_attr "v3pipe" "true,true,true,false,false,false,false,false,false,true,true")
    (set_attr "cpu_feature" "vis,vis,vis,*,*,*,*,*,*,vis3,vis3")])
 
 (define_insn "*mov<VM64:mode>_insn_sp64"
@@ -7834,6 +7852,7 @@
   movxtod\t%1, %0
   mov\t%1, %0"
   [(set_attr "type" "visl,visl,vismv,fpload,fpstore,store,load,store,vismv,vismv,*")
+   (set_attr "v3pipe" "true, true, true, false, false, false, false, false, false, false, false")
    (set_attr "cpu_feature" "vis,vis,vis,*,*,*,*,*,vis3,vis3,*")])
 
 (define_insn "*mov<VM64:mode>_insn_sp32"
@@ -7857,6 +7876,7 @@
   #
   #"
   [(set_attr "type" "visl,visl,vismv,*,*,fpload,fpstore,store,load,store,*,*")
+   (set_attr "v3pipe" "true, true, true, false, false, false, false, false, false, false, false, false")
    (set_attr "length" "*,*,*,2,2,*,*,*,*,*,2,2")
    (set_attr "cpu_feature" "vis,vis,vis,vis3,vis3,*,*,*,*,*,*,*")])
 
@@ -7936,7 +7956,8 @@
   "TARGET_VIS"
   "fp<plusminus_insn><vbits>\t%1, %2, %0"
   [(set_attr "type" "fga")
-   (set_attr "fptype" "<vfptype>")])
+   (set_attr "fptype" "<vfptype>")
+   (set_attr "v3pipe" "true")])
 
 (define_mode_iterator VL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])
 (define_mode_attr vlsuf [(V1SI "s") (V2HI "s") (V4QI "s")
@@ -7952,6 +7973,7 @@
   "TARGET_VIS"
   "f<vlinsn><vlsuf>\t%1, %2, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "<vfptype>")])
 
 (define_insn "*not_<code><mode>3"
@@ -7961,6 +7983,7 @@
   "TARGET_VIS"
   "f<vlninsn><vlsuf>\t%1, %2, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "<vfptype>")])
 
 ;; (ior (not (op1)) (not (op2))) is the canonical form of NAND.
@@ -7971,6 +7994,7 @@
   "TARGET_VIS"
   "fnand<vlsuf>\t%1, %2, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "<vfptype>")])
 
 (define_code_iterator vlnotop [ior and])
@@ -7982,6 +8006,7 @@
   "TARGET_VIS"
   "f<vlinsn>not1<vlsuf>\t%1, %2, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "<vfptype>")])
 
 (define_insn "*<code>_not2<mode>_vis"
@@ -7991,6 +8016,7 @@
   "TARGET_VIS"
   "f<vlinsn>not2<vlsuf>\t%1, %2, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "<vfptype>")])
 
 (define_insn "one_cmpl<mode>2"
@@ -7999,6 +8025,7 @@
   "TARGET_VIS"
   "fnot1<vlsuf>\t%1, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "<vfptype>")])
 
 ;; Hard to generate VIS instructions.  We have builtins for these.
@@ -8225,7 +8252,8 @@
   "TARGET_VIS"
   "faligndata\t%1, %2, %0"
   [(set_attr "type" "fga")
-   (set_attr "fptype" "double")])
+   (set_attr "fptype" "double")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "alignaddrsi_vis"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -8235,7 +8263,8 @@
         (zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]
   "TARGET_VIS"
   "alignaddr\t%r1, %r2, %0"
-  [(set_attr "type" "gsr")])
+  [(set_attr "type" "gsr")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "alignaddrdi_vis"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -8245,7 +8274,8 @@
         (plus:DI (match_dup 1) (match_dup 2)))]
   "TARGET_VIS"
   "alignaddr\t%r1, %r2, %0"
-  [(set_attr "type" "gsr")])
+  [(set_attr "type" "gsr")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "alignaddrlsi_vis"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -8256,7 +8286,8 @@
                 (const_int 7)))]
   "TARGET_VIS"
   "alignaddrl\t%r1, %r2, %0"
-  [(set_attr "type" "gsr")])
+  [(set_attr "type" "gsr")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "alignaddrldi_vis"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -8267,7 +8298,8 @@
                 (const_int 7)))]
   "TARGET_VIS"
   "alignaddrl\t%r1, %r2, %0"
-  [(set_attr "type" "gsr")])
+  [(set_attr "type" "gsr")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "pdist_vis"
   [(set (match_operand:DI 0 "register_operand" "=e")
@@ -8360,6 +8392,17 @@
   "TARGET_VIS"
   "fcmp<code><GCM:gcm_name>\t%1, %2, %0"
   [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")
+   (set_attr "fptype" "double")])
+
+(define_insn "fpcmp<code>8<P:mode>_vis"
+  [(set (match_operand:P 0 "register_operand" "=r")
+  	(unspec:P [(gcond:V8QI (match_operand:V8QI 1 "register_operand" "e")
+		               (match_operand:V8QI 2 "register_operand" "e"))]
+	 UNSPEC_FCMP))]
+  "TARGET_VIS4"
+  "fpcmp<code>8\t%1, %2, %0"
+  [(set_attr "type" "visl")
    (set_attr "fptype" "double")])
 
 (define_expand "vcond<mode><mode>"
@@ -8427,7 +8470,8 @@
         (plus:DI (match_dup 1) (match_dup 2)))]
   "TARGET_VIS2"
   "bmask\t%r1, %r2, %0"
-  [(set_attr "type" "array")])
+  [(set_attr "type" "array")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "bmasksi_vis"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -8437,7 +8481,8 @@
         (zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]
   "TARGET_VIS2"
   "bmask\t%r1, %r2, %0"
-  [(set_attr "type" "array")])
+  [(set_attr "type" "array")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "bshuffle<VM64:mode>_vis"
   [(set (match_operand:VM64 0 "register_operand" "=e")
@@ -8448,7 +8493,8 @@
   "TARGET_VIS2"
   "bshuffle\t%1, %2, %0"
   [(set_attr "type" "fga")
-   (set_attr "fptype" "double")])
+   (set_attr "fptype" "double")
+   (set_attr "v3pipe" "true")])
 
 ;; The rtl expanders will happily convert constant permutations on other
 ;; modes down to V8QI.  Rely on this to avoid the complexity of the byte
@@ -8550,7 +8596,8 @@
                    UNSPEC_CMASK8))]
   "TARGET_VIS3"
   "cmask8\t%r0"
-  [(set_attr "type" "fga")])
+  [(set_attr "type" "fga")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "cmask16<P:mode>_vis"
   [(set (reg:DI GSR_REG)
@@ -8559,7 +8606,8 @@
                    UNSPEC_CMASK16))]
   "TARGET_VIS3"
   "cmask16\t%r0"
-  [(set_attr "type" "fga")])
+  [(set_attr "type" "fga")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "cmask32<P:mode>_vis"
   [(set (reg:DI GSR_REG)
@@ -8568,7 +8616,8 @@
                    UNSPEC_CMASK32))]
   "TARGET_VIS3"
   "cmask32\t%r0"
-  [(set_attr "type" "fga")])
+  [(set_attr "type" "fga")
+   (set_attr "v3pipe" "true")])
 
 (define_insn "fchksm16_vis"
   [(set (match_operand:V4HI 0 "register_operand" "=e")
@@ -8601,6 +8650,7 @@
   "TARGET_VIS3"
   "pdistn\t%1, %2, %0"
   [(set_attr "type" "pdistn")
+   (set_attr "v3pipe" "true")
    (set_attr "fptype" "double")])
 
 (define_insn "fmean16_vis"
@@ -8628,6 +8678,14 @@
   "fp<plusminus_insn>64\t%1, %2, %0"
   [(set_attr "type" "fga")])
 
+(define_insn "<plusminus_insn>v8qi3"
+  [(set (match_operand:V8QI 0 "register_operand" "=e")
+        (plusminus:V8QI (match_operand:V8QI 1 "register_operand" "e")
+                        (match_operand:V8QI 2 "register_operand" "e")))]
+  "TARGET_VIS4"
+  "fp<plusminus_insn>8\t%1, %2, %0"
+  [(set_attr "type" "fga")])
+
 (define_mode_iterator VASS [V4HI V2SI V2HI V1SI])
 (define_code_iterator vis3_addsub_ss [ss_plus ss_minus])
 (define_code_attr vis3_addsub_ss_insn
@@ -8641,8 +8699,63 @@
                              (match_operand:VASS 2 "register_operand" "<vconstr>")))]
   "TARGET_VIS3"
   "<vis3_addsub_ss_insn><vbits>\t%1, %2, %0"
+  [(set_attr "type" "fga")
+   (set_attr "v3pipe" "true")])
+
+(define_mode_iterator VMMAX [V8QI V4HI V2SI])
+(define_code_iterator vis4_minmax [smin smax])
+(define_code_attr vis4_minmax_insn
+  [(smin "fpmin") (smax "fpmax")])
+(define_code_attr vis4_minmax_patname
+  [(smin "min") (smax "max")])
+
+(define_insn "<vis4_minmax_patname><mode>3"
+  [(set (match_operand:VMMAX 0 "register_operand" "=<vconstr>")
+        (vis4_minmax:VMMAX (match_operand:VMMAX 1 "register_operand" "<vconstr>")
+                           (match_operand:VMMAX 2 "register_operand" "<vconstr>")))]
+  "TARGET_VIS4"
+  "<vis4_minmax_insn><vbits>\t%1, %2, %0"
+  [(set_attr "type" "fga")])
+
+(define_code_iterator vis4_uminmax [umin umax])
+(define_code_attr vis4_uminmax_insn
+  [(umin "fpminu") (umax "fpmaxu")])
+(define_code_attr vis4_uminmax_patname
+ [(umin "minu") (umax "maxu")])
+
+(define_insn "<vis4_uminmax_patname><mode>3"
+  [(set (match_operand:VMMAX 0 "register_operand" "=<vconstr>")
+        (vis4_uminmax:VMMAX (match_operand:VMMAX 1 "register_operand" "<vconstr>")
+                            (match_operand:VMMAX 2 "register_operand" "<vconstr>")))]
+  "TARGET_VIS4"
+  "<vis4_uminmax_insn><vbits>\t%1, %2, %0"
+  [(set_attr "type" "fga")])
+
+;; The use of vis3_addsub_ss_patname in the VIS4 instruction below is
+;; intended.
+(define_insn "<vis3_addsub_ss_patname>v8qi3"
+  [(set (match_operand:V8QI 0 "register_operand" "=e")
+        (vis3_addsub_ss:V8QI (match_operand:V8QI 1 "register_operand" "e")
+                             (match_operand:V8QI 2 "register_operand" "e")))]
+  "TARGET_VIS4"
+  "<vis3_addsub_ss_insn>8\t%1, %2, %0"
   [(set_attr "type" "fga")])
 
+(define_mode_iterator VAUS [V4HI V8QI])
+(define_code_iterator vis4_addsub_us [us_plus us_minus])
+(define_code_attr vis4_addsub_us_insn
+  [(us_plus "fpaddus") (us_minus "fpsubus")])
+(define_code_attr vis4_addsub_us_patname
+  [(us_plus "usadd") (us_minus "ussub")])
+
+(define_insn "<vis4_addsub_us_patname><mode>3"
+ [(set (match_operand:VAUS 0 "register_operand" "=<vconstr>")
+       (vis4_addsub_us:VAUS (match_operand:VAUS 1 "register_operand" "<vconstr>")
+                            (match_operand:VAUS 2 "register_operand" "<vconstr>")))]
+ "TARGET_VIS4"
+ "<vis4_addsub_us_insn><vbits>\t%1, %2, %0"
+ [(set_attr "type" "fga")])
+
 (define_insn "fucmp<code>8<P:mode>_vis"
   [(set (match_operand:P 0 "register_operand" "=r")
   	(unspec:P [(gcond:V8QI (match_operand:V8QI 1 "register_operand" "e")
@@ -8650,7 +8763,18 @@
 	 UNSPEC_FUCMP))]
   "TARGET_VIS3"
   "fucmp<code>8\t%1, %2, %0"
-  [(set_attr "type" "visl")])
+  [(set_attr "type" "visl")
+   (set_attr "v3pipe" "true")])
+
+(define_insn "fpcmpu<code><GCM:gcm_name><P:mode>_vis"
+  [(set (match_operand:P 0 "register_operand" "=r")
+  	(unspec:P [(gcond:GCM (match_operand:GCM 1 "register_operand" "e")
+		              (match_operand:GCM 2 "register_operand" "e"))]
+	 UNSPEC_FUCMP))]
+  "TARGET_VIS4"
+  "fpcmpu<code><GCM:gcm_name>\t%1, %2, %0"
+  [(set_attr "type" "visl")
+   (set_attr "fptype" "double")])
 
 (define_insn "*naddsf3"
   [(set (match_operand:SF 0 "register_operand" "=f")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/sparc.opt gcc-6-20160721/gcc/config/sparc/sparc.opt
--- gcc-6.1.0/gcc/config/sparc/sparc.opt	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/sparc.opt	2016-06-08 13:34:25.000000000 +0000
@@ -73,6 +73,10 @@
 Target Report Mask(VIS3)
 Use UltraSPARC Visual Instruction Set version 3.0 extensions.
 
+mvis4
+Target Report Mask(VIS4)
+Use UltraSPARC Visual Instruction Set version 4.0 extensions.
+
 mcbcond
 Target Report Mask(CBCOND)
 Use UltraSPARC Compare-and-Branch extensions.
@@ -194,6 +198,9 @@
 EnumValue
 Enum(sparc_processor_type) String(niagara4) Value(PROCESSOR_NIAGARA4)
 
+EnumValue
+Enum(sparc_processor_type) String(niagara7) Value(PROCESSOR_NIAGARA7)
+
 mcmodel=
 Target RejectNegative Joined Var(sparc_cmodel_string)
 Use given SPARC-V9 code model.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/sparc/visintrin.h gcc-6-20160721/gcc/config/sparc/visintrin.h
--- gcc-6.1.0/gcc/config/sparc/visintrin.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/sparc/visintrin.h	2016-06-08 13:34:25.000000000 +0000
@@ -704,6 +704,192 @@
 
 #endif /* __VIS__ >= 0x300 */
 
+#if __VIS__ >= 0x400
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpadd8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpadd8 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpadds8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpadds8 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpaddus8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpaddus8 (__A, __B);
+}
+
+extern __inline __v4hi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpaddus16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpaddus16 (__A, __B);
+}
+
+extern __inline long
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpcmple8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpcmple8 (__A, __B);
+}
+
+extern __inline long
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpcmpgt8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpcmpgt8 (__A, __B);
+}
+
+extern __inline long
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpcmpule16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpcmpule16 (__A, __B);
+}
+
+extern __inline long
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpcmpugt16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpcmpugt16 (__A, __B);
+}
+
+extern __inline long
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpcmpule32 (__v2si __A, __v2si __B)
+{
+  return __builtin_vis_fpcmpule32 (__A, __B);
+}
+
+extern __inline long
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpcmpugt32 (__v2si __A, __v2si __B)
+{
+  return __builtin_vis_fpcmpugt32 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmax8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpmax8 (__A, __B);
+}
+
+extern __inline __v4hi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmax16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpmax16 (__A, __B);
+}
+
+extern __inline __v2si
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmax32 (__v2si __A, __v2si __B)
+{
+  return __builtin_vis_fpmax32 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmaxu8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpmaxu8 (__A, __B);
+}
+
+extern __inline __v4hi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmaxu16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpmaxu16 (__A, __B);
+}
+
+extern __inline __v2si
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmaxu32 (__v2si __A, __v2si __B)
+{
+  return __builtin_vis_fpmaxu32 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmin8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpmin8 (__A, __B);
+}
+
+extern __inline __v4hi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmin16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpmin16 (__A, __B);
+}
+
+extern __inline __v2si
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpmin32 (__v2si __A, __v2si __B)
+{
+  return __builtin_vis_fpmin32 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpminu8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpminu8 (__A, __B);
+}
+
+extern __inline __v4hi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpminu16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpminu16 (__A, __B);
+}
+
+extern __inline __v2si
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpminu32 (__v2si __A, __v2si __B)
+{
+  return __builtin_vis_fpminu32 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpsub8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpsub8 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpsubs8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpsubs8 (__A, __B);
+}
+
+extern __inline __v8qi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpsubus8 (__v8qi __A, __v8qi __B)
+{
+  return __builtin_vis_fpsubus8 (__A, __B);
+}
+
+extern __inline __v4hi
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+__vis_fpsubus16 (__v4hi __A, __v4hi __B)
+{
+  return __builtin_vis_fpsubus16 (__A, __B);
+}
+
+#endif /* __VIS__ >= 0x400 */
+
 #endif /* __VIS__ */
 
 #endif  /* _VISINTRIN_H_INCLUDED */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/visium/visium-protos.h gcc-6-20160721/gcc/config/visium/visium-protos.h
--- gcc-6.1.0/gcc/config/visium/visium-protos.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/visium/visium-protos.h	2016-05-27 15:09:38.000000000 +0000
@@ -49,7 +49,8 @@
 extern const char *output_ubranch (rtx, rtx_insn *);
 extern const char *output_cbranch (rtx, enum rtx_code, enum machine_mode, int,
 				   rtx_insn *);
-extern void split_double_move (rtx *, enum machine_mode);
+extern void visium_split_double_move (rtx *, enum machine_mode);
+extern void visium_split_double_add (enum rtx_code, rtx, rtx, rtx);
 extern void visium_expand_copysign (rtx *, enum machine_mode);
 extern void visium_expand_int_cstore (rtx *, enum machine_mode);
 extern void visium_expand_fp_cstore (rtx *, enum machine_mode);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/visium/visium.c gcc-6-20160721/gcc/config/visium/visium.c
--- gcc-6.1.0/gcc/config/visium/visium.c	2016-02-17 11:17:15.000000000 +0000
+++ gcc-6-20160721/gcc/config/visium/visium.c	2016-05-30 08:48:32.000000000 +0000
@@ -2026,7 +2026,7 @@
 /* Split a double move of OPERANDS in MODE.  */
 
 void
-split_double_move (rtx *operands, enum machine_mode mode)
+visium_split_double_move (rtx *operands, enum machine_mode mode)
 {
   bool swap = false;
 
@@ -2076,14 +2076,74 @@
     }
 }
 
+/* Split a double addition or subtraction of operands.  */
+
+void
+visium_split_double_add (enum rtx_code code, rtx op0, rtx op1, rtx op2)
+{
+  rtx op3 = gen_lowpart (SImode, op0);
+  rtx op4 = gen_lowpart (SImode, op1);
+  rtx op5;
+  rtx op6 = gen_highpart (SImode, op0);
+  rtx op7 = (op1 == const0_rtx ? op1 : gen_highpart (SImode, op1));
+  rtx op8;
+  rtx x, pat, flags;
+
+  /* If operand #2 is a small constant, then its high part is null.  */
+  if (CONST_INT_P (op2))
+    {
+      HOST_WIDE_INT val = INTVAL (op2);
+
+      if (val < 0)
+	{
+	  code = (code == MINUS ? PLUS : MINUS);
+	  val = -val;
+	}
+
+      op5 = gen_int_mode (val, SImode);
+      op8 = const0_rtx;
+    }
+  else
+    {
+      op5 = gen_lowpart (SImode, op2);
+      op8 = gen_highpart (SImode, op2);
+    }
+
+  /* This is the {add,sub,neg}si3_insn_set_flags pattern.  */
+  if (op4 == const0_rtx)
+    x = gen_rtx_NEG (SImode, op5);
+  else
+    x = gen_rtx_fmt_ee (code, SImode, op4, op5);
+  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
+  XVECEXP (pat, 0, 0) = gen_rtx_SET (op3, x);
+  flags = gen_rtx_REG (CC_NOOVmode, FLAGS_REGNUM);
+  x = gen_rtx_COMPARE (CC_NOOVmode, shallow_copy_rtx (x), const0_rtx);
+  XVECEXP (pat, 0, 1) = gen_rtx_SET (flags, x);
+  emit_insn (pat);
+
+  /* This is the plus_[plus_]sltu_flags or minus_[minus_]sltu_flags pattern.  */
+  if (op8 == const0_rtx)
+    x = op7;
+  else
+    x = gen_rtx_fmt_ee (code, SImode, op7, op8);
+  x = gen_rtx_fmt_ee (code, SImode, x, gen_rtx_LTU (SImode, flags, const0_rtx));
+  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
+  XVECEXP (pat, 0, 0) = gen_rtx_SET (op6, x);
+  flags = gen_rtx_REG (CCmode, FLAGS_REGNUM);
+  XVECEXP (pat, 0, 1) = gen_rtx_CLOBBER (VOIDmode, flags);
+  emit_insn (pat);
+
+  visium_flags_exposed = true;
+}
+
 /* Expand a copysign of OPERANDS in MODE.  */
 
 void
 visium_expand_copysign (rtx *operands, enum machine_mode mode)
 {
-  rtx dest = operands[0];
-  rtx op0 = operands[1];
-  rtx op1 = operands[2];
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
   rtx mask = force_reg (SImode, GEN_INT (0x7fffffff));
   rtx x;
 
@@ -2091,37 +2151,37 @@
      the FPU on the MCM have a non-standard behavior wrt NaNs.  */
   gcc_assert (mode == SFmode);
 
-  /* First get all the non-sign bits of OP0.  */
-  if (GET_CODE (op0) == CONST_DOUBLE)
+  /* First get all the non-sign bits of op1.  */
+  if (GET_CODE (op1) == CONST_DOUBLE)
     {
-      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op0)))
-	op0 = simplify_unary_operation (ABS, mode, op0, mode);
-      if (op0 != CONST0_RTX (mode))
+      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op1)))
+	op1 = simplify_unary_operation (ABS, mode, op1, mode);
+      if (op1 != CONST0_RTX (mode))
 	{
 	  long l;
-	  REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (op0), l);
-	  op0 = force_reg (SImode, GEN_INT (trunc_int_for_mode (l, SImode)));
+	  REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (op1), l);
+	  op1 = force_reg (SImode, gen_int_mode (l, SImode));
 	}
     }
   else
     {
-      op0 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op0));
-      op0 = force_reg (SImode, gen_rtx_AND (SImode, op0, mask));
+      op1 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op1));
+      op1 = force_reg (SImode, gen_rtx_AND (SImode, op1, mask));
     }
 
-  /* Then get the sign bit of OP1.  */
+  /* Then get the sign bit of op2.  */
   mask = force_reg (SImode, gen_rtx_NOT (SImode, mask));
-  op1 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op1));
-  op1 = force_reg (SImode, gen_rtx_AND (SImode, op1, mask));
+  op2 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op2));
+  op2 = force_reg (SImode, gen_rtx_AND (SImode, op2, mask));
 
   /* Finally OR the two values.  */
-  if (op0 == CONST0_RTX (SFmode))
-    x = op1;
+  if (op1 == CONST0_RTX (SFmode))
+    x = op2;
   else
-    x = force_reg (SImode, gen_rtx_IOR (SImode, op0, op1));
+    x = force_reg (SImode, gen_rtx_IOR (SImode, op1, op2));
 
   /* And move the result to the destination.  */
-  emit_insn (gen_rtx_SET (dest, gen_lowpart (SFmode, x)));
+  emit_insn (gen_rtx_SET (op0, gen_lowpart (SFmode, x)));
 }
 
 /* Expand a cstore of OPERANDS in MODE for EQ/NE/LTU/GTU/GEU/LEU.  We generate
@@ -3537,18 +3597,15 @@
 int
 visium_initial_elimination_offset (int from, int to ATTRIBUTE_UNUSED)
 {
-  const int frame_size = visium_compute_frame_size (get_frame_size ());
   const int save_fp = current_frame_info.save_fp;
   const int save_lr = current_frame_info.save_lr;
   const int lr_slot = current_frame_info.lr_slot;
-  const int local_frame_offset
-    = (save_fp + save_lr + lr_slot) * UNITS_PER_WORD;
   int offset;
 
   if (from == FRAME_POINTER_REGNUM)
-    offset = local_frame_offset;
+    offset = (save_fp + save_lr + lr_slot) * UNITS_PER_WORD;
   else if (from == ARG_POINTER_REGNUM)
-    offset = frame_size;
+    offset = visium_compute_frame_size (get_frame_size ());
   else
     gcc_unreachable ();
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config/visium/visium.md gcc-6-20160721/gcc/config/visium/visium.md
--- gcc-6.1.0/gcc/config/visium/visium.md	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/config/visium/visium.md	2016-05-27 15:09:38.000000000 +0000
@@ -627,7 +627,7 @@
   [(set (match_dup 2) (match_dup 3))
    (set (match_dup 4) (match_dup 5))]
 {
-  split_double_move (operands, DImode);
+  visium_split_double_move (operands, DImode);
 })
 
 ;;
@@ -726,7 +726,7 @@
   [(set (match_dup 2) (match_dup 3))
    (set (match_dup 4) (match_dup 5))]
 {
-  split_double_move (operands, DFmode);
+  visium_split_double_move (operands, DFmode);
 })
 
 ;;
@@ -815,31 +815,20 @@
 		 (match_operand:DI 2 "add_operand" "")))]
   "")
 
+; Disfavour the use of add.l because of the early clobber.
+
 (define_insn_and_split "*addi3_insn"
   [(set (match_operand:DI 0 "register_operand"          "=r,r,&r")
 	(plus:DI (match_operand:DI 1 "register_operand" "%0,0, r")
-		 (match_operand:DI 2 "add_operand"      " J,L, r")))]
+		 (match_operand:DI 2 "add_operand"      " L,J, r")))]
   "ok_for_simple_arith_logic_operands (operands, DImode)"
   "#"
   "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (plus:DI (match_dup 1) (match_dup 2)))
-	      (clobber (reg:CC R_FLAGS))])]
-  ""
-  [(set_attr "type" "arith2")])
-
-; Disfavour the use of add.l because of the early clobber.
-
-(define_insn "*adddi3_insn_flags"
-  [(set (match_operand:DI 0 "register_operand"          "=r,r,&r")
-	(plus:DI (match_operand:DI 1 "register_operand" "%0,0, r")
-		 (match_operand:DI 2 "add_operand"      " J,L, r")))
-   (clobber (reg:CC R_FLAGS))]
-  "reload_completed"
-  "@
-    addi    %d0,%2\n\tadc.l   %0,%0,r0
-    subi    %d0,%n2\n\tsubc.l  %0,%0,r0
-    add.l   %d0,%d1,%d2\n\tadc.l   %0,%1,%2"
+  [(const_int 0)]
+{
+  visium_split_double_add (PLUS, operands[0], operands[1], operands[2]);
+  DONE;
+}
   [(set_attr "type" "arith2")])
 
 ;;
@@ -847,7 +836,7 @@
 ;;
 ;; Integer Add with Carry
 ;;
-;; Only SI mode is supported as slt[u] for the sake of cstore.
+;; Only SI mode is supported.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
@@ -869,6 +858,16 @@
   "adc.l   %0,%1,r0"
   [(set_attr "type" "arith")])
 
+(define_insn "*plus_plus_sltu<subst_arith>"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (plus:SI (match_operand:SI 1 "register_operand" "r")
+			  (match_operand:SI 2 "register_operand" "r"))
+		 (ltu:SI (reg R_FLAGS) (const_int 0))))
+   (clobber (reg:CC R_FLAGS))]
+  "reload_completed"
+  "adc.l   %0,%1,%2"
+  [(set_attr "type" "arith")])
+
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
@@ -955,31 +954,20 @@
 		  (match_operand:DI 2 "add_operand" "")))]
   "")
 
+; Disfavour the use of the sub.l because of the early clobber.
+
 (define_insn_and_split "*subdi3_insn"
   [(set (match_operand:DI 0 "register_operand"           "=r,r,&r")
 	(minus:DI (match_operand:DI 1 "register_operand" " 0,0, r")
-		  (match_operand:DI 2 "add_operand"      " J,L, r")))]
+		  (match_operand:DI 2 "add_operand"      " L,J, r")))]
   "ok_for_simple_arith_logic_operands (operands, DImode)"
   "#"
   "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (minus:DI (match_dup 1) (match_dup 2)))
-	      (clobber (reg:CC R_FLAGS))])]
- ""
-  [(set_attr "type" "arith2")])
-
-; Disfavour the use of the sub.l because of the early clobber.
-
-(define_insn "*subdi3_insn_flags"
-  [(set (match_operand:DI 0 "register_operand"           "=r,r,&r")
-	(minus:DI (match_operand:DI 1 "register_operand" " 0,0, r")
-		  (match_operand:DI 2 "add_operand"      " J,L, r")))
-   (clobber (reg:CC R_FLAGS))]
-  "reload_completed"
-  "@
-    subi    %d0,%2\n\tsubc.l  %0,%0,r0
-    addi    %d0,%n2\n\tadc.l   %0,%0,r0
-    sub.l   %d0,%d1,%d2\n\tsubc.l  %0,%1,%2"
+  [(const_int 0)]
+{
+  visium_split_double_add (MINUS, operands[0], operands[1], operands[2]);
+  DONE;
+}
   [(set_attr "type" "arith2")])
 
 ;;
@@ -987,7 +975,7 @@
 ;;
 ;; Integer Subtract with Carry
 ;;
-;; Only SI mode is supported as neg<slt[u]> for the sake of cstore.
+;; Only SI mode is supported.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
@@ -1009,6 +997,16 @@
   "subc.l  %0,%1,r0"
   [(set_attr "type" "arith")])
 
+(define_insn "*minus_minus_sltu<subst_arith>"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(minus:SI (minus:SI (match_operand:SI 1 "reg_or_0_operand" "rO")
+			    (match_operand:SI 2 "register_operand" "r"))
+		  (ltu:SI (reg R_FLAGS) (const_int 0))))
+   (clobber (reg:CC R_FLAGS))]
+  "reload_completed"
+  "subc.l  %0,%r1,%2"
+  [(set_attr "type" "arith")])
+
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
@@ -1054,17 +1052,11 @@
   "ok_for_simple_arith_logic_operands (operands, DImode)"
   "#"
   "reload_completed"
-  [(parallel [(set (match_dup 0) (neg:DI (match_dup 1)))
-	      (clobber (reg:CC R_FLAGS))])]
-  ""
-  [(set_attr "type" "arith2")])
-
-(define_insn "*negdi2_insn_flags"
-  [(set (match_operand:DI 0 "register_operand" "=&r")
-	(neg:DI (match_operand:DI 1 "register_operand" "r")))
-   (clobber (reg:CC R_FLAGS))]
-  "reload_completed"
-  "sub.l   %d0,r0,%d1\n\tsubc.l  %0,r0,%1"
+  [(const_int 0)]
+{
+  visium_split_double_add (MINUS, operands[0], const0_rtx, operands[1]);
+  DONE;
+}
   [(set_attr "type" "arith2")])
 
 ;;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config.gcc gcc-6-20160721/gcc/config.gcc
--- gcc-6.1.0/gcc/config.gcc	2016-04-11 10:14:59.000000000 +0000
+++ gcc-6-20160721/gcc/config.gcc	2016-06-08 13:34:25.000000000 +0000
@@ -1058,11 +1058,9 @@
 	case $target in
 	armv6*-*-freebsd*)
 	    tm_defines="${tm_defines} TARGET_FREEBSD_ARMv6=1"
-	    ;;
-	esac
-	case $target in
-	arm*hf-*-freebsd*)
-	    tm_defines="${tm_defines} TARGET_FREEBSD_ARM_HARD_FLOAT=1"
+            if test $fbsd_major -ge 11; then
+               tm_defines="${tm_defines} TARGET_FREEBSD_ARM_HARD_FLOAT=1"
+            fi
 	    ;;
 	esac
 	with_tls=${with_tls:-gnu}
@@ -4280,9 +4278,9 @@
 		esac
 		;;
 	sparc*-*-*)
-		supported_defaults="cpu float tune"
+		supported_defaults="cpu cpu_32 cpu_64 float tune tune_32 tune_64"
 
-		for which in cpu tune; do
+		for which in cpu cpu_32 cpu_64 tune tune_32 tune_64; do
 			eval "val=\$with_$which"
 			case ${val} in
 			"" | sparc | sparcv9 | sparc64 \
@@ -4291,7 +4289,7 @@
 			| sparclite | f930 | f934 | sparclite86x \
 			| sparclet | tsc701 \
 			| v9 | ultrasparc | ultrasparc3 | niagara | niagara2 \
-			| niagara3 | niagara4)
+			| niagara3 | niagara4 | niagara7)
 				# OK
 				;;
 			*)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/config.in gcc-6-20160721/gcc/config.in
--- gcc-6.1.0/gcc/config.in	2016-04-27 08:22:11.000000000 +0000
+++ gcc-6-20160721/gcc/config.in	2016-07-21 22:33:06.000000000 +0000
@@ -622,6 +622,12 @@
 #endif
 
 
+/* Define if your assembler supports SPARC5 and VIS 4.0 instructions. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_SPARC5_VIS4
+#endif
+
+
 /* Define if your assembler and linker support GOTDATA_OP relocs. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_SPARC_GOTDATA_OP
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/configure gcc-6-20160721/gcc/configure
--- gcc-6.1.0/gcc/configure	2016-01-27 16:54:48.000000000 +0000
+++ gcc-6-20160721/gcc/configure	2016-06-08 13:34:25.000000000 +0000
@@ -25092,6 +25092,42 @@
 
 fi
 
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for SPARC5 and VIS 4.0 instructions" >&5
+$as_echo_n "checking assembler for SPARC5 and VIS 4.0 instructions... " >&6; }
+if test "${gcc_cv_as_sparc_sparc5+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_sparc_sparc5=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.text
+       .register %g2, #scratch
+       .register %g3, #scratch
+       .align 4
+       subxc %g1, %g2, %g3
+       fpadd8 %f0, %f2, %f4' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -xarch=sparc5 -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_sparc_sparc5=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_sparc_sparc5" >&5
+$as_echo "$gcc_cv_as_sparc_sparc5" >&6; }
+if test $gcc_cv_as_sparc_sparc5 = yes; then
+
+$as_echo "#define HAVE_AS_SPARC5_VIS4 1" >>confdefs.h
+
+fi
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions" >&5
 $as_echo_n "checking assembler for LEON instructions... " >&6; }
 if test "${gcc_cv_as_sparc_leon+set}" = set; then :
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/configure.ac gcc-6-20160721/gcc/configure.ac
--- gcc-6.1.0/gcc/configure.ac	2016-01-27 16:54:48.000000000 +0000
+++ gcc-6-20160721/gcc/configure.ac	2016-06-08 13:34:25.000000000 +0000
@@ -3906,6 +3906,18 @@
       [AC_DEFINE(HAVE_AS_SPARC4, 1,
                 [Define if your assembler supports SPARC4 instructions.])])
 
+    gcc_GAS_CHECK_FEATURE([SPARC5 and VIS 4.0 instructions],
+      gcc_cv_as_sparc_sparc5,,
+      [-xarch=sparc5],
+      [.text
+       .register %g2, #scratch
+       .register %g3, #scratch
+       .align 4
+       subxc %g1, %g2, %g3
+       fpadd8 %f0, %f2, %f4],,
+      [AC_DEFINE(HAVE_AS_SPARC5_VIS4, 1,
+                [Define if your assembler supports SPARC5 and VIS 4.0 instructions.])])
+
     gcc_GAS_CHECK_FEATURE([LEON instructions],
       gcc_cv_as_sparc_leon,,
       [-Aleon],
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/ChangeLog gcc-6-20160721/gcc/cp/ChangeLog
--- gcc-6.1.0/gcc/cp/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/cp/ChangeLog	2016-07-21 18:24:48.000000000 +0000
@@ -1,3 +1,456 @@
+2016-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71728
+	* constexpr.c (potential_constant_expression_1) <case GOTO_EXPR>:
+	Replace assert with test, return false if the goto isn't break
+	or continue.  Formatting fix.
+
+2016-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71941
+	* cp-gimplify.c (cp_genericize): For nested cp_genericize calls
+	save/restore bc_label array.
+
+2016-07-21  Patrick Palka  <ppalka@gcc.gnu.org>
+
+	PR c++/70822
+	PR c++/70106
+	* cp-tree.h (REF_PARENTHESIZED_P): Make this flag apply to
+	SCOPE_REFs too.
+	* pt.c (tsubst_qualified_id): If REF_PARENTHESIZED_P is set
+	on the qualified_id then propagate it to the resulting
+	expression.
+	(do_auto_deduction): Check REF_PARENTHESIZED_P on SCOPE_REFs
+	too.
+	* semantics.c (force_paren_expr): If given a SCOPE_REF, just set
+	its REF_PARENTHESIZED_P flag.
+
+2016-07-21  Andrew Sutton  <andrew.n.sutton@gmail.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	Improving concepts performance and diagnostics.
+	PR c++/67565
+	PR c++/67579
+	PR c++/71843
+	* cp-tree.def (CHECK_CONSTR): New.
+	* cp-tree.h (CHECK_CONSTR_CONCEPT): New.
+	(CHECK_CONSTR_ARGS): New.
+	* constraint.cc (make_predicate_constraint): Remove in favor of
+	normalize_expression.
+	(resolve_constraint_check): Actually return error_mark_node when
+	resolution fails.
+	(resolve_variable_concept_check): Perform coercion as if processing
+	a template. Also return errors on resolution failure.
+	(lift_*): Remove all of these functions. Don't unnecessarily inline
+	concepts.
+	(learn_*): Add facilities to memoize implications for subsumption
+	during normalization.
+	(expanding_concept): New.
+	(expand_concept): New. Return the inlined and normalized definition
+	of a concept when needed.
+	(transform_*, xform_*): Rename to normalize_* to better reflect the
+	responsibility of those functions.
+	(normalize_template_id_expression): Check for non-boolean operands
+	when possible. Generate check constraints instead of normal variable
+	references.
+	(normalize_call_expression): Report errors when resolution fails.
+	(check_for_logical_overloads): Rewrite this check to more accurately
+	report the error.
+	(normalize_atom): Check for overloaded calls and invalid types before
+	determining if the expression refers to a concept.
+	(build_constraints): Don't cache normalized constraints or decomposed
+	assumptions.
+	(finish_shorthand_constraint): Return a normalized expression instead
+	of a predicate constraint.
+	(finish_template_introduction): Same.
+	(placeholder_extract_concept_and_args): Rewrite this since we only
+	ever get check constraints here.
+	(equivalent_placeholder_constraints): Rewrite in terms of check
+	constraints, and handle error_mark_nodes correctly.
+	(tsubst_check_constraint, tsubst_expr_constr, tsubst_type_constr)
+	(tsubst_implicit_conversion_constr)
+	(tsubst_argument_deduction_constr, tsubst_exception_constr)
+	(tsubst_parameterized_constraint, tsubst_constraint): New.
+	(tsbust_conjunection): Replace with tsubst_logical_operator and
+	actually generate the right kind of constraint.
+	(tsubst_requirement_body): Reverse the order of substituted arguments
+	so that they appear in the order written (helps diagnostics).
+	(satisfy_check_constraint): New.
+	(satisfy_conjunction): Simplify.
+	(satisfy_disjunction): Same.
+	(satisfy_constraint_1): Handle check constraints.
+	(eval_constr): New (private) global state.
+	(evaluating_constraints_sentinel): New. Manages eval_constr.
+	(satisfy_constraint): Add timing variables.
+	(satisfy_associated_constraints): Add hooks for memoization.
+	(evaluate_function_concept): Build a check constraint instead of
+	normalizing its definition.
+	(evaluate_variable_concept): Same.
+	(evaluate_constraint_expression): Normalize, but in the current
+	declaration processing context.
+	(evaluating_constraints_p): New.
+	(elide_constraint_failure_p): Actually emit constraint_thresh errors.
+	(diagnose_*): Remove artificial indentation. Add a new parameter to
+	each that tracks the current (complete) constraint prior to any
+	substitutions.
+	(diagnose_expression): Removed.
+	(diagnose_call_expression): Same.
+	(diagnose_template_id): Same.
+	(diagnose_template_id): New.
+	(diagnose_logical_constraint): New.
+	(diagnose_expression_constraint): Show the original expression.
+	(diagnose_type_constraint): Show the original type.
+	(diagnose_implicit_conversion_constraint): Be specific about
+	failures, don't re-diagnose a known-to-be-failed substitutions,
+	and manage elisions properly.
+	(diagnose_argument_deduction_constraint): Same.
+	(diagnose_exception_constraint): Same.
+	(diagnose_parameterized_constraint): Same.
+	(constraint_p): Allow EXPR_PACK_EXPANSION.
+	* logic.cc (next_by_distance): Removed. No longer used.
+	(any_p): Renamed from any_of.
+	(term_entry, term_hasher): New.
+	(term_list): Rewrite to include a hash table for quick lookup.
+	Also, make less stateful.
+	(proof_state): Extend to allow goals to be discharged once
+	satisfied.
+	(non_atomic_constraint_p): New.
+	(any_non_atomic_constraints_p): New.
+	(...rest...): Previous implementation completely replaced with an
+	iterative algorithm that opportunistically prunes the search space
+	before committing to using more memory.
+	* parser.c: (cp_parser_type_parameter): Normalize constraints.
+	(cp_parser_explicit_template_declaration): Same.
+	* pt.c: (finish_template_variable): Be less redundant with this error
+	message.
+	(template_args_equal): No longer static.
+	(tsubst_decl): Don't try to find specializations of variables that
+	have already been instantiated.
+	(build_non_dependent_expr): Avoid infinite recursion during concept
+	expansion.
+	(make_constrained_auto): Normalize constraints.
+	(do_auto_deduction): When doing auto deduction from a
+	partial-concept-id, be sure to include the explicit args checking
+	the constraints.
+	(constraint_sat_*): New. Memoize satisfied constraints.
+	(concept_spec_*): New. Memoize expressions associated with a concept
+	specialization.
+	(constraint_memos, concept_memos): New.
+	(lookup_constraint_satisfaction, memoize_constraint_satisfaction): New.
+	(lookup_concept_satisfaction, memoize_concept_satisfaction): New.
+	(get_concept_expansion, save_concept_expansion): New.
+	(hash_subsumption_args): New.
+	(comp_subsumption_args): New.
+	(subsumption_*): New. Memoize parts of the subsumption relation.
+	(lookup_subsumption_result, save_subsumption_result): New.
+	(init_constraint_processing): Initialize memo tables.
+	(get_constraints): Shortcut if !flag_concepts.
+	* decl.c (grokfndecl): Normalize constraints.
+	* error.c (dump_simple_decl): Print "concept" when appropriate.
+	(dump_function_decl): Same.
+	(dump_template_decl): Don't write requirements when we're not
+	printing the header.
+	(dump_expr): Handle fold expressions.
+	* cxx-pretty-print.c (cxx_pretty_printer::expression): Handle
+	fold expressions.
+	(get_fold_operator): New.
+	(pp_cxx_unary_left_fold_expression): New.
+	(pp_cxx_unary_right_fold_expression): New.
+	(pp_cxx_binary_fold_expression): New.
+	(pp_cxx_check_constraint): New.
+	(pp_cxx_*_constraint): Rewrite the grammar of internal constraints
+	to make them easier to read when debugging.
+	* search.c (accessible_p): Don't shortcut when evaluating constraints.
+	* tree.c (cp_tree_equal): Handle CHECK_CONSTR.
+
+2016-07-21  Jason Merrill  <jason@redhat.com>
+
+	PR c++/70781
+	* parser.c (cp_parser_lambda_expression): Unset OK if there was an
+	error parsing the lambda-declarator.
+
+	PR c++/71896
+	* constexpr.c (cxx_eval_binary_expression): Handle comparison
+	between lowered and unlowered PTRMEM_CST.
+
+	PR c++/71092
+	* constexpr.c (cxx_eval_call_expression): Fail quietly when cgraph
+	threw away DECL_SAVED_TREE.
+
+	PR c++/71117
+	Core 2189
+	* call.c (add_template_conv_candidate): Disable if there are
+	viable candidates.
+
+	PR c++/71495
+	* call.c (convert_like_real): Mask complain.
+
+	PR c++/71511
+	* typeck2.c (cxx_incomplete_type_diagnostic): Handle DECLTYPE_TYPE.
+
+	PR c++/71513
+	* pt.c (tsubst_attributes): Fix loop logic.
+
+	PR c++/71604
+	PR c++/54430
+	* parser.c (cp_parser_range_for): Modify IDENTIFIER_BINDING directly.
+	(cp_parser_simple_declaration): Diagnose type definition in
+	for-range-declaration.
+
+	PR c++/71711
+	* operators.def: Add *_FOLD_EXPR.
+	* cp-tree.h (FOLD_EXPR_P): Parenthesize.
+	* mangle.c (write_expression): Handle fold-expressions.
+	* pt.c (tsubst_unary_left_fold, tsubst_binary_left_fold)
+	(tsubst_unary_right_fold, tsubst_binary_right_fold): Handle
+	partial instantiation.
+
+	PR c++/71814
+	* mangle.c (write_expression): Handle sizeof... an argument pack.
+
+	PR c++/71718
+	* pt.c (push_tinst_level_loc): Set at_eof before fatal_error.
+
+	PR c++/70824
+	* init.c (constant_value_1): Don't instantiated DECL_INITIAL of
+	artificial variables.
+
+	* lambda.c (maybe_add_lambda_conv_op): Fix null object argument.
+
+2016-07-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71909
+	* parser.c (cp_parser_save_member_function_body): Consume
+	__transaction_relaxed or __transaction_atomic with optional
+	attribute.  Only skip catch with block if try keyword is seen.
+
+2016-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-07-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71835
+	* call.c (build_op_call_1): Use convert_like_with_context only
+	if cand->fn is a decl.
+
+	PR c++/71828
+	* constexpr.c (cxx_eval_constant_expression) <case REALPART_EXPR>:
+	For lval don't use cxx_eval_unary_expression and instead recurse
+	and if needed rebuild the reference.
+
+	PR c++/71822
+	* cp-gimplify.c (cp_gimplify_expr) <case VEC_INIT_EXPR>: Recursively
+	fold *expr_p before genericizing it.
+
+	PR c++/71871
+	* typeck.c (build_x_conditional_expr): Revert the 2012-10-25 change.
+
+	2016-07-07  Jakub Jelinek  <jakub@redhat.com>
+		    Kai Tietz  <ktietz70@googlemail.com>
+
+	PR c++/70869
+	PR c++/71054
+	* cp-gimplify.c (cp_genericize_r): For DECL_EXPR for non-static
+	artificial vars, genericize their initializers.
+
+2016-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-06-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* semantics.c (handle_omp_array_sections_1): Don't ICE when
+	processing_template_decl when checking for bitfields and unions.
+	Look through REFERENCE_REF_P as base of COMPONENT_REF.
+	(finish_omp_clauses): Look through REFERENCE_REF_P even for
+	array sections with COMPONENT_REF bases.
+
+	2016-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* parser.c (cp_parser_omp_var_list_no_open): Call
+	convert_from_reference before cp_parser_postfix_dot_deref_expression.
+	* semantics.c (finish_omp_clauses): Don't ICE when
+	processing_template_decl when checking for bitfields and unions.
+	Look through REFERENCE_REF_P as base of COMPONENT_REF.
+
+	2016-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71528
+	* decl.c (duplicate_decls): For DECL_INITIALIZED_P non-external
+	olddecl vars, preserve their TREE_READONLY bit.
+
+2016-06-14  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70572
+	* decl.c (cp_finish_decl): Check do_auto_deduction return value
+	and return immediately in case of erroneous code.
+
+2016-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71516
+	* decl.c (complete_vars): Handle gracefully type == error_mark_node.
+
+2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR c/71381
+	Backport from trunk r237290:
+	* parser.c (cp_parser_omp_var_list_no_open) <OMP_CLAUSE__CACHE_>:
+	Loosen checking.
+
+2016-06-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71442
+	* pt.c (tsubst_copy): Only set TREE_USED on DECLs.
+
+2016-06-06  Jakub Jelinek  <jakub@redhat.com>
+	    Patrick Palka  <ppalka@gcc.gnu.org>
+
+	PR c++/70847
+	PR c++/71330
+	PR c++/71393
+	* cp-gimplify.c (cp_fold_r): Set *walk_subtrees = 0 and return NULL
+	right after cp_fold call if cp_fold has returned the same stmt
+	already in some earlier cp_fold_r call.
+	(cp_fold_function): Add pset automatic variable, pass its address
+	to cp_walk_tree.
+
+2016-06-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71372
+	* cp-gimplify.c (cp_fold): For INDIRECT_REF, if the folded expression
+	is INDIRECT_REF or MEM_REF, copy over TREE_READONLY, TREE_SIDE_EFFECTS
+	and TREE_THIS_VOLATILE flags.  For ARRAY_REF and ARRAY_RANGE_REF, copy
+	over TREE_READONLY, TREE_SIDE_EFFECTS and TREE_THIS_VOLATILE flags
+	to the newly built tree.
+
+2016-06-02  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70972
+	* method.c (forward_parm): Use cp_build_reference_type.
+
+2016-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71166
+	* decl2.c (c_parse_final_cleanups): Don't call fini_constexpr.
+
+	PR c++/71227
+	* pt.c (check_explicit_specialization): Give better diagnostic about
+	specializing a hidden friend.
+
+	PR c++/60095
+	PR c++/69515
+	PR c++/69009
+	* pt.c (instantiate_template_1): Don't put the partial
+	specialization in DECL_TI_TEMPLATE.
+	(partial_specialization_p, impartial_args): Remove.
+	(regenerate_decl_from_template): Add args parm.
+	(instantiate_decl): Look up the partial specialization again.
+
+	PR c++/71173
+	PR c++/70522
+	* cp-tree.h (enum tag_types): Add scope_type.
+	* parser.c (cp_parser_class_name): Use scope_type.
+	(prefer_type_arg): Handle scope_type.
+	(cp_parser_lookup_name): Use prefer_type_arg.
+	* name-lookup.c (lookup_qualified_name): Change bool is_type_p to
+	int prefer_type, use lookup_flags.
+	* name-lookup.h: Adjust.
+
+	PR c++/70584
+	* cp-gimplify.c (cp_fold_maybe_rvalue): Loop in case cp_fold
+	returns a decl.
+	(cp_fold) [INDIRECT_REF]: Call maybe_undo_parenthesized_ref.
+
+	PR c++/70735
+	* pt.c (tsubst_copy): Just return a local variable from
+	non-template context.  Don't call rest_of_decl_compilation for
+	duplicated static locals.
+	(tsubst_decl): Set DECL_CONTEXT of local static from another
+	function.
+
+2016-05-31  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/71306
+	* init.c (warn_placement_new_too_small): Handle placement new arguments
+	that are elements of arrays more carefully.  Remove a pointless loop.
+
+2016-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71349
+	* parser.c (cp_parser_omp_for): Don't disallow nowait clause
+	when combined with target construct.
+	(cp_parser_omp_parallel): Pass cclauses == NULL as last argument
+	to cp_parser_omp_all_clauses.
+
+2016-05-29  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/71105
+	* lambda.c (maybe_add_lambda_conv_op): Early return also when
+	LAMBDA_EXPR_DEFAULT_CAPTURE_MODE != CPLD_NONE.
+
+2016-05-24  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/71147
+	* decl.c (layout_var_decl, grokdeclarator): Use
+	complete_or_array_type_p.
+	* pt.c (instantiate_class_template_1): Try to complete the element
+	type of a flexible array member.
+	(can_complete_type_without_circularity): Handle arrays of unknown bound.
+	* typeck.c (complete_type): Also complete the type of the elements of
+	arrays with an unspecified bound.
+
+2016-05-24  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/69872
+	* typeck2.c (check_narrowing): Check pedwarn return value.
+
+2016-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71257
+	* semantics.c (finish_omp_clauses) <case OMP_CLAUSE_LINEAR>:
+	For OMP_CLAUSE_LINEAR_REF don't require type to be
+	integral or pointer.
+
+2016-05-23  Jason Merrill  <jason@redhat.com>
+
+	PR c++/70344
+	* constexpr.c (cxx_eval_call_expression): Check for
+	fun == current_function_decl again.
+
+2016-05-19  David Malcolm  <dmalcolm@redhat.com>
+
+	Backport from trunk r236483.
+	PR c++/71184
+	* parser.c (cp_parser_operator): For array new/delete, check that
+	cp_parser_require returned a non-NULL token before dereferencing
+	it.
+
+2016-05-19  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+	2016-05-19  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* decl.c (finish_enum_value_list): Use the specified mode.
+
+2016-05-18  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70466
+	* call.c (convert_like_real): Check that we are actually converting
+	from an init list.
+
+2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR middle-end/70626
+	* parser.c (cp_parser_oacc_loop): Don't augment mask with
+	OACC_LOOP_CLAUSE_MASK.
+	(cp_parser_oacc_kernels_parallel): Update call to
+	c_oacc_split_loop_clauses.
+
+2016-04-28  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70540
+	* semantics.c (process_outer_var_ref): Unconditionally return
+	error_mark_node when mark_used returns false.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/call.c gcc-6-20160721/gcc/cp/call.c
--- gcc-6.1.0/gcc/cp/call.c	2016-04-14 16:23:06.000000000 +0000
+++ gcc-6-20160721/gcc/cp/call.c	2016-07-21 06:16:11.000000000 +0000
@@ -3184,6 +3184,12 @@
 			     tree return_type, tree access_path,
 			     tree conversion_path, tsubst_flags_t complain)
 {
+  /* Making this work broke PR 71117, so until the committee resolves core
+     issue 2189, let's disable this candidate if there are any viable call
+     operators.  */
+  if (any_strictly_viable (*candidates))
+    return NULL;
+
   return
     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,
 				 NULL_TREE, arglist, return_type, access_path,
@@ -4386,8 +4392,11 @@
 	result = build_over_call (cand, LOOKUP_NORMAL, complain);
       else
 	{
-	  obj = convert_like_with_context (cand->convs[0], obj, cand->fn, -1,
-					   complain);
+	  if (DECL_P (cand->fn))
+	    obj = convert_like_with_context (cand->convs[0], obj, cand->fn,
+					     -1, complain);
+	  else
+	    obj = convert_like (cand->convs[0], obj, complain);
 	  obj = convert_from_reference (obj);
 	  result = cp_build_function_call_vec (obj, args, complain);
 	}
@@ -6360,8 +6369,9 @@
 	/* When converting from an init list we consider explicit
 	   constructors, but actually trying to call one is an error.  */
 	if (DECL_NONCONVERTING_P (convfn) && DECL_CONSTRUCTOR_P (convfn)
+	    && BRACE_ENCLOSED_INITIALIZER_P (expr)
 	    /* Unless this is for direct-list-initialization.  */
-	    && !DIRECT_LIST_INIT_P (expr)
+	    && !CONSTRUCTOR_IS_DIRECT_INIT (expr)
 	    /* And in C++98 a default constructor can't be explicit.  */
 	    && cxx_dialect >= cxx11)
 	  {
@@ -6546,7 +6556,7 @@
       expr = decay_conversion (expr, complain);
       if (expr == error_mark_node)
 	{
-	  if (complain)
+	  if (complain & tf_error)
 	    {
 	      maybe_print_user_conv_context (convs);
 	      if (fn)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/constexpr.c gcc-6-20160721/gcc/cp/constexpr.c
--- gcc-6.1.0/gcc/cp/constexpr.c	2016-04-22 15:39:03.000000000 +0000
+++ gcc-6-20160721/gcc/cp/constexpr.c	2016-07-21 18:24:48.000000000 +0000
@@ -1371,11 +1371,17 @@
   else
     {
       new_call.fundef = retrieve_constexpr_fundef (fun);
-      if (new_call.fundef == NULL || new_call.fundef->body == NULL)
+      if (new_call.fundef == NULL || new_call.fundef->body == NULL
+	  || fun == current_function_decl)
         {
 	  if (!ctx->quiet)
 	    {
-	      if (DECL_INITIAL (fun) == error_mark_node)
+	      /* We need to check for current_function_decl here in case we're
+		 being called during cp_fold_function, because at that point
+		 DECL_INITIAL is set properly and we have a fundef but we
+		 haven't lowered invisirefs yet (c++/70344).  */
+	      if (DECL_INITIAL (fun) == error_mark_node
+		  || fun == current_function_decl)
 		error_at (loc, "%qD called in a constant expression before its "
 			  "definition is complete", fun);
 	      else if (DECL_INITIAL (fun))
@@ -1444,9 +1450,19 @@
     }
   else
     {
-      if (!result || result == error_mark_node)
+      if (result && result != error_mark_node)
+	/* OK */;
+      else if (!DECL_SAVED_TREE (fun))
+	{
+	  /* When at_eof >= 2, cgraph has started throwing away
+	     DECL_SAVED_TREE, so fail quietly.  FIXME we get here because of
+	     late code generation for VEC_INIT_EXPR, which needs to be
+	     completely reconsidered.  */
+	  gcc_assert (at_eof >= 2 && ctx->quiet);
+	  *non_constant_p = true;
+	}
+      else
 	{
-	  gcc_assert (DECL_SAVED_TREE (fun));
 	  tree body, parms, res;
 
 	  /* Reuse or create a new unshared copy of this function's body.  */
@@ -1750,6 +1766,10 @@
 	       && (null_member_pointer_value_p (lhs)
 		   || null_member_pointer_value_p (rhs)))
 	r = constant_boolean_node (!is_code_eq, type);
+      else if (TREE_CODE (lhs) == PTRMEM_CST)
+	lhs = cplus_expand_constant (lhs);
+      else if (TREE_CODE (rhs) == PTRMEM_CST)
+	rhs = cplus_expand_constant (rhs);
     }
 
   if (r == NULL_TREE)
@@ -3714,6 +3734,19 @@
 
     case REALPART_EXPR:
     case IMAGPART_EXPR:
+      if (lval)
+	{
+	  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), lval,
+					    non_constant_p, overflow_p);
+	  if (r == error_mark_node)
+	    ;
+	  else if (r == TREE_OPERAND (t, 0))
+	    r = t;
+	  else
+	    r = fold_build1 (TREE_CODE (t), TREE_TYPE (t), r);
+	  break;
+	}
+      /* FALLTHRU */
     case CONJ_EXPR:
     case FIX_TRUNC_EXPR:
     case FLOAT_EXPR:
@@ -5140,10 +5173,12 @@
     case GOTO_EXPR:
       {
 	tree *target = &TREE_OPERAND (t, 0);
-	/* Gotos representing break and continue are OK; we should have
-	   rejected other gotos in parsing.  */
-	gcc_assert (breaks (target) || continues (target));
-	return true;
+	/* Gotos representing break and continue are OK.  */
+	if (breaks (target) || continues (target))
+	  return true;
+	if (flags & tf_error)
+	  error ("%<goto%> is not a constant-expression");
+	return false;
       }
 
     default:
@@ -5151,7 +5186,7 @@
 	return false;
 
       sorry ("unexpected AST of kind %s", get_tree_code_name (TREE_CODE (t)));
-      gcc_unreachable();
+      gcc_unreachable ();
       return false;
     }
 #undef RECUR
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/constraint.cc gcc-6-20160721/gcc/cp/constraint.cc
--- gcc-6.1.0/gcc/cp/constraint.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/cp/constraint.cc	2016-07-21 06:18:06.000000000 +0000
@@ -22,6 +22,7 @@
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "timevar.h"
 #include "hash-set.h"
 #include "machmode.h"
 #include "vec.h"
@@ -55,7 +56,9 @@
 static inline bool
 constraint_p (tree_code c)
 {
-  return (PRED_CONSTR <= c && c <= DISJ_CONSTR) || c == ERROR_MARK;
+  return ((PRED_CONSTR <= c && c <= DISJ_CONSTR)
+          || c == EXPR_PACK_EXPANSION
+          || c == ERROR_MARK);
 }
 
 /* Returns true if T is a constraint. Note that error_mark_node
@@ -67,14 +70,6 @@
   return constraint_p (TREE_CODE (t));
 }
 
-/* Make a predicate constraint from the given expression. */
-
-tree
-make_predicate_constraint (tree expr)
-{
-  return build_nt (PRED_CONSTR, expr);
-}
-
 /* Returns the conjunction of two constraints A and B. Note that
    conjoining a non-null constraint with NULL_TREE is an identity
    operation. That is, for non-null A,
@@ -132,6 +127,53 @@
   return false;
 }
 
+/* Returns true if any of the arguments in the template
+   argument list is a wildcard or wildcard pack.  */
+
+bool
+contains_wildcard_p (tree args)
+{
+  for (int i = 0; i < TREE_VEC_LENGTH (args); ++i)
+    {
+      tree arg = TREE_VEC_ELT (args, i);
+      if (TREE_CODE (arg) == WILDCARD_DECL)
+	return true;
+    }
+  return false;
+}
+
+/* Build a new call expression, but don't actually generate a
+   new function call. We just want the tree, not the semantics.  */
+
+inline tree
+build_call_check (tree id)
+{
+  ++processing_template_decl;
+  vec<tree, va_gc> *fargs = make_tree_vector();
+  tree call = finish_call_expr (id, &fargs, false, false, tf_none);
+  release_tree_vector (fargs);
+  --processing_template_decl;
+  return call;
+}
+
+/* Build an expression that will check a variable concept. If any
+   argument contains a wildcard, don't try to finish the variable
+   template because we can't substitute into a non-existent
+   declaration.  */
+
+tree
+build_variable_check (tree id)
+{
+  gcc_assert (TREE_CODE (id) == TEMPLATE_ID_EXPR);
+  if (contains_wildcard_p (TREE_OPERAND (id, 1)))
+    return id;
+
+  ++processing_template_decl;
+  tree var = finish_template_variable (id);
+  --processing_template_decl;
+  return var;
+}
+
 /*---------------------------------------------------------------------------
                     Resolution of qualified concept names
 ---------------------------------------------------------------------------*/
@@ -160,6 +202,7 @@
 static tree
 resolve_constraint_check (tree ovl, tree args)
 {
+  int nerrs = 0;
   tree cands = NULL_TREE;
   for (tree p = ovl; p != NULL_TREE; p = OVL_NEXT (p))
     {
@@ -185,15 +228,21 @@
       ++processing_template_decl;
       tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (tmpl));
       if (tree subst = coerce_template_parms (parms, args, tmpl))
-        if (subst != error_mark_node)
-          cands = tree_cons (subst, fn, cands);
+        {
+          if (subst == error_mark_node)
+            ++nerrs;
+          else
+	    cands = tree_cons (subst, fn, cands);
+        }
       --processing_template_decl;
     }
 
-  // If we didn't find a unique candidate, then this is
-  // not a constraint check.
-  if (!cands || TREE_CHAIN (cands))
-    return NULL_TREE;
+  if (!cands)
+    /* We either had no candidates or failed deductions.  */
+    return nerrs ? error_mark_node : NULL_TREE;
+  else if (TREE_CHAIN (cands))
+    /* There are multiple candidates.  */
+    return error_mark_node;
 
   return cands;
 }
@@ -250,14 +299,16 @@
      assuming that it works.  Note that failing to deduce
      will result in diagnostics.  */
   tree parms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));
+  ++processing_template_decl;
   tree result = coerce_template_parms (parms, args, tmpl);
+  --processing_template_decl;
   if (result != error_mark_node)
     {
       tree decl = DECL_TEMPLATE_RESULT (tmpl);
       return build_tree_list (result, decl);
     }
   else
-    return NULL_TREE;
+    return error_mark_node;
 }
 
 
@@ -315,45 +366,119 @@
 namespace {
 
 /*---------------------------------------------------------------------------
-                       Lifting of concept definitions
+                       Constraint implication learning
 ---------------------------------------------------------------------------*/
 
-/* Part of constraint normalization.  Whenever we find a reference to
-   a variable concept or a call to a function concept, we lift or
-   inline that concept's definition into the constraint.  This ensures
-   that constraints are always checked in the immediate instantiation
-   context. */
+/* The implication context determines how we memoize concept checks.
+   Given two checks C1 and C2, the direction of implication depends
+   on whether we are learning implications of a conjunction or disjunction.
+   For example:
 
-tree lift_expression (tree);
+      template<typename T> concept bool C = ...;
+      template<typenaem T> concept bool D = C<T> && true;
 
-/* If the tree T has operands, then lift any concepts out of them.  */
-tree
-lift_operands (tree t)
+   From this, we can learn that D<T> implies C<T>. We cannot learn,
+   without further testing, that C<T> does not imply D<T>. If, for
+   example, C<T> were defined as true, then these constraints would
+   be logically equivalent.
+
+   In rare cases, we may start with a logical equivalence. For example:
+
+      template<typename T> concept bool C = ...;
+      template<typename T> concept bool D = C<T>;
+
+   Here, we learn that C<T> implies D<T> and vice versa.   */
+
+enum implication_context
 {
-  if (int n = tree_operand_length (t))
+  conjunction_cxt, /* C1 implies C2. */
+  disjunction_cxt, /* C2 implies C1. */
+  equivalence_cxt  /* C1 implies C2, C2 implies C1. */
+};
+
+void learn_implications(tree, tree, implication_context);
+
+void
+learn_implication (tree parent, tree child, implication_context cxt)
+{
+  switch (cxt)
     {
-      t = copy_node (t);
-      for (int i = 0; i < n; ++i)
-        TREE_OPERAND (t, i) = lift_expression (TREE_OPERAND (t, i));
+      case conjunction_cxt:
+        save_subsumption_result (parent, child, true);
+        break;
+      case disjunction_cxt:
+        save_subsumption_result (child, parent, true);
+        break;
+      case equivalence_cxt:
+        save_subsumption_result (parent, child, true);
+        save_subsumption_result (child, parent, true);
+        break;
     }
-  return t;
 }
 
-/* Recursively lift all operands of the function call. Also, check
-   that the call target is not accidentally a variable concept
-   since that's ill-formed.  */
-tree
-lift_function_call (tree t)
+void
+learn_logical_operation (tree parent, tree constr, implication_context cxt)
 {
-  gcc_assert (TREE_CODE (t) == CALL_EXPR);
-  gcc_assert (!VAR_P (CALL_EXPR_FN (t)));
-  return lift_operands (t);
+  learn_implications (parent, TREE_OPERAND (constr, 0), cxt);
+  learn_implications (parent, TREE_OPERAND (constr, 1), cxt);
 }
 
-/* Inline a function (concept) definition by substituting
-   ARGS into its body. */
+void
+learn_implications (tree parent, tree constr, implication_context cxt)
+{
+  switch (TREE_CODE (constr))
+    {
+      case CHECK_CONSTR:
+        return learn_implication (parent, constr, cxt);
+
+      case CONJ_CONSTR:
+        if (cxt == disjunction_cxt)
+          return;
+        return learn_logical_operation (parent, constr, cxt);
+
+      case DISJ_CONSTR:
+        if (cxt == conjunction_cxt)
+          return;
+        return learn_logical_operation (parent, constr, cxt);
+
+      default:
+        break;
+    }
+}
+
+/* Quickly scan the top-level constraints of CONSTR to learn and
+   cache logical relations between concepts.  The search does not
+   include conjunctions of disjunctions or vice versa.  */
+
+void
+learn_implications (tree tmpl, tree args, tree constr)
+{
+  /* Don't memoize relations between non-dependent arguemnts. It's not
+     helpful. */
+  if (!uses_template_parms (args))
+    return;
+
+  /* Build a check constraint for the purpose of caching. */
+  tree parent = build_nt (CHECK_CONSTR, tmpl, args);
+
+  /* Start learning based on the kind of the top-level contraint. */
+  if (TREE_CODE (constr) == CONJ_CONSTR)
+    return learn_logical_operation (parent, constr, conjunction_cxt);
+  else if (TREE_CODE (constr) == DISJ_CONSTR)
+    return learn_logical_operation (parent, constr, disjunction_cxt);
+  else if (TREE_CODE (constr) == CHECK_CONSTR)
+    /* This is the rare concept alias case. */
+    return learn_implication (parent, constr, equivalence_cxt);
+}
+
+/*---------------------------------------------------------------------------
+                       Expansion of concept definitions
+---------------------------------------------------------------------------*/
+
+/* Returns the expression of a function concept. */
+
 tree
-lift_function_definition (tree fn, tree args)
+get_returned_expression (tree fn)
 {
   /* Extract the body of the function minus the return expression.  */
   tree body = DECL_SAVED_TREE (fn);
@@ -364,202 +489,107 @@
   if (TREE_CODE (body) != RETURN_EXPR)
     return error_mark_node;
 
-  body = TREE_OPERAND (body, 0);
-
-  /* Substitute template arguments to produce our inline expression.  */
-  tree result = tsubst_expr (body, args, tf_none, NULL_TREE, false);
-  if (result == error_mark_node)
-    return error_mark_node;
-
-  return lift_expression (result);
+  return TREE_OPERAND (body, 0);
 }
 
-/* Inline a reference to a function concept.  */
-tree
-lift_call_expression (tree t)
-{
-  /* Try to resolve this function call as a concept.  If not, then
-     it can be returned as-is.  */
-  tree check = resolve_constraint_check (t);
-  if (!check)
-    return lift_function_call (t);
-  if (check == error_mark_node)
-    return error_mark_node;
-
-  tree fn = TREE_VALUE (check);
-  tree args = TREE_PURPOSE (check);
-  return lift_function_definition (fn, args);
-}
+/* Returns the initializer of a variable concept. */
 
 tree
-lift_variable_initializer (tree var, tree args)
+get_variable_initializer (tree var)
 {
-  /* Extract the body from the variable initializer.  */
   tree init = DECL_INITIAL (var);
   if (!init)
     return error_mark_node;
+  return init;
+}
 
-  /* Substitute the arguments to form our new inline expression.  */
-  tree result = tsubst_expr (init, args, tf_none, NULL_TREE, false);
-  if (result == error_mark_node)
-    return error_mark_node;
+/* Returns the definition of a variable or function concept.  */
 
-  return lift_expression (result);
+tree
+get_concept_definition (tree decl)
+{
+  if (TREE_CODE (decl) == VAR_DECL)
+    return get_variable_initializer (decl);
+  else if (TREE_CODE (decl) == FUNCTION_DECL)
+    return get_returned_expression (decl);
+  gcc_unreachable ();
 }
 
-/* Determine if a template-id is a variable concept and inline.  */
+int expansion_level = 0;
 
-tree
-lift_template_id (tree t)
+struct expanding_concept_sentinel
 {
-  if (tree info = resolve_variable_concept_check (t))
-    {
-      tree decl = TREE_VALUE (info);
-      tree args = TREE_PURPOSE (info);
-      return lift_variable_initializer (decl, args);
-    }
+  expanding_concept_sentinel ()
+  {
+    ++expansion_level;
+  }
 
-  /* Check that we didn't refer to a function concept like
-      a variable.
+  ~expanding_concept_sentinel()
+  {
+    --expansion_level;
+  }
+};
 
-     TODO: Add a note on how to fix this.  */
-  tree tmpl = TREE_OPERAND (t, 0);
-  if (TREE_CODE (tmpl) == OVERLOAD)
-    {
-      tree fn = OVL_FUNCTION (tmpl);
-      if (TREE_CODE (fn) == TEMPLATE_DECL
-          && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))
-        {
-          error_at (location_of (t),
-		    "invalid reference to function concept %qD", fn);
-          return error_mark_node;
-        }
-    }
 
-  return t;
-}
+} /* namespace */
 
-/* Lift any constraints appearing in a nested requirement of
-   a requires-expression. */
-tree
-lift_requires_expression (tree t)
+/* Returns true when a concept is being expanded.  */
+
+bool
+expanding_concept()
 {
-  tree parms = TREE_OPERAND (t, 0);
-  tree reqs = TREE_OPERAND (t, 1);
-  tree result = NULL_TREE;
-  for (; reqs != NULL_TREE; reqs = TREE_CHAIN (reqs))
-    {
-      tree req = TREE_VALUE (reqs);
-      if (TREE_CODE (req) == NESTED_REQ)
-        {
-          tree expr = lift_expression (TREE_OPERAND (req, 0));
-          req = finish_nested_requirement (expr);
-        }
-      result = tree_cons (NULL_TREE, req, result);
-    }
-  return finish_requires_expr (parms, result);
+  return expansion_level > 0;
 }
 
-/* Inline references to specializations of concepts.  */
+/* Expand a concept declaration (not a template) and its arguments to
+   a constraint defined by the concept's initializer or definition.  */
+
 tree
-lift_expression (tree t)
+expand_concept (tree decl, tree args)
 {
-  if (t == NULL_TREE)
-    return NULL_TREE;
+  expanding_concept_sentinel sentinel;
 
-  if (t == error_mark_node)
-    return error_mark_node;
-
-  /* Concepts can be referred to by call or variable. All other
-     nodes are preserved.  */
-  switch (TREE_CODE (t))
-    {
-    case CALL_EXPR:
-      return lift_call_expression (t);
+  if (TREE_CODE (decl) == TEMPLATE_DECL)
+    decl = DECL_TEMPLATE_RESULT (decl);
+  tree tmpl = DECL_TI_TEMPLATE (decl);
 
-    case TEMPLATE_ID_EXPR:
-      return lift_template_id (t);
+  /* Check for a previous specialization. */
+  if (tree spec = get_concept_expansion (tmpl, args))
+    return spec;
 
-    case REQUIRES_EXPR:
-      return lift_requires_expression (t);
+  /* Substitute the arguments to form a new definition expression.  */
+  tree def = get_concept_definition (decl);
 
-    case EXPR_PACK_EXPANSION:
-      /* Use copy_node rather than make_pack_expansion so that
-	 PACK_EXPANSION_PARAMETER_PACKS stays the same.  */
-      t = copy_node (t);
-      SET_PACK_EXPANSION_PATTERN
-	(t, lift_expression (PACK_EXPANSION_PATTERN (t)));
-      return t;
-
-    case TREE_LIST:
-      {
-        t = copy_node (t);
-        TREE_VALUE (t) = lift_expression (TREE_VALUE (t));
-        TREE_CHAIN (t) = lift_expression (TREE_CHAIN (t));
-        return t;
-      }
+  ++processing_template_decl;
+  tree result = tsubst_expr (def, args, tf_none, NULL_TREE, true);
+  --processing_template_decl;
+  if (result == error_mark_node)
+    return error_mark_node;
 
-    default:
-      return lift_operands (t);
-    }
+  /* And lastly, normalize it, check for implications, and save
+     the specialization for later.  */
+  tree norm = normalize_expression (result);
+  learn_implications (tmpl, args, norm);
+  return save_concept_expansion (tmpl, args, norm);
 }
 
-/*---------------------------------------------------------------------------
-                Transformation of expressions into constraints
----------------------------------------------------------------------------*/
-
-/* Part of constraint normalization. The following functions rewrite
-   expressions as constraints.  */
-
-tree transform_expression (tree);
 
-/* Check that the logical-or or logical-and expression does
-   not result in a call to a user-defined user-defined operator
-   (temp.constr.op). Returns true if the logical operator is
-   admissible and false otherwise. */
-
-bool
-check_logical_expr (tree t)
-{
-  /* We can't do much for type dependent expressions. */
-  if (type_dependent_expression_p (t))
-    return true;
+/*---------------------------------------------------------------------------
+                Stepwise normalization of expressions
 
-  /* Resolve the logical operator. Note that template processing is
-     disabled so we get the actual call or target expression back.
-     not_processing_template_sentinel sentinel.
-
-     TODO: This check is actually subsumed by the requirement that
-     constraint operands have type bool. I'm not sure we need it
-     unless we allow conversions.  */
-  tree arg1 = TREE_OPERAND (t, 0);
-  tree arg2 = TREE_OPERAND (t, 1);
-  tree ovl = NULL_TREE;
-  tree expr = build_x_binary_op (EXPR_LOC_OR_LOC (arg2, input_location),
-                                 TREE_CODE (t),
-                                 arg1, TREE_CODE (arg1),
-                                 arg2, TREE_CODE (arg2),
-                                 &ovl,
-                                 tf_none);
-  if (TREE_CODE (expr) != TREE_CODE (t))
-    {
-      error ("user-defined operator %qs in constraint %q+E",
-	     operator_name_info[TREE_CODE (t)].name, t);
-      return false;
-    }
-  return true;
-}
+This set of functions will transform an expression into a constraint
+in a sequence of steps. Normalization does not not look into concept
+definitions.
+---------------------------------------------------------------------------*/
 
 /* Transform a logical-or or logical-and expression into either
    a conjunction or disjunction. */
 
 tree
-xform_logical (tree t, tree_code c)
+normalize_logical_operation (tree t, tree_code c)
 {
-  if (!check_logical_expr (t))
-    return error_mark_node;
-  tree t0 = transform_expression (TREE_OPERAND (t, 0));
-  tree t1 = transform_expression (TREE_OPERAND (t, 1));
+  tree t0 = normalize_expression (TREE_OPERAND (t, 0));
+  tree t1 = normalize_expression (TREE_OPERAND (t, 1));
   return build_nt (c, t0, t1);
 }
 
@@ -567,7 +597,7 @@
    for its expression. */
 
 inline tree
-xform_simple_requirement (tree t)
+normalize_simple_requirement (tree t)
 {
   return build_nt (EXPR_CONSTR, TREE_OPERAND (t, 0));
 }
@@ -575,7 +605,7 @@
 /* A type requirement T introduce a type constraint for its type.  */
 
 inline tree
-xform_type_requirement (tree t)
+normalize_type_requirement (tree t)
 {
   return build_nt (TYPE_CONSTR, TREE_OPERAND (t, 0));
 }
@@ -589,7 +619,7 @@
    includes an exception constraint.  */
 
 tree
-xform_compound_requirement (tree t)
+normalize_compound_requirement (tree t)
 {
   tree expr = TREE_OPERAND (t, 0);
   tree constr = build_nt (EXPR_CONSTR, TREE_OPERAND (t, 0));
@@ -627,29 +657,29 @@
    will guarantee that the constraint is never satisfied.  */
 
 inline tree
-xform_nested_requirement (tree t)
+normalize_nested_requirement (tree t)
 {
-  return transform_expression (TREE_OPERAND (t, 0));
+  return normalize_expression (TREE_OPERAND (t, 0));
 }
 
 /* Transform a requirement T into one or more constraints.  */
 
 tree
-xform_requirement (tree t)
+normalize_requirement (tree t)
 {
   switch (TREE_CODE (t))
     {
     case SIMPLE_REQ:
-      return xform_simple_requirement (t);
+      return normalize_simple_requirement (t);
 
     case TYPE_REQ:
-      return xform_type_requirement (t);
+      return normalize_type_requirement (t);
 
     case COMPOUND_REQ:
-      return xform_compound_requirement (t);
+      return normalize_compound_requirement (t);
 
     case NESTED_REQ:
-      return xform_nested_requirement (t);
+      return normalize_nested_requirement (t);
 
     default:
       gcc_unreachable ();
@@ -661,46 +691,165 @@
    constraints. */
 
 tree
-xform_requirements (tree t)
+normalize_requirements (tree t)
 {
   tree result = NULL_TREE;
   for (; t; t = TREE_CHAIN (t))
     {
-      tree constr = xform_requirement (TREE_VALUE (t));
+      tree constr = normalize_requirement (TREE_VALUE (t));
       result = conjoin_constraints (result, constr);
     }
   return result;
 }
 
-/* Transform a requires-expression into a parameterized constraint.  */
+/* The normal form of a requires-expression is a parameterized
+   constraint having the same parameters and a conjunction of
+   constraints representing the normal form of requirements.  */
 
 tree
-xform_requires_expr (tree t)
+normalize_requires_expression (tree t)
 {
-  tree operand = xform_requirements (TREE_OPERAND (t, 1));
+  tree operand = normalize_requirements (TREE_OPERAND (t, 1));
   if (tree parms = TREE_OPERAND (t, 0))
     return build_nt (PARM_CONSTR, parms, operand);
   else
     return operand;
 }
 
-/* Transform an expression into an atomic predicate constraint.
-   After substitution, the expression of a predicate constraint
-   shall have type bool (temp.constr.pred).  For non-type-dependent
-   expressions, we can check that now.  */
+/* For a template-id referring to a variable concept, returns
+   a check constraint. Otherwise, returns a predicate constraint. */
 
 tree
-xform_atomic (tree t)
+normalize_template_id_expression (tree t)
 {
-  if (TREE_TYPE (t) && !type_dependent_expression_p (t))
-  {
-    tree type = cv_unqualified (TREE_TYPE (t));
-    if (!same_type_p (type, boolean_type_node))
-      {
-        error ("predicate constraint %q+E does not have type %<bool%>", t);
+  if (tree info = resolve_variable_concept_check (t))
+    {
+      if (info == error_mark_node)
+        {
+          /* We get this when the template arguments don't match
+             the variable concept. */
+          error ("invalid reference to concept %qE", t);
+          return error_mark_node;
+        }
+
+      tree decl = TREE_VALUE (info);
+      tree args = TREE_PURPOSE (info);
+      return build_nt (CHECK_CONSTR, decl, args);
+    }
+
+  /* Check that we didn't refer to a function concept like a variable.  */
+  tree tmpl = TREE_OPERAND (t, 0);
+  if (TREE_CODE (tmpl) == OVERLOAD)
+    {
+      tree fn = OVL_FUNCTION (tmpl);
+      if (TREE_CODE (fn) == TEMPLATE_DECL
+          && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))
+        {
+          error_at (location_of (t),
+                    "invalid reference to function concept %qD", fn);
+          return error_mark_node;
+        }
+    }
+
+  return build_nt (PRED_CONSTR, t);
+}
+
+/* For a call expression to a function concept, returns a check
+   constraint. Otherwise, returns a predicate constraint. */
+
+tree
+normalize_call_expression (tree t)
+{
+  /* Try to resolve this function call as a concept.  If not, then
+     it can be returned as a predicate constraint.  */
+  tree check = resolve_constraint_check (t);
+  if (!check)
+    return build_nt (PRED_CONSTR, t);
+  if (check == error_mark_node)
+    {
+      /* TODO: Improve diagnostics. We could report why the reference
+         is invalid. */
+      error ("invalid reference to concept %qE", t);
+      return error_mark_node;
+    }
+
+  tree fn = TREE_VALUE (check);
+  tree args = TREE_PURPOSE (check);
+  return build_nt (CHECK_CONSTR, fn, args);
+}
+
+/* If T is a call to an overloaded && or || operator, diagnose that
+   as a non-SFINAEable error.  Returns true if an error is emitted.
+
+   TODO: It would be better to diagnose this at the point of definition,
+   if possible. Perhaps we should immediately do a first-pass normalization
+   of a concept definition to catch obvious non-dependent errors like
+   this.  */
+
+bool
+check_for_logical_overloads (tree t)
+{
+  if (TREE_CODE (t) != CALL_EXPR)
+    return false;
+
+  tree fn = CALL_EXPR_FN (t);
+
+  /* For member calls, try extracting the function from the
+     component ref.  */
+  if (TREE_CODE (fn) == COMPONENT_REF)
+    {
+      fn = TREE_OPERAND (fn, 1);
+      if (TREE_CODE (fn) == BASELINK)
+        fn = BASELINK_FUNCTIONS (fn);
+    }
+
+  if (TREE_CODE (fn) != FUNCTION_DECL)
+    return false;
+
+  if (DECL_OVERLOADED_OPERATOR_P (fn))
+    {
+      location_t loc = EXPR_LOC_OR_LOC (t, input_location);
+      error_at (loc, "constraint %qE, uses overloaded operator", t);
+      return true;
+    }
+
+  return false;
+}
+
+/* The normal form of an atom depends on the expression. The normal
+   form of a function call to a function concept is a check constraint
+   for that concept. The normal form of a reference to a variable
+   concept is a check constraint for that concept. Otherwise, the
+   constraint is a predicate constraint.  */
+
+tree
+normalize_atom (tree t)
+{
+  /* We can get constraints pushed down through pack expansions, so
+     just return them. */
+  if (constraint_p (t))
+    return t;
+
+  tree type = TREE_TYPE (t);
+  if (!type || type_unknown_p (t) || TREE_CODE (type) == TEMPLATE_TYPE_PARM)
+    ;
+  else if (!dependent_type_p (type))
+    {
+      if (check_for_logical_overloads (t))
         return error_mark_node;
-      }
-  }
+
+      type = cv_unqualified (type);
+      if (!same_type_p (type, boolean_type_node))
+	{
+	  error ("predicate constraint %q+E does not have type %<bool%>", t);
+	  return error_mark_node;
+	}
+    }
+
+  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)
+    return normalize_template_id_expression (t);
+  if (TREE_CODE (t) == CALL_EXPR)
+    return normalize_call_expression (t);
   return build_nt (PRED_CONSTR, t);
 }
 
@@ -735,49 +884,48 @@
    leaves of the constraint so that partial ordering will work.  */
 
 tree
-xform_pack_expansion (tree t)
+normalize_pack_expansion (tree t)
 {
-  tree pat = transform_expression (PACK_EXPANSION_PATTERN (t));
+  tree pat = normalize_expression (PACK_EXPANSION_PATTERN (t));
   return push_down_pack_expansion (t, pat);
 }
 
 /* Transform an expression into a constraint.  */
 
 tree
-xform_expr (tree t)
+normalize_any_expression (tree t)
 {
   switch (TREE_CODE (t))
     {
     case TRUTH_ANDIF_EXPR:
-      return xform_logical (t, CONJ_CONSTR);
+      return normalize_logical_operation (t, CONJ_CONSTR);
 
     case TRUTH_ORIF_EXPR:
-      return xform_logical (t, DISJ_CONSTR);
+      return normalize_logical_operation (t, DISJ_CONSTR);
 
     case REQUIRES_EXPR:
-      return xform_requires_expr (t);
+      return normalize_requires_expression (t);
 
     case BIND_EXPR:
-      return transform_expression (BIND_EXPR_BODY (t));
+      return normalize_expression (BIND_EXPR_BODY (t));
 
     case EXPR_PACK_EXPANSION:
-      return xform_pack_expansion (t);
+      return normalize_pack_expansion (t);
 
     default:
       /* All other constraints are atomic. */
-      return xform_atomic (t);
+      return normalize_atom (t);
     }
 }
 
 /* Transform a statement into an expression.  */
-
 tree
-xform_stmt (tree t)
+normalize_any_statement (tree t)
 {
   switch (TREE_CODE (t))
     {
     case RETURN_EXPR:
-      return transform_expression (TREE_OPERAND (t, 0));
+      return normalize_expression (TREE_OPERAND (t, 0));
     default:
       gcc_unreachable ();
     }
@@ -787,24 +935,22 @@
 /* Reduction rules for the declaration T.  */
 
 tree
-xform_decl (tree t)
+normalize_any_declaration (tree t)
 {
   switch (TREE_CODE (t))
     {
     case VAR_DECL:
-      return xform_atomic (t);
+      return normalize_atom (t);
     default:
       gcc_unreachable ();
     }
   return error_mark_node;
 }
 
-/* Transform a lifted expression into a constraint. This either
-   returns a constraint, or it returns error_mark_node when
-   a constraint cannot be formed.  */
+/* Returns the normal form of a constraint expression. */
 
 tree
-transform_expression (tree t)
+normalize_expression (tree t)
 {
   if (!t)
     return NULL_TREE;
@@ -818,20 +964,20 @@
     case tcc_binary:
     case tcc_expression:
     case tcc_vl_exp:
-      return xform_expr (t);
+      return normalize_any_expression (t);
 
     case tcc_statement:
-      return xform_stmt (t);
+      return normalize_any_statement (t);
 
     case tcc_declaration:
-      return xform_decl (t);
+      return normalize_any_declaration (t);
 
     case tcc_exceptional:
     case tcc_constant:
     case tcc_reference:
     case tcc_comparison:
       /* These are all atomic predicate constraints. */
-      return xform_atomic (t);
+      return normalize_atom (t);
 
     default:
       /* Unhandled node kind. */
@@ -840,6 +986,7 @@
   return error_mark_node;
 }
 
+
 /*---------------------------------------------------------------------------
                         Constraint normalization
 ---------------------------------------------------------------------------*/
@@ -879,8 +1026,7 @@
 {
   ++processing_template_decl;
   tree expr = PRED_CONSTR_EXPR (t);
-  tree lifted = lift_expression (expr);
-  tree constr = transform_expression (lifted);
+  tree constr = normalize_expression (expr);
   --processing_template_decl;
   return constr;
 }
@@ -938,7 +1084,6 @@
   return error_mark_node;
 }
 
-} /* namespace */
 
 
 // -------------------------------------------------------------------------- //
@@ -1028,61 +1173,11 @@
   ci->declarator_reqs = decl_reqs;
   ci->associated_constr = conjoin_constraints (tmpl_reqs, decl_reqs);
 
-  ++processing_template_decl;
-  ci->normalized_constr = normalize_constraint (ci->associated_constr);
-  --processing_template_decl;
-
-  ci->assumptions = decompose_assumptions (ci->normalized_constr);
   return (tree)ci;
 }
 
 namespace {
 
-/* Returns true if any of the arguments in the template
-   argument list is a wildcard or wildcard pack. */
-bool
-contains_wildcard_p (tree args)
-{
-  for (int i = 0; i < TREE_VEC_LENGTH (args); ++i)
-    {
-      tree arg = TREE_VEC_ELT (args, i);
-      if (TREE_CODE (arg) == WILDCARD_DECL)
-	return true;
-    }
-  return false;
-}
-
-/* Build a new call expression, but don't actually generate
-   a new function call. We just want the tree, not the
-   semantics. */
-inline tree
-build_call_check (tree id)
-{
-  ++processing_template_decl;
-  vec<tree, va_gc> *fargs = make_tree_vector();
-  tree call = finish_call_expr (id, &fargs, false, false, tf_none);
-  release_tree_vector (fargs);
-  --processing_template_decl;
-  return call;
-}
-
-/* Build an expression that will check a variable concept. If any
-   argument contains a wildcard, don't try to finish the variable
-   template because we can't substitute into a non-existent
-   declaration.  */
-tree
-build_variable_check (tree id)
-{
-  gcc_assert (TREE_CODE (id) == TEMPLATE_ID_EXPR);
-  if (contains_wildcard_p (TREE_OPERAND (id, 1)))
-    return id;
-
-  ++processing_template_decl;
-  tree var = finish_template_variable (id);
-  --processing_template_decl;
-  return var;
-}
-
 /* Construct a sequence of template arguments by prepending
    ARG to REST. Either ARG or REST may be null. */
 tree
@@ -1158,7 +1253,9 @@
 
    Note that the constraints are neither reduced nor decomposed.
    That is done only after the requires clause has been parsed
-   (or not). */
+   (or not).
+
+   This will always return a CHECK_CONSTR. */
 tree
 finish_shorthand_constraint (tree decl, tree constr)
 {
@@ -1207,7 +1304,7 @@
       TREE_TYPE (check) = boolean_type_node;
     }
 
-  return make_predicate_constraint (check);
+  return normalize_expression (check);
 }
 
 /* Returns a conjunction of shorthand requirements for the template
@@ -1346,7 +1443,7 @@
 
   /* Associate the constraint. */
   tree check = build_concept_check (tmpl_decl, NULL_TREE, check_args);
-  tree constr = make_predicate_constraint (check);
+  tree constr = normalize_expression (check);
   TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = constr;
 
   return parm_list;
@@ -1362,41 +1459,28 @@
 {
   if (TREE_CODE (t) == TYPE_DECL)
     {
-      /* A constrained parameter.  */
-      tmpl = DECL_TI_TEMPLATE (CONSTRAINED_PARM_CONCEPT (t));
-      args = CONSTRAINED_PARM_EXTRA_ARGS (t);
+      /* A constrained parameter.  Build a constraint check
+         based on the prototype parameter and then extract the
+         arguments from that.  */
+      tree proto = CONSTRAINED_PARM_PROTOTYPE (t);
+      tree check = finish_shorthand_constraint (proto, t);
+      placeholder_extract_concept_and_args (check, tmpl, args);
       return;
     }
 
-  gcc_assert (TREE_CODE (t) == PRED_CONSTR);
-  t = PRED_CONSTR_EXPR (t);
-  gcc_assert (TREE_CODE (t) == CALL_EXPR
-              || TREE_CODE (t) == TEMPLATE_ID_EXPR
-              || VAR_P (t));
-
-  if (TREE_CODE (t) == CALL_EXPR)
-    t = CALL_EXPR_FN (t);
-  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)
+  if (TREE_CODE (t) == CHECK_CONSTR)
     {
-      tmpl = TREE_OPERAND (t, 0);
-      if (TREE_CODE (tmpl) == OVERLOAD)
-	{
-	  gcc_assert (OVL_CHAIN (tmpl) == NULL_TREE);
-	  tmpl = OVL_FUNCTION (tmpl);
-	}
-      args = TREE_OPERAND (t, 1);
-    }
-  else if (DECL_P (t))
-    {
-      tmpl = DECL_TI_TEMPLATE (t);
-      args = DECL_TI_ARGS (t);
+      tree decl = CHECK_CONSTR_CONCEPT (t);
+      tmpl = DECL_TI_TEMPLATE (decl);
+      args = CHECK_CONSTR_ARGS (t);
+      return;
     }
-  else
+
     gcc_unreachable ();
 }
 
 /* Returns true iff the placeholders C1 and C2 are equivalent.  C1
-   and C2 can be either PRED_CONSTR_EXPR or TEMPLATE_TYPE_PARM.  */
+   and C2 can be either CHECK_CONSTR or TEMPLATE_TYPE_PARM.  */
 
 bool
 equivalent_placeholder_constraints (tree c1, tree c2)
@@ -1411,6 +1495,11 @@
     return true;
   if (!c1 || !c2)
     return false;
+  if (c1 == error_mark_node || c2 == error_mark_node)
+    /* We get here during satisfaction; when a deduction constraint
+       fails, substitution can produce an error_mark_node for the
+       placeholder constraints.  */
+    return false;
 
   tree t1, t2, a1, a2;
   placeholder_extract_concept_and_args (c1, t1, a1);
@@ -1419,21 +1508,20 @@
   if (t1 != t2)
     return false;
 
-  /* Skip the first argument to avoid infinite recursion on the
-     placeholder auto itself.  */
-  bool skip1 = (TREE_CODE (c1) == PRED_CONSTR);
-  bool skip2 = (TREE_CODE (c2) == PRED_CONSTR);
-
-  int len1 = (a1 ? TREE_VEC_LENGTH (a1) : 0) - skip1;
-  int len2 = (a2 ? TREE_VEC_LENGTH (a2) : 0) - skip2;
-
+  int len1 = TREE_VEC_LENGTH (a1);
+  int len2 = TREE_VEC_LENGTH (a2);
   if (len1 != len2)
     return false;
 
-  for (int i = 0; i < len1; ++i)
-    if (!cp_tree_equal (TREE_VEC_ELT (a1, i + skip1),
-			TREE_VEC_ELT (a2, i + skip2)))
+  /* Skip the first argument so we don't infinitely recurse.
+     Also, they may differ in template parameter index.  */
+  for (int i = 1; i < len1; ++i)
+    {
+      tree t1 = TREE_VEC_ELT (a1, i);
+      tree t2 = TREE_VEC_ELT (a2, i);
+      if (!template_args_equal (t1, t2))
       return false;
+    }
   return true;
 }
 
@@ -1492,40 +1580,139 @@
   return build_nt (PRED_CONSTR, result);
 }
 
+/* Substitute into a check constraint. */
+
+tree
+tsubst_check_constraint (tree t, tree args,
+                         tsubst_flags_t complain, tree in_decl)
+{
+  tree decl = CHECK_CONSTR_CONCEPT (t);
+  tree tmpl = DECL_TI_TEMPLATE (decl);
+  tree targs = CHECK_CONSTR_ARGS (t);
+
+  /* Substitute through by building an template-id expression
+     and then substituting into that. */
+  tree expr = build_nt(TEMPLATE_ID_EXPR, tmpl, targs);
+  ++processing_template_decl;
+  tree result = tsubst_expr (expr, args, complain, in_decl, false);
+  --processing_template_decl;
+
+  if (result == error_mark_node)
+    return error_mark_node;
+
+  /* Extract the results and rebuild the check constraint. */
+  decl = DECL_TEMPLATE_RESULT (TREE_OPERAND (result, 0));
+  args = TREE_OPERAND (result, 1);
+
+  return build_nt (CHECK_CONSTR, decl, args);
+}
+
 /* Substitute into the conjunction of constraints. Returns
    error_mark_node if substitution into either operand fails. */
+
 tree
-tsubst_conjunction (tree t, tree args,
-                    tsubst_flags_t complain, tree in_decl)
+tsubst_logical_operator (tree t, tree args,
+			 tsubst_flags_t complain, tree in_decl)
 {
   tree t0 = TREE_OPERAND (t, 0);
   tree r0 = tsubst_constraint (t0, args, complain, in_decl);
+  if (r0 == error_mark_node)
+    return error_mark_node;
   tree t1 = TREE_OPERAND (t, 1);
   tree r1 = tsubst_constraint (t1, args, complain, in_decl);
-  return build_nt (CONJ_CONSTR, r0, r1);
+  if (r1 == error_mark_node)
+    return error_mark_node;
+  return build_nt (TREE_CODE (t), r0, r1);
+}
+
+namespace {
+
+/* Substitute ARGS into the expression constraint T.  */
+
+tree
+tsubst_expr_constr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+{
+  cp_unevaluated guard;
+  tree expr = EXPR_CONSTR_EXPR (t);
+  tree ret = tsubst_expr (expr, args, complain, in_decl, false);
+  if (ret == error_mark_node)
+    return error_mark_node;
+  return build_nt (EXPR_CONSTR, ret);
+}
+
+/* Substitute ARGS into the type constraint T.  */
+
+tree
+tsubst_type_constr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+{
+  tree type = TYPE_CONSTR_TYPE (t);
+  tree ret = tsubst (type, args, complain, in_decl);
+  if (ret == error_mark_node)
+    return error_mark_node;
+  return build_nt (TYPE_CONSTR, ret);
+}
+
+/* Substitute ARGS into the implicit conversion constraint T.  */
+
+tree
+tsubst_implicit_conversion_constr (tree t, tree args, tsubst_flags_t complain,
+                                   tree in_decl)
+{
+  cp_unevaluated guard;
+  tree expr = ICONV_CONSTR_EXPR (t);
+  tree type = ICONV_CONSTR_TYPE (t);
+  tree new_expr = tsubst_expr (expr, args, complain, in_decl, false);
+  if (new_expr == error_mark_node)
+    return error_mark_node;
+  tree new_type = tsubst (type, args, complain, in_decl);
+  if (new_type == error_mark_node)
+    return error_mark_node;
+  return build_nt (ICONV_CONSTR, new_expr, new_type);
 }
 
-/* Substitute ARGS into the constraint T. */
+/* Substitute ARGS into the argument deduction constraint T.  */
+
 tree
-tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+tsubst_argument_deduction_constr (tree t, tree args, tsubst_flags_t complain,
+                                  tree in_decl)
 {
-  if (t == NULL_TREE)
-    return t;
-  if (TREE_CODE (t) == CONJ_CONSTR)
-    return tsubst_conjunction (t, args, complain, in_decl);
-  else if (TREE_CODE (t) == PRED_CONSTR)
-    return tsubst_predicate_constraint (t, args, complain, in_decl);
-  else
-    gcc_unreachable ();
-  return error_mark_node;
+  cp_unevaluated guard;
+  tree expr = DEDUCT_CONSTR_EXPR (t);
+  tree pattern = DEDUCT_CONSTR_PATTERN (t);
+  tree autos = DEDUCT_CONSTR_PLACEHOLDER(t);
+  tree new_expr = tsubst_expr (expr, args, complain, in_decl, false);
+  if (new_expr == error_mark_node)
+    return error_mark_node;
+  /* It seems like substituting through the pattern will not affect the
+     placeholders.  We should (?) be able to reuse the existing list
+     without any problems.  If not, then we probably want to create a
+     new list of placeholders and then instantiate the pattern using
+     those.  */
+  tree new_pattern = tsubst (pattern, args, complain, in_decl);
+  if (new_pattern == error_mark_node)
+    return error_mark_node;
+  return build_nt (DEDUCT_CONSTR, new_expr, new_pattern, autos);
 }
 
-namespace {
+/* Substitute ARGS into the exception constraint T.  */
+
+tree
+tsubst_exception_constr (tree t, tree args, tsubst_flags_t complain,
+			 tree in_decl)
+{
+  cp_unevaluated guard;
+  tree expr = EXCEPT_CONSTR_EXPR (t);
+  tree ret = tsubst_expr (expr, args, complain, in_decl, false);
+  if (ret == error_mark_node)
+    return error_mark_node;
+  return build_nt (EXCEPT_CONSTR, ret);
+}
 
 /* A subroutine of tsubst_constraint_variables. Register local
    specializations for each of parameter in PARMS and its
    corresponding substituted constraint variable in VARS.
    Returns VARS. */
+
 tree
 declare_constraint_vars (tree parms, tree vars)
 {
@@ -1553,6 +1740,7 @@
    Note that the caller must establish a local specialization stack
    prior to calling this function since this substitution will
    declare the substituted parameters. */
+
 tree
 tsubst_constraint_variables (tree t, tree args,
                              tsubst_flags_t complain, tree in_decl)
@@ -1568,10 +1756,29 @@
   return declare_constraint_vars (t, vars);
 }
 
+/* Substitute ARGS into the parameterized constraint T.  */
+
+tree
+tsubst_parameterized_constraint (tree t, tree args,
+				 tsubst_flags_t complain, tree in_decl)
+{
+  local_specialization_stack stack;
+  tree vars = tsubst_constraint_variables (PARM_CONSTR_PARMS (t),
+					   args, complain, in_decl);
+  if (vars == error_mark_node)
+    return error_mark_node;
+  tree expr = tsubst_constraint (PARM_CONSTR_OPERAND (t), args,
+				 complain, in_decl);
+  if (expr == error_mark_node)
+    return error_mark_node;
+  return build_nt (PARM_CONSTR, vars, expr);
+}
+
 /* Substitute ARGS into the simple requirement T. Note that
    substitution may result in an ill-formed expression without
    causing the program to be ill-formed. In such cases, the
    requirement wraps an error_mark_node. */
+
 inline tree
 tsubst_simple_requirement (tree t, tree args,
                            tsubst_flags_t complain, tree in_decl)
@@ -1627,6 +1834,8 @@
   return finish_nested_requirement (expr);
 }
 
+/* Substitute ARGS into the requirement T.  */
+
 inline tree
 tsubst_requirement (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 {
@@ -1662,7 +1871,8 @@
       r = tree_cons (NULL_TREE, e, r);
       t = TREE_CHAIN (t);
     }
-  return r;
+  /* Ensure that the order of constraints is the same as the original.  */
+  return nreverse (r);
 }
 
 } /* namespace */
@@ -1696,6 +1906,7 @@
 
 /* Substitute ARGS into the constraint information CI, producing a new
    constraint record. */
+
 tree
 tsubst_constraint_info (tree t, tree args,
                         tsubst_flags_t complain, tree in_decl)
@@ -1714,6 +1925,39 @@
   return build_constraints (tmpl_constr, decl_constr);
 }
 
+/* Substitute ARGS into the constraint T. */
+
+tree
+tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+{
+  if (t == NULL_TREE)
+    return t;
+  switch (TREE_CODE (t))
+  {
+  case PRED_CONSTR:
+    return tsubst_predicate_constraint (t, args, complain, in_decl);
+  case CHECK_CONSTR:
+    return tsubst_check_constraint (t, args, complain, in_decl);
+  case CONJ_CONSTR:
+  case DISJ_CONSTR:
+    return tsubst_logical_operator (t, args, complain, in_decl);
+  case PARM_CONSTR:
+    return tsubst_parameterized_constraint (t, args, complain, in_decl);
+  case EXPR_CONSTR:
+    return tsubst_expr_constr (t, args, complain, in_decl);
+  case TYPE_CONSTR:
+    return tsubst_type_constr (t, args, complain, in_decl);
+  case ICONV_CONSTR:
+    return tsubst_implicit_conversion_constr (t, args, complain, in_decl);
+  case DEDUCT_CONSTR:
+    return tsubst_argument_deduction_constr (t, args, complain, in_decl);
+  case EXCEPT_CONSTR:
+    return tsubst_exception_constr (t, args, complain, in_decl);
+  default:
+    gcc_unreachable ();
+  }
+  return error_mark_node;
+}
 
 /*---------------------------------------------------------------------------
                         Constraint satisfaction
@@ -1738,11 +1982,14 @@
      gen_elem_of_pack_expansion_instantiation will check that each element of
      the expansion is satisfied.  */
   tree exprs = tsubst_pack_expansion (t, args, complain, in_decl);
+
   if (exprs == error_mark_node)
     return boolean_false_node;
-  int n = TREE_VEC_LENGTH (exprs);
 
-  for (int i = 0; i < n; ++i)
+  /* TODO: It might be better to normalize each expanded term
+     and evaluate them separately. That would provide better
+     opportunities for diagnostics.  */
+  for (int i = 0; i < TREE_VEC_LENGTH (exprs); ++i)
     if (TREE_VEC_ELT (exprs, i) != boolean_true_node)
       return boolean_false_node;
   return boolean_true_node;
@@ -1760,12 +2007,14 @@
 satisfy_predicate_constraint (tree t, tree args,
                               tsubst_flags_t complain, tree in_decl)
 {
-  tree original = TREE_OPERAND (t, 0);
+  tree expr = TREE_OPERAND (t, 0);
 
   /* We should never have a naked pack expansion in a predicate constraint.  */
-  gcc_assert (TREE_CODE (original) != EXPR_PACK_EXPANSION);
+  gcc_assert (TREE_CODE (expr) != EXPR_PACK_EXPANSION);
 
-  tree expr = tsubst_expr (original, args, complain, in_decl, false);
+  /* If substitution into the expression fails, the constraint
+     is not satisfied.  */
+  expr = tsubst_expr (expr, args, complain, in_decl, false);
   if (expr == error_mark_node)
     return boolean_false_node;
 
@@ -1781,8 +2030,37 @@
       return boolean_false_node;
     }
 
-  tree value = cxx_constant_value (expr);
-  return value;
+  return cxx_constant_value (expr);
+}
+
+/* A concept check constraint like C<CARGS> is satisfied if substituting ARGS
+   into CARGS succeeds and C is satisfied for the resulting arguments.  */
+
+tree
+satisfy_check_constraint (tree t, tree args,
+                          tsubst_flags_t complain, tree in_decl)
+{
+  tree decl = CHECK_CONSTR_CONCEPT (t);
+  tree tmpl = DECL_TI_TEMPLATE (decl);
+  tree cargs = CHECK_CONSTR_ARGS (t);
+
+  /* Instantiate the concept check arguments.  */
+  tree targs = tsubst (cargs, args, tf_none, NULL_TREE);
+  if (targs == error_mark_node)
+    return boolean_false_node;
+
+  /* Search for a previous value.  */
+  if (tree prev = lookup_concept_satisfaction (tmpl, targs))
+    return prev;
+
+  /* Expand the concept; failure here implies non-satisfaction.  */
+  tree def = expand_concept (decl, targs);
+  if (def == error_mark_node)
+    return memoize_concept_satisfaction (tmpl, args, boolean_false_node);
+
+  /* Recursively satisfy the constraint.  */
+  tree result = satisfy_constraint_1 (def, targs, complain, in_decl);
+  return memoize_concept_satisfaction (tmpl, targs, result);
 }
 
 /* Check an expression constraint. The constraint is satisfied if
@@ -1803,7 +2081,6 @@
     return boolean_false_node;
   if (!perform_deferred_access_checks (tf_none))
     return boolean_false_node;
-
   return boolean_true_node;
 }
 
@@ -1822,7 +2099,6 @@
     return boolean_false_node;
   if (!perform_deferred_access_checks (complain))
     return boolean_false_node;
-
   return boolean_true_node;
 }
 
@@ -1932,11 +2208,8 @@
 {
   tree t0 = satisfy_constraint_1 (TREE_OPERAND (t, 0), args, complain, in_decl);
   if (t0 == boolean_false_node)
-    return t0;
-  tree t1 = satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);
-  if (t1 == boolean_false_node)
-    return t1;
-  return boolean_true_node;
+    return boolean_false_node;
+  return satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);
 }
 
 /* Check that the disjunction of constraints is satisfied. Note
@@ -1949,10 +2222,7 @@
   tree t0 = satisfy_constraint_1 (TREE_OPERAND (t, 0), args, complain, in_decl);
   if (t0 == boolean_true_node)
     return boolean_true_node;
-  tree t1 = satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);
-  if (t1 == boolean_true_node)
-    return boolean_true_node;
-  return boolean_false_node;
+  return satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);
 }
 
 /* Dispatch to an appropriate satisfaction routine depending on the
@@ -1974,6 +2244,9 @@
   case PRED_CONSTR:
     return satisfy_predicate_constraint (t, args, complain, in_decl);
 
+  case CHECK_CONSTR:
+    return satisfy_check_constraint (t, args, complain, in_decl);
+
   case EXPR_CONSTR:
     return satisfy_expression_constraint (t, args, complain, in_decl);
 
@@ -2014,15 +2287,19 @@
 tree
 satisfy_constraint (tree t, tree args)
 {
+  auto_timevar time (TV_CONSTRAINT_SAT);
+
   /* Turn off template processing. Constraint satisfaction only applies
-     to non-dependent terms, so we want full checking here.  */
-  processing_template_decl_sentinel sentinel (true);
+     to non-dependent terms, so we want to ensure full checking here.  */
+  processing_template_decl_sentinel proc (true);
+
   /* Avoid early exit in tsubst and tsubst_copy from null args; since earlier
      substitution was done with processing_template_decl forced on, there will
      be expressions that still need semantic processing, possibly buried in
      decltype or a template argument.  */
   if (args == NULL_TREE)
     args = make_tree_vec (1);
+
   return satisfy_constraint_1 (t, args, tf_none, NULL_TREE);
 }
 
@@ -2042,11 +2319,13 @@
   if (args && uses_template_parms (args))
     return boolean_true_node;
 
-  /* Invalid requirements cannot be satisfied. */
-  if (!valid_constraints_p (ci))
-    return boolean_false_node;
-
-  return satisfy_constraint (CI_NORMALIZED_CONSTRAINTS (ci), args);
+  /* Check if we've seen a previous result. */
+  if (tree prev = lookup_constraint_satisfaction (ci, args))
+    return prev;
+
+  /* Actually test for satisfaction. */
+  tree result = satisfy_constraint (CI_ASSOCIATED_CONSTRAINTS (ci), args);
+  return memoize_constraint_satisfaction (ci, args, result);
 }
 
 } /* namespace */
@@ -2059,7 +2338,7 @@
 evaluate_constraints (tree constr, tree args)
 {
   gcc_assert (constraint_p (constr));
-  return satisfy_constraint (normalize_constraint (constr), args);
+  return satisfy_constraint (constr, args);
 }
 
 /* Evaluate the function concept FN by substituting its own args
@@ -2070,14 +2349,7 @@
 tree
 evaluate_function_concept (tree fn, tree args)
 {
-  ++processing_template_decl;
-  /* We lift using DECL_TI_ARGS because we want to delay producing
-     non-dependent expressions until we're doing satisfaction.  We can't just
-     go without any substitution because we need to lower the level of 'auto's
-     in type deduction constraints.  */
-  tree constr = transform_expression (lift_function_definition
-				      (fn, DECL_TI_ARGS (fn)));
-  --processing_template_decl;
+  tree constr = build_nt (CHECK_CONSTR, fn, args);
   return satisfy_constraint (constr, args);
 }
 
@@ -2087,12 +2359,9 @@
    boolean_false_node otherwise.  */
 
 tree
-evaluate_variable_concept (tree decl, tree args)
+evaluate_variable_concept (tree var, tree args)
 {
-  ++processing_template_decl;
-  tree constr = transform_expression (lift_variable_initializer
-				      (decl, DECL_TI_ARGS (decl)));
-  --processing_template_decl;
+  tree constr = build_nt (CHECK_CONSTR, var, args);
   return satisfy_constraint (constr, args);
 }
 
@@ -2103,9 +2372,7 @@
 tree
 evaluate_constraint_expression (tree expr, tree args)
 {
-  ++processing_template_decl;
-  tree constr = transform_expression (lift_expression (expr));
-  --processing_template_decl;
+  tree constr = normalize_expression (expr);
   return satisfy_constraint (constr, args);
 }
 
@@ -2165,7 +2432,6 @@
 
 } /* namespace */
 
-
 /*---------------------------------------------------------------------------
                 Semantic analysis of requires-expressions
 ---------------------------------------------------------------------------*/
@@ -2309,6 +2575,7 @@
 ---------------------------------------------------------------------------*/
 
 /* Returns true when the the constraints in A subsume those in B.  */
+
 bool
 subsumes_constraints (tree a, tree b)
 {
@@ -2332,6 +2599,7 @@
 
    Returns 1 if A is more constrained than B, -1 if B is more constrained
    than A, and 0 otherwise. */
+
 int
 more_constrained (tree d1, tree d2)
 {
@@ -2348,6 +2616,7 @@
 /* Returns true if D1 is at least as constrained as D2. That is, the
    associated constraints of D1 subsume those of D2, or both declarations
    are unconstrained. */
+
 bool
 at_least_as_constrained (tree d1, tree d2)
 {
@@ -2359,49 +2628,71 @@
 
 /*---------------------------------------------------------------------------
                         Constraint diagnostics
+
+FIXME: Normalize expressions into constraints before evaluating them.
+This should be the general pattern for all such diagnostics.
 ---------------------------------------------------------------------------*/
 
-/* The diagnosis of constraints performs a combination of
-   normalization and satisfaction testing. We recursively
-   walk through the conjunction (or disjunctions) of associated
-   constraints, testing each sub-expression in turn.
-
-   We currently restrict diagnostics to just the top-level
-   conjunctions within the associated constraints. A fully
-   recursive walk is possible, but it can generate a lot
-   of errors. */
+/* The number of detailed constraint failures.  */
 
+int constraint_errors = 0;
 
-namespace {
+/* Do not generate errors after diagnosing this number of constraint
+   failures.
 
-void diagnose_expression (location_t, tree, tree);
-void diagnose_constraint (location_t, tree, tree);
+   FIXME: This is a really arbitrary number. Provide better control of
+   constraint diagnostics with a command line option.  */
 
-/* Diagnose a conjunction of constraints. */
-void
-diagnose_logical_operation (location_t loc, tree t, tree args)
+int constraint_thresh = 20;
+
+
+/* Returns true if we should elide the diagnostic for a constraint failure.
+   This is the case when the number of errors has exceeded the pre-configured
+   threshold.  */
+
+inline bool
+elide_constraint_failure_p ()
 {
-  diagnose_expression (loc, TREE_OPERAND (t, 0), args);
-  diagnose_expression (loc, TREE_OPERAND (t, 0), args);
+  bool ret = constraint_thresh <= constraint_errors;
+  ++constraint_errors;
+  return ret;
 }
 
-/* Determine if the trait expression T is satisfied by ARGS.
-   Emit a precise diagnostic if it is not. */
+/* Returns the number of undiagnosed errors. */
+
+inline int
+undiagnosed_constraint_failures ()
+{
+  return constraint_errors - constraint_thresh;
+}
+
+/* The diagnosis of constraints performs a combination of normalization
+   and satisfaction testing. We recursively walk through the conjunction or
+   disjunction of associated constraints, testing each sub-constraint in
+   turn.  */
+
+namespace {
+
+void diagnose_constraint (location_t, tree, tree, tree);
+
+/* Emit a specific diagnostics for a failed trait.  */
+
 void
-diagnose_trait_expression (location_t loc, tree t, tree args)
+diagnose_trait_expression (location_t loc, tree, tree cur, tree args)
 {
-  if (constraint_expression_satisfied_p (t, args))
+  if (constraint_expression_satisfied_p (cur, args))
+    return;
+  if (elide_constraint_failure_p())
     return;
 
-  /* Rebuild the trait expression so we can diagnose the
-     specific failure. */
+  tree expr = PRED_CONSTR_EXPR (cur);
   ++processing_template_decl;
-  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);
+  expr = tsubst_expr (expr, args, tf_none, NULL_TREE, false);
   --processing_template_decl;
 
   tree t1 = TRAIT_EXPR_TYPE1 (expr);
   tree t2 = TRAIT_EXPR_TYPE2 (expr);
-  switch (TRAIT_EXPR_KIND (t))
+  switch (TRAIT_EXPR_KIND (expr))
     {
     case CPTK_HAS_NOTHROW_ASSIGN:
       inform (loc, "  %qT is not nothrow copy assignable", t1);
@@ -2471,93 +2762,52 @@
     }
 }
 
-/* Determine if the call expression T, when normalized as a constraint,
-   is satisfied by ARGS.
+/* Diagnose the expression of a predicate constraint.  */
 
-   TODO: If T is refers to a concept, We could recursively analyze
-   its definition to identify the exact failure, but that could
-   emit a *lot* of error messages (defeating the purpose of
-   improved diagnostics). Consider adding a flag to control the
-   depth of diagnostics. */
 void
-diagnose_call_expression (location_t loc, tree t, tree args)
+diagnose_other_expression (location_t loc, tree, tree cur, tree args)
 {
-  if (constraint_expression_satisfied_p (t, args))
+  if (constraint_expression_satisfied_p (cur, args))
     return;
-
-  /* Rebuild the expression for the purpose of diagnostics. */
-  ++processing_template_decl;
-  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);
-  --processing_template_decl;
-
-  /* If the function call is known to be a concept check, then
-     diagnose it differently (i.e., we may recurse). */
-  if (resolve_constraint_check (t))
-    inform (loc, "  concept %qE was not satisfied", expr);
-  else
-    inform (loc, "  %qE evaluated to false", expr);
-}
-
-/* Determine if the template-id T, when normalized as a constraint
-   is satisfied by ARGS. */
-void
-diagnose_template_id (location_t loc, tree t, tree args)
-{
-  /* Check for invalid template-ids. */
-  if (!variable_template_p (TREE_OPERAND (t, 0)))
-    {
-      inform (loc, "  invalid constraint %qE", t);
-      return;
-    }
-
-  if (constraint_expression_satisfied_p (t, args))
+  if (elide_constraint_failure_p())
     return;
+  inform (loc, "%qE evaluated to false", cur);
+}
 
-  /* Rebuild the expression for the purpose of diagnostics. */
-  ++processing_template_decl;
-  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);
-  --processing_template_decl;
+/* Do our best to infer meaning from predicates.  */
 
-  tree var = DECL_TEMPLATE_RESULT (TREE_OPERAND (t, 0));
-  if (DECL_DECLARED_CONCEPT_P (var))
-    inform (loc, "  concept %qE was not satisfied", expr);
+inline void
+diagnose_predicate_constraint (location_t loc, tree orig, tree cur, tree args)
+{
+  if (TREE_CODE (PRED_CONSTR_EXPR (cur)) == TRAIT_EXPR)
+    diagnose_trait_expression (loc, orig, cur, args);
   else
-    inform (loc, "  %qE evaluated to false", expr);
+    diagnose_other_expression (loc, orig, cur, args);
 }
 
-/* Determine if the requires-expression, when normalized as a
-   constraint is satisfied by ARGS.
+/* Diagnose a failed pack expansion, possibly containing constraints.  */
 
-   TODO: Build sets of expressions, types, and constraints
-   based on the requirements in T and emit specific diagnostics
-   for those. */
 void
-diagnose_requires_expression (location_t loc, tree t, tree args)
+diagnose_pack_expansion (location_t loc, tree, tree cur, tree args)
 {
-  if (constraint_expression_satisfied_p (t, args))
+  if (constraint_expression_satisfied_p (cur, args))
     return;
-  inform (loc, "requirements not satisfied");
-}
-
-void
-diagnose_pack_expansion (location_t loc, tree t, tree args)
-{
-  if (constraint_expression_satisfied_p (t, args))
+  if (elide_constraint_failure_p())
     return;
 
   /* Make sure that we don't have naked packs that we don't expect. */
-  if (!same_type_p (TREE_TYPE (t), boolean_type_node))
+  if (!same_type_p (TREE_TYPE (cur), boolean_type_node))
     {
-      inform (loc, "invalid pack expansion in constraint %qE", t);
+      inform (loc, "invalid pack expansion in constraint %qE", cur);
       return;
     }
 
-  inform (loc, "  in the expansion of %qE", t);
+  inform (loc, "in the expansion of %qE", cur);
 
   /* Get the vector of expanded arguments. Note that n must not
      be 0 since this constraint is not satisfied.  */
   ++processing_template_decl;
-  tree exprs = tsubst_pack_expansion (t, args, tf_none, NULL_TREE);
+  tree exprs = tsubst_pack_expansion (cur, args, tf_none, NULL_TREE);
   --processing_template_decl;
   if (exprs == error_mark_node)
     {
@@ -2576,82 +2826,276 @@
     }
 }
 
-/* Diagnose an expression that would be characterized as
-   a predicate constraint. */
+/* Diagnose a potentially unsatisfied concept check constraint DECL<CARGS>.
+   Parameters are as for diagnose_constraint.  */
+
 void
-diagnose_other_expression (location_t loc, tree t, tree args)
+diagnose_check_constraint (location_t loc, tree orig, tree cur, tree args)
 {
-  if (constraint_expression_satisfied_p (t, args))
+  if (constraints_satisfied_p (cur, args))
     return;
-  inform (loc, "  %qE evaluated to false", t);
+
+  tree decl = CHECK_CONSTR_CONCEPT (cur);
+  tree cargs = CHECK_CONSTR_ARGS (cur);
+  tree tmpl = DECL_TI_TEMPLATE (decl);
+  tree check = build_nt (CHECK_CONSTR, decl, cargs);
+
+  /* Instantiate the concept check arguments.  */
+  tree targs = tsubst (cargs, args, tf_none, NULL_TREE);
+  if (targs == error_mark_node)
+    {
+      if (elide_constraint_failure_p ())
+        return;
+      inform (loc, "invalid use of the concept %qE", check);
+      tsubst (cargs, args, tf_warning_or_error, NULL_TREE);
+      return;
+    }
+
+  tree sub = build_tree_list (tmpl, targs);
+  /* Update to the expanded definitions. */
+  cur = expand_concept (decl, targs);
+  if (cur == error_mark_node)
+    {
+      if (elide_constraint_failure_p ())
+        return;
+      inform (loc, "in the expansion of concept %qE %S", check, sub);
+      cur = get_concept_definition (decl);
+      tsubst_expr (cur, targs, tf_warning_or_error, NULL_TREE, false);
+      return;
+    }
+
+  orig = get_concept_definition (CHECK_CONSTR_CONCEPT (orig));
+  orig = normalize_expression (orig);
+
+  location_t dloc = DECL_SOURCE_LOCATION (decl);
+  inform (dloc, "within %qS", sub);
+  diagnose_constraint (dloc, orig, cur, targs);
 }
 
+/* Diagnose a potentially unsatisfied conjunction or disjunction.  Parameters
+   are as for diagnose_constraint.  */
+
 void
-diagnose_expression (location_t loc, tree t, tree args)
+diagnose_logical_constraint (location_t loc, tree orig, tree cur, tree args)
 {
-  switch (TREE_CODE (t))
-    {
-    case TRUTH_ANDIF_EXPR:
-      diagnose_logical_operation (loc, t, args);
-      break;
+  tree t0 = TREE_OPERAND (cur, 0);
+  tree t1 = TREE_OPERAND (cur, 1);
+  if (!constraints_satisfied_p (t0, args))
+    diagnose_constraint (loc, TREE_OPERAND (orig, 0), t0, args);
+  else if (TREE_CODE (orig) == TRUTH_ORIF_EXPR)
+    return;
+  if (!constraints_satisfied_p (t1, args))
+    diagnose_constraint (loc, TREE_OPERAND (orig, 1), t1, args);
+}
 
-    case TRUTH_ORIF_EXPR:
-      diagnose_logical_operation (loc, t, args);
-      break;
+/* Diagnose a potential expression constraint failure. */
 
-    case CALL_EXPR:
-      diagnose_call_expression (loc, t, args);
-      break;
+void
+diagnose_expression_constraint (location_t loc, tree orig, tree cur, tree args)
+{
+  if (constraints_satisfied_p (cur, args))
+    return;
+  if (elide_constraint_failure_p())
+    return;
 
-    case TEMPLATE_ID_EXPR:
-      diagnose_template_id (loc, t, args);
-      break;
+  tree expr = EXPR_CONSTR_EXPR (orig);
+  inform (loc, "the required expression %qE would be ill-formed", expr);
 
-    case REQUIRES_EXPR:
-      diagnose_requires_expression (loc, t, args);
-      break;
+  // TODO: We should have a flag that controls this substitution.
+  // I'm finding it very useful for resolving concept check errors.
 
-    case TRAIT_EXPR:
-      diagnose_trait_expression (loc, t, args);
-      break;
+  // inform (input_location, "==== BEGIN DUMP ====");
+  // tsubst_expr (EXPR_CONSTR_EXPR (orig), args, tf_warning_or_error, NULL_TREE, false);
+  // inform (input_location, "==== END DUMP ====");
+}
 
-    case EXPR_PACK_EXPANSION:
-      diagnose_pack_expansion (loc, t, args);
-      break;
+/* Diagnose a potentially failed type constraint. */
 
-    default:
-      diagnose_other_expression (loc, t, args);
-      break;
+void
+diagnose_type_constraint (location_t loc, tree orig, tree cur, tree args)
+{
+  if (constraints_satisfied_p (cur, args))
+    return;
+  if (elide_constraint_failure_p())
+    return;
+
+  tree type = TYPE_CONSTR_TYPE (orig);
+  inform (loc, "the required type %qT would be ill-formed", type);
+}
+
+/* Diagnose a potentially unsatisfied conversion constraint. */
+
+void
+diagnose_implicit_conversion_constraint (location_t loc, tree orig, tree cur,
+					 tree args)
+{
+  if (constraints_satisfied_p (cur, args))
+    return;
+
+  /* The expression and type will previously have been substituted into,
+     and therefore may already be an error. Also, we will have already
+     diagnosed substitution failures into an expression since this must be
+     part of a compound requirement.  */
+  tree expr = ICONV_CONSTR_EXPR (cur);
+  if (error_operand_p (expr))
+    return;
+
+  /* Don't elide a previously diagnosed failure.  */
+  if (elide_constraint_failure_p())
+    return;
+
+  tree type = ICONV_CONSTR_TYPE (cur);
+  if (error_operand_p (type))
+    {
+      inform (loc, "substitution into type %qT failed",
+	      ICONV_CONSTR_TYPE (orig));
+      return;
     }
+
+  inform(loc, "%qE is not implicitly convertible to %qT", expr, type);
 }
 
-inline void
-diagnose_predicate_constraint (location_t loc, tree t, tree args)
+/* Diagnose an argument deduction constraint. */
+
+void
+diagnose_argument_deduction_constraint (location_t loc, tree orig, tree cur,
+					tree args)
 {
-  diagnose_expression (loc, PRED_CONSTR_EXPR (t), args);
+  if (constraints_satisfied_p (cur, args))
+    return;
+
+  /* The expression and type will previously have been substituted into,
+     and therefore may already be an error. Also, we will have already
+     diagnosed substution failures into an expression since this must be
+     part of a compound requirement.  */
+  tree expr = DEDUCT_CONSTR_EXPR (cur);
+  if (error_operand_p (expr))
+    return;
+
+  /* Don't elide a previously diagnosed failure.  */
+  if (elide_constraint_failure_p ())
+    return;
+
+  tree pattern = DEDUCT_CONSTR_PATTERN (cur);
+  if (error_operand_p (pattern))
+    {
+      inform (loc, "substitution into type %qT failed",
+	      DEDUCT_CONSTR_PATTERN (orig));
+      return;
+    }
+
+  inform (loc, "unable to deduce placeholder type %qT from %qE",
+	  pattern, expr);
 }
 
-inline void
-diagnose_conjunction (location_t loc, tree t, tree args)
+/* Diagnose an exception constraint. */
+
+void
+diagnose_exception_constraint (location_t loc, tree orig, tree cur, tree args)
 {
-  diagnose_constraint (loc, TREE_OPERAND (t, 0), args);
-  diagnose_constraint (loc, TREE_OPERAND (t, 1), args);
+  if (constraints_satisfied_p (cur, args))
+    return;
+  if (elide_constraint_failure_p ())
+    return;
+
+  /* Rebuild a noexcept expression. */
+  tree expr = EXCEPT_CONSTR_EXPR (cur);
+  if (error_operand_p (expr))
+    return;
+
+  inform (loc, "%qE evaluated to false", EXCEPT_CONSTR_EXPR (orig));
 }
 
-/* Diagnose the constraint T for the given ARGS. This is only
-   ever invoked on the associated constraints, so we can
-   only have conjunctions of predicate constraints. */
+/* Diagnose a potentially unsatisfied parameterized constraint.  */
+
 void
-diagnose_constraint (location_t loc, tree t, tree args)
+diagnose_parameterized_constraint (location_t loc, tree orig, tree cur,
+				   tree args)
 {
-  switch (TREE_CODE (t))
+  if (constraints_satisfied_p (cur, args))
+    return;
+
+  local_specialization_stack stack;
+  tree parms = PARM_CONSTR_PARMS (cur);
+  tree vars = tsubst_constraint_variables (parms, args, tf_warning_or_error,
+					   NULL_TREE);
+  if (vars == error_mark_node)
+    {
+      if (elide_constraint_failure_p ())
+        return;
+
+      /* TODO: Check which variable failed and use orig to diagnose
+         that substitution error.  */
+      inform (loc, "failed to instantiate constraint variables");
+      return;
+    }
+
+  /* TODO: It would be better write these in a list. */
+  while (vars)
+    {
+      inform (loc, "    with %q#D", vars);
+      vars = TREE_CHAIN (vars);
+    }
+  orig = PARM_CONSTR_OPERAND (orig);
+  cur = PARM_CONSTR_OPERAND (cur);
+  return diagnose_constraint (loc, orig, cur, args);
+}
+
+/* Diagnose the constraint CUR for the given ARGS. This is only ever invoked
+   on the associated constraints, so we can only have conjunctions of
+   predicate constraints.  The ORIGinal (dependent) constructs follow
+   the current constraints to enable better diagnostics.  Note that ORIG
+   and CUR must be the same kinds of node, except when CUR is an error.  */
+
+void
+diagnose_constraint (location_t loc, tree orig, tree cur, tree args)
+{
+  switch (TREE_CODE (cur))
     {
+    case EXPR_CONSTR:
+      diagnose_expression_constraint (loc, orig, cur, args);
+      break;
+
+    case TYPE_CONSTR:
+      diagnose_type_constraint (loc, orig, cur, args);
+      break;
+
+    case ICONV_CONSTR:
+      diagnose_implicit_conversion_constraint (loc, orig, cur, args);
+      break;
+
+    case DEDUCT_CONSTR:
+      diagnose_argument_deduction_constraint (loc, orig, cur, args);
+      break;
+
+    case EXCEPT_CONSTR:
+      diagnose_exception_constraint (loc, orig, cur, args);
+      break;
+
     case CONJ_CONSTR:
-      diagnose_conjunction (loc, t, args);
+    case DISJ_CONSTR:
+      diagnose_logical_constraint (loc, orig, cur, args);
       break;
 
     case PRED_CONSTR:
-      diagnose_predicate_constraint (loc, t, args);
+      diagnose_predicate_constraint (loc, orig, cur, args);
+      break;
+
+    case PARM_CONSTR:
+      diagnose_parameterized_constraint (loc, orig, cur, args);
+      break;
+
+    case CHECK_CONSTR:
+      diagnose_check_constraint (loc, orig, cur, args);
+      break;
+
+    case EXPR_PACK_EXPANSION:
+      diagnose_pack_expansion (loc, orig, cur, args);
+      break;
+
+    case ERROR_MARK:
+      /* TODO: Can we improve the diagnostic with the original?  */
+      inform (input_location, "ill-formed constraint");
       break;
 
     default:
@@ -2676,16 +3120,10 @@
 	args = TI_ARGS (ti);
     }
 
-  /* Check that the constraints are actually valid.  */
-  tree ci = get_constraints (decl);
-  if (!valid_constraints_p (ci))
-    {
-      inform (loc, "    invalid constraints");
-      return;
-    }
-
   /* Recursively diagnose the associated constraints.  */
-  diagnose_constraint (loc, CI_ASSOCIATED_CONSTRAINTS (ci), args);
+  tree ci = get_constraints (decl);
+  tree t = CI_ASSOCIATED_CONSTRAINTS (ci);
+  diagnose_constraint (loc, t, t, args);
 }
 
 } // namespace
@@ -2697,8 +3135,17 @@
 void
 diagnose_constraints (location_t loc, tree t, tree args)
 {
+  constraint_errors = 0;
+
   if (constraint_p (t))
-    diagnose_constraint (loc, t, args);
-  else
+    diagnose_constraint (loc, t, t, args);
+  else if (DECL_P (t))
     diagnose_declaration_constraints (loc, t, args);
+  else
+    gcc_unreachable ();
+
+  /* Note the number of elided failures. */
+  int n = undiagnosed_constraint_failures ();
+  if (n > 0)
+    inform (loc, "... and %d more constraint errors not shown", n);
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/cp-gimplify.c gcc-6-20160721/gcc/cp/cp-gimplify.c
--- gcc-6.1.0/gcc/cp/cp-gimplify.c	2016-04-13 14:33:53.000000000 +0000
+++ gcc-6-20160721/gcc/cp/cp-gimplify.c	2016-07-21 07:13:42.000000000 +0000
@@ -592,6 +592,8 @@
 				  init, VEC_INIT_EXPR_VALUE_INIT (*expr_p),
 				  from_array,
 				  tf_warning_or_error);
+	hash_set<tree> pset;
+	cp_walk_tree (expr_p, cp_fold_r, &pset, NULL);
 	cp_genericize_tree (expr_p);
 	ret = GS_OK;
 	input_location = loc;
@@ -939,6 +941,17 @@
 
   *stmt_p = stmt = cp_fold (*stmt_p);
 
+  if (((hash_set<tree> *) data)->add (stmt))
+    {
+      /* Don't walk subtrees of stmts we've already walked once, otherwise
+	 we can have exponential complexity with e.g. lots of nested
+	 SAVE_EXPRs or TARGET_EXPRs.  cp_fold uses a cache and will return
+	 always the same tree, which the first time cp_fold_r has been
+	 called on it had the subtrees walked.  */
+      *walk_subtrees = 0;
+      return NULL;
+    }
+
   code = TREE_CODE (stmt);
   if (code == OMP_FOR || code == OMP_SIMD || code == OMP_DISTRIBUTE
       || code == OMP_TASKLOOP || code == CILK_FOR || code == CILK_SIMD
@@ -996,7 +1009,8 @@
 void
 cp_fold_function (tree fndecl)
 {
-  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, NULL, NULL);
+  hash_set<tree> pset;
+  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &pset, NULL);
 }
 
 /* Perform any pre-gimplification lowering of C++ front end trees to
@@ -1266,7 +1280,15 @@
     {
       tree d = DECL_EXPR_DECL (stmt);
       if (TREE_CODE (d) == VAR_DECL)
-	gcc_assert (CP_DECL_THREAD_LOCAL_P (d) == DECL_THREAD_LOCAL_P (d));
+	{
+	  gcc_assert (CP_DECL_THREAD_LOCAL_P (d) == DECL_THREAD_LOCAL_P (d));
+	  /* User var initializers should be genericized during containing
+	     BIND_EXPR genericization when walk_tree walks DECL_INITIAL
+	     of BIND_EXPR_VARS.  Artificial temporaries might not be
+	     mentioned there though, so walk them now.  */
+	  if (DECL_ARTIFICIAL (d) && !TREE_STATIC (d) && DECL_INITIAL (d))
+	    cp_walk_tree (&DECL_INITIAL (d), cp_genericize_r, data, NULL);
+	}
     }
   else if (TREE_CODE (stmt) == OMP_PARALLEL
 	   || TREE_CODE (stmt) == OMP_TASK
@@ -1547,6 +1569,13 @@
   if (DECL_CLONED_FUNCTION_P (fndecl))
     return;
 
+  /* Allow cp_genericize calls to be nested.  */
+  tree save_bc_label[2];
+  save_bc_label[bc_break] = bc_label[bc_break];
+  save_bc_label[bc_continue] = bc_label[bc_continue];
+  bc_label[bc_break] = NULL_TREE;
+  bc_label[bc_continue] = NULL_TREE;
+
   /* Expand all the array notations here.  */
   if (flag_cilkplus 
       && contains_array_notation_expr (DECL_SAVED_TREE (fndecl)))
@@ -1566,6 +1595,8 @@
 
   gcc_assert (bc_label[bc_break] == NULL);
   gcc_assert (bc_label[bc_continue] == NULL);
+  bc_label[bc_break] = save_bc_label[bc_break];
+  bc_label[bc_continue] = save_bc_label[bc_continue];
 }
 
 /* Build code to apply FN to each member of ARG1 and ARG2.  FN may be
@@ -1877,13 +1908,21 @@
 static tree
 cp_fold_maybe_rvalue (tree x, bool rval)
 {
-  if (rval && DECL_P (x))
+  while (true)
     {
-      tree v = decl_constant_value (x);
-      if (v != error_mark_node)
-	x = v;
+      x = cp_fold (x);
+      if (rval && DECL_P (x))
+	{
+	  tree v = decl_constant_value (x);
+	  if (v != x && v != error_mark_node)
+	    {
+	      x = v;
+	      continue;
+	    }
+	}
+      break;
     }
-  return cp_fold (x);
+  return x;
 }
 
 /* Fold expression X which is used as an rvalue.  */
@@ -1995,6 +2034,15 @@
 
       break;
 
+    case INDIRECT_REF:
+      /* We don't need the decltype(auto) obfuscation anymore.  */
+      if (REF_PARENTHESIZED_P (x))
+	{
+	  tree p = maybe_undo_parenthesized_ref (x);
+	  return cp_fold (p);
+	}
+      goto unary;
+
     case ADDR_EXPR:
     case REALPART_EXPR:
     case IMAGPART_EXPR:
@@ -2007,7 +2055,7 @@
     case BIT_NOT_EXPR:
     case TRUTH_NOT_EXPR:
     case FIXED_CONVERT_EXPR:
-    case INDIRECT_REF:
+    unary:
 
       loc = EXPR_LOCATION (x);
       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);
@@ -2017,7 +2065,16 @@
 	  if (op0 == error_mark_node)
 	    x = error_mark_node;
 	  else
-	    x = fold_build1_loc (loc, code, TREE_TYPE (x), op0);
+	    {
+	      x = fold_build1_loc (loc, code, TREE_TYPE (x), op0);
+	      if (code == INDIRECT_REF
+		  && (INDIRECT_REF_P (x) || TREE_CODE (x) == MEM_REF))
+		{
+		  TREE_READONLY (x) = TREE_READONLY (org_x);
+		  TREE_SIDE_EFFECTS (x) = TREE_SIDE_EFFECTS (org_x);
+		  TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (org_x);
+		}
+	    }
 	}
       else
 	x = fold (x);
@@ -2294,7 +2351,12 @@
 	      || op3 == error_mark_node)
 	    x = error_mark_node;
 	  else
-	    x = build4_loc (loc, code, TREE_TYPE (x), op0, op1, op2, op3);
+	    {
+	      x = build4_loc (loc, code, TREE_TYPE (x), op0, op1, op2, op3);
+	      TREE_READONLY (x) = TREE_READONLY (org_x);
+	      TREE_SIDE_EFFECTS (x) = TREE_SIDE_EFFECTS (org_x);
+	      TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (org_x);
+	    }
 	}
 
       x = fold (x);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/cp-tree.def gcc-6-20160721/gcc/cp/cp-tree.def
--- gcc-6.1.0/gcc/cp/cp-tree.def	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/cp/cp-tree.def	2016-07-21 06:18:06.000000000 +0000
@@ -536,6 +536,14 @@
    PRED_CONSTR_EXPR has the expression to be evaluated. */
 DEFTREECODE (PRED_CONSTR, "pred_constr", tcc_expression, 1)
 
+/* A check constraint represents the checking of a concept
+   C. It has two operands: the template defining the concept
+   and a sequence of template arguments.
+
+   CHECK_CONSTR_CONCEPT has the concept definition
+   CHECK_CONSTR_ARGUMENTS are the template arguments */
+DEFTREECODE (CHECK_CONSTR, "check_constr", tcc_expression, 2)
+
 /* An expression constraint determines the validity of a expression E.
 
    EXPR_CONST_EXPR has the expression being validated. */
@@ -560,7 +568,7 @@
    T must contain at least one place holder.
 
    DEDUCT_CONSTR_EXPR has the expression E
-   DEDUCT_CONSTR_PATTERN has the type patter T.
+   DEDUCT_CONSTR_PATTERN has the type pattern T.
    DEDUCT_CONSTR_PLACEHOLDERS has the list of placeholder nodes in T. */
 DEFTREECODE (DEDUCT_CONSTR, "deduct_constr", tcc_expression, 3)
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/cp-tree.h gcc-6-20160721/gcc/cp/cp-tree.h
--- gcc-6.1.0/gcc/cp/cp-tree.h	2016-04-15 14:51:06.000000000 +0000
+++ gcc-6-20160721/gcc/cp/cp-tree.h	2016-07-21 06:29:32.000000000 +0000
@@ -170,7 +170,7 @@
       TARGET_EXPR_DIRECT_INIT_P (in TARGET_EXPR)
       FNDECL_USED_AUTO (in FUNCTION_DECL)
       DECLTYPE_FOR_LAMBDA_PROXY (in DECLTYPE_TYPE)
-      REF_PARENTHESIZED_P (in COMPONENT_REF, INDIRECT_REF)
+      REF_PARENTHESIZED_P (in COMPONENT_REF, INDIRECT_REF, SCOPE_REF)
       AGGR_INIT_ZERO_FIRST (in AGGR_INIT_EXPR)
       CONSTRUCTOR_MUTABLE_POISON (in CONSTRUCTOR)
    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).
@@ -891,10 +891,6 @@
 // - a constraint expression introduced by a function declarator
 // - the associated constraints, which are the conjunction of those,
 //   and used for declaration matching
-// - the cached normalized associated constraints which are used
-//   to support satisfaction and subsumption.
-// - assumptions which is the result of decomposing the normalized
-//   constraints.
 //
 // The template and declarator requirements are kept to support pretty
 // printing constrained declarations.
@@ -903,8 +899,6 @@
   tree template_reqs;
   tree declarator_reqs;
   tree associated_constr;
-  tree normalized_constr;
-  tree assumptions;
 };
 
 // Require that pointer P is non-null before returning.
@@ -943,14 +937,6 @@
 #define CI_ASSOCIATED_CONSTRAINTS(NODE) \
   check_constraint_info (check_nonnull(NODE))->associated_constr
 
-// The normalized associated constraints.
-#define CI_NORMALIZED_CONSTRAINTS(NODE) \
-  check_constraint_info (check_nonnull(NODE))->normalized_constr
-
-// Get the set of assumptions associated with the constraint info node.
-#define CI_ASSUMPTIONS(NODE) \
-  check_constraint_info (check_nonnull(NODE))->assumptions
-
 // Access the logical constraints on the template parameters introduced
 // at a given template parameter list level indicated by NODE.
 #define TEMPLATE_PARMS_CONSTRAINTS(NODE) \
@@ -974,6 +960,14 @@
 #define PRED_CONSTR_EXPR(NODE) \
   TREE_OPERAND (TREE_CHECK (NODE, PRED_CONSTR), 0)
 
+/* The concept of a concept check. */
+#define CHECK_CONSTR_CONCEPT(NODE) \
+  TREE_OPERAND (TREE_CHECK (NODE, CHECK_CONSTR), 0)
+
+/* The template arguments of a concept check. */
+#define CHECK_CONSTR_ARGS(NODE) \
+  TREE_OPERAND (TREE_CHECK (NODE, CHECK_CONSTR), 1)
+
 /* The expression validated by the predicate constraint. */
 #define EXPR_CONSTR_EXPR(NODE) \
   TREE_OPERAND (TREE_CHECK (NODE, EXPR_CONSTR), 0)
@@ -3332,11 +3326,11 @@
   TREE_CHECK2 (NODE, BINARY_LEFT_FOLD_EXPR, BINARY_RIGHT_FOLD_EXPR)
 
 /* True if NODE is UNARY_FOLD_EXPR or a BINARY_FOLD_EXPR */
-#define FOLD_EXPR_P(NODE) \
-  TREE_CODE (NODE) == UNARY_LEFT_FOLD_EXPR \
-    || TREE_CODE (NODE) == UNARY_RIGHT_FOLD_EXPR \
-    || TREE_CODE (NODE) == BINARY_LEFT_FOLD_EXPR \
-    || TREE_CODE (NODE) == BINARY_RIGHT_FOLD_EXPR
+#define FOLD_EXPR_P(NODE)				\
+  (TREE_CODE (NODE) == UNARY_LEFT_FOLD_EXPR		\
+   || TREE_CODE (NODE) == UNARY_RIGHT_FOLD_EXPR		\
+   || TREE_CODE (NODE) == BINARY_LEFT_FOLD_EXPR		\
+   || TREE_CODE (NODE) == BINARY_RIGHT_FOLD_EXPR)
 
 /* True when NODE is a fold over a compound assignment operator. */
 #define FOLD_EXPR_MODIFY_P(NODE) \
@@ -3398,12 +3392,12 @@
 #define PAREN_STRING_LITERAL_P(NODE) \
   TREE_LANG_FLAG_0 (STRING_CST_CHECK (NODE))
 
-/* Indicates whether a COMPONENT_REF has been parenthesized, or an
-   INDIRECT_REF comes from parenthesizing a _DECL.  Currently only set
-   some of the time in C++14 mode.  */
+/* Indicates whether a COMPONENT_REF or a SCOPE_REF has been parenthesized, or
+   an INDIRECT_REF comes from parenthesizing a _DECL.  Currently only set some
+   of the time in C++14 mode.  */
 
 #define REF_PARENTHESIZED_P(NODE) \
-  TREE_LANG_FLAG_2 (TREE_CHECK2 ((NODE), COMPONENT_REF, INDIRECT_REF))
+  TREE_LANG_FLAG_2 (TREE_CHECK3 ((NODE), COMPONENT_REF, INDIRECT_REF, SCOPE_REF))
 
 /* Nonzero if this AGGR_INIT_EXPR provides for initialization via a
    constructor call, rather than an ordinary function call.  */
@@ -4601,7 +4595,8 @@
   class_type,    /* "class" types.  */
   union_type,    /* "union" types.  */
   enum_type,     /* "enum" types.  */
-  typename_type  /* "typename" types.  */
+  typename_type, /* "typename" types.  */
+  scope_type	 /* namespace or tagged type name followed by :: */
 };
 
 /* The various kinds of lvalues we distinguish.  */
@@ -6096,6 +6091,7 @@
 extern tree get_pattern_parm			(tree, tree);
 extern int comp_template_args			(tree, tree, tree * = NULL,
 						 tree * = NULL);
+extern int template_args_equal                  (tree, tree);
 extern tree maybe_process_partial_specialization (tree);
 extern tree most_specialized_instantiation	(tree);
 extern void print_candidates			(tree);
@@ -6809,10 +6805,8 @@
 /* in constraint.cc */
 extern void init_constraint_processing          ();
 extern bool constraint_p                        (tree);
-extern tree make_predicate_constraint           (tree);
 extern tree conjoin_constraints                 (tree, tree);
 extern tree conjoin_constraints                 (tree);
-extern bool valid_constraints_p                 (tree);
 extern tree get_constraints                     (tree);
 extern void set_constraints                     (tree, tree);
 extern void remove_constraints                  (tree);
@@ -6843,13 +6837,23 @@
 extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);
 extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);
 extern bool function_concept_check_p            (tree);
-
+extern tree normalize_expression                (tree);
+extern tree expand_concept                      (tree, tree);
+extern bool expanding_concept                   ();
 extern tree evaluate_constraints                (tree, tree);
 extern tree evaluate_function_concept           (tree, tree);
 extern tree evaluate_variable_concept           (tree, tree);
 extern tree evaluate_constraint_expression      (tree, tree);
 extern bool constraints_satisfied_p             (tree);
 extern bool constraints_satisfied_p             (tree, tree);
+extern tree lookup_constraint_satisfaction      (tree, tree);
+extern tree memoize_constraint_satisfaction     (tree, tree, tree);
+extern tree lookup_concept_satisfaction         (tree, tree);
+extern tree memoize_concept_satisfaction        (tree, tree, tree);
+extern tree get_concept_expansion               (tree, tree);
+extern tree save_concept_expansion              (tree, tree, tree);
+extern bool* lookup_subsumption_result          (tree, tree);
+extern bool save_subsumption_result             (tree, tree, bool);
 
 extern bool equivalent_constraints              (tree, tree);
 extern bool equivalently_constrained            (tree, tree);
@@ -6860,7 +6864,6 @@
 extern void diagnose_constraints                (location_t, tree, tree);
 
 /* in logic.cc */
-extern tree decompose_assumptions               (tree);
 extern tree decompose_conclusions               (tree);
 extern bool subsumes                            (tree, tree);
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/cxx-pretty-print.c gcc-6-20160721/gcc/cp/cxx-pretty-print.c
--- gcc-6.1.0/gcc/cp/cxx-pretty-print.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/cp/cxx-pretty-print.c	2016-07-21 06:18:06.000000000 +0000
@@ -35,6 +35,9 @@
 static void pp_cxx_template_parameter (cxx_pretty_printer *, tree);
 static void pp_cxx_cast_expression (cxx_pretty_printer *, tree);
 static void pp_cxx_typeid_expression (cxx_pretty_printer *, tree);
+static void pp_cxx_unary_left_fold_expression (cxx_pretty_printer *, tree);
+static void pp_cxx_unary_right_fold_expression (cxx_pretty_printer *, tree);
+static void pp_cxx_binary_fold_expression (cxx_pretty_printer *, tree);
 
 
 static inline void
@@ -1140,6 +1143,19 @@
       pp_cxx_ws_string (this, "...");
       break;
 
+    case UNARY_LEFT_FOLD_EXPR:
+      pp_cxx_unary_left_fold_expression (this, t);
+      break;
+
+    case UNARY_RIGHT_FOLD_EXPR:
+      pp_cxx_unary_right_fold_expression (this, t);
+    break;
+
+    case BINARY_LEFT_FOLD_EXPR:
+    case BINARY_RIGHT_FOLD_EXPR:
+      pp_cxx_binary_fold_expression (this, t);
+      break;
+
     case TEMPLATE_ID_EXPR:
       pp_cxx_template_id (this, t);
       break;
@@ -1166,6 +1182,7 @@
       break;
 
     case PRED_CONSTR:
+    case CHECK_CONSTR:
     case EXPR_CONSTR:
     case TYPE_CONSTR:
     case ICONV_CONSTR:
@@ -2199,6 +2216,11 @@
 pp_cxx_constrained_type_spec (cxx_pretty_printer *pp, tree c)
 {
   tree t, a;
+  if (c == error_mark_node)
+    {
+      pp_cxx_ws_string(pp, "<unsatisfied-constrained-placeholder>");
+      return;
+    }
   placeholder_extract_concept_and_args (c, t, a);
   pp->id_expression (t);
   if (TREE_VEC_LENGTH (a) > 1)
@@ -2408,6 +2430,102 @@
   pp_cxx_right_paren (pp);
 }
 
+static char const*
+get_fold_operator (tree t)
+{
+  int op = int_cst_value (FOLD_EXPR_OP (t));
+  if (FOLD_EXPR_MODIFY_P (t))
+    {
+      switch (op)
+        {
+        case NOP_EXPR: return "=";
+        case PLUS_EXPR: return "+=";
+        case MINUS_EXPR: return "-=";
+        case MULT_EXPR: return "*=";
+        case TRUNC_DIV_EXPR: return "/=";
+        case TRUNC_MOD_EXPR: return "%=";
+        case BIT_XOR_EXPR: return "^=";
+        case BIT_AND_EXPR: return "&=";
+        case BIT_IOR_EXPR: return "|=";
+        case LSHIFT_EXPR: return "<<=";
+        case RSHIFT_EXPR: return ">>=";
+        default: gcc_unreachable ();
+        }
+    }
+  else
+    {
+      switch (op)
+        {
+        case PLUS_EXPR: return "+";
+        case MINUS_EXPR: return "-";
+        case MULT_EXPR: return "*";
+        case TRUNC_DIV_EXPR: return "/";
+        case TRUNC_MOD_EXPR: return "%";
+        case BIT_XOR_EXPR: return "^";
+        case BIT_AND_EXPR: return "&";
+        case BIT_IOR_EXPR: return "|";
+        case LSHIFT_EXPR: return "<<";
+        case RSHIFT_EXPR: return ">>";
+        case EQ_EXPR: return "==";
+        case NE_EXPR: return "!=";
+        case LT_EXPR: return "<";
+        case GT_EXPR: return ">";
+        case LE_EXPR: return "<=";
+        case GE_EXPR: return ">=";
+        case TRUTH_ANDIF_EXPR: return "&&";
+        case TRUTH_ORIF_EXPR: return "||";
+        case MEMBER_REF: return "->*";
+        case DOTSTAR_EXPR: return ".*";
+        case OFFSET_REF: return ".*";
+        default: return ","; /* FIXME: Not the right default.  */
+        }
+    }
+}
+
+void
+pp_cxx_unary_left_fold_expression (cxx_pretty_printer *pp, tree t)
+{
+  char const* op = get_fold_operator (t);
+  tree expr = PACK_EXPANSION_PATTERN (FOLD_EXPR_PACK (t));
+  pp_cxx_left_paren (pp);
+  pp_cxx_ws_string (pp, "...");
+  pp_cxx_ws_string (pp, op);
+  pp->expression (expr);
+  pp_cxx_right_paren (pp);
+}
+
+void
+pp_cxx_unary_right_fold_expression (cxx_pretty_printer *pp, tree t)
+{
+  char const* op = get_fold_operator (t);
+  tree expr = PACK_EXPANSION_PATTERN (FOLD_EXPR_PACK (t));
+  pp_cxx_left_paren (pp);
+  pp->expression (expr);
+  pp_space (pp);
+  pp_cxx_ws_string (pp, op);
+  pp_cxx_ws_string (pp, "...");
+  pp_cxx_right_paren (pp);
+}
+
+void
+pp_cxx_binary_fold_expression (cxx_pretty_printer *pp, tree t)
+{
+  char const* op = get_fold_operator (t);
+  tree t1 = TREE_OPERAND (t, 1);
+  tree t2 = TREE_OPERAND (t, 2);
+  if (t1 == FOLD_EXPR_PACK (t))
+    t1 = PACK_EXPANSION_PATTERN (t1);
+  else
+    t2 = PACK_EXPANSION_PATTERN (t2);
+  pp_cxx_left_paren (pp);
+  pp->expression (t1);
+  pp_cxx_ws_string (pp, op);
+  pp_cxx_ws_string (pp, "...");
+  pp_cxx_ws_string (pp, op);
+  pp->expression (t2);
+  pp_cxx_right_paren (pp);
+}
+
 void
 pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)
 {
@@ -2618,6 +2736,7 @@
       pp_cxx_ws_string (pp, "->");
       pp->type_id (type);
     }
+  pp_cxx_semicolon (pp);
 }
 
 /* nested requirement:
@@ -2633,74 +2752,94 @@
 void
 pp_cxx_predicate_constraint (cxx_pretty_printer *pp, tree t)
 {
-  pp_string (pp, "predicate");
-  pp_left_paren (pp);
   pp->expression (TREE_OPERAND (t, 0));
-  pp_right_paren (pp);
+}
+
+void
+pp_cxx_check_constraint (cxx_pretty_printer *pp, tree t)
+{
+  tree decl = CHECK_CONSTR_CONCEPT (t);
+  tree tmpl = DECL_TI_TEMPLATE (decl);
+  tree args = CHECK_CONSTR_ARGS (t);
+  tree id = build_nt (TEMPLATE_ID_EXPR, tmpl, args);
+
+  if (TREE_CODE (decl) == VAR_DECL)
+    pp->expression (id);
+  else if (TREE_CODE (decl) == FUNCTION_DECL)
+    {
+      tree call = build_vl_exp (CALL_EXPR, 2);
+      TREE_OPERAND (call, 0) = integer_two_node;
+      TREE_OPERAND (call, 1) = id;
+      pp->expression (call);
+    }
+  else
+    gcc_unreachable ();
 }
 
 void
 pp_cxx_expression_constraint (cxx_pretty_printer *pp, tree t)
 {
-  pp_string (pp, "valid_expr");
-  pp_left_paren (pp);
+  pp_string (pp, "<valid-expression ");
+  pp_cxx_left_paren (pp);
   pp->expression (TREE_OPERAND (t, 0));
-  pp_right_paren (pp);
+  pp_cxx_right_paren (pp);
+  pp_string (pp, ">");
 }
 
 void
 pp_cxx_type_constraint (cxx_pretty_printer *pp, tree t)
 {
-  pp_string (pp, "valid_type");
-  pp_left_paren (pp);
+  pp_string (pp, "<valid-type ");
   pp->type_id (TREE_OPERAND (t, 0));
-  pp_right_paren (pp);
+  pp_string (pp, ">");
 }
 
 void
 pp_cxx_implicit_conversion_constraint (cxx_pretty_printer *pp, tree t)
 {
-  pp_string (pp, "convertible");
-  pp_left_paren (pp);
+  pp_string (pp, "<implicitly-conversion ");
+  pp_cxx_left_paren (pp);
   pp->expression (ICONV_CONSTR_EXPR (t));
-  pp_cxx_separate_with (pp, ',');
-  pp->expression (ICONV_CONSTR_TYPE (t));
-  pp_right_paren (pp);
+  pp_cxx_right_paren (pp);
+  pp_cxx_ws_string (pp, "to");
+  pp->type_id (ICONV_CONSTR_TYPE (t));
+  pp_string (pp, ">");
 }
 
 void
 pp_cxx_argument_deduction_constraint (cxx_pretty_printer *pp, tree t)
 {
-  pp_string (pp, "deducible");
-  pp_left_paren (pp);
+  pp_string (pp, "<argument-deduction ");
+  pp_cxx_left_paren (pp);
   pp->expression (DEDUCT_CONSTR_EXPR (t));
-  pp_cxx_separate_with (pp, ',');
+  pp_cxx_right_paren (pp);
+  pp_cxx_ws_string (pp, "as");
   pp->expression (DEDUCT_CONSTR_PATTERN (t));
-  pp_right_paren (pp);
+  pp_string (pp, ">");
 }
 
 void
 pp_cxx_exception_constraint (cxx_pretty_printer *pp, tree t)
 {
   pp_cxx_ws_string (pp, "noexcept");
-  pp_left_paren (pp);
+  pp_cxx_whitespace (pp);
+  pp_cxx_left_paren (pp);
   pp->expression (TREE_OPERAND (t, 0));
-  pp_right_paren (pp);
+  pp_cxx_right_paren (pp);
 }
 
 void
 pp_cxx_parameterized_constraint (cxx_pretty_printer *pp, tree t)
 {
   pp_left_paren (pp);
-  pp_string (pp, "forall");
+  pp_string (pp, "<requires ");
   if (tree parms = PARM_CONSTR_PARMS (t))
     {
-      if (parms)
 	pp_cxx_parameter_declaration_clause (pp, parms);
       pp_cxx_whitespace (pp);
     }
   pp_cxx_constraint (pp, PARM_CONSTR_OPERAND (t));
-  pp_right_paren (pp);
+  pp_string (pp, ">");
 }
 
 void
@@ -2731,6 +2870,10 @@
       pp_cxx_predicate_constraint (pp, t);
       break;
 
+    case CHECK_CONSTR:
+      pp_cxx_check_constraint (pp, t);
+      break;
+
     case EXPR_CONSTR:
       pp_cxx_expression_constraint (pp, t);
       break;
@@ -2763,6 +2906,10 @@
       pp_cxx_disjunction (pp, t);
       break;
 
+    case EXPR_PACK_EXPANSION:
+      pp->expression (TREE_OPERAND (t, 0));
+      break;
+
     default:
       gcc_unreachable ();
     }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/decl.c gcc-6-20160721/gcc/cp/decl.c
--- gcc-6.1.0/gcc/cp/decl.c	2016-04-15 04:02:49.000000000 +0000
+++ gcc-6-20160721/gcc/cp/decl.c	2016-07-21 06:18:06.000000000 +0000
@@ -2090,6 +2090,14 @@
       if (VAR_P (newdecl))
 	{
 	  DECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);
+	  /* For already initialized vars, TREE_READONLY could have been
+	     cleared in cp_finish_decl, because the var needs runtime
+	     initialization or destruction.  Make sure not to set
+	     TREE_READONLY on it again.  */
+	  if (DECL_INITIALIZED_P (olddecl)
+	      && !DECL_EXTERNAL (olddecl)
+	      && !TREE_READONLY (olddecl))
+	    TREE_READONLY (newdecl) = 0;
 	  DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);
 	  DECL_NONTRIVIALLY_INITIALIZED_P (newdecl)
 	    |= DECL_NONTRIVIALLY_INITIALIZED_P (olddecl);
@@ -5329,10 +5337,7 @@
     complete_type (type);
   if (!DECL_SIZE (decl)
       && TREE_TYPE (decl) != error_mark_node
-      && (COMPLETE_TYPE_P (type)
-	  || (TREE_CODE (type) == ARRAY_TYPE
-	      && !TYPE_DOMAIN (type)
-	      && COMPLETE_TYPE_P (TREE_TYPE (type)))))
+      && complete_or_array_type_p (type))
     layout_decl (decl, 0);
 
   if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == NULL_TREE)
@@ -6633,6 +6638,13 @@
                                                    adc_variable_type);
       if (type == error_mark_node)
 	return;
+      if (TREE_CODE (type) == FUNCTION_TYPE)
+	{
+	  error ("initializer for %<decltype(auto) %D%> has function type "
+		 "(did you forget the %<()%> ?)", decl);
+	  TREE_TYPE (decl) = error_mark_node;
+	  return;
+	}
       cp_apply_type_quals_to_decl (cp_type_quals (type), decl);
     }
 
@@ -7905,7 +7917,7 @@
 
       /* Adjust the required expression into a constraint. */
       if (decl_reqs)
-        decl_reqs = make_predicate_constraint (decl_reqs);
+        decl_reqs = normalize_expression (decl_reqs);
 
       tree ci = build_constraints (tmpl_reqs, decl_reqs);
       set_constraints (decl, ci);
@@ -11186,8 +11198,7 @@
 	  }
 	else if (!staticp && !dependent_type_p (type)
 		 && !COMPLETE_TYPE_P (complete_type (type))
-		 && (TREE_CODE (type) != ARRAY_TYPE
-		     || !COMPLETE_TYPE_P (TREE_TYPE (type))
+		 && (!complete_or_array_type_p (type)
 		     || initialized == 0))
 	  {
 	    if (TREE_CODE (type) != ARRAY_TYPE
@@ -13382,6 +13393,19 @@
       use_short_enum = flag_short_enums
         || lookup_attribute ("packed", TYPE_ATTRIBUTES (enumtype));
 
+      /* If the precision of the type was specified with an attribute and it
+	 was too small, give an error.  Otherwise, use it.  */
+      if (TYPE_PRECISION (enumtype))
+	{
+	  if (precision > TYPE_PRECISION (enumtype))
+	    error ("specified mode too small for enumeral values");
+	  else
+	    {
+	      use_short_enum = true;
+	      precision = TYPE_PRECISION (enumtype);
+	    }
+	}
+
       for (itk = (use_short_enum ? itk_char : itk_int);
            itk != itk_none;
            itk++)
@@ -14999,8 +15023,9 @@
 	  tree var = iv->decl;
 	  tree type = TREE_TYPE (var);
 
-	  if (TYPE_MAIN_VARIANT (strip_array_types (type))
-	      == iv->incomplete_type)
+	  if (type != error_mark_node
+	      && (TYPE_MAIN_VARIANT (strip_array_types (type))
+		  == iv->incomplete_type))
 	    {
 	      /* Complete the type of the variable.  The VAR_DECL itself
 		 will be laid out in expand_expr.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/decl2.c gcc-6-20160721/gcc/cp/decl2.c
--- gcc-6.1.0/gcc/cp/decl2.c	2016-04-15 14:51:06.000000000 +0000
+++ gcc-6-20160721/gcc/cp/decl2.c	2016-05-31 21:36:46.000000000 +0000
@@ -4904,8 +4904,6 @@
 
   finish_repo ();
 
-  fini_constexpr ();
-
   /* The entire file is now complete.  If requested, dump everything
      to a file.  */
   dump_tu ();
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/error.c gcc-6-20160721/gcc/cp/error.c
--- gcc-6.1.0/gcc/cp/error.c	2016-04-22 11:08:16.000000000 +0000
+++ gcc-6-20160721/gcc/cp/error.c	2016-07-21 06:18:06.000000000 +0000
@@ -961,7 +961,12 @@
     {
       if (VAR_P (t)
 	  && DECL_DECLARED_CONSTEXPR_P (t))
-	pp_cxx_ws_string (pp, "constexpr");
+            {
+              if (DECL_DECLARED_CONCEPT_P (t))
+                pp_cxx_ws_string (pp, "concept");
+              else
+		pp_cxx_ws_string (pp, "constexpr");
+            }
       dump_type_prefix (pp, type, flags & ~TFF_UNQUALIFIED_NAME);
       pp_maybe_space (pp);
     }
@@ -1334,16 +1339,19 @@
 	  if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))
 	    pp_cxx_ws_string (pp, "...");
 	}
+
+      /* Only print the requirements if we're also printing
+         the template header.  */
+      if (flag_concepts)
+	if (tree ci = get_constraints (t))
+	  if (check_constraint_info (ci))
+	    if (tree reqs = CI_TEMPLATE_REQS (ci))
+	      {
+		pp_cxx_requires_clause (pp, reqs);
+		pp_cxx_whitespace (pp);
+	      }
     }
 
-  if (flag_concepts)
-    if (tree ci = get_constraints (t))
-      if (check_constraint_info (ci))
-        if (tree reqs = CI_TEMPLATE_REQS (ci))
-	  {
-	    pp_cxx_requires_clause (pp, reqs);
-	    pp_cxx_whitespace (pp);
-	  }
 
   if (DECL_CLASS_TEMPLATE_P (t))
     dump_type (pp, TREE_TYPE (t),
@@ -1530,7 +1538,12 @@
 	pp_cxx_ws_string (pp, "virtual");
 
       if (DECL_DECLARED_CONSTEXPR_P (t))
-	pp_cxx_ws_string (pp, "constexpr");
+        {
+          if (DECL_DECLARED_CONCEPT_P (t))
+            pp_cxx_ws_string (pp, "concept");
+          else
+	    pp_cxx_ws_string (pp, "constexpr");
+	}
     }
 
   /* Print the return type?  */
@@ -2661,6 +2674,10 @@
       break;
 
     case EXPR_PACK_EXPANSION:
+    case UNARY_LEFT_FOLD_EXPR:
+    case UNARY_RIGHT_FOLD_EXPR:
+    case BINARY_LEFT_FOLD_EXPR:
+    case BINARY_RIGHT_FOLD_EXPR:
     case TYPEID_EXPR:
     case MEMBER_REF:
     case DOTSTAR_EXPR:
@@ -2733,6 +2750,7 @@
       break;
 
     case PRED_CONSTR:
+    case CHECK_CONSTR:
     case EXPR_CONSTR:
     case TYPE_CONSTR:
     case ICONV_CONSTR:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/init.c gcc-6-20160721/gcc/cp/init.c
--- gcc-6.1.0/gcc/cp/init.c	2016-04-14 17:35:23.000000000 +0000
+++ gcc-6-20160721/gcc/cp/init.c	2016-07-21 06:14:51.000000000 +0000
@@ -2072,8 +2072,13 @@
 	  && TREE_CODE (init) == TREE_LIST
 	  && TREE_CHAIN (init) == NULL_TREE)
 	init = TREE_VALUE (init);
-      /* Instantiate a non-dependent initializer.  */
-      init = instantiate_non_dependent_or_null (init);
+      /* Instantiate a non-dependent initializer for user variables.  We
+	 mustn't do this for the temporary for an array compound literal;
+	 trying to instatiate the initializer will keep creating new
+	 temporaries until we crash.  Probably it's not useful to do it for
+	 other artificial variables, either.  */
+      if (!DECL_ARTIFICIAL (decl))
+	init = instantiate_non_dependent_or_null (init);
       if (!init
 	  || !TREE_TYPE (init)
 	  || !TREE_CONSTANT (init)
@@ -2375,7 +2380,8 @@
 
   STRIP_NOPS (oper);
 
-  if (TREE_CODE (oper) == ARRAY_REF)
+  if (TREE_CODE (oper) == ARRAY_REF
+      && (addr_expr || TREE_CODE (TREE_TYPE (oper)) == ARRAY_TYPE))
     {
       /* Similar to the offset computed above, see if the array index
 	 is a compile-time constant.  If so, and unless the offset was
@@ -2404,8 +2410,8 @@
   bool compref = TREE_CODE (oper) == COMPONENT_REF;
 
   /* Descend into a struct or union to find the member whose address
-     is being used as the agument.  */
-  while (TREE_CODE (oper) == COMPONENT_REF)
+     is being used as the argument.  */
+  if (TREE_CODE (oper) == COMPONENT_REF)
     {
       tree op0 = oper;
       while (TREE_CODE (op0 = TREE_OPERAND (op0, 0)) == COMPONENT_REF);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/lambda.c gcc-6-20160721/gcc/cp/lambda.c
--- gcc-6.1.0/gcc/cp/lambda.c	2016-02-25 15:23:47.000000000 +0000
+++ gcc-6-20160721/gcc/cp/lambda.c	2016-07-21 06:12:56.000000000 +0000
@@ -871,8 +871,10 @@
   bool nested = (cfun != NULL);
   bool nested_def = decl_function_context (TYPE_MAIN_DECL (type));
   tree callop = lambda_function (type);
+  tree lam = CLASSTYPE_LAMBDA_EXPR (type);
 
-  if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)
+  if (LAMBDA_EXPR_CAPTURE_LIST (lam) != NULL_TREE
+      || LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam) != CPLD_NONE)
     return;
 
   if (processing_template_decl)
@@ -901,6 +903,8 @@
   tree optype = TREE_TYPE (callop);
   tree fn_result = TREE_TYPE (optype);
 
+  tree thisarg = build_nop (TREE_TYPE (DECL_ARGUMENTS (callop)),
+			    null_pointer_node);
   if (generic_lambda_p)
     {
       /* Prepare the dependent member call for the static member function
@@ -908,7 +912,8 @@
 	 return expression for a deduced return call op to allow for simple
 	 implementation of the conversion operator.  */
 
-      tree instance = build_nop (type, null_pointer_node);
+      tree instance = cp_build_indirect_ref (thisarg, RO_NULL,
+					     tf_warning_or_error);
       tree objfn = build_min (COMPONENT_REF, NULL_TREE,
 			      instance, DECL_NAME (callop), NULL_TREE);
       int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;
@@ -920,9 +925,7 @@
   else
     {
       direct_argvec = make_tree_vector ();
-      direct_argvec->quick_push (build1 (NOP_EXPR,
-					 TREE_TYPE (DECL_ARGUMENTS (callop)),
-					 null_pointer_node));
+      direct_argvec->quick_push (thisarg);
     }
 
   /* Copy CALLOP's argument list (as per 'copy_list') as FN_ARGS in order to
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/logic.cc gcc-6-20160721/gcc/cp/logic.cc
--- gcc-6.1.0/gcc/cp/logic.cc	2016-04-22 11:09:22.000000000 +0000
+++ gcc-6-20160721/gcc/cp/logic.cc	2016-07-21 06:18:06.000000000 +0000
@@ -23,6 +23,7 @@
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "timevar.h"
 #include "hash-set.h"
 #include "machmode.h"
 #include "vec.h"
@@ -50,19 +51,52 @@
 
 // Helper algorithms
 
-// Increment iter distance(first, last) times.
-template<typename I1, typename I2, typename I3>
-  I1 next_by_distance (I1 iter, I2 first, I3 last)
-  {
-    for ( ; first != last; ++first, ++iter)
-      ;
-    return iter;
-  }
+template<typename I>
+inline I
+next (I iter)
+{
+  return ++iter;
+}
+
+template<typename I, typename P>
+inline bool
+any_p (I first, I last, P pred)
+{
+  while (first != last)
+    {
+      if (pred(*first))
+        return true;
+      ++first;
+    }
+  return false;
+}
+
+bool prove_implication (tree, tree);
 
 /*---------------------------------------------------------------------------
                            Proof state
 ---------------------------------------------------------------------------*/
 
+struct term_entry
+{
+  tree t;
+};
+
+/* Hashing function and equality for constraint entries.  */
+
+struct term_hasher : ggc_ptr_hash<term_entry>
+{
+  static hashval_t hash (term_entry *e)
+  {
+    return iterative_hash_template_arg (e->t, 0);
+  }
+
+  static bool equal (term_entry *e1, term_entry *e2)
+  {
+    return cp_tree_equal (e1->t, e2->t);
+  }
+};
+
 /* A term list is a list of atomic constraints. It is used
    to maintain the lists of assumptions and conclusions in a
    proof goal.
@@ -70,109 +104,122 @@
    Each term list maintains an iterator that refers to the current
    term. This can be used by various tactics to support iteration
    and stateful manipulation of the list. */
-struct term_list : std::list<tree>
+struct term_list
 {
-  term_list ();
-  term_list (const term_list &x);
-  term_list& operator= (const term_list &x);
-
-  tree       current_term ()       { return *current; }
-  const_tree current_term () const { return *current; }
+  typedef std::list<tree>::iterator iterator;
 
+  term_list ();
+  term_list (tree);
 
-  void insert (tree t);
-  tree erase ();
+  bool includes (tree);
+  iterator insert (iterator, tree);
+  iterator push_back (tree);
+  iterator erase (iterator);
+  iterator replace (iterator, tree);
+  iterator replace (iterator, tree, tree);
 
-  void start ();
-  void next ();
-  bool done() const;
+  iterator begin() { return seq.begin(); }
+  iterator end() { return seq.end(); }
 
-  iterator current;
+  std::list<tree>         seq;
+  hash_table<term_hasher> tab;
 };
 
 inline
 term_list::term_list ()
-  : std::list<tree> (), current (end ())
-{ }
+  : seq(), tab (11)
+{
+}
 
-inline
-term_list::term_list (const term_list &x)
-  : std::list<tree> (x)
-  , current (next_by_distance (begin (), x.begin (), x.current))
-{ }
+/* Initialize a term list with an initial term. */
 
-inline term_list&
-term_list::operator= (const term_list &x)
+inline
+term_list::term_list (tree t)
+  : seq (), tab (11)
 {
-  std::list<tree>::operator=(x);
-  current = next_by_distance (begin (), x.begin (), x.current);
-  return *this;
-}
-
-/* Try saving the term T into the list of terms. If
-   T is already in the list of terms, then no action is
-   performed. Otherwise, insert T before the current
-   position, making this term current.
-
-   Note that not inserting terms is an optimization
-   that corresponds to the structural rule of
-   contraction.
-
-   NOTE: With the contraction rule, this data structure
-   would be more efficiently represented as an ordered set
-   or hash set.  */
-void
-term_list::insert (tree t)
+  push_back (t);
+}
+
+/* Returns true if T is the in the tree. */
+
+inline bool
+term_list::includes (tree t)
 {
-  /* Search the current term list. If there is already
-     a matching term, do not add the new one.  */
-  for (iterator i = begin(); i != end(); ++i)
-    if (cp_tree_equal (*i, t))
-      return;
+  term_entry ent = {t};
+  return tab.find (&ent);
+}
 
-  current = std::list<tree>::insert (current, t);
+/* Append a term to the list. */
+inline term_list::iterator
+term_list::push_back (tree t)
+{
+  return insert (end(), t);
 }
 
-/* Remove the current term from the list, repositioning to
-   the term following the removed term. Note that the new
-   position could be past the end of the list.
+/* Insert a new (unseen) term T into the list before the proposition
+   indicated by ITER. Returns the iterator to the newly inserted
+   element.  */
 
-   The removed term is returned. */
-inline tree
-term_list::erase ()
+term_list::iterator
+term_list::insert (iterator iter, tree t)
 {
-  tree t = *current;
-  current = std::list<tree>::erase (current);
-  return t;
+  gcc_assert (!includes (t));
+  iter = seq.insert (iter, t);
+  term_entry ent = {t};
+  term_entry** slot = tab.find_slot (&ent, INSERT);
+  term_entry* ptr = ggc_alloc<term_entry> ();
+  *ptr = ent;
+  *slot = ptr;
+  return iter;
 }
 
-/* Initialize the current term to the first in the list. */
-inline void
-term_list::start ()
+/* Remove an existing term from the list. Returns an iterator referring
+   to the element after the removed term.  This may be end().  */
+
+term_list::iterator
+term_list::erase (iterator iter)
 {
-  current = begin ();
+  gcc_assert (includes (*iter));
+  term_entry ent = {*iter};
+  tab.remove_elt (&ent);
+  iter = seq.erase (iter);
+  return iter;
 }
 
-/* Advance to the next term in the list. */
-inline void
-term_list::next ()
+/* Replace the given term with that specified. If the term has
+   been previously seen, do not insert the term. Returns the
+   first iterator past the current term.  */
+
+term_list::iterator
+term_list::replace (iterator iter, tree t)
 {
-  ++current;
+  iter = erase (iter);
+  if (!includes (t))
+    insert (iter, t);
+  return iter;
 }
 
-/* Returns true when the current position is past the end. */
-inline bool
-term_list::done () const
+
+/* Replace the term at the given position by the supplied T1
+   followed by t2. This is used in certain logical operators to
+   load a list of assumptions or conclusions.  */
+
+term_list::iterator
+term_list::replace (iterator iter, tree t1, tree t2)
 {
-  return current == end ();
+  iter = erase (iter);
+  if (!includes (t1))
+    insert (iter, t1);
+  if (!includes (t2))
+    insert (iter, t2);
+  return iter;
 }
 
-
 /* A goal (or subgoal) models a sequent of the form
    'A |- C' where A and C are lists of assumptions and
    conclusions written as propositions in the constraint
-   language (i.e., lists of trees).
-*/
+   language (i.e., lists of trees). */
+
 struct proof_goal
 {
   term_list assumptions;
@@ -182,27 +229,27 @@
 /* A proof state owns a list of goals and tracks the
    current sub-goal. The class also provides facilities
    for managing subgoals and constructing term lists. */
+
 struct proof_state : std::list<proof_goal>
 {
   proof_state ();
 
   iterator branch (iterator i);
+  iterator discharge (iterator i);
 };
 
-/* An alias for proof state iterators. */
-typedef proof_state::iterator goal_iterator;
+/* Initialize the state with a single empty goal, and set that goal
+   as the current subgoal.  */
 
-/* Initialize the state with a single empty goal,
-   and set that goal as the current subgoal. */
 inline
 proof_state::proof_state ()
   : std::list<proof_goal> (1)
 { }
 
 
-/* Branch the current goal by creating a new subgoal,
-   returning a reference to // the new object. This does
-   not update the current goal. */
+/* Branch the current goal by creating a new subgoal, returning a
+   reference to the new object. This does not update the current goal. */
+
 inline proof_state::iterator
 proof_state::branch (iterator i)
 {
@@ -211,278 +258,536 @@
   return insert (++i, g);
 }
 
+/* Discharge the current goal, setting it equal to the
+   next non-satisfied goal. */
+
+inline proof_state::iterator
+proof_state::discharge (iterator i)
+{
+  gcc_assert (i != end());
+  return erase (i);
+}
+
+
 /*---------------------------------------------------------------------------
-                           Logical rules
+                        Debugging
 ---------------------------------------------------------------------------*/
 
-/*These functions modify the current state and goal by decomposing
-  logical expressions using the logical rules of sequent calculus for
-  first order logic.
+// void
+// debug (term_list& ts)
+// {
+//   for (term_list::iterator i = ts.begin(); i != ts.end(); ++i)
+//     verbatim ("  # %E", *i);
+// }
+//
+// void
+// debug (proof_goal& g)
+// {
+//   debug (g.assumptions);
+//   verbatim ("       |-");
+//   debug (g.conclusions);
+// }
+
+/*---------------------------------------------------------------------------
+                        Atomicity of constraints
+---------------------------------------------------------------------------*/
 
-  Note that in each decomposition rule, the term T has been erased
-  from term list before the specific rule is applied. */
+/* Returns true if T is not an atomic constraint.  */
 
-/* The left logical rule for conjunction adds both operands
-   to the current set of constraints. */
-void
-left_conjunction (proof_state &, goal_iterator i, tree t)
+bool
+non_atomic_constraint_p (tree t)
 {
-  gcc_assert (TREE_CODE (t) == CONJ_CONSTR);
+  switch (TREE_CODE (t))
+    {
+    case PRED_CONSTR:
+    case EXPR_CONSTR:
+    case TYPE_CONSTR:
+    case ICONV_CONSTR:
+    case DEDUCT_CONSTR:
+    case EXCEPT_CONSTR:
+      return false;
+    case CHECK_CONSTR:
+    case PARM_CONSTR:
+    case CONJ_CONSTR:
+    case DISJ_CONSTR:
+      return true;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Returns true if any constraints in T are not atomic.  */
 
-  /* Insert the operands into the current branch. Note that the
-     final order of insertion is left-to-right. */
-  term_list &l = i->assumptions;
-  l.insert (TREE_OPERAND (t, 1));
-  l.insert (TREE_OPERAND (t, 0));
+bool
+any_non_atomic_constraints_p (term_list& t)
+{
+  return any_p (t.begin(), t.end(), non_atomic_constraint_p);
 }
 
-/* The left logical rule for disjunction creates a new goal,
-   adding the first operand to the original set of
-   constraints and the second operand to the new set
-   of constraints. */
-void
-left_disjunction (proof_state &s, goal_iterator i, tree t)
+/*---------------------------------------------------------------------------
+                           Proof validations
+---------------------------------------------------------------------------*/
+
+enum proof_result
 {
-  gcc_assert (TREE_CODE (t) == DISJ_CONSTR);
+  invalid,
+  valid,
+  undecided
+};
+
+proof_result check_term (term_list&, tree);
+
 
-  /* Branch the current subgoal. */
-  goal_iterator j = s.branch (i);
-  term_list &l1 = i->assumptions;
-  term_list &l2 = j->assumptions;
+proof_result
+analyze_atom (term_list& ts, tree t)
+{
+  /* FIXME: Hook into special cases, if any. */
+  /*
+  term_list::iterator iter = ts.begin();
+  term_list::iterator end = ts.end();
+  while (iter != end)
+    {
+      ++iter;
+    }
+  */
 
-  /* Insert operands into the different branches. */
-  l1.insert (TREE_OPERAND (t, 0));
-  l2.insert (TREE_OPERAND (t, 1));
+  if (non_atomic_constraint_p (t))
+    return undecided;
+  if (any_non_atomic_constraints_p (ts))
+    return undecided;
+  return invalid;
 }
 
-/* The left logical rules for parameterized constraints
-   adds its operand to the current goal. The list of
-   parameters are effectively discarded. */
-void
-left_parameterized_constraint (proof_state &, goal_iterator i, tree t)
+/* Search for a pack expansion in the list of assumptions that would
+   make this expansion valid.  */
+
+proof_result
+analyze_pack (term_list& ts, tree t)
 {
-  gcc_assert (TREE_CODE (t) == PARM_CONSTR);
-  term_list &l = i->assumptions;
-  l.insert (PARM_CONSTR_OPERAND (t));
+  tree c1 = normalize_expression (PACK_EXPANSION_PATTERN (t));
+  term_list::iterator iter = ts.begin();
+  term_list::iterator end = ts.end();
+  while (iter != end)
+    {
+      if (TREE_CODE (*iter) == TREE_CODE (t))
+        {
+          tree c2 = normalize_expression (PACK_EXPANSION_PATTERN (*iter));
+          if (prove_implication (c2, c1))
+            return valid;
+          else
+            return invalid;
+        }
+      ++iter;
+    }
+  return invalid;
 }
 
-/*---------------------------------------------------------------------------
-                           Decomposition
----------------------------------------------------------------------------*/
+/* Search for concept checks in TS that we know subsume T. */
 
-/* The following algorithms decompose expressions into sets of
-   atomic propositions. In terms of the sequent calculus, these
-   functions exercise the logical rules only.
-
-   This is equivalent, for the purpose of determining subsumption,
-   to rewriting a constraint in disjunctive normal form. It also
-   allows the resulting assumptions to be used as declarations
-   for the purpose of separate checking. */
+proof_result
+search_known_subsumptions (term_list& ts, tree t)
+{
+  for (term_list::iterator i = ts.begin(); i != ts.end(); ++i)
+    if (TREE_CODE (*i) == CHECK_CONSTR)
+      {
+        if (bool* b = lookup_subsumption_result (*i, t))
+          return *b ? valid : invalid;
+      }
+  return undecided;
+}
 
-/* Apply the left logical rules to the proof state. */
-void
-decompose_left_term (proof_state &s, goal_iterator i)
+/* Determine if the terms in TS provide sufficient support for proving
+   the proposition T. If any term in TS is a concept check that is known
+   to subsume T, then the proof is valid. Otherwise, we have to expand T
+   and continue searching for support.  */
+
+proof_result
+analyze_check (term_list& ts, tree t)
+{
+  proof_result r = search_known_subsumptions (ts, t);
+  if (r != undecided)
+    return r;
+
+  tree tmpl = CHECK_CONSTR_CONCEPT (t);
+  tree args = CHECK_CONSTR_ARGS (t);
+  tree c = expand_concept (tmpl, args);
+  return check_term (ts, c);
+}
+
+/* Recursively check constraints of the parameterized constraint. */
+
+proof_result
+analyze_parameterized (term_list& ts, tree t)
+{
+  return check_term (ts, PARM_CONSTR_OPERAND (t));
+}
+
+proof_result
+analyze_conjunction (term_list& ts, tree t)
+{
+  proof_result r = check_term (ts, TREE_OPERAND (t, 0));
+  if (r == invalid || r == undecided)
+    return r;
+  return check_term (ts, TREE_OPERAND (t, 1));
+}
+
+proof_result
+analyze_disjunction (term_list& ts, tree t)
+{
+  proof_result r = check_term (ts, TREE_OPERAND (t, 0));
+  if (r == valid)
+    return r;
+  return check_term (ts, TREE_OPERAND (t, 1));
+}
+
+proof_result
+analyze_term (term_list& ts, tree t)
 {
-  term_list &l = i->assumptions;
-  tree t = l.current_term ();
   switch (TREE_CODE (t))
     {
+    case CHECK_CONSTR:
+      return analyze_check (ts, t);
+
+    case PARM_CONSTR:
+      return analyze_parameterized (ts, t);
+
     case CONJ_CONSTR:
-      left_conjunction (s, i, l.erase ());
-      break;
+      return analyze_conjunction (ts, t);
     case DISJ_CONSTR:
-      left_disjunction (s, i, l.erase ());
-      break;
-    case PARM_CONSTR:
-      left_parameterized_constraint (s, i, l.erase ());
-      break;
+      return analyze_disjunction (ts, t);
+
+    case PRED_CONSTR:
+    case EXPR_CONSTR:
+    case TYPE_CONSTR:
+    case ICONV_CONSTR:
+    case DEDUCT_CONSTR:
+    case EXCEPT_CONSTR:
+      return analyze_atom (ts, t);
+
+    case EXPR_PACK_EXPANSION:
+      return analyze_pack (ts, t);
+
+    case ERROR_MARK:
+      /* Encountering an error anywhere in a constraint invalidates
+         the proof, since the constraint is ill-formed.  */
+      return invalid;
     default:
-      l.next ();
-      break;
+      gcc_unreachable ();
     }
 }
 
-/* Apply the left logical rules of the sequent calculus
-   until the current goal is fully decomposed into atomic
-   constraints. */
+/* Check if a single term can be proven from a set of assumptions.
+   If the proof is not valid, then it is incomplete when either
+   the given term is non-atomic or any term in the list of assumptions
+   is not-atomic.  */
+
+proof_result
+check_term (term_list& ts, tree t)
+{
+  /* Try the easy way; search for an equivalent term.  */
+  if (ts.includes (t))
+    return valid;
+
+  /* The hard way; actually consider what the term means.  */
+  return analyze_term (ts, t);
+}
+
+/* Check to see if any term is proven by the assumptions in the
+   proof goal. The proof is valid if the proof of any term is valid.
+   If validity cannot be determined, but any particular
+   check was undecided, then this goal is undecided.  */
+
+proof_result
+check_goal (proof_goal& g)
+{
+  term_list::iterator iter = g.conclusions.begin ();
+  term_list::iterator end = g.conclusions.end ();
+  bool incomplete = false;
+  while (iter != end)
+    {
+      proof_result r = check_term (g.assumptions, *iter);
+      if (r == valid)
+        return r;
+      if (r == undecided)
+        incomplete = true;
+      ++iter;
+    }
+
+    /* Was the proof complete? */
+    if (incomplete)
+      return undecided;
+    else
+      return invalid;
+}
+
+/* Check if the the proof is valid. This is the case when all
+   goals can be discharged. If any goal is invalid, then the
+   entire proof is invalid. Otherwise, the proof is undecided.  */
+
+proof_result
+check_proof (proof_state& p)
+{
+  proof_state::iterator iter = p.begin();
+  proof_state::iterator end = p.end();
+  while (iter != end)
+    {
+      proof_result r = check_goal (*iter);
+      if (r == invalid)
+        return r;
+      if (r == valid)
+        iter = p.discharge (iter);
+      else
+        ++iter;
+    }
+
+  /* If all goals are discharged, then the proof is valid.  */
+  if (p.empty())
+    return valid;
+  else
+    return undecided;
+}
+
+/*---------------------------------------------------------------------------
+                           Left logical rules
+---------------------------------------------------------------------------*/
+
+term_list::iterator
+load_check_assumption (term_list& ts, term_list::iterator i)
+{
+  tree decl = CHECK_CONSTR_CONCEPT (*i);
+  tree tmpl = DECL_TI_TEMPLATE (decl);
+  tree args = CHECK_CONSTR_ARGS (*i);
+  return ts.replace(i, expand_concept (tmpl, args));
+}
+
+term_list::iterator
+load_parameterized_assumption (term_list& ts, term_list::iterator i)
+{
+  return ts.replace(i, PARM_CONSTR_OPERAND(*i));
+}
+
+term_list::iterator
+load_conjunction_assumption (term_list& ts, term_list::iterator i)
+{
+  tree t1 = TREE_OPERAND (*i, 0);
+  tree t2 = TREE_OPERAND (*i, 1);
+  return ts.replace(i, t1, t2);
+}
+
+/* Examine the terms in the list, and apply left-logical rules to move
+   terms into the set of assumptions. */
+
 void
-decompose_left_goal (proof_state &s, goal_iterator i)
+load_assumptions (proof_goal& g)
 {
-  term_list& l = i->assumptions;
-  l.start ();
-  while (!l.done ())
-    decompose_left_term (s, i);
+  term_list::iterator iter = g.assumptions.begin();
+  term_list::iterator end = g.assumptions.end();
+  while (iter != end)
+    {
+      switch (TREE_CODE (*iter))
+        {
+        case CHECK_CONSTR:
+          iter = load_check_assumption (g.assumptions, iter);
+          break;
+        case PARM_CONSTR:
+          iter = load_parameterized_assumption (g.assumptions, iter);
+          break;
+        case CONJ_CONSTR:
+          iter = load_conjunction_assumption (g.assumptions, iter);
+          break;
+        default:
+          ++iter;
+          break;
+        }
+    }
 }
 
-/* Apply the left logical rules of the sequent calculus
-   until the antecedents are fully decomposed into atomic
-   constraints. */
+/* In each subgoal, load constraints into the assumption set.  */
+
 void
-decompose_left (proof_state& s)
+load_assumptions(proof_state& p)
 {
-  goal_iterator iter = s.begin ();
-  goal_iterator end = s.end ();
-  for ( ; iter != end; ++iter)
-    decompose_left_goal (s, iter);
-}
-
-/* Returns a vector of terms from the term list L. */
-tree
-extract_terms (term_list& l)
-{
-  tree result = make_tree_vec (l.size());
-  term_list::iterator iter = l.begin();
-  term_list::iterator end = l.end();
-  for (int n = 0; iter != end; ++iter, ++n)
-    TREE_VEC_ELT (result, n) = *iter;
-  return result;
-}
-
-/* Extract the assumptions from the proof state S
-   as a vector of vectors of atomic constraints. */
-inline tree
-extract_assumptions (proof_state& s)
-{
-  tree result = make_tree_vec (s.size ());
-  goal_iterator iter = s.begin ();
-  goal_iterator end = s.end ();
-  for (int n = 0; iter != end; ++iter, ++n)
-    TREE_VEC_ELT (result, n) = extract_terms (iter->assumptions);
-  return result;
-}
-
-} // namespace
-
-/* Decompose the required expression T into a constraint set: a
-   vector of vectors containing only atomic propositions. If T is
-   invalid, return an error. */
-tree
-decompose_assumptions (tree t)
-{
-  if (!t || t == error_mark_node)
-    return t;
-
-  /* Create a proof state, and insert T as the sole assumption. */
-  proof_state s;
-  term_list &l = s.begin ()->assumptions;
-  l.insert (t);
-
-  /* Decompose the expression into a constraint set, and then
-     extract the terms for the AST. */
-  decompose_left (s);
-  return extract_assumptions (s);
+  proof_state::iterator iter = p.begin();
+  while (iter != p.end())
+    {
+      load_assumptions (*iter);
+      ++iter;
+    }
 }
 
+void
+explode_disjunction (proof_state& p, proof_state::iterator gi, term_list::iterator ti1)
+{
+  tree t1 = TREE_OPERAND (*ti1, 0);
+  tree t2 = TREE_OPERAND (*ti1, 1);
 
-/*---------------------------------------------------------------------------
-                           Subsumption Rules
----------------------------------------------------------------------------*/
+  /* Erase the current term from the goal. */
+  proof_goal& g1 = *gi;
+  proof_goal& g2 = *p.branch (gi);
 
-namespace {
+  /* Get an iterator to the equivalent position in th enew goal. */
+  int n = std::distance (g1.assumptions.begin (), ti1);
+  term_list::iterator ti2 = g2.assumptions.begin ();
+  std::advance (ti2, n);
 
-bool subsumes_constraint (tree, tree);
-bool subsumes_conjunction (tree, tree);
-bool subsumes_disjunction (tree, tree);
-bool subsumes_parameterized_constraint (tree, tree);
-bool subsumes_atomic_constraint (tree, tree);
-
-/* Returns true if the assumption A matches the conclusion C. This
-   is generally the case when A and C have the same syntax.
-
-   NOTE: There will be specialized matching rules to accommodate
-   type equivalence, conversion, inheritance, etc. But this is not
-   in the current concepts draft. */
-inline bool
-match_terms (tree a, tree c)
-{
-  return cp_tree_equal (a, c);
+  /* Replace the disjunction in both branches. */
+  g1.assumptions.replace (ti1, t1);
+  g2.assumptions.replace (ti2, t2);
 }
 
-/* Returns true if the list of assumptions AS subsumes the atomic
-   proposition C. This is the case when we can find a proposition
-  in AS that entails the conclusion C. */
+
+/* Search the assumptions of the goal for the first disjunction. */
+
 bool
-subsumes_atomic_constraint (tree as, tree c)
+explode_goal (proof_state& p, proof_state::iterator gi)
 {
-  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)
-    if (match_terms (TREE_VEC_ELT (as, i), c))
-      return true;
+  term_list& ts = gi->assumptions;
+  term_list::iterator ti = ts.begin();
+  term_list::iterator end = ts.end();
+  while (ti != end)
+    {
+      if (TREE_CODE (*ti) == DISJ_CONSTR)
+        {
+          explode_disjunction (p, gi, ti);
+          return true;
+        }
+      else ++ti;
+    }
   return false;
 }
 
-/* Returns true when both operands of C are subsumed by the
-   assumptions AS. */
-inline bool
-subsumes_conjunction (tree as, tree c)
+/* Search for the first goal with a disjunction, and then branch
+   creating a clone of that subgoal. */
+
+void
+explode_assumptions (proof_state& p)
 {
-  tree l = TREE_OPERAND (c, 0);
-  tree r = TREE_OPERAND (c, 1);
-  return subsumes_constraint (as, l) && subsumes_constraint (as, r);
+  proof_state::iterator iter = p.begin();
+  proof_state::iterator end = p.end();
+  while (iter != end)
+    {
+      if (explode_goal (p, iter))
+        return;
+      ++iter;
+    }
 }
 
-/* Returns true when either operand of C is subsumed by the
-   assumptions AS. */
-inline bool
-subsumes_disjunction (tree as, tree c)
+
+/*---------------------------------------------------------------------------
+                           Right logical rules
+---------------------------------------------------------------------------*/
+
+term_list::iterator
+load_disjunction_conclusion (term_list& g, term_list::iterator i)
 {
-  tree l = TREE_OPERAND (c, 0);
-  tree r = TREE_OPERAND (c, 1);
-  return subsumes_constraint (as, l) || subsumes_constraint (as, r);
+  tree t1 = TREE_OPERAND (*i, 0);
+  tree t2 = TREE_OPERAND (*i, 1);
+  return g.replace(i, t1, t2);
 }
 
-/* Returns true when the operand of C is subsumed by the
-   assumptions in AS. The parameters are not considered in
-   the subsumption rules. */
-bool
-subsumes_parameterized_constraint (tree as, tree c)
+/* Apply logical rules to the right hand side. This will load the
+   conclusion set with all tpp-level disjunctions.  */
+
+void
+load_conclusions (proof_goal& g)
 {
-  tree t = PARM_CONSTR_OPERAND (c);
-  return subsumes_constraint (as, t);
+  term_list::iterator iter = g.conclusions.begin();
+  term_list::iterator end = g.conclusions.end();
+  while (iter != end)
+    {
+      if (TREE_CODE (*iter) == DISJ_CONSTR)
+        iter = load_disjunction_conclusion (g.conclusions, iter);
+      else
+        ++iter;
+    }
+}
+
+void
+load_conclusions (proof_state& p)
+{
+  proof_state::iterator iter = p.begin();
+  while (iter != p.end())
+    {
+      load_conclusions (*iter);
+      ++iter;
+    }
 }
 
 
-/* Returns true when the list of assumptions AS subsumes the
-   concluded proposition C. This is a simple recursive descent
-   on C, matching against propositions in the assumption list AS. */
+/*---------------------------------------------------------------------------
+                          High-level proof tactics
+---------------------------------------------------------------------------*/
+
+/* Given two constraints A and C, try to derive a proof that
+   A implies C.  */
+
 bool
-subsumes_constraint (tree as, tree c)
+prove_implication (tree a, tree c)
 {
-  switch (TREE_CODE (c))
+  /* Quick accept. */
+  if (cp_tree_equal (a, c))
+    return true;
+
+  /* Build the initial proof state. */
+  proof_state proof;
+  proof_goal& goal = proof.front();
+  goal.assumptions.push_back(a);
+  goal.conclusions.push_back(c);
+
+  /* Perform an initial right-expansion in the off-chance that the right
+     hand side contains disjunctions. */
+  load_conclusions (proof);
+
+  int step_max = 1 << 10;
+  int step_count = 0;              /* FIXME: We shouldn't have this. */
+  std::size_t branch_limit = 1024; /* FIXME: This needs to be configurable. */
+  while (step_count < step_max && proof.size() < branch_limit)
     {
-    case CONJ_CONSTR:
-      return subsumes_conjunction (as, c);
-    case DISJ_CONSTR:
-      return subsumes_disjunction (as, c);
-    case PARM_CONSTR:
-      return subsumes_parameterized_constraint (as, c);
-    default:
-      return subsumes_atomic_constraint (as, c);
+      /* Determine if we can prove that the assumptions entail the
+         conclusions. If so, we're done. */
+      load_assumptions (proof);
+
+      /* Can we solve the proof based on this? */
+      proof_result r = check_proof (proof);
+      if (r != undecided)
+        return r == valid;
+
+      /* If not, then we need to dig into disjunctions.  */
+      explode_assumptions (proof);
+
+      ++step_count;
     }
+
+  if (step_count == step_max)
+    error ("subsumption failed to resolve");
+
+  if (proof.size() == branch_limit)
+    error ("exceeded maximum number of branches");
+
+  return false;
 }
 
-/* Returns true if the LEFT constraints subsume the RIGHT constraints.
-   This is done by checking that the RIGHT requirements follow from
-   each of the LEFT subgoals. */
+/* Returns true if the LEFT constraint subsume the RIGHT constraints.
+   This is done by deriving a proof of the conclusions on the RIGHT
+   from the assumptions on the LEFT assumptions.  */
+
 bool
 subsumes_constraints_nonnull (tree left, tree right)
 {
   gcc_assert (check_constraint_info (left));
   gcc_assert (check_constraint_info (right));
 
-  /* Check that the required expression in RIGHT is subsumed by each
-     subgoal in the assumptions of LEFT. */
-  tree as = CI_ASSUMPTIONS (left);
-  tree c = CI_NORMALIZED_CONSTRAINTS (right);
-  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)
-    if (!subsumes_constraint (TREE_VEC_ELT (as, i), c))
-      return false;
-  return true;
+  auto_timevar time (TV_CONSTRAINT_SUB);
+  tree a = CI_ASSOCIATED_CONSTRAINTS (left);
+  tree c = CI_ASSOCIATED_CONSTRAINTS (right);
+  return prove_implication (a, c);
 }
 
 } /* namespace */
 
 /* Returns true if the LEFT constraints subsume the RIGHT
-   constraints. */
+   constraints.  */
+
 bool
 subsumes (tree left, tree right)
 {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/mangle.c gcc-6-20160721/gcc/cp/mangle.c
--- gcc-6.1.0/gcc/cp/mangle.c	2016-04-11 13:38:34.000000000 +0000
+++ gcc-6-20160721/gcc/cp/mangle.c	2016-07-21 06:15:23.000000000 +0000
@@ -2774,6 +2774,39 @@
       write_type (TREE_TYPE (TREE_OPERAND (expr, 0)));
     }
   else if (TREE_CODE (expr) == SIZEOF_EXPR
+	   && ARGUMENT_PACK_P (TREE_OPERAND (expr, 0)))
+    {
+      tree args = ARGUMENT_PACK_ARGS (TREE_OPERAND (expr, 0));
+      int length = TREE_VEC_LENGTH (args);
+      if (abi_warn_or_compat_version_crosses (10))
+	G.need_abi_warning = true;
+      if (abi_version_at_least (10))
+	{
+	  /* sP <template-arg>* E # sizeof...(T), size of a captured
+	     template parameter pack from an alias template */
+	  write_string ("sP");
+	  for (int i = 0; i < length; ++i)
+	    write_template_arg (TREE_VEC_ELT (args, i));
+	  write_char ('E');
+	}
+      else
+	{
+	  /* In GCC 5 we represented this sizeof wrong, with the effect
+	     that we mangled it as the last element of the pack.  */
+	  tree arg = TREE_VEC_ELT (args, length-1);
+	  if (TYPE_P (arg))
+	    {
+	      write_string ("st");
+	      write_type (arg);
+	    }
+	  else
+	    {
+	      write_string ("sz");
+	      write_expression (arg);
+	    }
+	}
+    }
+  else if (TREE_CODE (expr) == SIZEOF_EXPR
 	   && TYPE_P (TREE_OPERAND (expr, 0)))
     {
       write_string ("st");
@@ -3094,6 +3127,29 @@
 			 "cannot be mangled");
 		  continue;
 		}
+	      else if (FOLD_EXPR_P (expr))
+		{
+		  /* The first 'operand' of a fold-expression is the operator
+		     that it folds over.  */
+		  if (i == 0)
+		    {
+		      int fcode = TREE_INT_CST_LOW (operand);
+		      write_string (operator_name_info[fcode].mangled_name);
+		      continue;
+		    }
+		  else if (code == BINARY_LEFT_FOLD_EXPR)
+		    {
+		      /* The order of operands of the binary left and right
+			 folds is the same, but we want to mangle them in
+			 lexical order, i.e. non-pack first.  */
+		      if (i == 1)
+			operand = FOLD_EXPR_INIT (expr);
+		      else
+			operand = FOLD_EXPR_PACK (expr);
+		    }
+		  if (PACK_EXPANSION_P (operand))
+		    operand = PACK_EXPANSION_PATTERN (operand);
+		}
 	      write_expression (operand);
 	    }
 	}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/method.c gcc-6-20160721/gcc/cp/method.c
--- gcc-6.1.0/gcc/cp/method.c	2016-03-04 01:48:33.000000000 +0000
+++ gcc-6-20160721/gcc/cp/method.c	2016-06-02 11:30:44.000000000 +0000
@@ -484,6 +484,8 @@
   tree type = TREE_TYPE (parm);
   if (DECL_PACK_P (parm))
     type = PACK_EXPANSION_PATTERN (type);
+  if (TREE_CODE (type) != REFERENCE_TYPE)
+    type = cp_build_reference_type (type, /*rval=*/true);
   exp = build_static_cast (type, exp, tf_warning_or_error);
   if (DECL_PACK_P (parm))
     exp = make_pack_expansion (exp);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/name-lookup.c gcc-6-20160721/gcc/cp/name-lookup.c
--- gcc-6.1.0/gcc/cp/name-lookup.c	2016-04-22 15:38:57.000000000 +0000
+++ gcc-6-20160721/gcc/cp/name-lookup.c	2016-05-31 21:36:28.000000000 +0000
@@ -4518,8 +4518,10 @@
 }
 
 /* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL
-   or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type
-   bindings.
+   or a class TYPE).
+
+   If PREFER_TYPE is > 0, we only return TYPE_DECLs or namespaces.
+   If PREFER_TYPE is > 1, we only return TYPE_DECLs.
 
    Returns a DECL (or OVERLOAD, or BASELINK) representing the
    declaration found.  If no suitable declaration can be found,
@@ -4527,28 +4529,25 @@
    neither a class-type nor a namespace a diagnostic is issued.  */
 
 tree
-lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain,
+lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,
 		       bool find_hidden)
 {
-  int flags = 0;
   tree t = NULL_TREE;
 
-  if (find_hidden)
-    flags |= LOOKUP_HIDDEN;
-
   if (TREE_CODE (scope) == NAMESPACE_DECL)
     {
       struct scope_binding binding = EMPTY_SCOPE_BINDING;
 
-      if (is_type_p)
-	flags |= LOOKUP_PREFER_TYPES;
+      int flags = lookup_flags (prefer_type, /*namespaces_only*/false);
+      if (find_hidden)
+	flags |= LOOKUP_HIDDEN;
       if (qualified_lookup_using_namespace (name, scope, &binding, flags))
 	t = binding.value;
     }
   else if (cxx_dialect != cxx98 && TREE_CODE (scope) == ENUMERAL_TYPE)
     t = lookup_enumerator (scope, name);
   else if (is_class_type (scope, complain))
-    t = lookup_member (scope, name, 2, is_type_p, tf_warning_or_error);
+    t = lookup_member (scope, name, 2, prefer_type, tf_warning_or_error);
 
   if (!t)
     return error_mark_node;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/name-lookup.h gcc-6-20160721/gcc/cp/name-lookup.h
--- gcc-6.1.0/gcc/cp/name-lookup.h	2016-02-16 19:01:49.000000000 +0000
+++ gcc-6-20160721/gcc/cp/name-lookup.h	2016-05-31 21:36:28.000000000 +0000
@@ -327,7 +327,7 @@
 extern void set_namespace_binding (tree, tree, tree);
 extern bool hidden_name_p (tree);
 extern tree remove_hidden_names (tree);
-extern tree lookup_qualified_name (tree, tree, bool, bool, /*hidden*/bool = false);
+extern tree lookup_qualified_name (tree, tree, int, bool, /*hidden*/bool = false);
 extern tree lookup_name_nonclass (tree);
 extern tree lookup_name_innermost_nonclass_level (tree);
 extern bool is_local_extern (tree);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/operators.def gcc-6-20160721/gcc/cp/operators.def
--- gcc-6.1.0/gcc/cp/operators.def	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/cp/operators.def	2016-07-21 06:15:23.000000000 +0000
@@ -155,3 +155,7 @@
 
 /* Variadic templates extension. */
 DEF_SIMPLE_OPERATOR ("...", EXPR_PACK_EXPANSION, "sp", 1)
+DEF_SIMPLE_OPERATOR ("... +", UNARY_LEFT_FOLD_EXPR, "fl", 2)
+DEF_SIMPLE_OPERATOR ("+ ...", UNARY_RIGHT_FOLD_EXPR, "fr", 2)
+DEF_SIMPLE_OPERATOR ("+ ... +", BINARY_LEFT_FOLD_EXPR, "fL", 3)
+DEF_SIMPLE_OPERATOR ("+ ... +", BINARY_RIGHT_FOLD_EXPR, "fR", 3)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/parser.c gcc-6-20160721/gcc/cp/parser.c
--- gcc-6.1.0/gcc/cp/parser.c	2016-04-15 12:24:18.000000000 +0000
+++ gcc-6-20160721/gcc/cp/parser.c	2016-07-21 06:18:06.000000000 +0000
@@ -9747,10 +9747,12 @@
 
     ok &= cp_parser_lambda_declarator_opt (parser, lambda_expr);
 
+    if (ok && cp_parser_error_occurred (parser))
+      ok = false;
+
     if (ok)
       {
-	if (!cp_parser_error_occurred (parser)
-	    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)
+	if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)
 	    && cp_parser_start_tentative_firewall (parser))
 	  start = token;
 	cp_parser_lambda_body (parser, lambda_expr);
@@ -11184,11 +11186,17 @@
 		     bool ivdep)
 {
   tree stmt, range_expr;
+  cxx_binding *binding = NULL;
+  tree name = NULL_TREE;
 
   /* Get the range declaration momentarily out of the way so that
      the range expression doesn't clash with it. */
   if (range_decl != error_mark_node)
-    pop_binding (DECL_NAME (range_decl), range_decl);
+    {
+      name = DECL_NAME (range_decl);
+      binding = IDENTIFIER_BINDING (name);
+      IDENTIFIER_BINDING (name) = binding->previous;
+    }
 
   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))
     {
@@ -11200,7 +11208,10 @@
 
   /* Put the range declaration back into scope. */
   if (range_decl != error_mark_node)
-    push_binding (DECL_NAME (range_decl), range_decl, current_binding_level);
+    {
+      binding->previous = IDENTIFIER_BINDING (name);
+      IDENTIFIER_BINDING (name) = binding;
+    }
 
   /* If in template, STMT is converted to a normal for-statement
      at instantiation. If not, it is done just ahead. */
@@ -12434,8 +12445,15 @@
       if (token->type == CPP_COMMA)
 	/* will be consumed next time around */;
       /* If it's a `;', we are done.  */
-      else if (token->type == CPP_SEMICOLON || maybe_range_for_decl)
+      else if (token->type == CPP_SEMICOLON)
 	break;
+      else if (maybe_range_for_decl)
+	{
+	  if (declares_class_or_enum && token->type == CPP_COLON)
+	    pedwarn (decl_specifiers.locations[ds_type_spec], 0,
+		     "types may not be defined in a for-range-declaration");
+	  break;
+	}
       /* Anything else is an error.  */
       else
 	{
@@ -13793,8 +13811,9 @@
 	    /* Consume the `[' token.  */
 	    cp_lexer_consume_token (parser->lexer);
 	    /* Look for the `]' token.  */
-	    end_loc = cp_parser_require (parser, CPP_CLOSE_SQUARE,
-                                         RT_CLOSE_SQUARE)->location;
+	    if (cp_token *close_token
+		= cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))
+	      end_loc = close_token->location;
 	    id = ansi_opname (op == NEW_EXPR
 			      ? VEC_NEW_EXPR : VEC_DELETE_EXPR);
 	  }
@@ -14686,10 +14705,13 @@
 	cp_parser_require (parser, CPP_GREATER, RT_GREATER);
 
         // If template requirements are present, parse them.
-	tree reqs = get_shorthand_constraints (current_template_parms);
-	if (tree r = cp_parser_requires_clause_opt (parser))
-	  reqs = conjoin_constraints (reqs, make_predicate_constraint (r));
-	TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;
+	if (flag_concepts)
+          {
+	    tree reqs = get_shorthand_constraints (current_template_parms);
+	    if (tree r = cp_parser_requires_clause_opt (parser))
+              reqs = conjoin_constraints (reqs, normalize_expression (r));
+	    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;
+          }
 
 	/* Look for the `class' or 'typename' keywords.  */
 	cp_parser_type_parameter_key (parser);
@@ -21178,7 +21200,7 @@
 	     resolution operator, object, function, and enumerator
 	     names are ignored.  */
 	  if (cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
-	    tag_type = typename_type;
+	    tag_type = scope_type;
 	  /* Look up the name.  */
 	  decl = cp_parser_lookup_name (parser, identifier,
 					tag_type,
@@ -24569,6 +24591,20 @@
 
 /* Support Functions */
 
+/* Return the appropriate prefer_type argument for lookup_name_real based on
+   tag_type.  */
+
+static inline int
+prefer_type_arg (tag_types tag_type)
+{
+  switch (tag_type)
+    {
+    case none_type:  return 0;	// No preference.
+    case scope_type: return 1;	// Type or namespace.
+    default:         return 2;	// Type only.
+    }
+}
+
 /* Looks up NAME in the current scope, as given by PARSER->SCOPE.
    NAME should have one of the representations used for an
    id-expression.  If NAME is the ERROR_MARK_NODE, the ERROR_MARK_NODE
@@ -24705,7 +24741,7 @@
 	     errors may be issued.  Even if we rollback the current
 	     tentative parse, those errors are valid.  */
 	  decl = lookup_qualified_name (parser->scope, name,
-					tag_type != none_type,
+					prefer_type_arg (tag_type),
 					/*complain=*/true);
 
 	  /* 3.4.3.1: In a lookup in which the constructor is an acceptable
@@ -24726,7 +24762,7 @@
 	      && DECL_SELF_REFERENCE_P (decl)
 	      && same_type_p (DECL_CONTEXT (decl), parser->scope))
 	    decl = lookup_qualified_name (parser->scope, ctor_identifier,
-					  tag_type != none_type,
+					  prefer_type_arg (tag_type),
 					  /*complain=*/true);
 
 	  /* If we have a single function from a using decl, pull it out.  */
@@ -24782,7 +24818,7 @@
 	decl = lookup_member (object_type,
 			      name,
 			      /*protect=*/0,
-			      tag_type != none_type,
+			      prefer_type_arg (tag_type),
 			      tf_warning_or_error);
       else
 	decl = NULL_TREE;
@@ -24790,7 +24826,7 @@
       if (!decl)
 	{
 	  /* Look it up in the enclosing context.  */
-	  decl = lookup_name_real (name, tag_type != none_type,
+	  decl = lookup_name_real (name, prefer_type_arg (tag_type),
 				   /*nonclass=*/0,
 				   /*block_p=*/true, is_namespace, 0);
 	  /* DR 141 says when looking for a template-name after -> or ., only
@@ -24815,7 +24851,7 @@
     }
   else
     {
-      decl = lookup_name_real (name, tag_type != none_type,
+      decl = lookup_name_real (name, prefer_type_arg (tag_type),
 			       /*nonclass=*/0,
 			       /*block_p=*/true, is_namespace, 0);
       parser->qualifying_scope = NULL_TREE;
@@ -25667,10 +25703,13 @@
   cp_parser_skip_to_end_of_template_parameter_list (parser);
 
   /* Manage template requirements */
-  tree reqs = get_shorthand_constraints (current_template_parms);
-  if (tree r = cp_parser_requires_clause_opt (parser))
-    reqs = conjoin_constraints (reqs, make_predicate_constraint (r));
-  TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;
+  if (flag_concepts)
+  {
+    tree reqs = get_shorthand_constraints (current_template_parms);
+    if (tree r = cp_parser_requires_clause_opt (parser))
+      reqs = conjoin_constraints (reqs, normalize_expression (r));
+    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;
+  }
 
   cp_parser_template_declaration_after_parameters (parser, parameter_list,
 						   member_p);
@@ -25978,6 +26017,7 @@
   cp_token *first;
   cp_token *last;
   tree fn;
+  bool function_try_block = false;
 
   /* Create the FUNCTION_DECL.  */
   fn = grokmethod (decl_specifiers, declarator, attributes);
@@ -25999,9 +26039,43 @@
   /* Save away the tokens that make up the body of the
      function.  */
   first = parser->lexer->next_token;
+
+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRANSACTION_RELAXED))
+    cp_lexer_consume_token (parser->lexer);
+  else if (cp_lexer_next_token_is_keyword (parser->lexer,
+					   RID_TRANSACTION_ATOMIC))
+    {
+      cp_lexer_consume_token (parser->lexer);
+      /* Match cp_parser_txn_attribute_opt [[ identifier ]].  */
+      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE)
+	  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_SQUARE)
+	  && (cp_lexer_nth_token_is (parser->lexer, 3, CPP_NAME)
+	      || cp_lexer_nth_token_is (parser->lexer, 3, CPP_KEYWORD))
+	  && cp_lexer_nth_token_is (parser->lexer, 4, CPP_CLOSE_SQUARE)
+	  && cp_lexer_nth_token_is (parser->lexer, 5, CPP_CLOSE_SQUARE))
+	{
+	  cp_lexer_consume_token (parser->lexer);
+	  cp_lexer_consume_token (parser->lexer);
+	  cp_lexer_consume_token (parser->lexer);
+	  cp_lexer_consume_token (parser->lexer);
+	  cp_lexer_consume_token (parser->lexer);
+	}
+      else
+	while (cp_next_tokens_can_be_gnu_attribute_p (parser)
+	       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN))
+	  {
+	    cp_lexer_consume_token (parser->lexer);
+	    if (cp_parser_cache_group (parser, CPP_CLOSE_PAREN, /*depth=*/0))
+	      break;
+	  }
+    }
+
   /* Handle function try blocks.  */
   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRY))
-    cp_lexer_consume_token (parser->lexer);
+    {
+      cp_lexer_consume_token (parser->lexer);
+      function_try_block = true;
+    }
   /* We can have braced-init-list mem-initializers before the fn body.  */
   if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))
     {
@@ -26019,8 +26093,9 @@
     }
   cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);
   /* Handle function try blocks.  */
-  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_CATCH))
-    cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);
+  if (function_try_block)
+    while (cp_lexer_next_token_is_keyword (parser->lexer, RID_CATCH))
+      cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);
   last = parser->lexer->next_token;
 
   /* Save away the inline definition; we will process it when the
@@ -29949,6 +30024,8 @@
 	  switch (kind)
 	    {
 	    case OMP_CLAUSE__CACHE_:
+	      /* The OpenACC cache directive explicitly only allows "array
+		 elements or subarrays".  */
 	      if (cp_lexer_peek_token (parser->lexer)->type != CPP_OPEN_SQUARE)
 		{
 		  error_at (token->location, "expected %<[%>");
@@ -29965,6 +30042,7 @@
 		    = cp_lexer_peek_token (parser->lexer)->location;
 		  cp_id_kind idk = CP_ID_KIND_NONE;
 		  cp_lexer_consume_token (parser->lexer);
+		  decl = convert_from_reference (decl);
 		  decl
 		    = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT,
 							      decl, false,
@@ -30000,25 +30078,6 @@
 					  RT_CLOSE_SQUARE))
 		    goto skip_comma;
 
-		  if (kind == OMP_CLAUSE__CACHE_)
-		    {
-		      if (TREE_CODE (low_bound) != INTEGER_CST
-			  && !TREE_READONLY (low_bound))
-			{
-			  error_at (token->location,
-				    "%qD is not a constant", low_bound);
-			  decl = error_mark_node;
-			}
-
-		      if (TREE_CODE (length) != INTEGER_CST
-			  && !TREE_READONLY (length))
-			{
-			  error_at (token->location,
-				    "%qD is not a constant", length);
-			  decl = error_mark_node;
-			}
-		    }
-
 		  decl = tree_cons (low_bound, length, decl);
 		}
 	      break;
@@ -33884,7 +33943,9 @@
 
   strcat (p_name, " for");
   mask |= OMP_FOR_CLAUSE_MASK;
-  if (cclauses)
+  /* parallel for{, simd} disallows nowait clause, but for
+     target {teams distribute ,}parallel for{, simd} it should be accepted.  */
+  if (cclauses && (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) == 0)
     mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT);
   /* Composite distribute parallel for{, simd} disallows ordered clause.  */
   if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)
@@ -34223,7 +34284,8 @@
 	}
     }
 
-  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok);
+  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,
+				       cclauses == NULL);
   if (cclauses)
     {
       cp_omp_split_clauses (loc, OMP_PARALLEL, mask, clauses, cclauses);
@@ -35396,6 +35458,8 @@
 cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,
 		     omp_clause_mask mask, tree *cclauses, bool *if_p)
 {
+  bool is_parallel = ((mask >> PRAGMA_OACC_CLAUSE_REDUCTION) & 1) == 1;
+
   strcat (p_name, " loop");
   mask |= OACC_LOOP_CLAUSE_MASK;
 
@@ -35403,7 +35467,7 @@
 					     cclauses == NULL);
   if (cclauses)
     {
-      clauses = c_oacc_split_loop_clauses (clauses, cclauses);
+      clauses = c_oacc_split_loop_clauses (clauses, cclauses, is_parallel);
       if (*cclauses)
 	*cclauses = finish_omp_clauses (*cclauses, false);
       if (clauses)
@@ -35496,8 +35560,6 @@
       if (strcmp (p, "loop") == 0)
 	{
 	  cp_lexer_consume_token (parser->lexer);
-	  mask |= OACC_LOOP_CLAUSE_MASK;
-
 	  tree block = begin_omp_parallel ();
 	  tree clauses;
 	  cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, &clauses,
@@ -37807,7 +37869,13 @@
       implicit template scope, and we're trying to synthesize a
       constrained parameter, try to find a previous parameter with
       the same name.  This is the same-type rule for abbreviated
-      function templates.  */
+      function templates.
+
+      NOTE: We can generate implicit parameters when tentatively
+      parsing a nested name specifier, only to reject that parse
+      later. However, matching the same template-id as part of a
+      direct-declarator should generate an identical template
+      parameter, so this rule will merge them. */
   if (parser->implicit_template_scope && constr)
     {
       tree t = parser->implicit_template_parms;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/pt.c gcc-6-20160721/gcc/cp/pt.c
--- gcc-6.1.0/gcc/cp/pt.c	2016-04-26 06:08:20.000000000 +0000
+++ gcc-6-20160721/gcc/cp/pt.c	2016-07-21 06:29:32.000000000 +0000
@@ -182,7 +182,6 @@
 static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);
 static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);
 static tree tsubst_template_parms (tree, tree, tsubst_flags_t);
-static void regenerate_decl_from_template (tree, tree);
 static tree most_specialized_partial_spec (tree, tsubst_flags_t);
 static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);
 static tree tsubst_arg_types (tree, tree, tree, tsubst_flags_t, tree);
@@ -196,7 +195,6 @@
 static int coerce_template_template_parms (tree, tree, tsubst_flags_t,
 					   tree, tree);
 static bool template_template_parm_bindings_ok_p (tree, tree);
-static int template_args_equal (tree, tree);
 static void tsubst_default_arguments (tree, tsubst_flags_t);
 static tree for_each_template_parm_r (tree *, int *, void *);
 static tree copy_default_args_to_explicit_spec_1 (tree, tree);
@@ -2808,6 +2806,13 @@
 		 context.  */
 	      fns = lookup_qualified_name (CP_DECL_CONTEXT (decl), dname,
 					   false, true);
+	      if (fns == error_mark_node)
+		/* If lookup fails, look for a friend declaration so we can
+		   give a better diagnostic.  */
+		fns = lookup_qualified_name (CP_DECL_CONTEXT (decl), dname,
+					     /*type*/false, /*complain*/true,
+					     /*hidden*/true);
+
 	      if (fns == error_mark_node || !is_overloaded_fn (fns))
 		{
 		  error ("%qD is not a template function", dname);
@@ -2953,6 +2958,15 @@
 					   CP_DECL_CONTEXT (tmpl)))
 	    error ("%qD is not declared in %qD",
 		   tmpl, current_namespace);
+	  else if (TREE_CODE (decl) == FUNCTION_DECL
+		   && DECL_HIDDEN_FRIEND_P (tmpl))
+	    {
+	      if (pedwarn (DECL_SOURCE_LOCATION (decl), 0,
+			   "friend declaration %qD is not visible to "
+			   "explicit specialization", tmpl))
+		inform (DECL_SOURCE_LOCATION (tmpl),
+			"friend declaration here");
+	    }
 
 	  tree gen_tmpl = most_general_template (tmpl);
 
@@ -7823,7 +7837,7 @@
 
 /* Returns 1 if template args OT and NT are equivalent.  */
 
-static int
+int
 template_args_equal (tree ot, tree nt)
 {
   if (nt == ot)
@@ -8680,7 +8694,7 @@
     {
       if (complain & tf_error)
 	{
-	  error ("constraints for %qD not satisfied", templ);
+	  error ("use of invalid variable template %qE", var);
 	  diagnose_constraints (location_of (var), templ, arglist);
 	}
       return error_mark_node;
@@ -9071,6 +9085,8 @@
 
   if (tinst_depth >= max_tinst_depth)
     {
+      /* Tell error.c not to try to instantiate any templates.  */
+      at_eof = 2;
       fatal_error (input_location,
 		   "template instantiation depth exceeds maximum of %d"
                    " (use -ftemplate-depth= to increase the maximum)",
@@ -9554,7 +9570,7 @@
     return 0;
   else if (COMPLETE_TYPE_P (type))
     return 1;
-  else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))
+  else if (TREE_CODE (type) == ARRAY_TYPE)
     return can_complete_type_without_circularity (TREE_TYPE (type));
   else if (CLASS_TYPE_P (type)
 	   && TYPE_BEING_DEFINED (TYPE_MAIN_VARIANT (type)))
@@ -9649,20 +9665,23 @@
       }
 
   if (last_dep)
-    for (tree *p = &attributes; *p; p = &TREE_CHAIN (*p))
+    for (tree *p = &attributes; *p; )
       {
 	tree t = *p;
 	if (ATTR_IS_DEPENDENT (t))
 	  {
 	    tree subst = tsubst_attribute (t, NULL, args, complain, in_decl);
-	    if (subst == t)
-	      continue;
-	    *p = subst;
-	    do
-	      p = &TREE_CHAIN (*p);
-	    while (*p);
-	    *p = TREE_CHAIN (t);
+	    if (subst != t)
+	      {
+		*p = subst;
+		do
+		  p = &TREE_CHAIN (*p);
+		while (*p);
+		*p = TREE_CHAIN (t);
+		continue;
+	      }
 	  }
+	p = &TREE_CHAIN (*p);
       }
 
   return attributes;
@@ -10118,17 +10137,12 @@
 			  if (can_complete_type_without_circularity (rtype))
 			    complete_type (rtype);
 
-                          if (TREE_CODE (r) == FIELD_DECL
-                              && TREE_CODE (rtype) == ARRAY_TYPE
-                              && COMPLETE_TYPE_P (TREE_TYPE (rtype))
-                              && !COMPLETE_TYPE_P (rtype))
-                            {
-                              /* Flexible array mmembers of elements
-                                 of complete type have an incomplete type
-                                 and that's okay.  */
-                            }
-                          else if (!COMPLETE_TYPE_P (rtype))
+			  if (!complete_or_array_type_p (rtype))
 			    {
+			      /* If R's type couldn't be completed and
+				 it isn't a flexible array member (whose
+				 type is incomplete by definition) give
+				 an error.  */
 			      cxx_incomplete_type_error (r, rtype);
 			      TREE_TYPE (r) = error_mark_node;
 			    }
@@ -10732,6 +10746,12 @@
   tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);
   if (pack == error_mark_node)
     return error_mark_node;
+  if (PACK_EXPANSION_P (pack))
+    {
+      tree r = copy_node (t);
+      FOLD_EXPR_PACK (r) = pack;
+      return r;
+    }
   if (TREE_VEC_LENGTH (pack) == 0)
     return expand_empty_fold (t, complain);
   else
@@ -10754,6 +10774,14 @@
   if (init == error_mark_node)
     return error_mark_node;
 
+  if (PACK_EXPANSION_P (pack))
+    {
+      tree r = copy_node (t);
+      FOLD_EXPR_PACK (r) = pack;
+      FOLD_EXPR_INIT (r) = init;
+      return r;
+    }
+
   tree vec = make_tree_vec (TREE_VEC_LENGTH (pack) + 1);
   TREE_VEC_ELT (vec, 0) = init;
   for (int i = 0; i < TREE_VEC_LENGTH (pack); ++i)
@@ -10795,6 +10823,12 @@
   tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);
   if (pack == error_mark_node)
     return error_mark_node;
+  if (PACK_EXPANSION_P (pack))
+    {
+      tree r = copy_node (t);
+      FOLD_EXPR_PACK (r) = pack;
+      return r;
+    }
   if (TREE_VEC_LENGTH (pack) == 0)
     return expand_empty_fold (t, complain);
   else
@@ -10817,6 +10851,14 @@
   if (init == error_mark_node)
     return error_mark_node;
 
+  if (PACK_EXPANSION_P (pack))
+    {
+      tree r = copy_node (t);
+      FOLD_EXPR_PACK (r) = pack;
+      FOLD_EXPR_INIT (r) = init;
+      return r;
+    }
+
   int n = TREE_VEC_LENGTH (pack);
   tree vec = make_tree_vec (n + 1);
   for (int i = 0; i < n; ++i)
@@ -12285,6 +12327,14 @@
 	    local_p = true;
 	    /* Subsequent calls to pushdecl will fill this in.  */
 	    ctx = NULL_TREE;
+	    /* Unless this is a reference to a static variable from an
+	       enclosing function, in which case we need to fill it in now.  */
+	    if (TREE_STATIC (t))
+	      {
+		tree fn = tsubst (DECL_CONTEXT (t), args, complain, in_decl);
+		if (fn != current_function_decl)
+		  ctx = fn;
+	      }
 	    spec = retrieve_local_specialization (t);
 	  }
 	/* If we already have the specialization we need, there is
@@ -13740,8 +13790,10 @@
     {
       if (is_template)
 	expr = build_min_nt_loc (loc, TEMPLATE_ID_EXPR, expr, template_args);
-      return build_qualified_name (NULL_TREE, scope, expr,
-				   QUALIFIED_NAME_IS_TEMPLATE (qualified_id));
+      tree r = build_qualified_name (NULL_TREE, scope, expr,
+				     QUALIFIED_NAME_IS_TEMPLATE (qualified_id));
+      REF_PARENTHESIZED_P (r) = REF_PARENTHESIZED_P (qualified_id);
+      return r;
     }
 
   if (!BASELINK_P (name) && !DECL_P (expr))
@@ -13821,6 +13873,9 @@
       && TREE_CODE (expr) != OFFSET_REF)
     expr = convert_from_reference (expr);
 
+  if (REF_PARENTHESIZED_P (qualified_id))
+    expr = force_paren_expr (expr);
+
   return expr;
 }
 
@@ -13996,7 +14051,8 @@
     case FUNCTION_DECL:
       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))
 	r = tsubst (t, args, complain, in_decl);
-      else if (local_variable_p (t))
+      else if (local_variable_p (t)
+	       && uses_template_parms (DECL_CONTEXT (t)))
 	{
 	  r = retrieve_local_specialization (t);
 	  if (r == NULL_TREE)
@@ -14040,14 +14096,9 @@
 		  gcc_assert (cp_unevaluated_operand || TREE_STATIC (r)
 			      || decl_constant_var_p (r)
 			      || errorcount || sorrycount);
-		  if (!processing_template_decl)
-		    {
-		      if (TREE_STATIC (r))
-			rest_of_decl_compilation (r, toplevel_bindings_p (),
-						  at_eof);
-		      else
-			r = process_outer_var_ref (r, complain);
-		    }
+		  if (!processing_template_decl
+		      && !TREE_STATIC (r))
+		    r = process_outer_var_ref (r, complain);
 		}
 	      /* Remember this for subsequent uses.  */
 	      if (local_specializations)
@@ -14145,7 +14196,8 @@
 	      len = TREE_VEC_LENGTH (expanded);
 	      /* Set TREE_USED for the benefit of -Wunused.  */
 	      for (int i = 0; i < len; i++)
-		TREE_USED (TREE_VEC_ELT (expanded, i)) = true;
+		if (DECL_P (TREE_VEC_ELT (expanded, i)))
+		  TREE_USED (TREE_VEC_ELT (expanded, i)) = true;
 	    }
 
 	  if (expanded == error_mark_node)
@@ -17376,6 +17428,7 @@
 
   tree pattern = DECL_TEMPLATE_RESULT (gen_tmpl);
 
+  fndecl = NULL_TREE;
   if (VAR_P (pattern))
     {
       /* We need to determine if we're using a partial or explicit
@@ -17387,14 +17440,16 @@
 	pattern = error_mark_node;
       else if (elt)
 	{
-	  tmpl = TREE_VALUE (elt);
-	  pattern = DECL_TEMPLATE_RESULT (tmpl);
-	  targ_ptr = TREE_PURPOSE (elt);
+	  tree partial_tmpl = TREE_VALUE (elt);
+	  tree partial_args = TREE_PURPOSE (elt);
+	  tree partial_pat = DECL_TEMPLATE_RESULT (partial_tmpl);
+	  fndecl = tsubst (partial_pat, partial_args, complain, gen_tmpl);
 	}
     }
 
   /* Substitute template parameters to obtain the specialization.  */
-  fndecl = tsubst (pattern, targ_ptr, complain, gen_tmpl);
+  if (fndecl == NULL_TREE)
+    fndecl = tsubst (pattern, targ_ptr, complain, gen_tmpl);
   if (DECL_CLASS_SCOPE_P (gen_tmpl))
     pop_nested_class ();
   pop_from_top_level ();
@@ -20848,36 +20903,6 @@
   return decl;
 }
 
-/* True iff the TEMPLATE_DECL tmpl is a partial specialization.  */
-
-static bool
-partial_specialization_p (tree tmpl)
-{
-  /* Any specialization has DECL_TEMPLATE_SPECIALIZATION.  */
-  if (!DECL_TEMPLATE_SPECIALIZATION (tmpl))
-    return false;
-  tree t = DECL_TI_TEMPLATE (tmpl);
-  /* A specialization that fully specializes one of the containing classes is
-     not a partial specialization.  */
-  return (list_length (DECL_TEMPLATE_PARMS (tmpl))
-	  == list_length (DECL_TEMPLATE_PARMS (t)));
-}
-
-/* If TMPL is a partial specialization, return the arguments for its primary
-   template.  */
-
-static tree
-impartial_args (tree tmpl, tree args)
-{
-  if (!partial_specialization_p (tmpl))
-    return args;
-
-  /* If TMPL is a partial specialization, we need to substitute to get
-     the args for the primary template.  */
-  return tsubst_template_args (DECL_TI_ARGS (tmpl), args,
-			       tf_warning_or_error, tmpl);
-}
-
 /* Return the most specialized of the template partial specializations
    which can produce TARGET, a specialization of some class or variable
    template.  The value returned is actually a TREE_LIST; the TREE_VALUE is
@@ -21379,14 +21404,12 @@
    to instantiate the DECL, we regenerate it.  */
 
 static void
-regenerate_decl_from_template (tree decl, tree tmpl)
+regenerate_decl_from_template (tree decl, tree tmpl, tree args)
 {
   /* The arguments used to instantiate DECL, from the most general
      template.  */
-  tree args;
   tree code_pattern;
 
-  args = DECL_TI_ARGS (decl);
   code_pattern = DECL_TEMPLATE_RESULT (tmpl);
 
   /* Make sure that we can see identifiers, and compute access
@@ -21702,7 +21725,7 @@
     return d;
 
   gen_tmpl = most_general_template (tmpl);
-  gen_args = impartial_args (tmpl, DECL_TI_ARGS (d));
+  gen_args = DECL_TI_ARGS (d);
 
   if (tmpl != gen_tmpl)
     /* We should already have the extra args.  */
@@ -21721,6 +21744,20 @@
   /* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern
      for the instantiation.  */
   td = template_for_substitution (d);
+  args = gen_args;
+
+  if (VAR_P (d))
+    {
+      /* Look up an explicit specialization, if any.  */
+      tree tid = lookup_template_variable (gen_tmpl, gen_args);
+      tree elt = most_specialized_partial_spec (tid, tf_warning_or_error);
+      if (elt && elt != error_mark_node)
+	{
+	  td = TREE_VALUE (elt);
+	  args = TREE_PURPOSE (elt);
+	}
+    }
+
   code_pattern = DECL_TEMPLATE_RESULT (td);
 
   /* We should never be trying to instantiate a member of a class
@@ -21733,9 +21770,7 @@
        outside the class, we may have too many arguments.  Drop the
        ones we don't need.  The same is true for specializations.  */
     args = get_innermost_template_args
-      (gen_args, TMPL_PARMS_DEPTH  (DECL_TEMPLATE_PARMS (td)));
-  else
-    args = gen_args;
+      (args, TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (td)));
 
   if (TREE_CODE (d) == FUNCTION_DECL)
     {
@@ -21901,7 +21936,7 @@
 
   /* Regenerate the declaration in case the template has been modified
      by a subsequent redeclaration.  */
-  regenerate_decl_from_template (d, td);
+  regenerate_decl_from_template (d, td, args);
 
   /* We already set the file and line above.  Reset them now in case
      they changed as a result of calling regenerate_decl_from_template.  */
@@ -23628,7 +23663,10 @@
   if (0 && flag_checking && cxx_dialect >= cxx11
       /* Don't do this during nsdmi parsing as it can lead to
 	 unexpected recursive instantiations.  */
-      && !parsing_nsdmi ())
+      && !parsing_nsdmi ()
+      /* Don't do this during concept expansion either and for
+         the same reason.  */
+      && !expanding_concept ())
     fold_non_dependent_expr (expr);
 
   /* Preserve OVERLOADs; the functions must be available to resolve
@@ -23766,7 +23804,7 @@
   else
     expr = build_concept_check (build_overload (tmpl, NULL_TREE), type, args);
 
-  tree constr = make_predicate_constraint (expr);
+  tree constr = normalize_expression (expr);
   PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;
 
   /* Our canonical type depends on the constraint.  */
@@ -23918,7 +23956,10 @@
 /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced
    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.
    The CONTEXT determines the context in which auto deduction is performed
-   and is used to control error diagnostics.  */
+   and is used to control error diagnostics.
+
+   For partial-concept-ids, extra args may be appended to the list of deduced
+   template arguments prior to determining constraint satisfaction.  */
 
 tree
 do_auto_deduction (tree type, tree init, tree auto_node,
@@ -23965,8 +24006,10 @@
 
   if (AUTO_IS_DECLTYPE (auto_node))
     {
-      bool id = (DECL_P (init) || (TREE_CODE (init) == COMPONENT_REF
-				   && !REF_PARENTHESIZED_P (init)));
+      bool id = (DECL_P (init)
+		 || ((TREE_CODE (init) == COMPONENT_REF
+		      || TREE_CODE (init) == SCOPE_REF)
+		     && !REF_PARENTHESIZED_P (init)));
       targs = make_tree_vec (1);
       TREE_VEC_ELT (targs, 0)
 	= finish_decltype_type (init, id, tf_warning_or_error);
@@ -24023,8 +24066,19 @@
   if (flag_concepts && !processing_template_decl)
     if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (auto_node))
       {
-        /* Use the deduced type to check the associated constraints. */
-        if (!constraints_satisfied_p (constr, targs))
+        /* Use the deduced type to check the associated constraints. If we
+           have a partial-concept-id, rebuild the argument list so that
+           we check using the extra arguments. */
+        gcc_assert (TREE_CODE (constr) == CHECK_CONSTR);
+        tree cargs = CHECK_CONSTR_ARGS (constr);
+        if (TREE_VEC_LENGTH (cargs) > 1)
+          {
+            cargs = copy_node (cargs);
+            TREE_VEC_ELT (cargs, 0) = TREE_VEC_ELT (targs, 0);
+          }
+        else
+          cargs = targs;
+        if (!constraints_satisfied_p (constr, cargs))
           {
             if (complain & tf_warning_or_error)
               {
@@ -24344,24 +24398,15 @@
 
 static GTY (()) hash_table<constr_hasher> *decl_constraints;
 
-/* Returns true iff cinfo contains a valid set of constraints.
-   This is the case when the associated requirements have been
-   successfully decomposed into lists of atomic constraints.
-   That is, when the saved assumptions are not error_mark_node.  */
-
-bool
-valid_constraints_p (tree cinfo)
-{
-  gcc_assert (cinfo);
-  return CI_ASSUMPTIONS (cinfo) != error_mark_node;
-}
-
 /* Returns the template constraints of declaration T. If T is not
    constrained, return NULL_TREE. Note that T must be non-null. */
 
 tree
 get_constraints (tree t)
 {
+  if (!flag_concepts)
+    return NULL_TREE;
+
   gcc_assert (DECL_P (t));
   if (TREE_CODE (t) == TEMPLATE_DECL)
     t = DECL_TEMPLATE_RESULT (t);
@@ -24383,7 +24428,7 @@
 {
   if (!ci)
     return;
-  gcc_assert (t);
+  gcc_assert (t && flag_concepts);
   if (TREE_CODE (t) == TEMPLATE_DECL)
     t = DECL_TEMPLATE_RESULT (t);
   gcc_assert (!get_constraints (t));
@@ -24409,12 +24454,244 @@
     decl_constraints->clear_slot (slot);
 }
 
+/* Memoized satisfaction results for declarations. This
+   maps the pair (constraint_info, arguments) to the result computed
+   by constraints_satisfied_p.  */
+
+struct GTY((for_user)) constraint_sat_entry
+{
+  tree ci;
+  tree args;
+  tree result;
+};
+
+/* Hashing function and equality for constraint entries. */
+
+struct constraint_sat_hasher : ggc_ptr_hash<constraint_sat_entry>
+{
+  static hashval_t hash (constraint_sat_entry *e)
+  {
+    hashval_t val = iterative_hash_object(e->ci, 0);
+    return iterative_hash_template_arg (e->args, val);
+  }
+
+  static bool equal (constraint_sat_entry *e1, constraint_sat_entry *e2)
+  {
+    return e1->ci == e2->ci && comp_template_args (e1->args, e2->args);
+  }
+};
+
+/* Memoized satisfaction results for concept checks. */
+
+struct GTY((for_user)) concept_spec_entry
+{
+  tree tmpl;
+  tree args;
+  tree result;
+};
+
+/* Hashing function and equality for constraint entries.  */
+
+struct concept_spec_hasher : ggc_ptr_hash<concept_spec_entry>
+{
+  static hashval_t hash (concept_spec_entry *e)
+  {
+    return hash_tmpl_and_args (e->tmpl, e->args);
+  }
+
+  static bool equal (concept_spec_entry *e1, concept_spec_entry *e2)
+  {
+    ++comparing_specializations;
+    bool eq = e1->tmpl == e2->tmpl && comp_template_args (e1->args, e2->args);
+    --comparing_specializations;
+    return eq;
+  }
+};
+
+static GTY (()) hash_table<constraint_sat_hasher> *constraint_memos;
+static GTY (()) hash_table<concept_spec_hasher> *concept_memos;
+
+/* Search for a memoized satisfaction result. Returns one of the
+   truth value nodes if previously memoized, or NULL_TREE otherwise.   */
+
+tree
+lookup_constraint_satisfaction (tree ci, tree args)
+{
+  constraint_sat_entry elt = { ci, args, NULL_TREE };
+  constraint_sat_entry* found = constraint_memos->find (&elt);
+  if (found)
+    return found->result;
+  else
+    return NULL_TREE;
+}
+
+/* Memoize the result of a satisfication test. Returns the saved result.  */
+
+tree
+memoize_constraint_satisfaction (tree ci, tree args, tree result)
+{
+  constraint_sat_entry elt = {ci, args, result};
+  constraint_sat_entry** slot = constraint_memos->find_slot (&elt, INSERT);
+  constraint_sat_entry* entry = ggc_alloc<constraint_sat_entry> ();
+  *entry = elt;
+  *slot = entry;
+  return result;
+}
+
+/* Search for a memoized satisfaction result for a concept. */
+
+tree
+lookup_concept_satisfaction (tree tmpl, tree args)
+{
+  concept_spec_entry elt = { tmpl, args, NULL_TREE };
+  concept_spec_entry* found = concept_memos->find (&elt);
+  if (found)
+    return found->result;
+  else
+    return NULL_TREE;
+}
+
+/* Memoize the result of a concept check. Returns the saved result.  */
+
+tree
+memoize_concept_satisfaction (tree tmpl, tree args, tree result)
+{
+  concept_spec_entry elt = {tmpl, args, result};
+  concept_spec_entry** slot = concept_memos->find_slot (&elt, INSERT);
+  concept_spec_entry* entry = ggc_alloc<concept_spec_entry> ();
+  *entry = elt;
+  *slot = entry;
+  return result;
+}
+
+static GTY (()) hash_table<concept_spec_hasher> *concept_expansions;
+
+/* Returns a prior concept specialization. This returns the substituted
+   and normalized constraints defined by the concept.  */
+
+tree
+get_concept_expansion (tree tmpl, tree args)
+{
+  concept_spec_entry elt = { tmpl, args, NULL_TREE };
+  concept_spec_entry* found = concept_expansions->find (&elt);
+  if (found)
+    return found->result;
+  else
+    return NULL_TREE;
+}
+
+/* Save a concept expansion for later.  */
+
+tree
+save_concept_expansion (tree tmpl, tree args, tree def)
+{
+  concept_spec_entry elt = {tmpl, args, def};
+  concept_spec_entry** slot = concept_expansions->find_slot (&elt, INSERT);
+  concept_spec_entry* entry = ggc_alloc<concept_spec_entry> ();
+  *entry = elt;
+  *slot = entry;
+  return def;
+}
+
+static hashval_t
+hash_subsumption_args (tree t1, tree t2)
+{
+  gcc_assert (TREE_CODE (t1) == CHECK_CONSTR);
+  gcc_assert (TREE_CODE (t2) == CHECK_CONSTR);
+  int val = 0;
+  val = iterative_hash_object (CHECK_CONSTR_CONCEPT (t1), val);
+  val = iterative_hash_template_arg (CHECK_CONSTR_ARGS (t1), val);
+  val = iterative_hash_object (CHECK_CONSTR_CONCEPT (t2), val);
+  val = iterative_hash_template_arg (CHECK_CONSTR_ARGS (t2), val);
+  return val;
+}
+
+/* Compare the constraints of two subsumption entries.  The LEFT1 and
+   LEFT2 arguments comprise the first subsumption pair and the RIGHT1
+   and RIGHT2 arguments comprise the second. These are all CHECK_CONSTRs. */
+
+static bool
+comp_subsumption_args (tree left1, tree left2, tree right1, tree right2)
+{
+  if (CHECK_CONSTR_CONCEPT (left1) == CHECK_CONSTR_CONCEPT (right1))
+    if (CHECK_CONSTR_CONCEPT (left2) == CHECK_CONSTR_CONCEPT (right2))
+      if (comp_template_args (CHECK_CONSTR_ARGS (left1),
+                             CHECK_CONSTR_ARGS (right1)))
+        return comp_template_args (CHECK_CONSTR_ARGS (left2),
+                                  CHECK_CONSTR_ARGS (right2));
+  return false;
+}
+
+/* Key/value pair for learning and memoizing subsumption results. This
+   associates a pair of check constraints (including arguments) with
+   a boolean value indicating the result.  */
+
+struct GTY((for_user)) subsumption_entry
+{
+  tree t1;
+  tree t2;
+  bool result;
+};
+
+/* Hashing function and equality for constraint entries.  */
+
+struct subsumption_hasher : ggc_ptr_hash<subsumption_entry>
+{
+  static hashval_t hash (subsumption_entry *e)
+  {
+    return hash_subsumption_args (e->t1, e->t2);
+  }
+
+  static bool equal (subsumption_entry *e1, subsumption_entry *e2)
+  {
+    ++comparing_specializations;
+    bool eq = comp_subsumption_args(e1->t1, e1->t2, e2->t1, e2->t2);
+    --comparing_specializations;
+    return eq;
+  }
+};
+
+static GTY (()) hash_table<subsumption_hasher> *subsumption_table;
+
+/* Search for a previously cached subsumption result. */
+
+bool*
+lookup_subsumption_result (tree t1, tree t2)
+{
+  subsumption_entry elt = { t1, t2, false };
+  subsumption_entry* found = subsumption_table->find (&elt);
+  if (found)
+    return &found->result;
+  else
+    return 0;
+}
+
+/* Save a subsumption result. */
+
+bool
+save_subsumption_result (tree t1, tree t2, bool result)
+{
+  subsumption_entry elt = {t1, t2, result};
+  subsumption_entry** slot = subsumption_table->find_slot (&elt, INSERT);
+  subsumption_entry* entry = ggc_alloc<subsumption_entry> ();
+  *entry = elt;
+  *slot = entry;
+  return result;
+}
+
 /* Set up the hash table for constraint association. */
 
 void
 init_constraint_processing (void)
 {
+  if (!flag_concepts)
+    return;
+
   decl_constraints = hash_table<constr_hasher>::create_ggc(37);
+  constraint_memos = hash_table<constraint_sat_hasher>::create_ggc(37);
+  concept_memos = hash_table<concept_spec_hasher>::create_ggc(37);
+  concept_expansions = hash_table<concept_spec_hasher>::create_ggc(37);
+  subsumption_table = hash_table<subsumption_hasher>::create_ggc(37);
 }
 
 /* Set up the hash tables for template instantiations.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/ptree.c gcc-6-20160721/gcc/cp/ptree.c
--- gcc-6.1.0/gcc/cp/ptree.c	2016-02-10 15:34:45.000000000 +0000
+++ gcc-6-20160721/gcc/cp/ptree.c	2016-07-21 06:18:06.000000000 +0000
@@ -260,7 +260,6 @@
 		      indent+4);
         print_node (file, "associated_constr",
                           cinfo->associated_constr, indent+4);
-        print_node_brief (file, "assumptions", cinfo->assumptions, indent+4);
         break;
       }
     case ARGUMENT_PACK_SELECT:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/search.c gcc-6-20160721/gcc/cp/search.c
--- gcc-6.1.0/gcc/cp/search.c	2016-03-18 01:26:50.000000000 +0000
+++ gcc-6-20160721/gcc/cp/search.c	2016-07-21 06:18:06.000000000 +0000
@@ -947,6 +947,7 @@
      in default arguments for template parameters), and access
      checking should be performed in the outermost parameter list.  */
   if (processing_template_decl
+      && !expanding_concept ()
       && (!processing_template_parmlist || processing_template_decl > 1))
     return 1;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/semantics.c gcc-6-20160721/gcc/cp/semantics.c
--- gcc-6.1.0/gcc/cp/semantics.c	2016-04-20 13:24:17.000000000 +0000
+++ gcc-6-20160721/gcc/cp/semantics.c	2016-07-21 06:29:32.000000000 +0000
@@ -1647,17 +1647,10 @@
       && TREE_CODE (expr) != SCOPE_REF)
     return expr;
 
-  if (TREE_CODE (expr) == COMPONENT_REF)
+  if (TREE_CODE (expr) == COMPONENT_REF
+      || TREE_CODE (expr) == SCOPE_REF)
     REF_PARENTHESIZED_P (expr) = true;
-  else if (type_dependent_expression_p (expr)
-	   /* When processing_template_decl, a SCOPE_REF may actually be
-	      referring to a non-static data member of the current class, in
-	      which case its TREE_TYPE may not be properly cv-qualified (the
-	      cv-qualifiers of the implicit *this object haven't yet been taken
-	      into account) so we have to delay building a static_cast until
-	      instantiation.  */
-	   || (processing_template_decl
-	       && TREE_CODE (expr) == SCOPE_REF))
+  else if (type_dependent_expression_p (expr))
     expr = build1 (PAREN_EXPR, TREE_TYPE (expr), expr);
   else if (VAR_P (expr) && DECL_HARD_REGISTER (expr))
     /* We can't bind a hard register variable to a reference.  */;
@@ -3276,7 +3269,7 @@
   tree initializer = convert_from_reference (decl);
 
   /* Mark it as used now even if the use is ill-formed.  */
-  if (!mark_used (decl, complain) && !(complain & tf_error))
+  if (!mark_used (decl, complain))
     return error_mark_node;
 
   bool saw_generic_lambda = false;
@@ -4507,7 +4500,8 @@
 	      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM)
 	  && !type_dependent_expression_p (t))
 	{
-	  if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))
+	  if (TREE_CODE (TREE_OPERAND (t, 1)) == FIELD_DECL
+	      && DECL_BIT_FIELD (TREE_OPERAND (t, 1)))
 	    {
 	      error_at (OMP_CLAUSE_LOCATION (c),
 			"bit-field %qE in %qs clause",
@@ -4516,7 +4510,8 @@
 	    }
 	  while (TREE_CODE (t) == COMPONENT_REF)
 	    {
-	      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)
+	      if (TREE_TYPE (TREE_OPERAND (t, 0))
+		  && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)
 		{
 		  error_at (OMP_CLAUSE_LOCATION (c),
 			    "%qE is a member of a union", t);
@@ -4524,6 +4519,8 @@
 		}
 	      t = TREE_OPERAND (t, 0);
 	    }
+	  if (REFERENCE_REF_P (t))
+	    t = TREE_OPERAND (t, 0);
 	}
       if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)
 	{
@@ -5884,7 +5881,8 @@
 		}
 	      if (TREE_CODE (type) == REFERENCE_TYPE)
 		type = TREE_TYPE (type);
-	      if (!INTEGRAL_TYPE_P (type)
+	      if (OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_REF
+		  && !INTEGRAL_TYPE_P (type)
 		  && TREE_CODE (type) != POINTER_TYPE)
 		{
 		  error ("linear clause applied to non-integral non-pointer "
@@ -6583,6 +6581,8 @@
 		    {
 		      while (TREE_CODE (t) == COMPONENT_REF)
 			t = TREE_OPERAND (t, 0);
+		      if (REFERENCE_REF_P (t))
+			t = TREE_OPERAND (t, 0);
 		      if (bitmap_bit_p (&map_field_head, DECL_UID (t)))
 			break;
 		      if (bitmap_bit_p (&map_head, DECL_UID (t)))
@@ -6621,7 +6621,8 @@
 	    {
 	      if (type_dependent_expression_p (t))
 		break;
-	      if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))
+	      if (TREE_CODE (TREE_OPERAND (t, 1)) == FIELD_DECL
+		  && DECL_BIT_FIELD (TREE_OPERAND (t, 1)))
 		{
 		  error_at (OMP_CLAUSE_LOCATION (c),
 			    "bit-field %qE in %qs clause",
@@ -6637,8 +6638,9 @@
 		}
 	      while (TREE_CODE (t) == COMPONENT_REF)
 		{
-		  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))
-		      == UNION_TYPE)
+		  if (TREE_TYPE (TREE_OPERAND (t, 0))
+		      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))
+			  == UNION_TYPE))
 		    {
 		      error_at (OMP_CLAUSE_LOCATION (c),
 				"%qE is a member of a union", t);
@@ -6649,6 +6651,8 @@
 		}
 	      if (remove)
 		break;
+	      if (REFERENCE_REF_P (t))
+		t = TREE_OPERAND (t, 0);
 	      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)
 		{
 		  if (bitmap_bit_p (&map_field_head, DECL_UID (t)))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/tree.c gcc-6-20160721/gcc/cp/tree.c
--- gcc-6.1.0/gcc/cp/tree.c	2016-04-13 00:06:51.000000000 +0000
+++ gcc-6-20160721/gcc/cp/tree.c	2016-07-21 06:18:06.000000000 +0000
@@ -3139,6 +3139,11 @@
       return cp_tree_equal (CI_ASSOCIATED_CONSTRAINTS (t1),
                             CI_ASSOCIATED_CONSTRAINTS (t2));
 
+    case CHECK_CONSTR:
+      return (CHECK_CONSTR_CONCEPT (t1) == CHECK_CONSTR_CONCEPT (t2)
+              && comp_template_args (CHECK_CONSTR_ARGS (t1),
+				     CHECK_CONSTR_ARGS (t2)));
+
     case TREE_VEC:
       {
 	unsigned ix;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/typeck.c gcc-6-20160721/gcc/cp/typeck.c
--- gcc-6.1.0/gcc/cp/typeck.c	2016-04-13 00:06:51.000000000 +0000
+++ gcc-6-20160721/gcc/cp/typeck.c	2016-07-19 08:40:37.000000000 +0000
@@ -111,7 +111,7 @@
 
   if (type == error_mark_node || COMPLETE_TYPE_P (type))
     ;
-  else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))
+  else if (TREE_CODE (type) == ARRAY_TYPE)
     {
       tree t = complete_type (TREE_TYPE (type));
       unsigned int needs_constructing, has_nontrivial_dtor;
@@ -6270,8 +6270,7 @@
     }
 
   expr = build_conditional_expr (loc, ifexp, op1, op2, complain);
-  if (processing_template_decl && expr != error_mark_node
-      && TREE_CODE (expr) != VEC_COND_EXPR)
+  if (processing_template_decl && expr != error_mark_node)
     {
       tree min = build_min_non_dep (COND_EXPR, expr,
 				    orig_ifexp, orig_op1, orig_op2);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/cp/typeck2.c gcc-6-20160721/gcc/cp/typeck2.c
--- gcc-6.1.0/gcc/cp/typeck2.c	2016-04-15 04:02:49.000000000 +0000
+++ gcc-6-20160721/gcc/cp/typeck2.c	2016-07-21 06:15:58.000000000 +0000
@@ -539,6 +539,7 @@
       break;
 
     case TYPENAME_TYPE:
+    case DECLTYPE_TYPE:
       emit_diagnostic (diag_kind, loc, 0,
 		       "invalid use of dependent type %qT", type);
       break;
@@ -951,10 +952,12 @@
 	{
 	  if (complain & tf_warning_or_error)
 	    {
-	      if (!almost_ok || pedantic)
-		pedwarn (loc, OPT_Wnarrowing, "narrowing conversion of %qE "
-			 "from %qT to %qT inside { }", init, ftype, type);
-	      if (pedantic && almost_ok)
+	      if ((!almost_ok || pedantic)
+		  && pedwarn (loc, OPT_Wnarrowing,
+			      "narrowing conversion of %qE "
+			      "from %qT to %qT inside { }",
+			      init, ftype, type)
+		  && almost_ok)
 		inform (loc, " the expression has a constant value but is not "
 			"a C++ constant-expression");
 	      ok = true;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/df-problems.c gcc-6-20160721/gcc/df-problems.c
--- gcc-6.1.0/gcc/df-problems.c	2016-02-23 14:01:51.000000000 +0000
+++ gcc-6-20160721/gcc/df-problems.c	2016-06-29 15:15:25.000000000 +0000
@@ -3498,13 +3498,13 @@
 
   FOR_BB_INSNS_REVERSE (bb, insn)
     {
+      if (!INSN_P (insn))
+	continue;
+
       df_insn_info *insn_info = DF_INSN_INFO_GET (insn);
       df_mw_hardreg *mw;
       int debug_insn;
 
-      if (!INSN_P (insn))
-	continue;
-
       debug_insn = DEBUG_INSN_P (insn);
 
       bitmap_clear (do_not_gen);
Only in gcc-6.1.0/gcc/doc: aot-compile.1
Only in gcc-6.1.0/gcc/doc: cpp.1
Only in gcc-6.1.0/gcc/doc: cpp.info
Only in gcc-6.1.0/gcc/doc: cppinternals.info
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/doc/extend.texi gcc-6-20160721/gcc/doc/extend.texi
--- gcc-6.1.0/gcc/doc/extend.texi	2016-04-14 17:35:23.000000000 +0000
+++ gcc-6-20160721/gcc/doc/extend.texi	2016-07-07 19:42:07.000000000 +0000
@@ -962,8 +962,13 @@
 would use the following syntax to declare @code{_Complex128} to be a
 complex @code{__float128} type:
 
+On the PowerPC Linux VSX targets, you can declare complex types using
+the corresponding internal complex type, @code{KCmode} for
+@code{__float128} type and @code{ICmode} for @code{__ibm128} type:
+
 @smallexample
-typedef _Complex float __attribute__((mode(KC))) _Complex128;
+typedef _Complex float __attribute__((mode(KC))) _Complex_float128;
+typedef _Complex float __attribute__((mode(IC))) _Complex_ibm128;
 @end smallexample
 
 Not all targets support additional floating-point types.
@@ -13840,6 +13845,40 @@
 returns the Time Base Register value as an unsigned long, throwing away
 the most significant word on 32-bit environments.
 
+Additional built-in functions are available for the 64-bit PowerPC
+family of processors, for efficient use of 128-bit floating point
+(@code{__float128}) values.
+
+The following floating-point built-in functions are available with
+@code{-mfloat128} and Altivec support.  All of them implement the
+function that is part of the name.
+
+@smallexample
+__float128 __builtin_fabsq (__float128)
+__float128 __builtin_copysignq (__float128, __float128)
+@end smallexample
+
+The following built-in functions are available with @code{-mfloat128}
+and Altivec support.
+
+@table @code
+@item __float128 __builtin_infq (void)
+Similar to @code{__builtin_inf}, except the return type is @code{__float128}.
+@findex __builtin_infq
+
+@item __float128 __builtin_huge_valq (void)
+Similar to @code{__builtin_huge_val}, except the return type is @code{__float128}.
+@findex __builtin_huge_valq
+
+@item __float128 __builtin_nanq (void)
+Similar to @code{__builtin_nan}, except the return type is @code{__float128}.
+@findex __builtin_nanq
+
+@item __float128 __builtin_nansq (void)
+Similar to @code{__builtin_nans}, except the return type is @code{__float128}.
+@findex __builtin_nansq
+@end table
+
 The following built-in functions are available for the PowerPC family
 of processors, starting with ISA 2.06 or later (@option{-mcpu=power7}
 or @option{-mpopcntd}):
@@ -13863,6 +13902,74 @@
 64-bit environment support ISA 2.06 or later.
 
 The following built-in functions are available for the PowerPC family
+of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
+@smallexample
+long long __builtin_darn (void);
+long long __builtin_darn_raw (void);
+int __builtin_darn_32 (void);
+
+int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal128 value);
+int __builtin_dfp_dtstsfi_lt_dd (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_lt_td (unsigned int comparison, _Decimal128 value);
+
+int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal128 value);
+int __builtin_dfp_dtstsfi_gt_dd (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_gt_td (unsigned int comparison, _Decimal128 value);
+
+int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal128 value);
+int __builtin_dfp_dtstsfi_eq_dd (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_eq_td (unsigned int comparison, _Decimal128 value);
+
+int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);
+int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);
+int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);
+@end smallexample
+
+The @code{__builtin_darn} and @code{__builtin_darn_raw}
+functions require a
+64-bit environment supporting ISA 3.0 or later.
+The @code{__builtin_darn} function provides a 64-bit conditioned
+random number.  The @code{__builtin_darn_raw} function provides a
+64-bit raw random number.  The @code{__builtin_darn_32} function
+provides a 32-bit random number.
+
+The @code{__builtin_dfp_dtstsfi_lt} function returns a non-zero value
+if and only if the number of signficant digits of its @code{value} argument
+is less than its @code{comparison} argument.  The
+@code{__builtin_dfp_dtstsfi_lt_dd} and
+@code{__builtin_dfp_dtstsfi_lt_td} functions behave similarly, but
+require that the type of the @code{value} argument be
+@code{__Decimal64} and @code{__Decimal128} respectively.
+
+The @code{__builtin_dfp_dtstsfi_gt} function returns a non-zero value
+if and only if the number of signficant digits of its @code{value} argument
+is greater than its @code{comparison} argument.  The
+@code{__builtin_dfp_dtstsfi_gt_dd} and
+@code{__builtin_dfp_dtstsfi_gt_td} functions behave similarly, but
+require that the type of the @code{value} argument be
+@code{__Decimal64} and @code{__Decimal128} respectively.
+
+The @code{__builtin_dfp_dtstsfi_eq} function returns a non-zero value
+if and only if the number of signficant digits of its @code{value} argument
+equals its @code{comparison} argument.  The
+@code{__builtin_dfp_dtstsfi_eq_dd} and
+@code{__builtin_dfp_dtstsfi_eq_td} functions behave similarly, but
+require that the type of the @code{value} argument be
+@code{__Decimal64} and @code{__Decimal128} respectively.
+
+The @code{__builtin_dfp_dtstsfi_ov} function returns a non-zero value
+if and only if its @code{value} argument has an undefined number of
+significant digits, such as when @code{value} is an encoding of @code{NaN}.
+The @code{__builtin_dfp_dtstsfi_ov_dd} and
+@code{__builtin_dfp_dtstsfi_ov_td} functions behave similarly, but
+require that the type of the @code{value} argument be
+@code{__Decimal64} and @code{__Decimal128} respectively.
+
+The following built-in functions are available for the PowerPC family
 of processors when hardware decimal floating point
 (@option{-mhard-dfp}) is available:
 @smallexample
@@ -15932,6 +16039,18 @@
 void vec_st (vector double, int, double *);
 vector double vec_sub (vector double, vector double);
 vector double vec_trunc (vector double);
+vector double vec_xl (int, vector double *);
+vector double vec_xl (int, double *);
+vector long long vec_xl (int, vector long long *);
+vector long long vec_xl (int, long long *);
+vector unsigned long long vec_xl (int, vector unsigned long long *);
+vector unsigned long long vec_xl (int, unsigned long long *);
+vector float vec_xl (int, vector float *);
+vector float vec_xl (int, float *);
+vector int vec_xl (int, vector int *);
+vector int vec_xl (int, int *);
+vector unsigned int vec_xl (int, vector unsigned int *);
+vector unsigned int vec_xl (int, unsigned int *);
 vector double vec_xor (vector double, vector double);
 vector double vec_xor (vector double, vector bool long);
 vector double vec_xor (vector bool long, vector double);
@@ -15941,6 +16060,18 @@
 vector unsigned long vec_xor (vector unsigned long, vector unsigned long);
 vector unsigned long vec_xor (vector unsigned long, vector bool long);
 vector unsigned long vec_xor (vector bool long, vector unsigned long);
+void vec_xst (vector double, int, vector double *);
+void vec_xst (vector double, int, double *);
+void vec_xst (vector long long, int, vector long long *);
+void vec_xst (vector long long, int, long long *);
+void vec_xst (vector unsigned long long, int, vector unsigned long long *);
+void vec_xst (vector unsigned long long, int, unsigned long long *);
+void vec_xst (vector float, int, vector float *);
+void vec_xst (vector float, int, float *);
+void vec_xst (vector int, int, vector int *);
+void vec_xst (vector int, int, int *);
+void vec_xst (vector unsigned int, int, vector unsigned int *);
+void vec_xst (vector unsigned int, int, unsigned int *);
 int vec_all_eq (vector double, vector double);
 int vec_all_ge (vector double, vector double);
 int vec_all_gt (vector double, vector double);
@@ -16055,7 +16186,7 @@
 @samp{LXVW4X}, @samp{STXVD2X}, and @samp{STXVW4X} instructions.
 
 If the ISA 2.07 additions to the vector/scalar (power8-vector)
-instruction set is available, the following additional functions are
+instruction set are available, the following additional functions are
 available for both 32-bit and 64-bit targets.  For 64-bit targets, you
 can use @var{vector long} instead of @var{vector long long},
 @var{vector bool long} instead of @var{vector bool long long}, and
@@ -16368,7 +16499,7 @@
 @end smallexample
 
 If the ISA 2.07 additions to the vector/scalar (power8-vector)
-instruction set is available, the following additional functions are
+instruction set are available, the following additional functions are
 available for 64-bit targets.  New vector types
 (@var{vector __int128_t} and @var{vector __uint128_t}) are available
 to hold the @var{__int128_t} and @var{__uint128_t} types to use these
@@ -16423,6 +16554,115 @@
 int __builtin_bcdsub_ov (vector __int128_t, vector__int128_t);
 @end smallexample
 
+If the ISA 3.00 additions to the vector/scalar (power9-vector)
+instruction set are available:
+
+@smallexample
+vector long long vec_vctz (vector long long);
+vector unsigned long long vec_vctz (vector unsigned long long);
+vector int vec_vctz (vector int);
+vector unsigned int vec_vctz (vector int);
+vector short vec_vctz (vector short);
+vector unsigned short vec_vctz (vector unsigned short);
+vector signed char vec_vctz (vector signed char);
+vector unsigned char vec_vctz (vector unsigned char);
+
+vector signed char vec_vctzb (vector signed char);
+vector unsigned char vec_vctzb (vector unsigned char);
+
+vector long long vec_vctzd (vector long long);
+vector unsigned long long vec_vctzd (vector unsigned long long);
+
+vector short vec_vctzh (vector short);
+vector unsigned short vec_vctzh (vector unsigned short);
+
+vector int vec_vctzw (vector int);
+vector unsigned int vec_vctzw (vector int);
+
+vector int vec_vprtyb (vector int);
+vector unsigned int vec_vprtyb (vector unsigned int);
+vector long long vec_vprtyb (vector long long);
+vector unsigned long long vec_vprtyb (vector unsigned long long);
+
+vector int vec_vprtybw (vector int);
+vector unsigned int vec_vprtybw (vector unsigned int);
+
+vector long long vec_vprtybd (vector long long);
+vector unsigned long long vec_vprtybd (vector unsigned long long);
+@end smallexample
+
+
+If the ISA 3.00 additions to the vector/scalar (power9-vector)
+instruction set are available for 64-bit targets:
+
+@smallexample
+vector long vec_vprtyb (vector long);
+vector unsigned long vec_vprtyb (vector unsigned long);
+vector __int128_t vec_vprtyb (vector __int128_t);
+vector __uint128_t vec_vprtyb (vector __uint128_t);
+
+vector long vec_vprtybd (vector long);
+vector unsigned long vec_vprtybd (vector unsigned long);
+
+vector __int128_t vec_vprtybq (vector __int128_t);
+vector __uint128_t vec_vprtybd (vector __uint128_t);
+@end smallexample
+
+The following built-in vector functions are available for the PowerPC family
+of processors, starting with ISA 3.0 or later (@option{-mcpu=power9})
+or with @option{-mpower9-vector}:
+
+@smallexample
+__vector unsigned char
+vec_absd (__vector unsigned char arg1, __vector unsigned char arg2);
+__vector unsigned short
+vec_absd (__vector unsigned short arg1, __vector unsigned short arg2);
+__vector unsigned int
+vec_absd (__vector unsigned int arg1, __vector unsigned int arg2);
+
+__vector unsigned char
+vec_absdb (__vector unsigned char arg1, __vector unsigned char arg2);
+__vector unsigned short
+vec_absdh (__vector unsigned short arg1, __vector unsigned short arg2);
+__vector unsigned int
+vec_absdw (__vector unsigned int arg1, __vector unsigned int arg2);
+
+__vector unsigned char
+vec_slv (__vector unsigned char src, __vector unsigned char shift_distance);
+__vector unsigned char
+vec_srv (__vector unsigned char src, __vector unsigned char shift_distance);
+@end smallexample
+
+The @code{vec_absd}, @code{vec_absdb}, @code{vec_absdh}, and
+@code{vec_absdw} built-in functions each computes the absolute
+differences of the pairs of vector elements supplied in its two vector
+arguments, placing the absolute differences into the corresponding
+elements of the vector result.
+
+The @code{vec_slv} and @code{vec_srv} functions operate on
+all of the bytes of their @code{src} and @code{shift_distance}
+arguments in parallel.  The behavior of the @code{vec_slv} is as if
+there existed a temporary array of 17 unsigned characters
+@code{slv_array} within which elements 0 through 15 are the same as
+the entries in the @code{src} array and element 16 equals 0.  The
+result returned from the @code{vec_slv} function is a
+@code{__vector} of 16 unsigned characters within which element
+@code{i} is computed using the C expression
+@code{0xff & (*((unsigned short *)(slv_array + i)) << (0x07 &
+shift_distance[i]))},
+with this resulting value coerced to the @code{unsigned char} type.
+The behavior of the @code{vec_srv} is as if
+there existed a temporary array of 17 unsigned characters
+@code{srv_array} within which element 0 equals zero and
+elements 1 through 16 equal the elements 0 through 15 of
+the @code{src} array.  The
+result returned from the @code{vec_srv} function is a
+@code{__vector} of 16 unsigned characters within which element
+@code{i} is computed using the C expression
+@code{0xff & (*((unsigned short *)(srv_array + i)) >>
+(0x07 & shift_distance[i]))},
+with this resulting value coerced to the @code{unsigned char} type.
+
 If the cryptographic instructions are enabled (@option{-mcrypto} or
 @option{-mcpu=power8}), the following builtins are enabled.
 
@@ -16483,6 +16723,28 @@
 integer that is 0 or 1.  The third argument to these builtin functions
 must be a constant integer in the range of 0 to 15.
 
+If the ISA 3.00 additions to the vector/scalar (power9-vector)
+instruction set are available, the following additional functions are
+available for both 32-bit and 64-bit targets.
+
+vector short vec_xl (int, vector short *);
+vector short vec_xl (int, short *);
+vector unsigned short vec_xl (int, vector unsigned short *);
+vector unsigned short vec_xl (int, unsigned short *);
+vector char vec_xl (int, vector char *);
+vector char vec_xl (int, char *);
+vector unsigned char vec_xl (int, vector unsigned char *);
+vector unsigned char vec_xl (int, unsigned char *);
+
+void vec_xst (vector short, int, vector short *);
+void vec_xst (vector short, int, short *);
+void vec_xst (vector unsigned short, int, vector unsigned short *);
+void vec_xst (vector unsigned short, int, unsigned short *);
+void vec_xst (vector char, int, vector char *);
+void vec_xst (vector char, int, char *);
+void vec_xst (vector unsigned char, int, vector unsigned char *);
+void vec_xst (vector unsigned char, int, unsigned char *);
+
 @node PowerPC Hardware Transactional Memory Built-in Functions
 @subsection PowerPC Hardware Transactional Memory Built-in Functions
 GCC provides two interfaces for accessing the Hardware Transactional
@@ -17116,6 +17378,45 @@
 int64_t __builtin_vis_xmulxhi (int64_t, int64_t);
 @end smallexample
 
+When you use the @option{-mvis4} switch, the VIS version 4.0 built-in
+functions also become available:
+
+@smallexample
+v8qi __builtin_vis_fpadd8 (v8qi, v8qi);
+v8qi __builtin_vis_fpadds8 (v8qi, v8qi);
+v8qi __builtin_vis_fpaddus8 (v8qi, v8qi);
+v4hi __builtin_vis_fpaddus16 (v4hi, v4hi);
+
+v8qi __builtin_vis_fpsub8 (v8qi, v8qi);
+v8qi __builtin_vis_fpsubs8 (v8qi, v8qi);
+v8qi __builtin_vis_fpsubus8 (v8qi, v8qi);
+v4hi __builtin_vis_fpsubus16 (v4hi, v4hi);
+
+long __builtin_vis_fpcmple8 (v8qi, v8qi);
+long __builtin_vis_fpcmpgt8 (v8qi, v8qi);
+long __builtin_vis_fpcmpule16 (v4hi, v4hi);
+long __builtin_vis_fpcmpugt16 (v4hi, v4hi);
+long __builtin_vis_fpcmpule32 (v2si, v2si);
+long __builtin_vis_fpcmpugt32 (v2si, v2si);
+
+v8qi __builtin_vis_fpmax8 (v8qi, v8qi);
+v4hi __builtin_vis_fpmax16 (v4hi, v4hi);
+v2si __builtin_vis_fpmax32 (v2si, v2si);
+
+v8qi __builtin_vis_fpmaxu8 (v8qi, v8qi);
+v4hi __builtin_vis_fpmaxu16 (v4hi, v4hi);
+v2si __builtin_vis_fpmaxu32 (v2si, v2si);
+
+
+v8qi __builtin_vis_fpmin8 (v8qi, v8qi);
+v4hi __builtin_vis_fpmin16 (v4hi, v4hi);
+v2si __builtin_vis_fpmin32 (v2si, v2si);
+
+v8qi __builtin_vis_fpminu8 (v8qi, v8qi);
+v4hi __builtin_vis_fpminu16 (v4hi, v4hi);
+v2si __builtin_vis_fpminu32 (v2si, v2si);
+@end smallexample
+
 @node SPU Built-in Functions
 @subsection SPU Built-in Functions
 
Only in gcc-6.1.0/gcc/doc: fsf-funding.7
Only in gcc-6.1.0/gcc/doc: g++.1
Only in gcc-6.1.0/gcc/doc: gc-analyze.1
Only in gcc-6.1.0/gcc/doc: gcc.1
Only in gcc-6.1.0/gcc/doc: gcc.info
Only in gcc-6.1.0/gcc/doc: gccinstall.info
Only in gcc-6.1.0/gcc/doc: gccint.info
Only in gcc-6.1.0/gcc/doc: gcj-dbtool.1
Only in gcc-6.1.0/gcc/doc: gcj.1
Only in gcc-6.1.0/gcc/doc: gcj.info
Only in gcc-6.1.0/gcc/doc: gcov-tool.1
Only in gcc-6.1.0/gcc/doc: gcov.1
Only in gcc-6.1.0/gcc/doc: gfdl.7
Only in gcc-6.1.0/gcc/doc: gfortran.1
Only in gcc-6.1.0/gcc/doc: gij.1
Only in gcc-6.1.0/gcc/doc: gpl.7
Only in gcc-6.1.0/gcc/doc: grmic.1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/doc/install.texi gcc-6-20160721/gcc/doc/install.texi
--- gcc-6.1.0/gcc/doc/install.texi	2016-04-18 18:42:41.000000000 +0000
+++ gcc-6-20160721/gcc/doc/install.texi	2016-06-08 13:34:25.000000000 +0000
@@ -1241,7 +1241,7 @@
 PowerPC, and SPARC@.  It is mandatory for ARC@.  The @option{--with-cpu-32} and
 @option{--with-cpu-64} options specify separate default CPUs for
 32-bit and 64-bit modes; these options are only supported for i386,
-x86-64 and PowerPC.
+x86-64, PowerPC, and SPARC@.
 
 @item --with-schedule=@var{cpu}
 @itemx --with-arch=@var{cpu}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/doc/invoke.texi gcc-6-20160721/gcc/doc/invoke.texi
--- gcc-6.1.0/gcc/doc/invoke.texi	2016-04-22 13:17:26.000000000 +0000
+++ gcc-6-20160721/gcc/doc/invoke.texi	2016-07-08 14:51:44.000000000 +0000
@@ -996,14 +996,15 @@
 -mpointers-to-nested-functions -mno-pointers-to-nested-functions @gol
 -msave-toc-indirect -mno-save-toc-indirect @gol
 -mpower8-fusion -mno-mpower8-fusion -mpower8-vector -mno-power8-vector @gol
--mcrypto -mno-crypto -mdirect-move -mno-direct-move @gol
+-mcrypto -mno-crypto -mhtm -mno-htm -mdirect-move -mno-direct-move @gol
 -mquad-memory -mno-quad-memory @gol
 -mquad-memory-atomic -mno-quad-memory-atomic @gol
 -mcompat-align-parm -mno-compat-align-parm @gol
 -mupper-regs-df -mno-upper-regs-df -mupper-regs-sf -mno-upper-regs-sf @gol
 -mupper-regs -mno-upper-regs -mmodulo -mno-modulo @gol
 -mfloat128 -mno-float128 -mfloat128-hardware -mno-float128-hardware @gol
--mpower9-fusion -mno-mpower9-fusion -mpower9-vector -mno-power9-vector}
+-mpower9-fusion -mno-mpower9-fusion -mpower9-vector -mno-power9-vector @gol
+-mpower9-dform -mno-power9-dform -mlra -mno-lra}
 
 @emph{RX Options}
 @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol
@@ -13669,7 +13670,6 @@
 optimizers then assume that indexed stores exist, which is not
 the case.
 
-@item -mlra
 @opindex mlra
 Enable Local Register Allocation.  This is still experimental for ARC,
 so by default the compiler uses standard reload
@@ -19879,9 +19879,9 @@
 -mpopcntb -mpopcntd  -mpowerpc64 @gol
 -mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float @gol
 -msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol
--mcrypto -mdirect-move -mpower8-fusion -mpower8-vector @gol
+-mcrypto -mdirect-move -mhtm -mpower8-fusion -mpower8-vector @gol
 -mquad-memory -mquad-memory-atomic -mmodulo -mfloat128 -mfloat128-hardware @gol
--mpower9-fusion -mpower9-vector}
+-mpower9-fusion -mpower9-vector -mpower9-dform}
 
 The particular options set for any particular CPU varies between
 compiler versions, depending on what setting seems to produce optimal
@@ -20005,6 +20005,12 @@
 This switch has been deprecated.  Use @option{-misel} and
 @option{-mno-isel} instead.
 
+@item -mlra
+@opindex mlra
+Enable Local Register Allocation.  This is still experimental for PowerPC,
+so by default the compiler uses standard reload
+(i.e. @option{-mno-lra}).
+
 @item -mspe
 @itemx -mno-spe
 @opindex mspe
@@ -20047,6 +20053,14 @@
 between the general purpose registers and the vector/scalar (VSX)
 registers that were added in version 2.07 of the PowerPC ISA.
 
+@item -mhtm
+@itemx -mno-htm
+@opindex mhtm
+@opindex mno-htm
+Enable (disable) the use of the built-in functions that allow direct
+access to the Hardware Transactional Memory (HTM) instructions that
+were added in version 2.07 of the PowerPC ISA.
+
 @item -mpower8-fusion
 @itemx -mno-power8-fusion
 @opindex mpower8-fusion
@@ -20123,9 +20137,14 @@
 
 The VSX instruction set (@option{-mvsx}, @option{-mcpu=power7}, or
 @option{-mcpu=power8}) must be enabled to use the @option{-mfloat128}
-option.  The @code{-mfloat128} option only works on PowerPC 64-bit
+option.  The @option{-mfloat128} option only works on PowerPC 64-bit
 Linux systems.
 
+If you use the ISA 3.0 instruction set (@option{-mcpu=power9}), the
+@option{-mfloat128} option will also enable the generation of ISA 3.0
+IEEE 128-bit floating point instructions.  Otherwise, IEEE 128-bit
+floating point will be done with software emulation.
+
 @item -mfloat128-hardware
 @itemx -mno-float128-hardware
 @opindex mfloat128-hardware
@@ -20133,6 +20152,13 @@
 Enable/disable using ISA 3.0 hardware instructions to support the
 @var{__float128} data type.
 
+If you use @option{-mfloat128-hardware}, it will enable the option
+@option{-mfloat128} as well.
+
+If you select ISA 3.0 instructions with @option{-mcpu=power9}, but do
+not use either @option{-mfloat128} or @option{-mfloat128-hardware},
+the IEEE 128-bit floating point support will not be enabled.
+
 @item -mmodulo
 @itemx -mno-modulo
 @opindex mmodulo
@@ -20154,10 +20180,19 @@
 @opindex mpower9-vector
 @opindex mno-power9-vector
 Generate code that uses (does not use) the vector and scalar
-instructions that were added in version 2.07 of the PowerPC ISA.  Also
+instructions that were added in version 3.0 of the PowerPC ISA.  Also
 enable the use of built-in functions that allow more direct access to
 the vector instructions.
 
+@item -mpower9-dform
+@itemx -mno-power9-dform
+@opindex mpower9-dform
+@opindex mno-power9-dform
+Enable (disable) scalar d-form (register + offset) memory instructions
+to load/store traditional Altivec registers. If the @var{LRA} register
+allocator is enabled, also enable (disable) vector d-form memory
+instructions.
+
 @item -mfloat-gprs=@var{yes/single/double/no}
 @itemx -mfloat-gprs
 @opindex mfloat-gprs
@@ -22070,7 +22105,7 @@
 @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{sparclite}, @samp{f930},
 @samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701}, @samp{v9},
 @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2},
-@samp{niagara3} and @samp{niagara4}.
+@samp{niagara3}, @samp{niagara4} and @samp{niagara7}.
 
 Native Solaris and GNU/Linux toolchains also support the value @samp{native},
 which selects the best architecture option for the host processor.
@@ -22098,7 +22133,7 @@
 tsc701
 
 @item v9
-ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4
+ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4, niagara7
 @end table
 
 By default (unless configured otherwise), GCC generates code for the V7
@@ -22140,7 +22175,9 @@
 additionally optimizes it for Sun UltraSPARC T2 chips. With
 @option{-mcpu=niagara3}, the compiler additionally optimizes it for Sun
 UltraSPARC T3 chips.  With @option{-mcpu=niagara4}, the compiler
-additionally optimizes it for Sun UltraSPARC T4 chips.
+additionally optimizes it for Sun UltraSPARC T4 chips.  With
+@option{-mcpu=niagara7}, the compiler additionally optimizes it for
+Oracle SPARC M7 chips.
 
 @item -mtune=@var{cpu_type}
 @opindex mtune
@@ -22150,12 +22187,13 @@
 
 The same values for @option{-mcpu=@var{cpu_type}} can be used for
 @option{-mtune=@var{cpu_type}}, but the only useful values are those
-that select a particular CPU implementation.  Those are @samp{cypress},
-@samp{supersparc}, @samp{hypersparc}, @samp{leon}, @samp{leon3},
-@samp{leon3v7}, @samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{tsc701},
-@samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2},
-@samp{niagara3} and @samp{niagara4}.  With native Solaris and GNU/Linux
-toolchains, @samp{native} can also be used.
+that select a particular CPU implementation.  Those are
+@samp{cypress}, @samp{supersparc}, @samp{hypersparc}, @samp{leon},
+@samp{leon3}, @samp{leon3v7}, @samp{f930}, @samp{f934},
+@samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc},
+@samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3},
+@samp{niagara4} and @samp{niagara7}.  With native Solaris and
+GNU/Linux toolchains, @samp{native} can also be used.
 
 @item -mv8plus
 @itemx -mno-v8plus
@@ -22193,6 +22231,16 @@
 instructions, such as niagara-3 and later.  Setting @option{-mvis3}
 also sets @option{-mvis2} and @option{-mvis}.
 
+@item -mvis4
+@itemx -mno-vis4
+@opindex mvis4
+@opindex mno-vis4
+With @option{-mvis4}, GCC generates code that takes advantage of
+version 4.0 of the UltraSPARC Visual Instruction Set extensions.  The
+default is @option{-mvis4} when targeting a cpu that supports such
+instructions, such as niagara-7 and later.  Setting @option{-mvis4}
+also sets @option{-mvis3}, @option{-mvis2} and @option{-mvis}.
+
 @item -mcbcond
 @itemx -mno-cbcond
 @opindex mcbcond
Only in gcc-6.1.0/gcc/doc: jcf-dump.1
Only in gcc-6.1.0/gcc/doc: jv-convert.1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/doc/md.texi gcc-6-20160721/gcc/doc/md.texi
--- gcc-6.1.0/gcc/doc/md.texi	2016-02-22 21:27:08.000000000 +0000
+++ gcc-6-20160721/gcc/doc/md.texi	2016-06-09 23:28:23.000000000 +0000
@@ -3214,6 +3214,9 @@
 @item wD
 Int constant that is the element number of the 64-bit scalar in a vector.
 
+@item wE
+Vector constant that can be loaded with the XXSPLTIB instruction.
+
 @item wF
 Memory operand suitable for power9 fusion load/stores.
 
@@ -3221,13 +3224,22 @@
 Memory operand suitable for TOC fusion memory references.
 
 @item wL
-Int constant that is the element number that the MFVSRLD instruction
+Int constant that is the element number that the MFVSRLD instruction.
 targets.
 
+@item wM
+Match vector constant with all 1's if the XXLORC instruction is available.
+
+@item wO
+A memory operand suitable for the ISA 3.0 vector d-form instructions.
+
 @item wQ
 A memory address that will work with the @code{lq} and @code{stq}
 instructions.
 
+@item wS
+Vector constant that can be loaded with XXSPLTIB & sign extension.
+
 @item h
 @samp{MQ}, @samp{CTR}, or @samp{LINK} register
 
Only in gcc-6.1.0/gcc/doc: rebuild-gcj-db.1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/dwarf2out.c gcc-6-20160721/gcc/dwarf2out.c
--- gcc-6.1.0/gcc/dwarf2out.c	2016-03-17 13:43:01.000000000 +0000
+++ gcc-6-20160721/gcc/dwarf2out.c	2016-07-19 19:31:24.000000000 +0000
@@ -15573,7 +15573,7 @@
 
 	    if (stack_usage == NULL)
 	      return false;
-	    frame_offset += *stack_usage;
+	    frame_offset_ += *stack_usage;
 	    break;
 	  }
 
@@ -17805,7 +17805,7 @@
 	      fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));
 	      pos = int_byte_position (field);
 	      gcc_assert (pos + fieldsize <= size);
-	      if (val
+	      if (val && fieldsize != 0
 		  && !native_encode_initializer (val, array + pos, fieldsize))
 		return false;
 	    }
@@ -19401,11 +19401,13 @@
 static void
 retry_incomplete_types (void)
 {
+  set_early_dwarf s;
   int i;
 
   for (i = vec_safe_length (incomplete_types) - 1; i >= 0; i--)
     if (should_emit_struct_debug ((*incomplete_types)[i], DINFO_USAGE_DIR_USE))
       gen_type_die ((*incomplete_types)[i], comp_unit_die ());
+  vec_safe_truncate (incomplete_types, 0);
 }
 
 /* Determine what tag to use for a record type.  */
@@ -20724,14 +20726,17 @@
 	 void_type_node 2) an unprototyped function declaration (not a
 	 definition).  This just means that we have no info about the
 	 parameters at all.  */
-      if (prototype_p (TREE_TYPE (decl)))
+      if (early_dwarf)
 	{
-	  /* This is the prototyped case, check for....  */
-	  if (stdarg_p (TREE_TYPE (decl)))
+	  if (prototype_p (TREE_TYPE (decl)))
+	    {
+	      /* This is the prototyped case, check for....  */
+	      if (stdarg_p (TREE_TYPE (decl)))
+		gen_unspecified_parameters_die (decl, subr_die);
+	    }
+	  else if (DECL_INITIAL (decl) == NULL_TREE)
 	    gen_unspecified_parameters_die (decl, subr_die);
 	}
-      else if (DECL_INITIAL (decl) == NULL_TREE)
-	gen_unspecified_parameters_die (decl, subr_die);
     }
 
   if (subr_die != old_die)
@@ -27382,10 +27387,6 @@
   resolve_addr (comp_unit_die ());
   move_marked_base_types ();
 
-  /* Walk through the list of incomplete types again, trying once more to
-     emit full debugging info for them.  */
-  retry_incomplete_types ();
-
   if (flag_eliminate_unused_debug_types)
     prune_unused_types ();
 
@@ -27686,6 +27687,10 @@
 static void
 dwarf2out_early_finish (void)
 {
+  /* Walk through the list of incomplete types again, trying once more to
+     emit full debugging info for them.  */
+  retry_incomplete_types ();
+
   /* The point here is to flush out the limbo list so that it is empty
      and we don't need to stream it for LTO.  */
   flush_limbo_die_list ();
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fold-const.c gcc-6-20160721/gcc/fold-const.c
--- gcc-6.1.0/gcc/fold-const.c	2016-04-21 11:57:28.000000000 +0000
+++ gcc-6-20160721/gcc/fold-const.c	2016-07-08 20:20:23.000000000 +0000
@@ -117,14 +117,8 @@
 static int operand_equal_for_comparison_p (tree, tree, tree);
 static int twoval_comparison_p (tree, tree *, tree *, int *);
 static tree eval_subst (location_t, tree, tree, tree, tree, tree);
-static tree make_bit_field_ref (location_t, tree, tree,
-				HOST_WIDE_INT, HOST_WIDE_INT, int, int);
 static tree optimize_bit_field_compare (location_t, enum tree_code,
 					tree, tree, tree);
-static tree decode_field_reference (location_t, tree, HOST_WIDE_INT *,
-				    HOST_WIDE_INT *,
-				    machine_mode *, int *, int *, int *,
-				    tree *, tree *);
 static int simple_operand_p (const_tree);
 static bool simple_operand_p_2 (tree);
 static tree range_binop (enum tree_code, tree, tree, int, tree, int);
@@ -836,11 +830,10 @@
 	*minus_litp = *litp, *litp = 0;
       if (neg_conp_p)
 	*conp = negate_expr (*conp);
-      if (neg_var_p)
+      if (neg_var_p && var)
 	{
-	  /* Convert to TYPE before negating a pointer type expr.  */
-	  if (var && POINTER_TYPE_P (TREE_TYPE (var)))
-	    var = fold_convert_loc (loc, type, var);
+	  /* Convert to TYPE before negating.  */
+	  var = fold_convert_loc (loc, type, var);
 	  var = negate_expr (var);
 	}
     }
@@ -863,10 +856,12 @@
       else if (*minus_litp)
 	*litp = *minus_litp, *minus_litp = 0;
       *conp = negate_expr (*conp);
-      /* Convert to TYPE before negating a pointer type expr.  */
-      if (var && POINTER_TYPE_P (TREE_TYPE (var)))
-	var = fold_convert_loc (loc, type, var);
-      var = negate_expr (var);
+      if (var)
+	{
+	  /* Convert to TYPE before negating.  */
+	  var = fold_convert_loc (loc, type, var);
+	  var = negate_expr (var);
+	}
     }
 
   return var;
@@ -2199,7 +2194,6 @@
 
     case REAL_TYPE:
     case FIXED_POINT_TYPE:
-    case COMPLEX_TYPE:
     case VECTOR_TYPE:
     case VOID_TYPE:
       return TREE_CODE (type) == TREE_CODE (orig);
@@ -3781,15 +3775,23 @@
 
 /* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER
    starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero
-   and uses reverse storage order if REVERSEP is nonzero.  */
+   and uses reverse storage order if REVERSEP is nonzero.  ORIG_INNER
+   is the original memory reference used to preserve the alias set of
+   the access.  */
 
 static tree
-make_bit_field_ref (location_t loc, tree inner, tree type,
+make_bit_field_ref (location_t loc, tree inner, tree orig_inner, tree type,
 		    HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,
 		    int unsignedp, int reversep)
 {
   tree result, bftype;
 
+  if (get_alias_set (inner) != get_alias_set (orig_inner))
+    inner = fold_build2 (MEM_REF, TREE_TYPE (inner),
+			 build_fold_addr_expr (inner),
+			 build_int_cst
+			  (reference_alias_ptr_type (orig_inner), 0));
+
   if (bitpos == 0 && !reversep)
     {
       tree size = TYPE_SIZE (TREE_TYPE (inner));
@@ -3915,13 +3917,13 @@
        and return.  */
     return fold_build2_loc (loc, code, compare_type,
 			fold_build2_loc (loc, BIT_AND_EXPR, unsigned_type,
-				     make_bit_field_ref (loc, linner,
+				     make_bit_field_ref (loc, linner, lhs,
 							 unsigned_type,
 							 nbitsize, nbitpos,
 							 1, lreversep),
 				     mask),
 			fold_build2_loc (loc, BIT_AND_EXPR, unsigned_type,
-				     make_bit_field_ref (loc, rinner,
+				     make_bit_field_ref (loc, rinner, rhs,
 							 unsigned_type,
 							 nbitsize, nbitpos,
 							 1, rreversep),
@@ -3966,8 +3968,8 @@
   /* Make a new bitfield reference, shift the constant over the
      appropriate number of bits and mask it with the computed mask
      (in case this was a signed field).  If we changed it, make a new one.  */
-  lhs = make_bit_field_ref (loc, linner, unsigned_type, nbitsize, nbitpos, 1,
-			    lreversep);
+  lhs = make_bit_field_ref (loc, linner, lhs, unsigned_type,
+			    nbitsize, nbitpos, 1, lreversep);
 
   rhs = const_binop (BIT_AND_EXPR,
 		     const_binop (LSHIFT_EXPR,
@@ -4006,11 +4008,12 @@
    do anything with.  */
 
 static tree
-decode_field_reference (location_t loc, tree exp, HOST_WIDE_INT *pbitsize,
+decode_field_reference (location_t loc, tree *exp_, HOST_WIDE_INT *pbitsize,
 			HOST_WIDE_INT *pbitpos, machine_mode *pmode,
 			int *punsignedp, int *preversep, int *pvolatilep,
 			tree *pmask, tree *pand_mask)
 {
+  tree exp = *exp_;
   tree outer_type = 0;
   tree and_mask = 0;
   tree mask, inner, offset;
@@ -4047,6 +4050,8 @@
       || TREE_CODE (inner) == PLACEHOLDER_EXPR)
     return 0;
 
+  *exp_ = exp;
+
   /* If the number of bits in the reference is the same as the bitsize of
      the outer type, then the outer type gives the signedness. Otherwise
      (in case of a small bitfield) the signedness is unchanged.  */
@@ -5655,19 +5660,19 @@
 
   ll_reversep = lr_reversep = rl_reversep = rr_reversep = 0;
   volatilep = 0;
-  ll_inner = decode_field_reference (loc, ll_arg,
+  ll_inner = decode_field_reference (loc, &ll_arg,
 				     &ll_bitsize, &ll_bitpos, &ll_mode,
 				     &ll_unsignedp, &ll_reversep, &volatilep,
 				     &ll_mask, &ll_and_mask);
-  lr_inner = decode_field_reference (loc, lr_arg,
+  lr_inner = decode_field_reference (loc, &lr_arg,
 				     &lr_bitsize, &lr_bitpos, &lr_mode,
 				     &lr_unsignedp, &lr_reversep, &volatilep,
 				     &lr_mask, &lr_and_mask);
-  rl_inner = decode_field_reference (loc, rl_arg,
+  rl_inner = decode_field_reference (loc, &rl_arg,
 				     &rl_bitsize, &rl_bitpos, &rl_mode,
 				     &rl_unsignedp, &rl_reversep, &volatilep,
 				     &rl_mask, &rl_and_mask);
-  rr_inner = decode_field_reference (loc, rr_arg,
+  rr_inner = decode_field_reference (loc, &rr_arg,
 				     &rr_bitsize, &rr_bitpos, &rr_mode,
 				     &rr_unsignedp, &rr_reversep, &volatilep,
 				     &rr_mask, &rr_and_mask);
@@ -5829,12 +5834,14 @@
       lr_mask = const_binop (BIT_IOR_EXPR, lr_mask, rr_mask);
       if (lnbitsize == rnbitsize && xll_bitpos == xlr_bitpos)
 	{
-	  lhs = make_bit_field_ref (loc, ll_inner, lntype, lnbitsize, lnbitpos,
+	  lhs = make_bit_field_ref (loc, ll_inner, ll_arg,
+				    lntype, lnbitsize, lnbitpos,
 				    ll_unsignedp || rl_unsignedp, ll_reversep);
 	  if (! all_ones_mask_p (ll_mask, lnbitsize))
 	    lhs = build2 (BIT_AND_EXPR, lntype, lhs, ll_mask);
 
-	  rhs = make_bit_field_ref (loc, lr_inner, rntype, rnbitsize, rnbitpos,
+	  rhs = make_bit_field_ref (loc, lr_inner, lr_arg,
+				    rntype, rnbitsize, rnbitpos,
 				    lr_unsignedp || rr_unsignedp, lr_reversep);
 	  if (! all_ones_mask_p (lr_mask, rnbitsize))
 	    rhs = build2 (BIT_AND_EXPR, rntype, rhs, lr_mask);
@@ -5856,11 +5863,11 @@
 	{
 	  tree type;
 
-	  lhs = make_bit_field_ref (loc, ll_inner, lntype,
+	  lhs = make_bit_field_ref (loc, ll_inner, ll_arg, lntype,
 				    ll_bitsize + rl_bitsize,
 				    MIN (ll_bitpos, rl_bitpos),
 				    ll_unsignedp, ll_reversep);
-	  rhs = make_bit_field_ref (loc, lr_inner, rntype,
+	  rhs = make_bit_field_ref (loc, lr_inner, lr_arg, rntype,
 				    lr_bitsize + rr_bitsize,
 				    MIN (lr_bitpos, rr_bitpos),
 				    lr_unsignedp, lr_reversep);
@@ -5925,7 +5932,8 @@
      reference we will make.  Unless the mask is all ones the width of
      that field, perform the mask operation.  Then compare with the
      merged constant.  */
-  result = make_bit_field_ref (loc, ll_inner, lntype, lnbitsize, lnbitpos,
+  result = make_bit_field_ref (loc, ll_inner, ll_arg,
+			       lntype, lnbitsize, lnbitpos,
 			       ll_unsignedp || rl_unsignedp, ll_reversep);
 
   ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask);
@@ -7934,6 +7942,8 @@
     case VIEW_CONVERT_EXPR:
       if (TREE_CODE (op0) == MEM_REF)
         {
+	  if (TYPE_ALIGN (TREE_TYPE (op0)) != TYPE_ALIGN (type))
+	    type = build_aligned_type (type, TYPE_ALIGN (TREE_TYPE (op0)));
 	  tem = fold_build2_loc (loc, MEM_REF, type,
 				 TREE_OPERAND (op0, 0), TREE_OPERAND (op0, 1));
 	  REF_REVERSE_STORAGE_ORDER (tem) = REF_REVERSE_STORAGE_ORDER (op0);
@@ -8566,9 +8576,9 @@
 	  if ((offset0 == offset1
 	       || (offset0 && offset1
 		   && operand_equal_p (offset0, offset1, 0)))
-	      && (code == EQ_EXPR
-		  || code == NE_EXPR
-		  || (indirect_base0 && DECL_P (base0))
+	      && (equality_code
+		  || (indirect_base0
+		      && (DECL_P (base0) || CONSTANT_CLASS_P (base0)))
 		  || POINTER_TYPE_OVERFLOW_UNDEFINED))
 
 	    {
@@ -8607,7 +8617,8 @@
 	     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */
 	  else if (bitpos0 == bitpos1
 		   && (equality_code
-		       || (indirect_base0 && DECL_P (base0))
+		       || (indirect_base0
+			   && (DECL_P (base0) || CONSTANT_CLASS_P (base0)))
 		       || POINTER_TYPE_OVERFLOW_UNDEFINED))
 	    {
 	      /* By converting to signed sizetype we cover middle-end pointer
@@ -10514,11 +10525,15 @@
 	      || TREE_CODE (arg0) == BIT_IOR_EXPR
 	      || TREE_CODE (arg0) == BIT_XOR_EXPR)
 	  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)
-	return fold_build2_loc (loc, TREE_CODE (arg0), type,
-			    fold_build2_loc (loc, code, type,
-					 TREE_OPERAND (arg0, 0), arg1),
-			    fold_build2_loc (loc, code, type,
-					 TREE_OPERAND (arg0, 1), arg1));
+	{
+	  tree arg00 = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));
+	  tree arg01 = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 1));
+	  return fold_build2_loc (loc, TREE_CODE (arg0), type,
+				  fold_build2_loc (loc, code, type,
+						   arg00, arg1),
+				  fold_build2_loc (loc, code, type,
+						   arg01, arg1));
+	}
 
       /* Two consecutive rotates adding up to the some integer
 	 multiple of the precision of the type can be ignored.  */
@@ -10527,7 +10542,7 @@
 	  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST
 	  && wi::umod_trunc (wi::add (arg1, TREE_OPERAND (arg0, 1)),
 			     prec) == 0)
-	return TREE_OPERAND (arg0, 0);
+	return fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));
 
       return NULL_TREE;
 
@@ -11631,9 +11646,9 @@
       /* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR
 	 over COND_EXPR in cases such as floating point comparisons.  */
       if (integer_zerop (op1)
-	  && (code == VEC_COND_EXPR ? integer_all_onesp (op2)
-				    : (integer_onep (op2)
-				       && !VECTOR_TYPE_P (type)))
+	  && code == COND_EXPR
+	  && integer_onep (op2)
+	  && !VECTOR_TYPE_P (type)
 	  && truth_value_p (TREE_CODE (arg0)))
 	return pedantic_non_lvalue_loc (loc,
 				    fold_convert_loc (loc, type,
@@ -12305,7 +12320,8 @@
 	       || TYPE_REFERENCE_TO (expr)
 	       || TYPE_CACHED_VALUES_P (expr)
 	       || TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr)
-	       || TYPE_NEXT_VARIANT (expr)))
+	       || TYPE_NEXT_VARIANT (expr)
+	       || TYPE_ALIAS_SET_KNOWN_P (expr)))
     {
       /* Allow these fields to be modified.  */
       tree tmp;
@@ -12315,6 +12331,7 @@
       TYPE_POINTER_TO (tmp) = NULL;
       TYPE_REFERENCE_TO (tmp) = NULL;
       TYPE_NEXT_VARIANT (tmp) = NULL;
+      TYPE_ALIAS_SET (tmp) = -1;
       if (TYPE_CACHED_VALUES_P (tmp))
 	{
 	  TYPE_CACHED_VALUES_P (tmp) = 0;
@@ -13549,6 +13566,9 @@
 	if (!DECL_P (base))
 	  base = get_base_address (base);
 
+	if (base && TREE_CODE (base) == TARGET_EXPR)
+	  base = TARGET_EXPR_SLOT (base);
+
 	if (!base)
 	  return false;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/ChangeLog gcc-6-20160721/gcc/fortran/ChangeLog
--- gcc-6.1.0/gcc/fortran/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/ChangeLog	2016-07-16 03:54:12.000000000 +0000
@@ -1,3 +1,249 @@
+2016-07-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk:
+	PR fortran/71764
+	* trans-expr.c (gfc_trans_structure_assign): Remove assert.
+
+2016-07-13  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	Backport from trunk:
+	PR fortran/71623
+	* trans-stmt.c (gfc_trans_allocate): Add code of pre block of typespec
+	in allocate to parent block.
+
+2016-07-09  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk:
+	PR fortran/71783
+	* frontend-passes.c (create_var):  Always allocate a charlen
+	for character variables.
+
+2016-07-08  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from trunk:
+	2016-07-08  Cesar Philippidis  <cesar@codesourcery.com>
+
+	* parse.c (matcha): Define.
+	(decode_oacc_directive): Add spec_only local var and set it.  Use
+	matcha to parse acc directives except for routine and declare.  Return
+	ST_GET_FCN_CHARACTERISTICS if a non-declarative directive could be
+	matched.
+
+2016-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/71687
+	* f95-lang.c (struct binding_level): Add reversed field.
+	(clear_binding_level): Adjust initializer.
+	(getdecls): If reversed is clear, set it and nreverse the names
+	chain before returning it.
+	(poplevel): Use getdecls.
+	* trans-decl.c (gfc_generate_function_code, gfc_process_block_locals):
+	Use nreverse to pushdecl decls in the declaration order.
+
+	PR fortran/71717
+	* trans-openmp.c (gfc_omp_privatize_by_reference): Return false
+	for GFC_DECL_ASSOCIATE_VAR_P with POINTER_TYPE.
+
+	2016-06-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/71704
+	* parse.c (matchs, matcho): Move right before decode_omp_directive.
+	If spec_only, only gfc_match the keyword and if successful, goto
+	do_spec_only.
+	(matchds, matchdo): Define.
+	(decode_omp_directive): Add spec_only local var and set it.
+	Use matchds or matchdo macros instead of matchs or matcho
+	for declare target, declare simd, declare reduction and threadprivate
+	directives.  Return ST_GET_FCN_CHARACTERISTICS if a non-declarative
+	directive could be matched.
+	(next_statement): For ST_GET_FCN_CHARACTERISTICS restore
+	gfc_current_locus from old_locus even if there is no label.
+
+	PR fortran/71705
+	* trans-openmp.c (gfc_trans_omp_clauses): Set TREE_ADDRESSABLE on
+	decls in to/from clauses.
+
+2016-06-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Back port from trunk
+	2016-06-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	* openmp.c (match_oacc_clause_gang): Rename to ...
+	(match_oacc_clause_gwv): this.  Add support for OpenACC worker and
+	vector clauses.
+	(gfc_match_omp_clauses): Use match_oacc_clause_gwv for
+	OMP_CLAUSE_{GANG,WORKER,VECTOR}.  Propagate any MATCH_ERRORs for
+	invalid OMP_CLAUSE_{ASYNC,WAIT,GANG,WORKER,VECTOR} clauses.
+	(gfc_match_oacc_wait): Propagate MATCH_ERROR for invalid
+	oacc_expr_lists.  Adjust the first and needs_space arguments to
+	gfc_match_omp_clauses.
+
+2016-06-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/70673
+	* frontend-passes.c (realloc_string_callback): Add a call to
+	gfc_dep_compare_expr.
+
+2016-06-12  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR fortran/60751
+	* io.c (gfc_resolve_dt): Replace GFC_STD_GNU with GFC_STD_LEGACY.
+
+2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR c/71381
+	Backport from trunk r237290:
+	* openmp.c (gfc_match_oacc_cache): Add comment.
+
+2016-06-05  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/69659
+	* trans-array.c (gfc_trans_dummy_array_bias): For class arrays use
+	the address of the _data component to reference the arrays data
+	component.
+
+2016-06-01  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/71156
+	* decl.c (copy_prefix): Add checks that the module procedure
+	declaration prefixes are compliant with the interface. Invert
+	order of existing elemental and pure checks.
+	* resolve.c (resolve_fl_procedure): Invert order of elemental
+	and pure errors.
+
+2016-06-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* parse.c (case_decl): Move ST_OMP_* to ...
+	(case_omp_decl): ... here, new macro.
+	(verify_st_order): For case_omp_decl, complain about
+	p->state >= ORDER_EXEC, but don't change p->state otherwise.
+
+2016-05-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/66461
+	* scanner.c (gfc_next_char_literal): Clear end_flag when adjusting
+	current locus back to old_locus.
+
+2016-05-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/71204
+	* frontend-passes.c (realloc_string_callback): Clear inserted_block
+	and changed_statement before calling create_var.
+
+2016-05-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/69603
+	* interface.c (compare_parameter): Check for non-NULL pointer.
+
+2016-05-14  Fritz Reese  <fritzoreese@gmail.com>
+
+	Backport from trunk: r236242
+	* gfortran.texi: Update example of DEC UNION extension.
+
+	Backport from trunk: r236241
+	PR fortran/71047
+	* expr.c (gfc_default_initializer): Avoid extra component refs in
+	constructors for derived types and classes.
+
+	Backport from trunk: r235999
+	PR fortran/56226
+	* module.c (dt_upper_string): Rename to gfc_dt_upper_string
+	(dt_lower_string): Likewise.
+	* gfortran.h: Make new gfc_dt_upper/lower_string global.
+	* class.c: Use gfc_dt_upper_string.
+	* decl.c: Likewise.
+	* symbol.c: Likewise.
+	* resolve.c (resolve_component): New function.
+	(resolve_fl_derived0): Move component loop code to resolve_component.
+	* parse.c (check_component): New function.
+	(parse_derived): Move loop code to check_component.
+	* lang.opt, invoke.texi, options.c : New option -fdec-structure.
+	* libgfortran.h (bt): New basic type BT_UNION.
+	* gfortran.h (gfc_option): New option -fdec-structure.
+	(gfc_get_union_type, gfc_compare_union_types): New prototypes.
+	(gfc_bt_struct, gfc_fl_struct, case_bt_struct, case_fl_struct): New
+	macros.
+	(gfc_find_component): Change prototype.
+	* match.h (gfc_match_member_sep, gfc_match_map, gfc_match_union,
+	gfc_match_structure_decl): New prototypes.
+	* parse.h (gfc_comp_struct): New macro.
+	* symbol.c (gfc_find_component): Search for components in nested unions
+	* class.c (insert_component_ref, gfc_add_component_ref, add_proc_comp,
+	copy_vtab_proc_comps): Update calls to gfc_find_component.
+	* primary.c (gfc_convert_to_structure_constructor): Likewise.
+	* symbol.c (gfc_add_component): Likewise.
+	* resolve.c (resolve_typebound_function, resolve_typebound_subroutine,
+	resolve_typebound_procedure, resolve_component, resolve_fl_derived):
+	Likewise.
+	* expr.c (get_union_init, component_init): New functions.
+	* decl.c (match_clist_expr, match_record_decl, get_struct_decl,
+	gfc_match_map, gfc_match_union, gfc_match_structure_decl): Likewise.
+	* interface.c (compare_components, gfc_compare_union_types): Likewise.
+	* match.c (gfc_match_member_sep): Likewise.
+	* parse.c (check_component, parse_union, parse_struct_map): Likewise.
+	* resolve.c (resolve_fl_struct): Likewise.
+	* symbol.c (find_union_component): Likewise.
+	* trans-types.c (gfc_get_union_type): Likewise.
+	* parse.c (parse_derived): Use new functions.
+	* interface.c (gfc_compare_derived_types, gfc_compare_types): Likewise.
+	* expr.c (gfc_default_initializer): Likewise.
+	* gfortran.texi: Support for DEC structures, unions, and maps.
+	* gfortran.h (gfc_statement, sym_flavor): Likewise.
+	* check.c (gfc_check_kill_sub): Likewise.
+	* expr.c (gfc_copy_expr, simplify_const_ref,
+	gfc_has_default_initializer): Likewise.
+	* decl.c (build_sym, match_data_constant, add_init_expr_to_sym,
+	match_pointer_init, build_struct, variable_decl,
+	gfc_match_decl_type_spec, gfc_mach_data-decl, gfc_match_entry,
+	gfc_match_end, gfc_match_derived_decl): Likewise.
+	* interface.c (check_interface0, check_interface1,
+	gfc_search_interface): Likewise.
+	* misc.c (gfc_basic_typename, gfc_typename): Likewise.
+	* module.c (add_true_name, build_tnt, bt_types, mio_typespec,
+	fix_mio_expr, load_needed, mio_symbol, read_module, write_symbol,
+	gfc_get_module_backend_decl): Likewise.
+	* parse.h (gfc_compile_state): Likewise.
+	* parse.c (decode_specification_statement, decode_statement,
+	gfc_ascii_statement, verify_st_order, parse_spec): Likewise.
+	* primary.c (gfc_match_varspec, gfc_match_structure_constructor,
+	gfc_match_rvalue, match_variable): Likewise.
+	* resolve.c (find_arglists, resolve_structure_cons,
+	is_illegal_recursion, resolve_generic_f, get_declared_from_expr,
+	resolve_typebound_subroutine, resolve_allocate_expr,
+	nonscalar_typebound_assign, generate_component_assignments,
+	resolve_fl_variable_derived, check_defined_assignments,
+	resolve_component, resolve_symbol, resolve_equivalence_derived):
+	Likewise.
+	* symbol.c (flavors, check_conflict, gfc_add_flavor, gfc_use_derived,
+	gfc_restore_last_undo_checkpoint, gfc_type_compatible,
+	gfc_find_dt_in_generic): Likewise.
+	* trans-decl.c (gfc_get_module_backend_decl, create_function_arglist,
+	gfc_create_module_variable, check_constant_initializer): Likewise.
+	* trans-expr.c (gfc_conv_component_ref, gfc_conv_initializer,
+	gfc_trans_alloc_subarray_assign, gfc_trans_subcomponent_assign,
+	gfc_conv_structure, gfc_trans_scalar_assign, copyable_array_p):
+	Likewise.
+	* trans-io.c (transfer_namelist_element, transfer_expr,
+	gfc_trans_transfer): Likewise.
+	* trans-stmt.c (gfc_trans_deallocate): Likewise.
+	* trans-types.c (gfc_typenode_for_spec, gfc_copy_dt_decls_ifequal,
+	gfc_get_derived_type): Likewise.
+
+2016-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/70855
+	* frontend-passes.c (inline_matmul_assign): Disable in !$omp workshare.
+
+2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR middle-end/70626
+	* trans-openmp.c (gfc_trans_oacc_combined_directive): Duplicate
+	the reduction clause in both parallel and loop directives.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/check.c gcc-6-20160721/gcc/fortran/check.c
--- gcc-6.1.0/gcc/fortran/check.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/check.c	2016-05-14 19:52:46.000000000 +0000
@@ -2592,7 +2592,7 @@
 bool
 gfc_check_kind (gfc_expr *x)
 {
-  if (x->ts.type == BT_DERIVED || x->ts.type == BT_CLASS)
+  if (gfc_bt_struct (x->ts.type) || x->ts.type == BT_CLASS)
     {
       gfc_error ("%qs argument of %qs intrinsic at %L must be of "
 		 "intrinsic type", gfc_current_intrinsic_arg[0]->name,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/class.c gcc-6-20160721/gcc/fortran/class.c
--- gcc-6.1.0/gcc/fortran/class.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/class.c	2016-05-14 19:52:46.000000000 +0000
@@ -78,12 +78,11 @@
   gcc_assert (ts->type == BT_DERIVED || ts->type == BT_CLASS);
   type_sym = ts->u.derived;
 
-  new_ref = gfc_get_ref ();
-  new_ref->type = REF_COMPONENT;
-  new_ref->next = *ref;
-  new_ref->u.c.sym = type_sym;
-  new_ref->u.c.component = gfc_find_component (type_sym, name, true, true);
+  gfc_find_component (type_sym, name, true, true, &new_ref);
   gcc_assert (new_ref->u.c.component);
+  while (new_ref->next)
+    new_ref = new_ref->next;
+  new_ref->next = *ref;
 
   if (new_ref->next)
     {
@@ -206,8 +205,9 @@
 void
 gfc_add_component_ref (gfc_expr *e, const char *name)
 {
+  gfc_component *c;
   gfc_ref **tail = &(e->ref);
-  gfc_ref *next = NULL;
+  gfc_ref *ref, *next = NULL;
   gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;
   while (*tail != NULL)
     {
@@ -237,14 +237,13 @@
   else
     /* Avoid losing memory.  */
     gfc_free_ref_list (*tail);
-  (*tail) = gfc_get_ref();
-  (*tail)->next = next;
-  (*tail)->type = REF_COMPONENT;
-  (*tail)->u.c.sym = derived;
-  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);
-  gcc_assert((*tail)->u.c.component);
+  c = gfc_find_component (derived, name, true, true, tail);
+  gcc_assert (c);
+  for (ref = *tail; ref->next; ref = ref->next)
+    ;
+  ref->next = next;
   if (!next)
-    e->ts = (*tail)->u.c.component->ts;
+    e->ts = c->ts;
 }
 
 
@@ -477,8 +476,7 @@
   if (derived->attr.unlimited_polymorphic)
     strcpy (dt_name, "STAR");
   else
-    strcpy (dt_name, derived->name);
-  dt_name[0] = TOUPPER (dt_name[0]);
+    strcpy (dt_name, gfc_dt_upper_string (derived->name));
   if (derived->attr.unlimited_polymorphic)
     sprintf (string, "_%s", dt_name);
   else if (derived->module)
@@ -751,7 +749,7 @@
   if (tb->non_overridable)
     return;
 
-  c = gfc_find_component (vtype, name, true, true);
+  c = gfc_find_component (vtype, name, true, true, NULL);
 
   if (c == NULL)
     {
@@ -820,7 +818,7 @@
 
   for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)
     {
-      if (gfc_find_component (vtype, cmp->name, true, true))
+      if (gfc_find_component (vtype, cmp->name, true, true, NULL))
 	continue;
 
       add_proc_comp (vtype, cmp->name, cmp->tb);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/decl.c gcc-6-20160721/gcc/fortran/decl.c
--- gcc-6.1.0/gcc/fortran/decl.c	2016-03-12 13:59:10.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/decl.c	2016-06-01 18:46:11.000000000 +0000
@@ -391,13 +391,13 @@
 
   if (sym == NULL
       || (sym->attr.flavor != FL_PARAMETER
-	  && (!dt_sym || dt_sym->attr.flavor != FL_DERIVED)))
+	  && (!dt_sym || !gfc_fl_struct (dt_sym->attr.flavor))))
     {
       gfc_error ("Symbol %qs must be a PARAMETER in DATA statement at %C",
 		 name);
       return MATCH_ERROR;
     }
-  else if (dt_sym && dt_sym->attr.flavor == FL_DERIVED)
+  else if (dt_sym && gfc_fl_struct (dt_sym->attr.flavor))
     return gfc_match_structure_constructor (dt_sym, result);
 
   /* Check to see if the value is an initialization array expression.  */
@@ -606,6 +606,161 @@
 /************************ Declaration statements *********************/
 
 
+/* Like gfc_match_init_expr, but matches a 'clist' (old-style initialization
+   list). The difference here is the expression is a list of constants
+   and is surrounded by '/'. 
+   The typespec ts must match the typespec of the variable which the
+   clist is initializing.
+   The arrayspec tells whether this should match a list of constants 
+   corresponding to array elements or a scalar (as == NULL).  */
+
+static match
+match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
+{
+  gfc_constructor_base array_head = NULL;
+  gfc_expr *expr = NULL;
+  match m;
+  locus where;
+  mpz_t repeat, size;
+  bool scalar;
+  int cmp;
+
+  gcc_assert (ts);
+
+  mpz_init_set_ui (repeat, 0);
+  mpz_init (size);
+  scalar = !as || !as->rank;
+
+  /* We have already matched '/' - now look for a constant list, as with
+     top_val_list from decl.c, but append the result to an array.  */
+  if (gfc_match ("/") == MATCH_YES)
+    {
+      gfc_error ("Empty old style initializer list at %C");
+      goto cleanup;
+    }
+
+  where = gfc_current_locus;
+  for (;;)
+    {
+      m = match_data_constant (&expr);
+      if (m != MATCH_YES)
+        expr = NULL; /* match_data_constant may set expr to garbage */
+      if (m == MATCH_NO)
+        goto syntax;
+      if (m == MATCH_ERROR)
+        goto cleanup;
+
+      /* Found r in repeat spec r*c; look for the constant to repeat.  */
+      if ( gfc_match_char ('*') == MATCH_YES)
+        {
+          if (scalar)
+            {
+              gfc_error ("Repeat spec invalid in scalar initializer at %C");
+              goto cleanup;
+            }
+          if (expr->ts.type != BT_INTEGER)
+            {
+              gfc_error ("Repeat spec must be an integer at %C");
+              goto cleanup;
+            }
+          mpz_set (repeat, expr->value.integer);
+          gfc_free_expr (expr);
+          expr = NULL;
+
+          m = match_data_constant (&expr);
+          if (m == MATCH_NO)
+            gfc_error ("Expected data constant after repeat spec at %C");
+          if (m != MATCH_YES)
+            goto cleanup;
+        }
+      /* No repeat spec, we matched the data constant itself. */
+      else
+        mpz_set_ui (repeat, 1);
+
+      if (!scalar)
+        {
+          /* Add the constant initializer as many times as repeated. */
+          for (; mpz_cmp_ui (repeat, 0) > 0; mpz_sub_ui (repeat, repeat, 1))
+            {
+              /* Make sure types of elements match */
+              if(ts && !gfc_compare_types (&expr->ts, ts)
+                    && !gfc_convert_type (expr, ts, 1))
+                goto cleanup;
+
+              gfc_constructor_append_expr (&array_head,
+                  gfc_copy_expr (expr), &gfc_current_locus);
+            }
+
+          gfc_free_expr (expr);
+          expr = NULL;
+        }
+
+      /* For scalar initializers quit after one element.  */
+      else
+        {
+          if(gfc_match_char ('/') != MATCH_YES)
+            {
+              gfc_error ("End of scalar initializer expected at %C");
+              goto cleanup;
+            }
+          break;
+        }
+
+      if (gfc_match_char ('/') == MATCH_YES)
+        break;
+      if (gfc_match_char (',') == MATCH_NO)
+        goto syntax;
+    }
+
+  /* Set up expr as an array constructor. */
+  if (!scalar)
+    {
+      expr = gfc_get_array_expr (ts->type, ts->kind, &where);
+      expr->ts = *ts;
+      expr->value.constructor = array_head;
+
+      expr->rank = as->rank;
+      expr->shape = gfc_get_shape (expr->rank);
+
+      /* Validate sizes. */
+      gcc_assert (gfc_array_size (expr, &size));
+      gcc_assert (spec_size (as, &repeat));
+      cmp = mpz_cmp (size, repeat);
+      if (cmp < 0)
+        gfc_error ("Not enough elements in array initializer at %C");
+      else if (cmp > 0)
+        gfc_error ("Too many elements in array initializer at %C");
+      if (cmp)
+        goto cleanup;
+    }
+
+  /* Make sure scalar types match. */
+  else if (!gfc_compare_types (&expr->ts, ts)
+           && !gfc_convert_type (expr, ts, 1))
+    goto cleanup;
+
+  if (expr->ts.u.cl)
+    expr->ts.u.cl->length_from_typespec = 1;
+
+  *result = expr;
+  mpz_clear (size);
+  mpz_clear (repeat);
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in old style initializer list at %C");
+
+cleanup:
+  if (expr)
+    expr->value.constructor = NULL;
+  gfc_free_expr (expr);
+  gfc_constructor_free (array_head);
+  mpz_clear (size);
+  mpz_clear (repeat);
+  return MATCH_ERROR;
+}
+
+
 /* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */
 
 static bool
@@ -1239,7 +1394,8 @@
 
       st = gfc_find_symtree (gfc_current_ns->sym_root, u_name);
 
-      if (st != 0)
+      /* STRUCTURE types can alias symbol names */
+      if (st != 0 && st->n.sym->attr.flavor != FL_STRUCT)
 	{
 	  gfc_error ("Symbol %qs at %C also declared as a type at %L", name,
 		     &st->n.sym->declared_at);
@@ -1469,7 +1625,7 @@
 
       /* Check if the assignment can happen. This has to be put off
 	 until later for derived type variables and procedure pointers.  */
-      if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (sym->ts.type) && !gfc_bt_struct (init->ts.type)
 	  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS
 	  && !sym->attr.proc_pointer
 	  && !gfc_check_assign_symbol (sym, NULL, init))
@@ -1608,7 +1764,7 @@
 	 If we mark my_int as iso_c (since we can see it's value
 	 is equal to one of the named constants), then my_int_2
 	 will be considered C interoperable.  */
-      if (sym->ts.type != BT_CHARACTER && sym->ts.type != BT_DERIVED)
+      if (sym->ts.type != BT_CHARACTER && !gfc_bt_struct (sym->ts.type))
 	{
 	  sym->ts.is_iso_c |= init->ts.is_iso_c;
 	  sym->ts.is_c_interop |= init->ts.is_c_interop;
@@ -1666,6 +1822,7 @@
 build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
 	      gfc_array_spec **as)
 {
+  gfc_state_data *s;
   gfc_component *c;
   bool t = true;
 
@@ -1689,6 +1846,35 @@
 	}
     }
 
+  /* If we are in a nested union/map definition, gfc_add_component will not
+     properly find repeated components because:
+       (i) gfc_add_component does a flat search, where components of unions 
+           and maps are implicity chained so nested components may conflict.
+      (ii) Unions and maps are not linked as components of their parent
+           structures until after they are parsed.
+     For (i) we use gfc_find_component which searches recursively, and for (ii)
+     we search each block directly from the parse stack until we find the top
+     level structure.  */
+
+  s = gfc_state_stack;
+  if (s->state == COMP_UNION || s->state == COMP_MAP)
+    {
+      while (s->state == COMP_UNION || gfc_comp_struct (s->state))
+        {
+          c = gfc_find_component (s->sym, name, true, true, NULL);
+          if (c != NULL)
+            {
+              gfc_error_now ("Component '%s' at %C already declared at %L",
+                             name, &c->loc);
+              return false;
+            }
+          /* Break after we've searched the entire chain.  */
+          if (s->state == COMP_DERIVED || s->state == COMP_STRUCTURE)
+            break;
+          s = s->previous;
+        }
+    }
+
   if (!gfc_add_component (gfc_current_block(), name, &c))
     return false;
 
@@ -1868,7 +2054,7 @@
 {
   match m;
 
-  if (gfc_pure (NULL) && gfc_state_stack->state != COMP_DERIVED)
+  if (gfc_pure (NULL) && !gfc_comp_struct (gfc_state_stack->state))
     {
       gfc_error ("Initialization of pointer at %C is not allowed in "
 		 "a PURE procedure");
@@ -2062,7 +2248,7 @@
   /*  If this symbol has already shown up in a Cray Pointer declaration,
       and this is not a component declaration,
       then we want to set the type & bail out.  */
-  if (flag_cray_pointer && gfc_current_state () != COMP_DERIVED)
+  if (flag_cray_pointer && !gfc_comp_struct (gfc_current_state ()))
     {
       gfc_find_symbol (name, gfc_current_ns, 1, &sym);
       if (sym != NULL && sym->attr.cray_pointee)
@@ -2127,7 +2313,7 @@
      For components of derived types, it is not true, so we don't
      create a symbol for those yet.  If we fail to create the symbol,
      bail out.  */
-  if (gfc_current_state () != COMP_DERIVED
+  if (!gfc_comp_struct (gfc_current_state ())
       && !build_sym (name, cl, cl_deferred, &as, &var_locus))
     {
       m = MATCH_ERROR;
@@ -2154,6 +2340,9 @@
       if (!gfc_notify_std (GFC_STD_GNU, "Old-style "
 			   "initialization at %C"))
 	return MATCH_ERROR;
+
+      /* Allow old style initializations for components of STRUCTUREs and MAPs
+         but not components of derived types.  */
       else if (gfc_current_state () == COMP_DERIVED)
 	{
 	  gfc_error ("Invalid old style initialization for derived type "
@@ -2162,7 +2351,23 @@
 	  goto cleanup;
 	}
 
-      return match_old_style_init (name);
+      /* For structure components, read the initializer as a special
+         expression and let the rest of this function apply the initializer
+         as usual.  */
+      else if (gfc_comp_struct (gfc_current_state ()))
+        {
+          m = match_clist_expr (&initializer, &current_ts, as);
+          if (m == MATCH_NO)
+            gfc_error ("Syntax error in old style initialization of %s at %C",
+                       name);
+          if (m != MATCH_YES)
+            goto cleanup;
+        }
+
+      /* Otherwise we treat the old style initialization just like a
+         DATA declaration for the current variable.  */
+      else
+        return match_old_style_init (name);
     }
 
   /* The double colon must be present in order to have initializers.
@@ -2200,7 +2405,7 @@
 	    }
 
 	  if (current_attr.flavor != FL_PARAMETER && gfc_pure (NULL)
-	      && gfc_state_stack->state != COMP_DERIVED)
+	      && !gfc_comp_struct (gfc_state_stack->state))
 	    {
 	      gfc_error ("Initialization of variable at %C is not allowed in "
 			 "a PURE procedure");
@@ -2208,7 +2413,7 @@
 	    }
 
 	  if (current_attr.flavor != FL_PARAMETER
-	      && gfc_state_stack->state != COMP_DERIVED)
+	      && !gfc_comp_struct (gfc_state_stack->state))
 	    gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
 	  if (m != MATCH_YES)
@@ -2217,7 +2422,7 @@
     }
 
   if (initializer != NULL && current_attr.allocatable
-	&& gfc_current_state () == COMP_DERIVED)
+	&& gfc_comp_struct (gfc_current_state ()))
     {
       gfc_error ("Initialization of allocatable component at %C is not "
 		 "allowed");
@@ -2228,7 +2433,7 @@
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
-  if (gfc_current_state () != COMP_DERIVED)
+  if (!gfc_comp_struct (gfc_current_state ()))
     t = add_init_expr_to_sym (name, &initializer, &var_locus);
   else
     {
@@ -2236,6 +2441,12 @@
 	  && !current_attr.pointer && !initializer)
 	initializer = gfc_default_initializer (&current_ts);
       t = build_struct (name, cl, &initializer, &as);
+
+      /* If we match a nested structure definition we expect to see the
+       * body even if the variable declarations blow up, so we need to keep
+       * the structure declaration around.  */
+      if (gfc_new_block && gfc_new_block->attr.flavor == FL_STRUCT)
+        gfc_commit_symbol (gfc_new_block);
     }
 
   m = (t) ? MATCH_YES : MATCH_ERROR;
@@ -2724,6 +2935,36 @@
 }
 
 
+/* Matches a RECORD declaration. */
+
+static match
+match_record_decl (const char *name)
+{
+    locus old_loc;
+    old_loc = gfc_current_locus;
+
+    if (gfc_match (" record") == MATCH_YES)
+      {
+          if (!gfc_option.flag_dec_structure)
+            {
+                gfc_current_locus = old_loc;
+                gfc_error ("RECORD at %C is an extension, enable it with "
+                           "-fdec-structure");
+                return MATCH_ERROR;
+            }
+          if (gfc_match (" /%n/", name) != MATCH_YES)
+            {
+                gfc_error ("Structure name expected after RECORD at %C");
+                gfc_current_locus = old_loc;
+                return MATCH_ERROR;
+            }
+          return MATCH_YES;
+      }
+
+    gfc_current_locus = old_loc;
+    return MATCH_NO;
+}
+
 /* Matches a declaration-type-spec (F03:R502).  If successful, sets the ts
    structure to the matched specification.  This is necessary for FUNCTION and
    IMPLICIT statements.
@@ -2781,7 +3022,7 @@
 	{
 	  if ((m = gfc_match ("*)")) != MATCH_YES)
 	    return m;
-	  if (gfc_current_state () == COMP_DERIVED)
+	  if (gfc_comp_struct (gfc_current_state ()))
 	    {
 	      gfc_error ("Assumed type at %C is not allowed for components");
 	      return MATCH_ERROR;
@@ -2892,10 +3133,51 @@
   if (matched_type)
     m = gfc_match_char (')');
 
-  if (m == MATCH_YES)
-    ts->type = BT_DERIVED;
+  if (m != MATCH_YES)
+    m = match_record_decl (name);
+
+  if (matched_type || m == MATCH_YES)
+    {
+      ts->type = BT_DERIVED;
+      /* We accept record/s/ or type(s) where s is a structure, but we
+       * don't need all the extra derived-type stuff for structures.  */
+      if (gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &sym))
+        {
+          gfc_error ("Type name '%s' at %C is ambiguous", name);
+          return MATCH_ERROR;
+        }
+      if (sym && sym->attr.flavor == FL_STRUCT)
+        {
+          ts->u.derived = sym;
+          return MATCH_YES;
+        }
+      /* Actually a derived type.  */
+    }
+
   else
     {
+      /* Match nested STRUCTURE declarations; only valid within another
+         structure declaration.  */
+      m = gfc_match (" structure");
+      if (m == MATCH_ERROR)
+        return MATCH_ERROR;
+      else if (m == MATCH_YES)
+        {
+          if (   gfc_current_state () != COMP_STRUCTURE
+              && gfc_current_state () != COMP_MAP)
+              return MATCH_ERROR;
+
+          m = gfc_match_structure_decl ();
+          if (m == MATCH_YES)
+            {
+              /* gfc_new_block is updated by match_structure_decl.  */
+              ts->type = BT_DERIVED;
+              ts->u.derived = gfc_new_block;
+              return MATCH_YES;
+            }
+          return MATCH_ERROR;
+        }
+
       /* Match CLASS declarations.  */
       m = gfc_match (" class ( * )");
       if (m == MATCH_ERROR)
@@ -2964,9 +3246,7 @@
      stored in a symtree with the first letter of the name capitalized; the
      symtree with the all lower-case name contains the associated
      generic function.  */
-  dt_name = gfc_get_string ("%c%s",
-			    (char) TOUPPER ((unsigned char) name[0]),
-			    (const char*)&name[1]);
+  dt_name = gfc_dt_upper_string (name);
   sym = NULL;
   dt_sym = NULL;
   if (ts->kind != -1)
@@ -2998,7 +3278,7 @@
 	return MATCH_NO;
     }
 
-  if ((sym->attr.flavor != FL_UNKNOWN
+  if ((sym->attr.flavor != FL_UNKNOWN && sym->attr.flavor != FL_STRUCT
        && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))
       || sym->attr.subroutine)
     {
@@ -3038,7 +3318,7 @@
 
   gfc_set_sym_referenced (dt_sym);
 
-  if (dt_sym->attr.flavor != FL_DERIVED
+  if (dt_sym->attr.flavor != FL_DERIVED && dt_sym->attr.flavor != FL_STRUCT
       && !gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL))
     return MATCH_ERROR;
 
@@ -3480,9 +3760,7 @@
 		 letter of the name capitalized; the symtree with the all
 		 lower-case name contains the associated generic function.  */
 	      st = gfc_new_symtree (&gfc_current_ns->sym_root,
-			gfc_get_string ("%c%s",
-				(char) TOUPPER ((unsigned char) name[0]),
-				&name[1]));
+                                    gfc_dt_upper_string (name));
 	      st->n.sym = sym;
 	      sym->refs++;
 	      sym->attr.imported = 1;
@@ -4497,7 +4775,7 @@
     return m;
 
   if ((current_ts.type == BT_DERIVED || current_ts.type == BT_CLASS)
-	&& gfc_current_state () != COMP_DERIVED)
+	&& !gfc_comp_struct (gfc_current_state ()))
     {
       sym = gfc_use_derived (current_ts.u.derived);
 
@@ -4526,17 +4804,19 @@
       && !current_ts.u.derived->attr.zero_comp)
     {
 
-      if (current_attr.pointer && gfc_current_state () == COMP_DERIVED)
+      if (current_attr.pointer && gfc_comp_struct (gfc_current_state ()))
 	goto ok;
 
       gfc_find_symbol (current_ts.u.derived->name,
 		       current_ts.u.derived->ns, 1, &sym);
 
       /* Any symbol that we find had better be a type definition
-	 which has its components defined.  */
-      if (sym != NULL && sym->attr.flavor == FL_DERIVED
+	 which has its components defined, or be a structure definition
+         actively being parsed.  */
+      if (sym != NULL && gfc_fl_struct (sym->attr.flavor)
 	  && (current_ts.u.derived->components != NULL
-	      || current_ts.u.derived->attr.zero_comp))
+	      || current_ts.u.derived->attr.zero_comp
+	      || current_ts.u.derived == gfc_new_block))
 	goto ok;
 
       gfc_error ("Derived type at %C has not been previously defined "
@@ -4698,12 +4978,51 @@
 static bool
 copy_prefix (symbol_attribute *dest, locus *where)
 {
-  if (current_attr.pure && !gfc_add_pure (dest, where))
+  if (dest->module_procedure)
+    {
+      if (current_attr.elemental)
+	dest->elemental = 1;
+
+      if (current_attr.pure)
+	dest->pure = 1;
+
+      if (current_attr.recursive)
+	dest->recursive = 1;
+
+      /* Module procedures are unusual in that the 'dest' is copied from
+	 the interface declaration. However, this is an oportunity to
+	 check that the submodule declaration is compliant with the
+	 interface.  */
+      if (dest->elemental && !current_attr.elemental)
+	{
+	  gfc_error ("ELEMENTAL prefix in MODULE PROCEDURE interface is "
+		     "missing at %L", where);
     return false;
+	}
+
+      if (dest->pure && !current_attr.pure)
+	{
+	  gfc_error ("PURE prefix in MODULE PROCEDURE interface is "
+		     "missing at %L", where);
+	  return false;
+	}
+
+      if (dest->recursive && !current_attr.recursive)
+	{
+	  gfc_error ("RECURSIVE prefix in MODULE PROCEDURE interface is "
+		     "missing at %L", where);
+	  return false;
+	}
+
+      return true;
+    }
 
   if (current_attr.elemental && !gfc_add_elemental (dest, where))
     return false;
 
+  if (current_attr.pure && !gfc_add_pure (dest, where))
+    return false;
+
   if (current_attr.recursive && !gfc_add_recursive (dest, where))
     return false;
 
@@ -5791,6 +6110,10 @@
 	    gfc_error ("ENTRY statement at %C cannot appear within "
 		       "an INTERFACE");
 	    break;
+          case COMP_STRUCTURE:
+            gfc_error ("ENTRY statement at %C cannot appear within "
+                       "a STRUCTURE block");
+            break;
 	  case COMP_DERIVED:
 	    gfc_error ("ENTRY statement at %C cannot appear within "
 		       "a DERIVED TYPE block");
@@ -6450,6 +6773,24 @@
       eos_ok = 0;
       break;
 
+    case COMP_MAP:
+      *st = ST_END_MAP;
+      target = " map";
+      eos_ok = 0;
+      break;
+
+    case COMP_UNION:
+      *st = ST_END_UNION;
+      target = " union";
+      eos_ok = 0;
+      break;
+
+    case COMP_STRUCTURE:
+      *st = ST_END_STRUCTURE;
+      target = " structure";
+      eos_ok = 0;
+      break;
+
     case COMP_DERIVED:
     case COMP_DERIVED_CONTAINS:
       *st = ST_END_TYPE;
@@ -8020,6 +8361,208 @@
 }
 
 
+/* Common function for type declaration blocks similar to derived types, such
+   as STRUCTURES and MAPs. Unlike derived types, a structure type
+   does NOT have a generic symbol matching the name given by the user.
+   STRUCTUREs can share names with variables and PARAMETERs so we must allow
+   for the creation of an independent symbol.
+   Other parameters are a message to prefix errors with, the name of the new 
+   type to be created, and the flavor to add to the resulting symbol. */
+
+static bool
+get_struct_decl (const char *name, sym_flavor fl, locus *decl,
+                 gfc_symbol **result)
+{
+  gfc_symbol *sym;
+  locus where;
+
+  gcc_assert (name[0] == (char) TOUPPER (name[0]));
+
+  if (decl)
+    where = *decl;
+  else
+    where = gfc_current_locus;
+
+  if (gfc_get_symbol (name, NULL, &sym))
+    return false;
+
+  if (!sym)
+    {
+      gfc_internal_error ("Failed to create structure type '%s' at %C", name);
+      return false;
+    }
+
+  if (sym->components != NULL || sym->attr.zero_comp)
+    {
+      gfc_error ("Type definition of '%s' at %C was already defined at %L", 
+                 sym->name, &sym->declared_at);
+      return false;
+    }
+
+  sym->declared_at = where;
+
+  if (sym->attr.flavor != fl
+      && !gfc_add_flavor (&sym->attr, fl, sym->name, NULL))
+    return false;
+
+  if (!sym->hash_value)
+      /* Set the hash for the compound name for this type.  */
+    sym->hash_value = gfc_hash_value (sym);
+
+  /* Normally the type is expected to have been completely parsed by the time
+     a field declaration with this type is seen. For unions, maps, and nested
+     structure declarations, we need to indicate that it is okay that we
+     haven't seen any components yet. This will be updated after the structure
+     is fully parsed. */
+  sym->attr.zero_comp = 0;
+
+  /* Structures always act like derived-types with the SEQUENCE attribute */
+  gfc_add_sequence (&sym->attr, sym->name, NULL);
+
+  if (result) *result = sym;
+
+  return true;
+}
+
+
+/* Match the opening of a MAP block. Like a struct within a union in C;
+   behaves identical to STRUCTURE blocks.  */
+
+match
+gfc_match_map (void)
+{
+    /* Counter used to give unique internal names to map structures. */
+    static unsigned int gfc_map_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    locus old_loc;
+
+    old_loc = gfc_current_locus;
+
+    if (gfc_match_eos () != MATCH_YES)
+      {
+          gfc_error ("Junk after MAP statement at %C");
+          gfc_current_locus = old_loc;
+          return MATCH_ERROR;
+      }
+
+    /* Map blocks are anonymous so we make up unique names for the symbol table
+       which are invalid Fortran identifiers.  */
+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "MM$%u", gfc_map_id++);
+
+    if (!get_struct_decl (name, FL_STRUCT, &old_loc, &sym))
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+
+    return MATCH_YES;
+}
+
+
+/* Match the opening of a UNION block.  */
+
+match
+gfc_match_union (void)
+{
+    /* Counter used to give unique internal names to union types. */
+    static unsigned int gfc_union_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    locus old_loc;
+
+    old_loc = gfc_current_locus;
+
+    if (gfc_match_eos () != MATCH_YES)
+      {
+          gfc_error ("Junk after UNION statement at %C");
+          gfc_current_locus = old_loc;
+          return MATCH_ERROR;
+      }
+
+    /* Unions are anonymous so we make up unique names for the symbol table
+       which are invalid Fortran identifiers.  */
+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "UU$%u", gfc_union_id++);
+
+    if (!get_struct_decl (name, FL_UNION, &old_loc, &sym))
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+
+    return MATCH_YES;
+}
+
+
+/* Match the beginning of a STRUCTURE declaration. This is similar to
+   matching the beginning of a derived type declaration with a few
+   twists. The resulting type symbol has no access control or other
+   interesting attributes.  */
+
+match
+gfc_match_structure_decl (void)
+{
+    /* Counter used to give unique internal names to anonymous structures.  */
+    int gfc_structure_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    match m;
+    locus where;
+
+    if(!gfc_option.flag_dec_structure)
+      {
+          gfc_error ("STRUCTURE at %C is a DEC extension, enable with "
+                     "-fdec-structure");
+          return MATCH_ERROR;
+      }
+
+    name[0] = '\0';
+
+    m = gfc_match (" /%n/", name);
+    if (m != MATCH_YES)
+      {
+          /* Non-nested structure declarations require a structure name.  */
+          if (!gfc_comp_struct (gfc_current_state ()))
+            {
+                gfc_error ("Structure name expected in non-nested structure "
+                           "declaration at %C");
+                return MATCH_ERROR;
+            }
+          /* This is an anonymous structure; make up a unique name for it
+             (upper-case letters never make it to symbol names from the source).
+             The important thing is initializing the type variable
+             and setting gfc_new_symbol, which is immediately used by
+             parse_structure () and variable_decl () to add components of
+             this type.  */
+          snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "SS$%u", gfc_structure_id++);
+      }
+
+    where = gfc_current_locus;
+    /* No field list allowed after non-nested structure declaration.  */
+    if (!gfc_comp_struct (gfc_current_state ())
+        && gfc_match_eos () != MATCH_YES)
+      {
+          gfc_error ("Junk after non-nested STRUCTURE statement at %C");
+          return MATCH_ERROR;
+      }
+
+    /* Make sure the name is not the name of an intrinsic type.  */
+    if (gfc_is_intrinsic_typename (name))
+      {
+        gfc_error ("Structure name '%s' at %C cannot be the same as an"
+                   " intrinsic type", name);
+        return MATCH_ERROR;
+      }
+
+    /* Store the actual type symbol for the structure with an upper-case first
+       letter (an invalid Fortran identifier).  */
+
+    sprintf (name, gfc_dt_upper_string (name));
+    if (!get_struct_decl (name, FL_STRUCT, &where, &sym))
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+    return MATCH_YES;
+}
+
 /* Match the beginning of a derived type declaration.  If a type name
    was the result of a function, then it is possible to have a symbol
    already to be known as a derived type yet have no components.  */
@@ -8037,7 +8580,7 @@
   bool seen_attr = false;
   gfc_interface *intr = NULL, *head;
 
-  if (gfc_current_state () == COMP_DERIVED)
+  if (gfc_comp_struct (gfc_current_state ()))
     return MATCH_NO;
 
   name[0] = '\0';
@@ -8111,9 +8654,7 @@
   if (!sym)
     {
       /* Use upper case to save the actual derived-type symbol.  */
-      gfc_get_symbol (gfc_get_string ("%c%s",
-			(char) TOUPPER ((unsigned char) gensym->name[0]),
-			&gensym->name[1]), NULL, &sym);
+      gfc_get_symbol (gfc_dt_upper_string (gensym->name), NULL, &sym);
       sym->name = gfc_get_string (gensym->name);
       head = gensym->generic;
       intr = gfc_get_interface ();
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/dump-parse-tree.c gcc-6-20160721/gcc/fortran/dump-parse-tree.c
--- gcc-6.1.0/gcc/fortran/dump-parse-tree.c	2016-02-28 22:24:27.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/dump-parse-tree.c	2016-05-14 19:52:46.000000000 +0000
@@ -106,6 +106,7 @@
     {
     case BT_DERIVED:
     case BT_CLASS:
+    case BT_UNION:
       fprintf (dumpfile, "%s", ts->u.derived->name);
       break;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/expr.c gcc-6-20160721/gcc/fortran/expr.c
--- gcc-6.1.0/gcc/fortran/expr.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/expr.c	2016-05-14 19:52:46.000000000 +0000
@@ -335,7 +335,7 @@
 
 	case BT_HOLLERITH:
 	case BT_LOGICAL:
-	case BT_DERIVED:
+	case_bt_struct:
 	case BT_CLASS:
 	case BT_ASSUMED:
 	  break;		/* Already done.  */
@@ -1279,7 +1279,7 @@
   /* For extended types, check if the desired component is in one of the
    * parent types.  */
   while (ext > 0 && gfc_find_component (dt->components->ts.u.derived,
-					pick->name, true, true))
+					pick->name, true, true, NULL))
     {
       dt = dt->components->ts.u.derived;
       c = gfc_constructor_first (c->expr->value.constructor);
@@ -1649,7 +1649,7 @@
 
 	    case AR_FULL:
 	      if (p->ref->next != NULL
-		  && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))
+		  && (p->ts.type == BT_CHARACTER || gfc_bt_struct (p->ts.type)))
 		{
 		  for (c = gfc_constructor_first (p->value.constructor);
 		       c; c = gfc_constructor_next (c))
@@ -1659,7 +1659,7 @@
 			return false;
 		    }
 
-		  if (p->ts.type == BT_DERIVED
+		  if (gfc_bt_struct (p->ts.type)
 			&& p->ref->next
 			&& (c = gfc_constructor_first (p->value.constructor)))
 		    {
@@ -3926,9 +3926,9 @@
 {
   gfc_component *c;
 
-  gcc_assert (der->attr.flavor == FL_DERIVED);
+  gcc_assert (gfc_fl_struct (der->attr.flavor));
   for (c = der->components; c; c = c->next)
-    if (c->ts.type == BT_DERIVED)
+    if (gfc_bt_struct (c->ts.type))
       {
         if (!c->attr.pointer && !c->attr.proc_pointer
 	     && gfc_has_default_initializer (c->ts.u.derived))
@@ -3975,6 +3975,10 @@
 
       if (comp->initializer)
 	{
+	  /* Save the component ref for STRUCTUREs and UNIONs.  */
+	  if (ts->u.derived->attr.flavor == FL_STRUCT
+	      || ts->u.derived->attr.flavor == FL_UNION)
+	    ctor->n.component = comp;
 	  ctor->expr = gfc_copy_expr (comp->initializer);
 	  if ((comp->ts.type != comp->initializer->ts.type
 	       || comp->ts.kind != comp->initializer->ts.kind)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/f95-lang.c gcc-6-20160721/gcc/fortran/f95-lang.c
--- gcc-6.1.0/gcc/fortran/f95-lang.c	2016-02-08 15:36:16.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/f95-lang.c	2016-07-02 10:25:52.000000000 +0000
@@ -289,6 +289,9 @@
   tree blocks;
   /* The binding level containing this one (the enclosing binding level).  */
   struct binding_level *level_chain;
+  /* True if nreverse has been already called on names; if false, names
+     are ordered from newest declaration to oldest one.  */
+  bool reversed;
 };
 
 /* The binding level currently in effect.  */
@@ -299,7 +302,7 @@
 static GTY(()) struct binding_level *global_binding_level;
 
 /* Binding level structures are initialized by copying this one.  */
-static struct binding_level clear_binding_level = { NULL, NULL, NULL };
+static struct binding_level clear_binding_level = { NULL, NULL, NULL, false };
 
 
 /* Return true if we are in the global binding level.  */
@@ -313,6 +316,11 @@
 tree
 getdecls (void)
 {
+  if (!current_binding_level->reversed)
+    {
+      current_binding_level->reversed = true;
+      current_binding_level->names = nreverse (current_binding_level->names);
+    }
   return current_binding_level->names;
 }
 
@@ -350,7 +358,7 @@
      binding level that we are about to exit and which is returned by this
      routine.  */
   tree block_node = NULL_TREE;
-  tree decl_chain = current_binding_level->names;
+  tree decl_chain = getdecls ();
   tree subblock_chain = current_binding_level->blocks;
   tree subblock_node;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/frontend-passes.c gcc-6-20160721/gcc/fortran/frontend-passes.c
--- gcc-6.1.0/gcc/fortran/frontend-passes.c	2016-02-28 22:27:55.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/frontend-passes.c	2016-07-10 21:26:28.000000000 +0000
@@ -174,8 +174,17 @@
 
   if (!gfc_check_dependency (expr1, expr2, true))
     return 0;
-  
+
+  /* gfc_check_dependency doesn't always pick up identical expressions.
+     However, eliminating the above sends the compiler into an infinite
+     loop on valid expressions.  Without this check, the gimplifier emits
+     an ICE for a = a, where a is deferred character length.  */
+  if (!gfc_dep_compare_expr (expr1, expr2))
+    return 0;
+
   current_code = c;
+  inserted_block = NULL;
+  changed_statement = NULL;
   n = create_var (expr2, "trim");
   co->expr2 = n;
   return 0;
@@ -656,12 +665,10 @@
     {
       gfc_expr *length;
 
+      symbol->ts.u.cl = gfc_new_charlen (ns, NULL);
       length = constant_string_length (e);
       if (length)
-	{
-	  symbol->ts.u.cl = gfc_new_charlen (ns, NULL);
-	  symbol->ts.u.cl->length = length;
-	}
+	symbol->ts.u.cl->length = length;
       else
 	symbol->attr.allocatable = 1;
     }
@@ -2812,6 +2819,12 @@
   if (in_where)
     return 0;
 
+  /* For now don't do anything in OpenMP workshare, it confuses
+     its translation, which expects only the allowed statements in there.
+     We should figure out how to parallelize this eventually.  */
+  if (in_omp_workshare)
+    return 0;
+
   expr1 = co->expr1;
   expr2 = co->expr2;
   if (expr2->expr_type != EXPR_FUNCTION
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/gfortran.h gcc-6-20160721/gcc/fortran/gfortran.h
--- gcc-6.1.0/gcc/fortran/gfortran.h	2016-03-17 15:07:54.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/gfortran.h	2016-05-14 19:52:46.000000000 +0000
@@ -62,6 +62,15 @@
 
 #define gfc_is_whitespace(c) ((c==' ') || (c=='\t'))
 
+/* Macros to check for groups of structure-like types and flavors since
+   derived types, structures, maps, unions are often treated similarly. */
+#define gfc_bt_struct(t) \
+  ((t) == BT_DERIVED || (t) == BT_UNION)
+#define gfc_fl_struct(f) \
+  ((f) == FL_DERIVED || (f) == FL_UNION || (f) == FL_STRUCT)
+#define case_bt_struct case BT_DERIVED: case BT_UNION
+#define case_fl_struct case FL_DERIVED: case FL_UNION: case FL_STRUCT
+
 /* Stringization.  */
 #define stringize(x) expand_macro(x)
 #define expand_macro(x) # x
@@ -203,6 +212,8 @@
   ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE, ST_SIMPLE_IF,
   ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT, ST_ENUM,
   ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,
+  ST_STRUCTURE_DECL, ST_END_STRUCTURE,
+  ST_UNION, ST_END_UNION, ST_MAP, ST_END_MAP,
   ST_OACC_PARALLEL_LOOP, ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL,
   ST_OACC_END_PARALLEL, ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,
   ST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,
@@ -254,12 +265,12 @@
 };
 
 /* Symbol flavors: these are all mutually exclusive.
-   10 elements = 4 bits.  */
+   12 elements = 4 bits.  */
 enum sym_flavor
 {
   FL_UNKNOWN = 0, FL_PROGRAM, FL_BLOCK_DATA, FL_MODULE, FL_VARIABLE,
   FL_PARAMETER, FL_LABEL, FL_PROCEDURE, FL_DERIVED, FL_NAMELIST,
-  FL_VOID
+  FL_UNION, FL_STRUCT, FL_VOID
 };
 
 /* Procedure types.  7 elements = 3 bits.  */
@@ -2523,6 +2534,8 @@
   int flag_init_character;
   char flag_init_character_value;
 
+  int flag_dec_structure;
+
   int fpe;
   int fpe_summary;
   int rtcheck;
@@ -2743,6 +2756,7 @@
 int gfc_validate_kind (bt, int, bool);
 int gfc_get_int_kind_from_width_isofortranenv (int size);
 int gfc_get_real_kind_from_width_isofortranenv (int size);
+tree gfc_get_union_type (gfc_symbol *);
 tree gfc_get_derived_type (gfc_symbol * derived);
 extern int gfc_index_integer_kind;
 extern int gfc_default_integer_kind;
@@ -2831,7 +2845,8 @@
 bool gfc_add_component (gfc_symbol *, const char *, gfc_component **);
 gfc_symbol *gfc_use_derived (gfc_symbol *);
 gfc_symtree *gfc_use_derived_tree (gfc_symtree *);
-gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool);
+gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool,
+                                   gfc_ref **);
 
 gfc_st_label *gfc_get_st_label (int);
 void gfc_free_st_label (gfc_st_label *);
@@ -3174,6 +3189,8 @@
 void gfc_dump_module (const char *, int);
 bool gfc_check_symbol_access (gfc_symbol *);
 void gfc_free_use_stmts (gfc_use_list *);
+const char *gfc_dt_lower_string (const char *);
+const char *gfc_dt_upper_string (const char *);
 
 /* primary.c */
 symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);
Only in gcc-6.1.0/gcc/fortran: gfortran.info
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/gfortran.texi gcc-6-20160721/gcc/fortran/gfortran.texi
--- gcc-6.1.0/gcc/fortran/gfortran.texi	2016-04-13 13:17:45.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/gfortran.texi	2016-05-14 19:52:46.000000000 +0000
@@ -474,9 +474,9 @@
 standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
 including a number of standard and non-standard extensions, and can be
 used on real-world programs.  In particular, the supported extensions
-include OpenMP, Cray-style pointers, and several Fortran 2003 and Fortran
-2008 features, including TR 15581.  However, it is still under
-development and has a few remaining rough edges.
+include OpenMP, Cray-style pointers, some old vendor extensions, and several
+Fortran 2003 and Fortran 2008 features, including TR 15581.  However, it is
+still under development and has a few remaining rough edges.
 There also is initial support for OpenACC.
 Note that this is an experimental feature, incomplete, and subject to
 change in future versions of GCC.  See
@@ -1459,6 +1459,8 @@
 * OpenACC::
 * Argument list functions::
 * Read/Write after EOF marker::
+* STRUCTURE and RECORD::
+* UNION and MAP::
 @end menu
 
 @node Old-style kind specifications
@@ -2117,40 +2119,6 @@
 the file before the EOF marker.  As an extension, the run-time error may
 be disabled using -std=legacy.
 
-@node Extensions not implemented in GNU Fortran
-@section Extensions not implemented in GNU Fortran
-@cindex extensions, not implemented
-
-The long history of the Fortran language, its wide use and broad
-userbase, the large number of different compiler vendors and the lack of
-some features crucial to users in the first standards have lead to the
-existence of a number of important extensions to the language.  While
-some of the most useful or popular extensions are supported by the GNU
-Fortran compiler, not all existing extensions are supported.  This section
-aims at listing these extensions and offering advice on how best make
-code that uses them running with the GNU Fortran compiler.
-
-@c More can be found here:
-@c   -- https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
-@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:
-@c      http://tinyurl.com/2u4h5y
-
-@menu
-* STRUCTURE and RECORD::
-@c * UNION and MAP::
-* ENCODE and DECODE statements::
-* Variable FORMAT expressions::
-@c * Q edit descriptor::
-@c * AUTOMATIC statement::
-@c * TYPE and ACCEPT I/O Statements::
-@c * .XOR. operator::
-@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
-@c * Omitted arguments in procedure call::
-* Alternate complex function syntax::
-* Volatile COMMON blocks::
-* OPEN( ... NAME=)::
-@end menu
-
 
 @node STRUCTURE and RECORD
 @subsection @code{STRUCTURE} and @code{RECORD}
@@ -2226,16 +2194,211 @@
 print *, store_catalog(12)
 @end example
 
+@noindent
+GNU Fortran implements STRUCTURES like derived types with the following
+rules and exceptions:
+
+@itemize @bullet
+@item Structures act like derived types with the @code{SEQUENCE} attribute.
+Otherwise they may contain no specifiers.
 
-@c @node UNION and MAP
-@c @subsection @code{UNION} and @code{MAP}
-@c @cindex @code{UNION}
-@c @cindex @code{MAP}
-@c
-@c For help writing this one, see
-@c http://www.eng.umd.edu/~nsw/ench250/fortran1.htm#UNION and
-@c http://www.tacc.utexas.edu/services/userguides/pgi/pgiws_ug/pgi32u06.htm
+@item Structures may share names with other symbols. For example, the following
+is invalid for derived types, but valid for structures:
 
+@smallexample
+structure /header/
+  ! ...
+end structure
+record /header/ header
+@end smallexample
+
+@item Structure types may be declared nested within another parent structure.
+The syntax is:
+@smallexample
+structure /type-name/
+    ...
+    structure [/<type-name>/] <field-list>
+...
+@end smallexample
+
+The type name may be ommitted, in which case the structure type itself is
+anonymous, and other structures of the same type cannot be instantiated. The
+following shows some examples:
+
+@example
+structure /appointment/
+  ! nested structure definition: app_time is an array of two 'time'
+  structure /time/ app_time (2) 
+    integer(1) hour, minute
+  end structure
+  character(10) memo
+end structure
+
+! The 'time' structure is still usable
+record /time/ now
+now = time(5, 30)
+
+...
+
+structure /appointment/
+  ! anonymous nested structure definition
+  structure start, end
+    integer(1) hour, minute
+  end structure
+  character(10) memo
+end structure
+@end example
+
+@item Structures may contain @code{UNION} blocks. For more detail see the
+section on @ref{UNION and MAP}.
+
+@item Structures support old-style initialization of components, like
+those described in @ref{Old-style variable initialization}. For array
+initializers, an initializer may contain a repeat specification of the form
+@code{<literal-integer> * <constant-initializer>}. The value of the integer
+indicates the number of times to repeat the constant initializer when expanding
+the initializer list.
+@end itemize
+
+@node UNION and MAP
+@subsection @code{UNION} and @code{MAP}
+@cindex @code{UNION}
+@cindex @code{MAP}
+
+Unions are an old vendor extension which were commonly used with the
+non-standard @ref{STRUCTURE and RECORD} extensions. Use of @code{UNION} and
+@code{MAP} is automatically enabled with @option{-fdec-structure}.
+
+A @code{UNION} declaration occurs within a structure; within the definition of
+each union is a number of @code{MAP} blocks. Each @code{MAP} shares storage
+with its sibling maps (in the same union), and the size of the union is the
+size of the largest map within it, just as with unions in C. The major
+difference is that component references do not indicate which union or map the
+component is in (the compiler gets to figure that out).
+
+Here is a small example:
+@smallexample
+structure /myunion/
+union
+  map
+    character(2) w0, w1, w2
+  end map
+  map
+    character(6) long
+  end map
+end union
+end structure
+
+record /myunion/ rec
+! After this assignment...
+rec.long = 'hello!'
+
+! The following is true:
+! rec.w0 === 'he'
+! rec.w1 === 'll'
+! rec.w2 === 'o!'
+@end smallexample
+
+The two maps share memory, and the size of the union is ultimately six bytes:
+
+@example
+0    1    2    3    4   5   6     Byte offset
+-------------------------------
+|    |    |    |    |    |    |
+-------------------------------
+
+^    W0   ^    W1   ^    W2   ^
+ \-------/ \-------/ \-------/
+
+^             LONG            ^
+ \---------------------------/
+@end example
+
+Following is an example mirroring the layout of an Intel x86_64 register:
+
+@example
+structure /reg/
+  union ! U0                ! rax
+    map
+      character(16) rx
+    end map
+    map
+      character(8) rh         ! rah
+      union ! U1
+        map
+          character(8) rl     ! ral
+        end map
+        map
+          character(8) ex     ! eax
+        end map
+        map
+          character(4) eh     ! eah
+          union ! U2
+            map
+              character(4) el ! eal
+            end map
+            map
+              character(4) x  ! ax
+            end map
+            map
+              character(2) h  ! ah
+              character(2) l  ! al
+            end map
+          end union
+        end map
+      end union
+    end map
+  end union
+end structure
+record /reg/ a
+
+! After this assignment...
+a.rx     =     'AAAAAAAA.BBB.C.D'
+
+! The following is true:
+a.rx === 'AAAAAAAA.BBB.C.D'
+a.rh === 'AAAAAAAA'
+a.rl ===         '.BBB.C.D'
+a.ex ===         '.BBB.C.D'
+a.eh ===         '.BBB'
+a.el ===             '.C.D'
+a.x  ===             '.C.D'
+a.h  ===             '.C'
+a.l  ===               '.D'
+@end example
+
+
+@node Extensions not implemented in GNU Fortran
+@section Extensions not implemented in GNU Fortran
+@cindex extensions, not implemented
+
+The long history of the Fortran language, its wide use and broad
+userbase, the large number of different compiler vendors and the lack of
+some features crucial to users in the first standards have lead to the
+existence of a number of important extensions to the language.  While
+some of the most useful or popular extensions are supported by the GNU
+Fortran compiler, not all existing extensions are supported.  This section
+aims at listing these extensions and offering advice on how best make
+code that uses them running with the GNU Fortran compiler.
+
+@c More can be found here:
+@c   -- https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
+@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:
+@c      http://tinyurl.com/2u4h5y
+
+@menu
+* ENCODE and DECODE statements::
+* Variable FORMAT expressions::
+@c * Q edit descriptor::
+@c * AUTOMATIC statement::
+@c * TYPE and ACCEPT I/O Statements::
+@c * .XOR. operator::
+@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
+@c * Omitted arguments in procedure call::
+* Alternate complex function syntax::
+* Volatile COMMON blocks::
+* OPEN( ... NAME=)::
+@end menu
 
 @node ENCODE and DECODE statements
 @subsection @code{ENCODE} and @code{DECODE} statements
@@ -2355,7 +2518,6 @@
 @code{VOLATILE} variables in @code{COMMON} blocks since revision 4.3.
 
 
-
 @node OPEN( ... NAME=)
 @subsection @code{OPEN( ... NAME=)}
 @cindex @code{NAM}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/interface.c gcc-6-20160721/gcc/fortran/interface.c
--- gcc-6.1.0/gcc/fortran/interface.c	2016-01-24 22:18:20.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/interface.c	2016-05-15 18:48:40.000000000 +0000
@@ -387,19 +387,147 @@
 }
 
 
+/* Compare components according to 4.4.2 of the Fortran standard.  */
+
+static int
+compare_components (gfc_component *cmp1, gfc_component *cmp2,
+    gfc_symbol *derived1, gfc_symbol *derived2)
+{
+  gfc_symbol *d1, *d2;
+  bool anonymous = false;
+
+  /* Unions, maps, and anonymous structures all have names like "[xX]X$\d+"
+     which should not be compared.  */
+  d1 = cmp1->ts.u.derived;
+  d2 = cmp2->ts.u.derived;
+  if (   (d1 && (d1->attr.flavor == FL_STRUCT || d1->attr.flavor == FL_UNION)
+          && ISUPPER (cmp1->name[1]))
+      || (d2 && (d2->attr.flavor == FL_STRUCT || d2->attr.flavor == FL_UNION)
+          && ISUPPER (cmp1->name[1])))
+    anonymous = true;
+
+  if (!anonymous && strcmp (cmp1->name, cmp2->name) != 0)
+    return 0;
+
+  if (cmp1->attr.access != cmp2->attr.access)
+    return 0;
+
+  if (cmp1->attr.pointer != cmp2->attr.pointer)
+    return 0;
+
+  if (cmp1->attr.dimension != cmp2->attr.dimension)
+    return 0;
+
+  if (cmp1->attr.allocatable != cmp2->attr.allocatable)
+    return 0;
+
+  if (cmp1->attr.dimension && gfc_compare_array_spec (cmp1->as, cmp2->as) == 0)
+    return 0;
+
+  /* Make sure that link lists do not put this function into an
+     endless recursive loop!  */
+  if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+      && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived)
+      && gfc_compare_types (&cmp1->ts, &cmp2->ts) == 0)
+    return 0;
+
+  else if ( (cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+        && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
+    return 0;
+
+  else if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+        &&  (cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
+    return 0;
+
+  return 1;
+}
+
+
+/* Compare two union types by comparing the components of their maps.
+   Because unions and maps are anonymous their types get special internal
+   names; therefore the usual derived type comparison will fail on them.
+
+   Returns nonzero if equal, as with gfc_compare_derived_types. Also as with
+   gfc_compare_derived_types, 'equal' is closer to meaning 'duplicate
+   definitions' than 'equivalent structure'. */
+
+int
+gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)
+{
+  gfc_component *map1, *map2, *cmp1, *cmp2;
+
+  if (un1->attr.flavor != FL_UNION || un2->attr.flavor != FL_UNION)
+    return 0;
+
+  map1 = un1->components;
+  map2 = un2->components;
+
+  /* In terms of 'equality' here we are worried about types which are
+     declared the same in two places, not types that represent equivalent
+     structures. (This is common because of FORTRAN's weird scoping rules.)
+     Though two unions with their maps in different orders could be equivalent,
+     we will say they are not equal for the purposes of this test; therefore
+     we compare the maps sequentially. */
+  for (;;)
+  {
+    cmp1 = map1->ts.u.derived->components;
+    cmp2 = map2->ts.u.derived->components;
+    for (;;)
+    {
+      /* No two fields will ever point to the same map type unless they are
+         the same component, because one map field is created with its type
+         declaration. Therefore don't worry about recursion here. */
+      /* TODO: worry about recursion into parent types of the unions? */
+      if (compare_components (cmp1, cmp2,
+            map1->ts.u.derived, map2->ts.u.derived) == 0)
+        return 0;
+
+      cmp1 = cmp1->next;
+      cmp2 = cmp2->next;
+
+      if (cmp1 == NULL && cmp2 == NULL)
+        break;
+      if (cmp1 == NULL || cmp2 == NULL)
+        return 0;
+    }
+
+    map1 = map1->next;
+    map2 = map2->next;
+
+    if (map1 == NULL && map2 == NULL)
+      break;
+    if (map1 == NULL || map2 == NULL)
+      return 0;
+  }
+
+  return 1;
+}
+
+
+
 /* Compare two derived types using the criteria in 4.4.2 of the standard,
    recursing through gfc_compare_types for the components.  */
 
 int
 gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
 {
-  gfc_component *dt1, *dt2;
+  gfc_component *cmp1, *cmp2;
+  bool anonymous = false;
 
   if (derived1 == derived2)
     return 1;
 
   gcc_assert (derived1 && derived2);
 
+  /* MAP and anonymous STRUCTURE types have internal names of the form
+     mM* and sS* (we can get away this this because source names are converted
+     to lowerase). Compare anonymous type names specially because each
+     gets a unique name when it is declared. */
+  anonymous = (derived1->name[0] == derived2->name[0]
+      && derived1->name[1] && derived2->name[1] && derived2->name[2]
+      && derived1->name[1] == (char) TOUPPER (derived1->name[0])
+      && derived2->name[2] == (char) TOUPPER (derived2->name[0]));
+
   /* Special case for comparing derived types across namespaces.  If the
      true names and module names are the same and the module name is
      nonnull, then they are equal.  */
@@ -409,9 +537,11 @@
     return 1;
 
   /* Compare type via the rules of the standard.  Both types must have
-     the SEQUENCE or BIND(C) attribute to be equal.  */
+     the SEQUENCE or BIND(C) attribute to be equal. STRUCTUREs are special
+     because they can be anonymous; therefore two structures with different
+     names may be equal.  */
 
-  if (strcmp (derived1->name, derived2->name))
+  if (strcmp (derived1->name, derived2->name) != 0 && !anonymous)
     return 0;
 
   if (derived1->component_access == ACCESS_PRIVATE
@@ -422,53 +552,30 @@
       && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c))
     return 0;
 
-  dt1 = derived1->components;
-  dt2 = derived2->components;
+  /* Protect against null components.  */
+  if (derived1->attr.zero_comp != derived2->attr.zero_comp)
+    return 0;
+
+  if (derived1->attr.zero_comp)
+    return 1;
+
+  cmp1 = derived1->components;
+  cmp2 = derived2->components;
 
   /* Since subtypes of SEQUENCE types must be SEQUENCE types as well, a
      simple test can speed things up.  Otherwise, lots of things have to
      match.  */
   for (;;)
     {
-      if (strcmp (dt1->name, dt2->name) != 0)
-	return 0;
+      if (!compare_components (cmp1, cmp2, derived1, derived2))
+        return 0;
 
-      if (dt1->attr.access != dt2->attr.access)
-	return 0;
+      cmp1 = cmp1->next;
+      cmp2 = cmp2->next;
 
-      if (dt1->attr.pointer != dt2->attr.pointer)
-	return 0;
-
-      if (dt1->attr.dimension != dt2->attr.dimension)
-	return 0;
-
-     if (dt1->attr.allocatable != dt2->attr.allocatable)
-	return 0;
-
-      if (dt1->attr.dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)
-	return 0;
-
-      /* Make sure that link lists do not put this function into an
-	 endless recursive loop!  */
-      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-	    && !(dt2->ts.type == BT_DERIVED && derived2 == dt2->ts.u.derived)
-	    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)
-	return 0;
-
-      else if ((dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-		&& !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))
-	return 0;
-
-      else if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-		&& (dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))
-	return 0;
-
-      dt1 = dt1->next;
-      dt2 = dt2->next;
-
-      if (dt1 == NULL && dt2 == NULL)
+      if (cmp1 == NULL && cmp2 == NULL)
 	break;
-      if (dt1 == NULL || dt2 == NULL)
+      if (cmp1 == NULL || cmp2 == NULL)
 	return 0;
     }
 
@@ -509,18 +616,18 @@
       && (ts1->u.derived->attr.sequence || ts1->u.derived->attr.is_bind_c))
     return 1;
 
+  if (ts1->type == BT_UNION && ts2->type == BT_UNION)
+    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);
+
   if (ts1->type != ts2->type
-      && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
-	  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))
+      && ((!gfc_bt_struct (ts1->type) && ts1->type != BT_CLASS)
+	  || (!gfc_bt_struct (ts2->type) && ts2->type != BT_CLASS)))
     return 0;
   if (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
     return (ts1->kind == ts2->kind);
 
   /* Compare derived types.  */
-  if (gfc_type_compatible (ts1, ts2))
-    return 1;
-
-  return gfc_compare_derived_types (ts1->u.derived ,ts2->u.derived);
+  return gfc_type_compatible (ts1, ts2);
 }
 
 
@@ -1585,7 +1692,7 @@
 	 functions or subroutines.  */
       if (((!p->sym->attr.function && !p->sym->attr.subroutine)
 	   || !p->sym->attr.if_source)
-	  && p->sym->attr.flavor != FL_DERIVED)
+	  && !gfc_fl_struct (p->sym->attr.flavor))
 	{
 	  if (p->sym->attr.external)
 	    gfc_error ("Procedure %qs in %s at %L has no explicit interface",
@@ -1599,14 +1706,14 @@
 
       /* Verify that procedures are either all SUBROUTINEs or all FUNCTIONs.  */
       if ((psave->sym->attr.function && !p->sym->attr.function
-	   && p->sym->attr.flavor != FL_DERIVED)
+	   && !gfc_fl_struct (p->sym->attr.flavor))
 	  || (psave->sym->attr.subroutine && !p->sym->attr.subroutine))
 	{
-	  if (p->sym->attr.flavor != FL_DERIVED)
+	  if (!gfc_fl_struct (p->sym->attr.flavor))
 	    gfc_error ("In %s at %L procedures must be either all SUBROUTINEs"
 		       " or all FUNCTIONs", interface_name,
 		       &p->sym->declared_at);
-	  else
+	  else if (p->sym->attr.flavor == FL_DERIVED)
 	    gfc_error ("In %s at %L procedures must be all FUNCTIONs as the "
 		       "generic name is also the name of a derived type",
 		       interface_name, &p->sym->declared_at);
@@ -1666,8 +1773,8 @@
 	if (p->sym->name == q->sym->name && p->sym->module == q->sym->module)
 	  continue;
 
-	if (p->sym->attr.flavor != FL_DERIVED
-	    && q->sym->attr.flavor != FL_DERIVED
+	if (!gfc_fl_struct (p->sym->attr.flavor)
+	    && !gfc_fl_struct (q->sym->attr.flavor)
 	    && gfc_compare_interfaces (p->sym, q->sym, q->sym->name,
 				       generic_flag, 0, NULL, 0, NULL, NULL))
 	  {
@@ -2006,7 +2113,7 @@
     }
 
   ppc = gfc_get_proc_ptr_comp (actual);
-  if (ppc)
+  if (ppc && ppc->ts.interface)
     {
       if (!gfc_compare_interfaces (formal, ppc->ts.interface, ppc->name, 0, 1,
 				   err, sizeof(err), NULL, NULL))
@@ -3550,7 +3657,7 @@
 
   for (; intr; intr = intr->next)
     {
-      if (intr->sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (intr->sym->attr.flavor))
 	continue;
       if (sub_flag && intr->sym->attr.function)
 	continue;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/invoke.texi gcc-6-20160721/gcc/fortran/invoke.texi
--- gcc-6.1.0/gcc/fortran/invoke.texi	2016-03-13 00:19:08.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/invoke.texi	2016-05-14 19:52:46.000000000 +0000
@@ -115,7 +115,8 @@
 @item Fortran Language Options
 @xref{Fortran Dialect Options,,Options controlling Fortran dialect}.
 @gccoptlist{-fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code @gol
--fd-lines-as-comments -fdefault-double-8 -fdefault-integer-8 @gol
+-fd-lines-as-comments @gol
+-fdec -fdec-structure -fdefault-double-8 -fdefault-integer-8 @gol
 -fdefault-real-8 -fdollar-ok -ffixed-line-length-@var{n} @gol
 -ffixed-line-length-none -ffree-form -ffree-line-length-@var{n} @gol
 -ffree-line-length-none -fimplicit-none -finteger-4-integer-8 @gol
@@ -228,6 +229,24 @@
 @option{-fd-lines-as-comments} option is given, they are treated as
 comment lines.
 
+@item -fdec
+@opindex @code{fdec}
+DEC compatibility mode. Enables extensions and other features that mimic
+the default behavior of older compilers (such as DEC).
+These features are non-standard and should be avoided at all costs.
+For details on GNU Fortran's implementation of these extensions see the 
+full documentation.
+
+Other flags enabled by this switch are:
+@option{-fdollar-ok} @option{-fcray-pointer} @option{-fdec-structure}
+
+@item -fdec-structure
+@opindex @code{fdec-structure}
+Enable DEC @code{STRUCTURE} and @code{RECORD} as well as @code{UNION},
+@code{MAP}, and dot ('.') as a member separator (in addition to '%'). This is
+provided for compatibility only; Fortran 90 derived types should be used
+instead where possible.
+
 @item -fdollar-ok
 @opindex @code{fdollar-ok}
 @cindex @code{$}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/io.c gcc-6-20160721/gcc/fortran/io.c
--- gcc-6.1.0/gcc/fortran/io.c	2016-02-27 19:07:13.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/io.c	2016-06-12 14:04:08.000000000 +0000
@@ -3007,7 +3007,7 @@
     }
 
   if (dt->extra_comma
-      && !gfc_notify_std (GFC_STD_GNU, "Comma before i/o item list at %L", 
+      && !gfc_notify_std (GFC_STD_LEGACY, "Comma before i/o item list at %L", 
 			  &dt->extra_comma->where))
     return false;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/lang.opt gcc-6-20160721/gcc/fortran/lang.opt
--- gcc-6.1.0/gcc/fortran/lang.opt	2016-02-01 16:20:13.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/lang.opt	2016-05-14 19:52:46.000000000 +0000
@@ -416,6 +416,14 @@
 Fortran RejectNegative
 Treat lines with 'D' in column one as comments.
 
+fdec
+Fortran
+Enable all DEC language extensions.
+
+fdec-structure
+Fortran
+Enable support for DEC STRUCTURE/RECORD.
+
 fdefault-double-8
 Fortran Var(flag_default_double)
 Set the default double precision kind to an 8 byte wide type.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/libgfortran.h gcc-6-20160721/gcc/fortran/libgfortran.h
--- gcc-6.1.0/gcc/fortran/libgfortran.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/libgfortran.h	2016-05-14 19:52:46.000000000 +0000
@@ -164,6 +164,6 @@
 typedef enum
 { BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,
   BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,
-  BT_ASSUMED
+  BT_ASSUMED, BT_UNION
 }
 bt;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/match.c gcc-6-20160721/gcc/fortran/match.c
--- gcc-6.1.0/gcc/fortran/match.c	2016-02-28 19:07:42.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/match.c	2016-05-14 19:52:46.000000000 +0000
@@ -113,6 +113,128 @@
 
 /******************** Generic matching subroutines ************************/
 
+/* Matches a member separator. With standard FORTRAN this is '%', but with
+   DEC structures we must carefully match dot ('.').
+   Because operators are spelled ".op.", a dotted string such as "x.y.z..."
+   can be either a component reference chain or a combination of binary
+   operations.
+   There is no real way to win because the string may be grammatically
+   ambiguous. The following rules help avoid ambiguities - they match
+   some behavior of other (older) compilers. If the rules here are changed
+   the test cases should be updated. If the user has problems with these rules
+   they probably deserve the consequences. Consider "x.y.z":
+     (1) If any user defined operator ".y." exists, this is always y(x,z)
+         (even if ".y." is the wrong type and/or x has a member y).
+     (2) Otherwise if x has a member y, and y is itself a derived type,
+         this is (x->y)->z, even if an intrinsic operator exists which 
+         can handle (x,z). 
+     (3) If x has no member y or (x->y) is not a derived type but ".y." 
+         is an intrinsic operator (such as ".eq."), this is y(x,z).
+     (4) Lastly if there is no operator ".y." and x has no member "y", it is an
+         error.  
+   It is worth noting that the logic here does not support mixed use of member
+   accessors within a single string. That is, even if x has component y and y
+   has component z, the following are all syntax errors:
+         "x%y.z"  "x.y%z" "(x.y).z"  "(x%y)%z"
+ */
+
+match
+gfc_match_member_sep(gfc_symbol *sym)
+{
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  locus dot_loc, start_loc;
+  gfc_intrinsic_op iop;
+  match m;
+  gfc_symbol *tsym;
+  gfc_component *c = NULL;
+
+  /* What a relief: '%' is an unambiguous member separator.  */
+  if (gfc_match_char ('%') == MATCH_YES)
+    return MATCH_YES;
+
+  /* Beware ye who enter here.  */
+  if (!gfc_option.flag_dec_structure || !sym)
+    return MATCH_NO;
+
+  tsym = NULL;
+
+  /* We may be given either a derived type variable or the derived type
+    declaration itself (which actually contains the components); 
+    we need the latter to search for components.  */
+  if (gfc_fl_struct (sym->attr.flavor))
+    tsym = sym;
+  else if (gfc_bt_struct (sym->ts.type))
+    tsym = sym->ts.u.derived;
+
+  iop = INTRINSIC_NONE;
+  name[0] = '\0';
+  m = MATCH_NO;
+
+  /* If we have to reject come back here later.  */
+  start_loc = gfc_current_locus;
+
+  /* Look for a component access next.  */
+  if (gfc_match_char ('.') != MATCH_YES)
+    return MATCH_NO;
+
+  /* If we accept, come back here.  */
+  dot_loc = gfc_current_locus;
+
+  /* Try to match a symbol name following the dot.  */
+  if (gfc_match_name (name) != MATCH_YES)
+    {
+      gfc_error ("Expected structure component or operator name "
+                 "after '.' at %C");
+      goto error;
+    }
+
+  /* If no dot follows we have "x.y" which should be a component access.  */
+  if (gfc_match_char ('.') != MATCH_YES)
+    goto yes;
+
+  /* Now we have a string "x.y.z" which could be a nested member access
+    (x->y)->z or a binary operation y on x and z.  */
+
+  /* First use any user-defined operators ".y."  */
+  if (gfc_find_uop (name, sym->ns) != NULL)
+    goto no;
+
+  /* Match accesses to existing derived-type components for 
+    derived-type vars: "x.y.z" = (x->y)->z  */
+  c = gfc_find_component(tsym, name, false, true, NULL);
+  if (c && (gfc_bt_struct (c->ts.type) || c->ts.type == BT_CLASS))
+    goto yes;
+
+  /* If y is not a component or has no members, try intrinsic operators.  */
+  gfc_current_locus = start_loc;
+  if (gfc_match_intrinsic_op (&iop) != MATCH_YES)
+    {
+      /* If ".y." is not an intrinsic operator but y was a valid non-
+        structure component, match and leave the trailing dot to be 
+        dealt with later.  */
+      if (c)
+        goto yes;
+
+      gfc_error ("'%s' is neither a defined operator nor a "
+                 "structure component in dotted string at %C", name);
+      goto error;
+    }
+
+  /* .y. is an intrinsic operator, overriding any possible member access.  */
+  goto no;
+
+  /* Return keeping the current locus consistent with the match result.  */
+error:
+  m = MATCH_ERROR;
+no:
+  gfc_current_locus = start_loc;
+  return m;
+yes:
+  gfc_current_locus = dot_loc;
+  return MATCH_YES;
+}
+
+
 /* This function scans the current statement counting the opened and closed
    parenthesis to make sure they are balanced.  */
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/match.h gcc-6-20160721/gcc/fortran/match.h
--- gcc-6.1.0/gcc/fortran/match.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/match.h	2016-05-14 19:52:46.000000000 +0000
@@ -60,6 +60,7 @@
 match gfc_match_iterator (gfc_iterator *, int);
 match gfc_match_parens (void);
 match gfc_match_type_spec (gfc_typespec *);
+match gfc_match_member_sep(gfc_symbol *);
 
 
 /* Statement matchers.  */
@@ -208,6 +209,9 @@
 match gfc_match_entry (void);
 match gfc_match_subroutine (void);
 match gfc_match_submod_proc (void);
+match gfc_match_map (void);
+match gfc_match_union (void);
+match gfc_match_structure_decl (void);
 match gfc_match_derived_decl (void);
 match gfc_match_final_decl (void);
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/misc.c gcc-6-20160721/gcc/fortran/misc.c
--- gcc-6.1.0/gcc/fortran/misc.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/misc.c	2016-05-14 19:52:46.000000000 +0000
@@ -83,6 +83,9 @@
     case BT_HOLLERITH:
       p = "HOLLERITH";
       break;
+    case BT_UNION:
+      p = "UNION";
+      break;
     case BT_DERIVED:
       p = "DERIVED";
       break;
@@ -144,6 +147,9 @@
     case BT_HOLLERITH:
       sprintf (buffer, "HOLLERITH");
       break;
+    case BT_UNION:
+      sprintf (buffer, "UNION(%s)", ts->u.derived->name);
+      break;
     case BT_DERIVED:
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/module.c gcc-6-20160721/gcc/fortran/module.c
--- gcc-6.1.0/gcc/fortran/module.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/module.c	2016-05-14 19:52:46.000000000 +0000
@@ -422,8 +422,8 @@
    to convert the symtree name of a derived-type to the symbol name or to
    the name of the associated generic function.  */
 
-static const char *
-dt_lower_string (const char *name)
+const char *
+gfc_dt_lower_string (const char *name)
 {
   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))
     return gfc_get_string ("%c%s", (char) TOLOWER ((unsigned char) name[0]),
@@ -437,8 +437,8 @@
    symtree/symbol name of the associated generic function start with a lower-
    case character.  */
 
-static const char *
-dt_upper_string (const char *name)
+const char *
+gfc_dt_upper_string (const char *name)
 {
   if (name[0] != (char) TOUPPER ((unsigned char) name[0]))
     return gfc_get_string ("%c%s", (char) TOUPPER ((unsigned char) name[0]),
@@ -832,7 +832,7 @@
 
   /* For derived types.  */
   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))
-    low_name = dt_lower_string (name);
+    low_name = gfc_dt_lower_string (name);
 
   i = 0;
   for (u = gfc_rename_list; u; u = u->next)
@@ -861,7 +861,7 @@
     {
       if (u->local_name[0] == '\0')
 	return name;
-      return dt_upper_string (u->local_name);
+      return gfc_dt_upper_string (u->local_name);
     }
 
   return (u->local_name[0] != '\0') ? u->local_name : name;
@@ -989,8 +989,8 @@
 
   t = XCNEW (true_name);
   t->sym = sym;
-  if (sym->attr.flavor == FL_DERIVED)
-    t->name = dt_upper_string (sym->name);
+  if (gfc_fl_struct (sym->attr.flavor))
+    t->name = gfc_dt_upper_string (sym->name);
   else
     t->name = sym->name;
 
@@ -1011,8 +1011,8 @@
   build_tnt (st->left);
   build_tnt (st->right);
 
-  if (st->n.sym->attr.flavor == FL_DERIVED)
-    name = dt_upper_string (st->n.sym->name);
+  if (gfc_fl_struct (st->n.sym->attr.flavor))
+    name = gfc_dt_upper_string (st->n.sym->name);
   else
     name = st->n.sym->name;
 
@@ -2452,6 +2452,7 @@
     minit ("COMPLEX", BT_COMPLEX),
     minit ("LOGICAL", BT_LOGICAL),
     minit ("CHARACTER", BT_CHARACTER),
+    minit ("UNION", BT_UNION),
     minit ("DERIVED", BT_DERIVED),
     minit ("CLASS", BT_CLASS),
     minit ("PROCEDURE", BT_PROCEDURE),
@@ -2505,7 +2506,7 @@
 
   ts->type = MIO_NAME (bt) (ts->type, bt_types);
 
-  if (ts->type != BT_DERIVED && ts->type != BT_CLASS)
+  if (!gfc_bt_struct (ts->type) && ts->type != BT_CLASS)
     mio_integer (&ts->kind);
   else
     mio_symbol_ref (&ts->u.derived);
@@ -3322,8 +3323,8 @@
       if (e->symtree->n.sym && check_unique_name (e->symtree->name))
 	{
           const char *name = e->symtree->n.sym->name;
-	  if (e->symtree->n.sym->attr.flavor == FL_DERIVED)
-	    name = dt_upper_string (name);
+	  if (gfc_fl_struct (e->symtree->n.sym->attr.flavor))
+	    name = gfc_dt_upper_string (name);
 	  ns_st = gfc_find_symtree (gfc_current_ns->sym_root, name);
 	}
 
@@ -4265,7 +4266,7 @@
 
   mio_integer (&(sym->intmod_sym_id));
 
-  if (sym->attr.flavor == FL_DERIVED)
+  if (gfc_fl_struct (sym->attr.flavor))
     mio_integer (&(sym->hash_value));
 
   if (sym->formal_ns
@@ -4845,7 +4846,7 @@
 				 1, &ns->proc_name);
 
       sym = gfc_new_symbol (p->u.rsym.true_name, ns);
-      sym->name = dt_lower_string (p->u.rsym.true_name);
+      sym->name = gfc_dt_lower_string (p->u.rsym.true_name);
       sym->module = gfc_get_string (p->u.rsym.module);
       if (p->u.rsym.binding_label)
 	sym->binding_label = IDENTIFIER_POINTER (get_identifier
@@ -4857,6 +4858,12 @@
   mio_symbol (sym);
   sym->attr.use_assoc = 1;
 
+  /* Unliked derived types, a STRUCTURE may share names with other symbols.
+     We greedily converted the the symbol name to lowercase before we knew its
+     type, so now we must fix it. */
+  if (sym->attr.flavor == FL_STRUCT)
+    sym->name = gfc_dt_upper_string (sym->name);
+
   /* Mark as only or rename for later diagnosis for explicitly imported
      but not used warnings; don't mark internal symbols such as __vtab,
      __def_init etc. Only mark them if they have been explicitly loaded.  */
@@ -5059,7 +5066,7 @@
 	 can be used in expressions in the module.  To avoid the module loading
 	 failing, we need to associate the module's component pointer indexes
 	 with the existing symbol's component pointers.  */
-      if (sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  gfc_component *c;
 
@@ -5213,7 +5220,7 @@
 		{
 		  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,
 						     gfc_current_ns);
-		  info->u.rsym.sym->name = dt_lower_string (info->u.rsym.true_name);
+		  info->u.rsym.sym->name = gfc_dt_lower_string (info->u.rsym.true_name);
 		  sym = info->u.rsym.sym;
 		  sym->module = gfc_get_string (info->u.rsym.module);
 
@@ -5557,10 +5564,10 @@
 
   mio_integer (&n);
 
-  if (sym->attr.flavor == FL_DERIVED)
+  if (gfc_fl_struct (sym->attr.flavor))
     {
       const char *name;
-      name = dt_upper_string (sym->name);
+      name = gfc_dt_upper_string (sym->name);
       mio_pool_string (&name);
     }
   else
@@ -6568,7 +6575,7 @@
   sym->attr.function = 1;
   sym->attr.generic = 1;
 
-  gfc_get_sym_tree (dt_upper_string (sym->name),
+  gfc_get_sym_tree (gfc_dt_upper_string (sym->name),
 		    gfc_current_ns, &tmp_symtree, false);
   dt_sym = tmp_symtree->n.sym;
   dt_sym->name = gfc_get_string (sym->name);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/openmp.c gcc-6-20160721/gcc/fortran/openmp.c
--- gcc-6.1.0/gcc/fortran/openmp.c	2016-04-06 23:07:21.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/openmp.c	2016-06-29 16:08:13.000000000 +0000
@@ -396,43 +396,67 @@
 }
 
 static match
-match_oacc_clause_gang (gfc_omp_clauses *cp)
+match_oacc_clause_gwv (gfc_omp_clauses *cp, unsigned gwv)
 {
   match ret = MATCH_YES;
 
   if (gfc_match (" ( ") != MATCH_YES)
     return MATCH_NO;
 
-  /* The gang clause accepts two optional arguments, num and static.
-     The num argument may either be explicit (num: <val>) or
-     implicit without (<val> without num:).  */
-
-  while (ret == MATCH_YES)
+  if (gwv == GOMP_DIM_GANG)
     {
-      if (gfc_match (" static :") == MATCH_YES)
+        /* The gang clause accepts two optional arguments, num and static.
+	 The num argument may either be explicit (num: <val>) or
+	 implicit without (<val> without num:).  */
+
+      while (ret == MATCH_YES)
 	{
-	  if (cp->gang_static)
-	    return MATCH_ERROR;
+	  if (gfc_match (" static :") == MATCH_YES)
+	    {
+	      if (cp->gang_static)
+		return MATCH_ERROR;
+	      else
+		cp->gang_static = true;
+	      if (gfc_match_char ('*') == MATCH_YES)
+		cp->gang_static_expr = NULL;
+	      else if (gfc_match (" %e ", &cp->gang_static_expr) != MATCH_YES)
+		return MATCH_ERROR;
+	    }
 	  else
-	    cp->gang_static = true;
-	  if (gfc_match_char ('*') == MATCH_YES)
-	    cp->gang_static_expr = NULL;
-	  else if (gfc_match (" %e ", &cp->gang_static_expr) != MATCH_YES)
-	    return MATCH_ERROR;
-	}
-      else
-	{
-	  /* This is optional.  */
-	  if (cp->gang_num_expr || gfc_match (" num :") == MATCH_ERROR)
-	    return MATCH_ERROR;
-	  else if (gfc_match (" %e ", &cp->gang_num_expr) != MATCH_YES)
-	    return MATCH_ERROR;
+	    {
+	      if (cp->gang_num_expr)
+		return MATCH_ERROR;
+
+	      /* The 'num' argument is optional.  */
+	      gfc_match (" num :");
+
+	      if (gfc_match (" %e ", &cp->gang_num_expr) != MATCH_YES)
+		return MATCH_ERROR;
+	    }
+
+	  ret = gfc_match (" , ");
 	}
+    }
+  else if (gwv == GOMP_DIM_WORKER)
+    {
+      /* The 'num' argument is optional.  */
+      gfc_match (" num :");
 
-      ret = gfc_match (" , ");
+      if (gfc_match (" %e ", &cp->worker_expr) != MATCH_YES)
+	return MATCH_ERROR;
     }
+  else if (gwv == GOMP_DIM_VECTOR)
+    {
+      /* The 'length' argument is optional.  */
+      gfc_match (" length :");
+
+      if (gfc_match (" %e ", &cp->vector_expr) != MATCH_YES)
+	return MATCH_ERROR;
+    }
+  else
+    gfc_fatal_error ("Unexpected OpenACC parallelism.");
 
-  return gfc_match (" ) ");
+  return gfc_match (" )");
 }
 
 static match
@@ -640,17 +664,25 @@
       needs_space = false;
       first = false;
       gfc_gobble_whitespace ();
+      old_loc = gfc_current_locus;
       if ((mask & OMP_CLAUSE_ASYNC) && !c->async)
 	if (gfc_match ("async") == MATCH_YES)
 	  {
 	    c->async = true;
-	    needs_space = false;
-	    if (gfc_match (" ( %e )", &c->async_expr) != MATCH_YES)
+	    match m = gfc_match (" ( %e )", &c->async_expr);
+	    if (m == MATCH_ERROR)
 	      {
-		c->async_expr = gfc_get_constant_expr (BT_INTEGER,
-						       gfc_default_integer_kind,
-						      &gfc_current_locus);
+		gfc_current_locus = old_loc;
+		break;
+	      }
+	    else if (m == MATCH_NO)
+	      {
+		c->async_expr
+		  = gfc_get_constant_expr (BT_INTEGER,
+					   gfc_default_integer_kind,
+					   &gfc_current_locus);
 		mpz_set_si (c->async_expr->value.integer, GOMP_ASYNC_NOVAL);
+		needs_space = true;
 	      }
 	    continue;
 	  }
@@ -658,9 +690,13 @@
 	if (gfc_match ("gang") == MATCH_YES)
 	  {
 	    c->gang = true;
-	    if (match_oacc_clause_gang(c) == MATCH_YES)
-	      needs_space = false;
-	    else
+	    match m = match_oacc_clause_gwv (c, GOMP_DIM_GANG);
+	    if (m == MATCH_ERROR)
+	      {
+		gfc_current_locus = old_loc;
+		break;
+	      }
+	    else if (m == MATCH_NO)
 	      needs_space = true;
 	    continue;
 	  }
@@ -668,10 +704,13 @@
 	if (gfc_match ("worker") == MATCH_YES)
 	  {
 	    c->worker = true;
-	    if (gfc_match (" ( num : %e )", &c->worker_expr) == MATCH_YES
-	        || gfc_match (" ( %e )", &c->worker_expr) == MATCH_YES)
-	      needs_space = false;
-	    else
+	    match m = match_oacc_clause_gwv (c, GOMP_DIM_WORKER);
+	    if (m == MATCH_ERROR)
+	      {
+		gfc_current_locus = old_loc;
+		break;
+	      }
+	    else if (m == MATCH_NO)
 	      needs_space = true;
 	    continue;
 	  }
@@ -683,10 +722,13 @@
 	if (gfc_match ("vector") == MATCH_YES)
 	  {
 	    c->vector = true;
-	    if (gfc_match (" ( length : %e )", &c->vector_expr) == MATCH_YES
-	        || gfc_match (" ( %e )", &c->vector_expr) == MATCH_YES)
-	      needs_space = false;
-	    else
+	    match m = match_oacc_clause_gwv (c, GOMP_DIM_VECTOR);
+	    if (m == MATCH_ERROR)
+	      {
+		gfc_current_locus = old_loc;
+		break;
+	      }
+	    if (m == MATCH_NO)
 	      needs_space = true;
 	    continue;
 	  }
@@ -883,10 +925,16 @@
 	        && gfc_match ("wait") == MATCH_YES)
 	{
 	  c->wait = true;
-	  match_oacc_expr_list (" (", &c->wait_list, false);
+	  match m = match_oacc_expr_list (" (", &c->wait_list, false);
+	  if (m == MATCH_ERROR)
+	    {
+	      gfc_current_locus = old_loc;
+	      break;
+	    }
+	  else if (m == MATCH_NO)
+	    needs_space = true;
 	  continue;
 	}
-      old_loc = gfc_current_locus;
       if ((mask & OMP_CLAUSE_REDUCTION)
 	  && gfc_match ("reduction ( ") == MATCH_YES)
 	{
@@ -1582,15 +1630,18 @@
 {
   gfc_omp_clauses *c = gfc_get_omp_clauses ();
   gfc_expr_list *wait_list = NULL, *el;
+  bool space = true;
+  match m;
 
-  match_oacc_expr_list (" (", &wait_list, true);
-  gfc_match_omp_clauses (&c, OACC_WAIT_CLAUSES, false, false, true);
+  m = match_oacc_expr_list (" (", &wait_list, true);
+  if (m == MATCH_ERROR)
+    return m;
+  else if (m == MATCH_YES)
+    space = false;
 
-  if (gfc_match_omp_eos () != MATCH_YES)
-    {
-      gfc_error ("Unexpected junk in !$ACC WAIT at %C");
-      return MATCH_ERROR;
-    }
+  if (gfc_match_omp_clauses (&c, OACC_WAIT_CLAUSES, space, space, true)
+      == MATCH_ERROR)
+    return MATCH_ERROR;
 
   if (wait_list)
     for (el = wait_list; el; el = el->next)
@@ -1623,6 +1674,10 @@
 gfc_match_oacc_cache (void)
 {
   gfc_omp_clauses *c = gfc_get_omp_clauses ();
+  /* The OpenACC cache directive explicitly only allows "array elements or
+     subarrays", which we're currently not checking here.  Either check this
+     after the call of gfc_match_omp_variable_list, or add something like a
+     only_sections variant next to its allow_sections parameter.  */
   match m = gfc_match_omp_variable_list (" (",
 					 &c->lists[OMP_LIST_CACHE], true,
 					 NULL, NULL, true);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/options.c gcc-6-20160721/gcc/fortran/options.c
--- gcc-6.1.0/gcc/fortran/options.c	2016-03-13 00:19:08.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/options.c	2016-05-14 19:52:46.000000000 +0000
@@ -47,6 +47,15 @@
 }
 
 
+/* Set all the DEC extension flags. */
+
+static void
+set_dec_flags (int value)
+{
+    gfc_option.flag_dec_structure  = value;
+}
+
+
 /* Return language mask for Fortran options.  */
 
 unsigned int
@@ -102,6 +111,8 @@
   if (!global_options_set.x_cpp_warn_missing_include_dirs)
     global_options.x_cpp_warn_missing_include_dirs = 1;
 
+  set_dec_flags (0);
+
   set_default_std_flags ();
 
   /* Initialize cpp-related options.  */
@@ -709,6 +720,15 @@
     case OPT_fcheck_:
       gfc_handle_runtime_check_option (arg);
       break;
+
+    case OPT_fdec:
+      /* Enable all DEC extensions.  */
+      set_dec_flags (1);
+      break;
+
+    case OPT_fdec_structure:
+      gfc_option.flag_dec_structure = 1;
+      break;
     }
 
   Fortran_handle_option_auto (&global_options, &global_options_set, 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/parse.c gcc-6-20160721/gcc/fortran/parse.c
--- gcc-6.1.0/gcc/fortran/parse.c	2016-02-11 16:48:45.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/parse.c	2016-07-08 21:27:22.000000000 +0000
@@ -256,6 +256,7 @@
 
     case 's':
       match ("save", gfc_match_save, ST_ATTR_DECL);
+      match ("structure", gfc_match_structure_decl, ST_STRUCTURE_DECL);
       break;
 
     case 't':
@@ -507,6 +508,7 @@
       break;
 
     case 'm':
+      match ("map", gfc_match_map, ST_MAP);
       match ("module% procedure", gfc_match_modproc, ST_MODULE_PROC);
       match ("module", gfc_match_module, ST_MODULE);
       break;
@@ -542,6 +544,7 @@
       break;
 
     case 's':
+      match ("structure", gfc_match_structure_decl, ST_STRUCTURE_DECL);
       match ("sequence", gfc_match_eos, ST_SEQUENCE);
       match ("stop", gfc_match_stop, ST_STOP);
       match ("save", gfc_match_save, ST_ATTR_DECL);
@@ -558,6 +561,7 @@
       break;
 
     case 'u':
+      match ("union", gfc_match_union, ST_UNION);
       match ("unlock", gfc_match_unlock, ST_UNLOCK);
       break;
 
@@ -585,21 +589,12 @@
   return ST_NONE;
 }
 
-/* Like match, but set a flag simd_matched if keyword matched.  */
-#define matchs(keyword, subr, st)				\
-    do {							\
-      if (match_word_omp_simd (keyword, subr, &old_locus,	\
-			       &simd_matched) == MATCH_YES)	\
-	return st;						\
-      else							\
-	undo_new_statement ();				  	\
-    } while (0);
-
-/* Like match, but don't match anything if not -fopenmp.  */
-#define matcho(keyword, subr, st)				\
+/* Like match and if spec_only, goto do_spec_only without actually
+   matching.  */
+#define matcha(keyword, subr, st)				\
     do {							\
-      if (!flag_openmp)						\
-	;							\
+      if (spec_only && gfc_match (keyword) == MATCH_YES)	\
+	goto do_spec_only;					\
       else if (match_word (keyword, subr, &old_locus)		\
 	       == MATCH_YES)					\
 	return st;						\
@@ -612,6 +607,7 @@
 {
   locus old_locus;
   char c;
+  bool spec_only = false;
 
   gfc_enforce_clean_symbol_state ();
 
@@ -626,6 +622,10 @@
       return ST_NONE;
     }
 
+  if (gfc_current_state () == COMP_FUNCTION
+      && gfc_current_block ()->result->ts.kind == -1)
+    spec_only = true;
+
   gfc_unset_implicit_pure (NULL);
 
   old_locus = gfc_current_locus;
@@ -639,49 +639,52 @@
   switch (c)
     {
     case 'a':
-      match ("atomic", gfc_match_oacc_atomic, ST_OACC_ATOMIC);
+      matcha ("atomic", gfc_match_oacc_atomic, ST_OACC_ATOMIC);
       break;
     case 'c':
-      match ("cache", gfc_match_oacc_cache, ST_OACC_CACHE);
+      matcha ("cache", gfc_match_oacc_cache, ST_OACC_CACHE);
       break;
     case 'd':
-      match ("data", gfc_match_oacc_data, ST_OACC_DATA);
+      matcha ("data", gfc_match_oacc_data, ST_OACC_DATA);
       match ("declare", gfc_match_oacc_declare, ST_OACC_DECLARE);
       break;
     case 'e':
-      match ("end atomic", gfc_match_omp_eos, ST_OACC_END_ATOMIC);
-      match ("end data", gfc_match_omp_eos, ST_OACC_END_DATA);
-      match ("end host_data", gfc_match_omp_eos, ST_OACC_END_HOST_DATA);
-      match ("end kernels loop", gfc_match_omp_eos, ST_OACC_END_KERNELS_LOOP);
-      match ("end kernels", gfc_match_omp_eos, ST_OACC_END_KERNELS);
-      match ("end loop", gfc_match_omp_eos, ST_OACC_END_LOOP);
-      match ("end parallel loop", gfc_match_omp_eos, ST_OACC_END_PARALLEL_LOOP);
-      match ("end parallel", gfc_match_omp_eos, ST_OACC_END_PARALLEL);
-      match ("enter data", gfc_match_oacc_enter_data, ST_OACC_ENTER_DATA);
-      match ("exit data", gfc_match_oacc_exit_data, ST_OACC_EXIT_DATA);
+      matcha ("end atomic", gfc_match_omp_eos, ST_OACC_END_ATOMIC);
+      matcha ("end data", gfc_match_omp_eos, ST_OACC_END_DATA);
+      matcha ("end host_data", gfc_match_omp_eos, ST_OACC_END_HOST_DATA);
+      matcha ("end kernels loop", gfc_match_omp_eos, ST_OACC_END_KERNELS_LOOP);
+      matcha ("end kernels", gfc_match_omp_eos, ST_OACC_END_KERNELS);
+      matcha ("end loop", gfc_match_omp_eos, ST_OACC_END_LOOP);
+      matcha ("end parallel loop", gfc_match_omp_eos,
+	      ST_OACC_END_PARALLEL_LOOP);
+      matcha ("end parallel", gfc_match_omp_eos, ST_OACC_END_PARALLEL);
+      matcha ("enter data", gfc_match_oacc_enter_data, ST_OACC_ENTER_DATA);
+      matcha ("exit data", gfc_match_oacc_exit_data, ST_OACC_EXIT_DATA);
       break;
     case 'h':
-      match ("host_data", gfc_match_oacc_host_data, ST_OACC_HOST_DATA);
+      matcha ("host_data", gfc_match_oacc_host_data, ST_OACC_HOST_DATA);
       break;
     case 'p':
-      match ("parallel loop", gfc_match_oacc_parallel_loop, ST_OACC_PARALLEL_LOOP);
-      match ("parallel", gfc_match_oacc_parallel, ST_OACC_PARALLEL);
+      matcha ("parallel loop", gfc_match_oacc_parallel_loop,
+	      ST_OACC_PARALLEL_LOOP);
+      matcha ("parallel", gfc_match_oacc_parallel, ST_OACC_PARALLEL);
       break;
     case 'k':
-      match ("kernels loop", gfc_match_oacc_kernels_loop, ST_OACC_KERNELS_LOOP);
-      match ("kernels", gfc_match_oacc_kernels, ST_OACC_KERNELS);
+      matcha ("kernels loop", gfc_match_oacc_kernels_loop,
+	      ST_OACC_KERNELS_LOOP);
+      matcha ("kernels", gfc_match_oacc_kernels, ST_OACC_KERNELS);
       break;
     case 'l':
-      match ("loop", gfc_match_oacc_loop, ST_OACC_LOOP);
+      matcha ("loop", gfc_match_oacc_loop, ST_OACC_LOOP);
       break;
     case 'r':
       match ("routine", gfc_match_oacc_routine, ST_OACC_ROUTINE);
       break;
     case 'u':
-      match ("update", gfc_match_oacc_update, ST_OACC_UPDATE);
+      matcha ("update", gfc_match_oacc_update, ST_OACC_UPDATE);
       break;
     case 'w':
-      match ("wait", gfc_match_oacc_wait, ST_OACC_WAIT);
+      matcha ("wait", gfc_match_oacc_wait, ST_OACC_WAIT);
       break;
     }
 
@@ -696,14 +699,72 @@
   gfc_error_recovery ();
 
   return ST_NONE;
+
+ do_spec_only:
+  reject_statement ();
+  gfc_clear_error ();
+  gfc_buffer_error (false);
+  gfc_current_locus = old_locus;
+  return ST_GET_FCN_CHARACTERISTICS;
 }
 
+/* Like match, but set a flag simd_matched if keyword matched
+   and if spec_only, goto do_spec_only without actually matching.  */
+#define matchs(keyword, subr, st)				\
+    do {							\
+      if (spec_only && gfc_match (keyword) == MATCH_YES)	\
+	goto do_spec_only;					\
+      if (match_word_omp_simd (keyword, subr, &old_locus,	\
+			       &simd_matched) == MATCH_YES)	\
+	return st;						\
+      else							\
+	undo_new_statement ();				  	\
+    } while (0);
+
+/* Like match, but don't match anything if not -fopenmp
+   and if spec_only, goto do_spec_only without actually matching.  */
+#define matcho(keyword, subr, st)				\
+    do {							\
+      if (!flag_openmp)						\
+	;							\
+      else if (spec_only && gfc_match (keyword) == MATCH_YES)	\
+	goto do_spec_only;					\
+      else if (match_word (keyword, subr, &old_locus)		\
+	       == MATCH_YES)					\
+	return st;						\
+      else							\
+	undo_new_statement ();				  	\
+    } while (0);
+
+/* Like match, but set a flag simd_matched if keyword matched.  */
+#define matchds(keyword, subr, st)				\
+    do {							\
+      if (match_word_omp_simd (keyword, subr, &old_locus,	\
+			       &simd_matched) == MATCH_YES)	\
+	return st;						\
+      else							\
+	undo_new_statement ();				  	\
+    } while (0);
+
+/* Like match, but don't match anything if not -fopenmp.  */
+#define matchdo(keyword, subr, st)				\
+    do {							\
+      if (!flag_openmp)						\
+	;							\
+      else if (match_word (keyword, subr, &old_locus)		\
+	       == MATCH_YES)					\
+	return st;						\
+      else							\
+	undo_new_statement ();				  	\
+    } while (0);
+
 static gfc_statement
 decode_omp_directive (void)
 {
   locus old_locus;
   char c;
   bool simd_matched = false;
+  bool spec_only = false;
 
   gfc_enforce_clean_symbol_state ();
 
@@ -718,6 +779,10 @@
       return ST_NONE;
     }
 
+  if (gfc_current_state () == COMP_FUNCTION
+      && gfc_current_block ()->result->ts.kind == -1)
+    spec_only = true;
+
   gfc_unset_implicit_pure (NULL);
 
   old_locus = gfc_current_locus;
@@ -746,12 +811,12 @@
       matcho ("critical", gfc_match_omp_critical, ST_OMP_CRITICAL);
       break;
     case 'd':
-      matchs ("declare reduction", gfc_match_omp_declare_reduction,
-	      ST_OMP_DECLARE_REDUCTION);
-      matchs ("declare simd", gfc_match_omp_declare_simd,
-	      ST_OMP_DECLARE_SIMD);
-      matcho ("declare target", gfc_match_omp_declare_target,
-	      ST_OMP_DECLARE_TARGET);
+      matchds ("declare reduction", gfc_match_omp_declare_reduction,
+	       ST_OMP_DECLARE_REDUCTION);
+      matchds ("declare simd", gfc_match_omp_declare_simd,
+	       ST_OMP_DECLARE_SIMD);
+      matchdo ("declare target", gfc_match_omp_declare_target,
+	       ST_OMP_DECLARE_TARGET);
       matchs ("distribute parallel do simd",
 	      gfc_match_omp_distribute_parallel_do_simd,
 	      ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD);
@@ -871,8 +936,8 @@
       matcho ("teams distribute", gfc_match_omp_teams_distribute,
 	      ST_OMP_TEAMS_DISTRIBUTE);
       matcho ("teams", gfc_match_omp_teams, ST_OMP_TEAMS);
-      matcho ("threadprivate", gfc_match_omp_threadprivate,
-	      ST_OMP_THREADPRIVATE);
+      matchdo ("threadprivate", gfc_match_omp_threadprivate,
+	       ST_OMP_THREADPRIVATE);
       break;
     case 'w':
       matcho ("workshare", gfc_match_omp_workshare, ST_OMP_WORKSHARE);
@@ -895,6 +960,13 @@
   gfc_error_recovery ();
 
   return ST_NONE;
+
+ do_spec_only:
+  reject_statement ();
+  gfc_clear_error ();
+  gfc_buffer_error (false);
+  gfc_current_locus = old_locus;
+  return ST_GET_FCN_CHARACTERISTICS;
 }
 
 static gfc_statement
@@ -1315,10 +1387,13 @@
 
   gfc_buffer_error (false);
 
-  if (st == ST_GET_FCN_CHARACTERISTICS && gfc_statement_label != NULL)
+  if (st == ST_GET_FCN_CHARACTERISTICS)
     {
-      gfc_free_st_label (gfc_statement_label);
-      gfc_statement_label = NULL;
+      if (gfc_statement_label != NULL)
+	{
+	  gfc_free_st_label (gfc_statement_label);
+	  gfc_statement_label = NULL;
+	}
       gfc_current_locus = old_locus;
     }
 
@@ -1386,9 +1461,13 @@
 
 #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \
   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \
-  case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \
-  case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD: case ST_OMP_DECLARE_REDUCTION: \
-  case ST_OMP_DECLARE_TARGET: case ST_OACC_ROUTINE: case ST_OACC_DECLARE
+  case ST_TYPE: case ST_INTERFACE: case ST_PROCEDURE: case ST_OACC_ROUTINE: \
+  case ST_OACC_DECLARE
+
+/* OpenMP declaration statements.  */
+
+#define case_omp_decl case ST_OMP_THREADPRIVATE: case ST_OMP_DECLARE_SIMD: \
+  case ST_OMP_DECLARE_TARGET: case ST_OMP_DECLARE_REDUCTION
 
 /* Block end statements.  Errors associated with interchanging these
    are detected in gfc_match_end().  */
@@ -1642,6 +1721,15 @@
     case ST_DEALLOCATE:
       p = "DEALLOCATE";
       break;
+    case ST_MAP:
+      p = "MAP";
+      break;
+    case ST_UNION:
+      p = "UNION";
+      break;
+    case ST_STRUCTURE_DECL:
+      p = "STRUCTURE";
+      break;
     case ST_DERIVED_DECL:
       p = _("derived type declaration");
       break;
@@ -1711,6 +1799,15 @@
     case ST_END_WHERE:
       p = "END WHERE";
       break;
+    case ST_END_STRUCTURE:
+      p = "END STRUCTURE";
+      break;
+    case ST_END_UNION:
+      p = "END UNION";
+      break;
+    case ST_END_MAP:
+      p = "END MAP";
+      break;
     case ST_END_TYPE:
       p = "END TYPE";
       break;
@@ -2457,6 +2554,7 @@
 
     case ST_PUBLIC:
     case ST_PRIVATE:
+    case ST_STRUCTURE_DECL:
     case ST_DERIVED_DECL:
     case_decl:
       if (p->state >= ORDER_EXEC)
@@ -2465,6 +2563,14 @@
 	p->state = ORDER_SPEC;
       break;
 
+    case_omp_decl:
+      /* The OpenMP directives have to be somewhere in the specification
+	 part, but there are no further requirements on their ordering.
+	 Thus don't adjust p->state, just ignore them.  */
+      if (p->state >= ORDER_EXEC)
+	goto order;
+      break;
+
     case_executable:
     case_exec_markers:
       if (p->state < ORDER_EXEC)
@@ -2646,6 +2752,358 @@
 }
 
 
+/* Set attributes for the parent symbol based on the attributes of a component
+   and raise errors if conflicting attributes are found for the component.  */
+
+static void
+check_component (gfc_symbol *sym, gfc_component *c, gfc_component **lockp,
+    gfc_component **eventp)
+{
+  bool coarray, lock_type, event_type, allocatable, pointer;
+  coarray = lock_type = event_type = allocatable = pointer = false;
+  gfc_component *lock_comp = NULL, *event_comp = NULL;
+
+  if (lockp) lock_comp = *lockp;
+  if (eventp) event_comp = *eventp;
+
+  /* Look for allocatable components.  */
+  if (c->attr.allocatable
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.allocatable)
+      || (c->ts.type == BT_DERIVED && !c->attr.pointer
+          && c->ts.u.derived->attr.alloc_comp))
+    {
+      allocatable = true;
+      sym->attr.alloc_comp = 1;
+    }
+
+  /* Look for pointer components.  */
+  if (c->attr.pointer
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.class_pointer)
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))
+    {
+      pointer = true;
+      sym->attr.pointer_comp = 1;
+    }
+
+  /* Look for procedure pointer components.  */
+  if (c->attr.proc_pointer
+      || (c->ts.type == BT_DERIVED
+          && c->ts.u.derived->attr.proc_pointer_comp))
+    sym->attr.proc_pointer_comp = 1;
+
+  /* Looking for coarray components.  */
+  if (c->attr.codimension
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.codimension))
+    {
+      coarray = true;
+      sym->attr.coarray_comp = 1;
+    }
+ 
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
+      && !c->attr.pointer)
+    {
+      coarray = true;
+      sym->attr.coarray_comp = 1;
+    }
+
+  /* Looking for lock_type components.  */
+  if ((c->ts.type == BT_DERIVED
+          && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+          && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->ts.u.derived->from_intmod
+             == INTMOD_ISO_FORTRAN_ENV
+          && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
+             == ISOFORTRAN_LOCK_TYPE)
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp
+          && !allocatable && !pointer))
+    {
+      lock_type = 1;
+      lock_comp = c;
+      sym->attr.lock_comp = 1;
+    }
+
+    /* Looking for event_type components.  */
+    if ((c->ts.type == BT_DERIVED
+            && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+            && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+        || (c->ts.type == BT_CLASS && c->attr.class_ok
+            && CLASS_DATA (c)->ts.u.derived->from_intmod
+               == INTMOD_ISO_FORTRAN_ENV
+            && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
+               == ISOFORTRAN_EVENT_TYPE)
+        || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.event_comp
+            && !allocatable && !pointer))
+      {
+        event_type = 1;
+        event_comp = c;
+        sym->attr.event_comp = 1;
+      }
+
+  /* Check for F2008, C1302 - and recall that pointers may not be coarrays
+     (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
+     unless there are nondirect [allocatable or pointer] components
+     involved (cf. 1.3.33.1 and 1.3.33.3).  */
+
+  if (pointer && !coarray && lock_type)
+    gfc_error ("Component %s at %L of type LOCK_TYPE must have a "
+               "codimension or be a subcomponent of a coarray, "
+               "which is not possible as the component has the "
+               "pointer attribute", c->name, &c->loc);
+  else if (pointer && !coarray && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.lock_comp)
+    gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
+               "of type LOCK_TYPE, which must have a codimension or be a "
+               "subcomponent of a coarray", c->name, &c->loc);
+
+  if (lock_type && allocatable && !coarray)
+    gfc_error ("Allocatable component %s at %L of type LOCK_TYPE must have "
+               "a codimension", c->name, &c->loc);
+  else if (lock_type && allocatable && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.lock_comp)
+    gfc_error ("Allocatable component %s at %L must have a codimension as "
+               "it has a noncoarray subcomponent of type LOCK_TYPE",
+               c->name, &c->loc);
+
+  if (sym->attr.coarray_comp && !coarray && lock_type)
+    gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
+               "subcomponent of type LOCK_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as already a coarray "
+               "subcomponent exists)", c->name, &c->loc, sym->name);
+
+  if (sym->attr.lock_comp && coarray && !lock_type)
+    gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
+               "subcomponent of type LOCK_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as %s at %L has a codimension or a "
+               "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
+               sym->name, c->name, &c->loc);
+
+  /* Similarly for EVENT TYPE.  */
+
+  if (pointer && !coarray && event_type)
+    gfc_error ("Component %s at %L of type EVENT_TYPE must have a "
+               "codimension or be a subcomponent of a coarray, "
+               "which is not possible as the component has the "
+               "pointer attribute", c->name, &c->loc);
+  else if (pointer && !coarray && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.event_comp)
+    gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
+               "of type EVENT_TYPE, which must have a codimension or be a "
+               "subcomponent of a coarray", c->name, &c->loc);
+
+  if (event_type && allocatable && !coarray)
+    gfc_error ("Allocatable component %s at %L of type EVENT_TYPE must have "
+               "a codimension", c->name, &c->loc);
+  else if (event_type && allocatable && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.event_comp)
+    gfc_error ("Allocatable component %s at %L must have a codimension as "
+               "it has a noncoarray subcomponent of type EVENT_TYPE",
+               c->name, &c->loc);
+
+  if (sym->attr.coarray_comp && !coarray && event_type)
+    gfc_error ("Noncoarray component %s at %L of type EVENT_TYPE or with "
+               "subcomponent of type EVENT_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as already a coarray "
+               "subcomponent exists)", c->name, &c->loc, sym->name);
+
+  if (sym->attr.event_comp && coarray && !event_type)
+    gfc_error ("Noncoarray component %s at %L of type EVENT_TYPE or with "
+               "subcomponent of type EVENT_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as %s at %L has a codimension or a "
+               "coarray subcomponent)", event_comp->name, &event_comp->loc,
+               sym->name, c->name, &c->loc);
+
+  /* Look for private components.  */
+  if (sym->component_access == ACCESS_PRIVATE
+      || c->attr.access == ACCESS_PRIVATE
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))
+    sym->attr.private_comp = 1;
+
+  if (lockp) *lockp = lock_comp;
+  if (eventp) *eventp = event_comp;
+}
+
+
+static void parse_struct_map (gfc_statement);
+
+/* Parse a union component definition within a structure definition.  */
+
+static void
+parse_union (void)
+{
+  int compiling;
+  gfc_statement st;
+  gfc_state_data s;
+  gfc_component *c, *lock_comp = NULL, *event_comp = NULL;
+  gfc_symbol *un;
+
+  accept_statement(ST_UNION);
+  push_state (&s, COMP_UNION, gfc_new_block);
+  un = gfc_new_block;
+
+  compiling = 1;
+
+  while (compiling)
+    {
+      st = next_statement ();
+      /* Only MAP declarations valid within a union. */
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+
+        case ST_MAP:
+          accept_statement (ST_MAP);
+          parse_struct_map (ST_MAP);
+          /* Add a component to the union for each map. */
+          if (!gfc_add_component (un, gfc_new_block->name, &c))
+            {
+              gfc_internal_error ("failed to create map component '%s'", 
+                  gfc_new_block->name);
+              reject_statement ();
+              return;
+            }
+          c->ts.type = BT_DERIVED;
+          c->ts.u.derived = gfc_new_block;
+          /* Normally components get their initialization expressions when they
+             are created in decl.c (build_struct) so we can look through the
+             flat component list for initializers during resolution. Unions and
+             maps create components along with their type definitions so we
+             have to generate initializers here. */
+          c->initializer = gfc_default_initializer (&c->ts);
+          break;
+
+        case ST_END_UNION:
+          compiling = 0;
+          accept_statement (ST_END_UNION);
+          break;
+
+        default:
+          unexpected_statement (st);
+          break;
+        }
+    }
+
+  for (c = un->components; c; c = c->next)
+    check_component (un, c, &lock_comp, &event_comp);
+
+  /* Add the union as a component in its parent structure.  */
+  pop_state ();
+  if (!gfc_add_component (gfc_current_block (), un->name, &c))
+    {
+      gfc_internal_error ("failed to create union component '%s'", un->name);
+      reject_statement ();
+      return;
+    }
+  c->ts.type = BT_UNION;
+  c->ts.u.derived = un;
+  c->initializer = gfc_default_initializer (&c->ts);
+
+  un->attr.zero_comp = un->components == NULL;
+}
+
+
+/* Parse a STRUCTURE or MAP.  */
+
+static void
+parse_struct_map (gfc_statement block)
+{
+  int compiling_type;
+  gfc_statement st;
+  gfc_state_data s;
+  gfc_symbol *sym;
+  gfc_component *c, *lock_comp = NULL, *event_comp = NULL;
+  gfc_compile_state comp;
+  gfc_statement ends;
+
+  if (block == ST_STRUCTURE_DECL)
+    {
+      comp = COMP_STRUCTURE;
+      ends = ST_END_STRUCTURE;
+    }
+  else
+    {
+      gcc_assert (block == ST_MAP);
+      comp = COMP_MAP;
+      ends = ST_END_MAP;
+    }
+
+  accept_statement(block);
+  push_state (&s, comp, gfc_new_block);
+
+  gfc_new_block->component_access = ACCESS_PUBLIC;
+  compiling_type = 1;
+
+  while (compiling_type)
+    {
+      st = next_statement ();
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+
+        /* Nested structure declarations will be captured as ST_DATA_DECL.  */
+        case ST_STRUCTURE_DECL:
+          /* Let a more specific error make it to decode_statement().  */
+          if (gfc_error_check () == 0)
+            gfc_error ("Syntax error in nested structure declaration at %C");
+          reject_statement ();
+          /* Skip the rest of this statement.  */
+          gfc_error_recovery ();
+          break;
+
+        case ST_UNION:
+          accept_statement (ST_UNION);
+          parse_union ();
+          break;
+
+        case ST_DATA_DECL:
+          /* The data declaration was a nested/ad-hoc STRUCTURE field.  */
+          accept_statement (ST_DATA_DECL);
+          if (gfc_new_block && gfc_new_block != gfc_current_block ()
+                            && gfc_new_block->attr.flavor == FL_STRUCT)
+              parse_struct_map (ST_STRUCTURE_DECL);
+          break;
+
+        case ST_END_STRUCTURE:
+        case ST_END_MAP:
+          if (st == ends)
+            {
+              accept_statement (st);
+              compiling_type = 0;
+            }
+          else
+            unexpected_statement (st);
+          break;
+
+        default:
+          unexpected_statement (st);
+          break;
+        }
+    }
+
+  /* Validate each component.  */
+  sym = gfc_current_block ();
+  for (c = sym->components; c; c = c->next)
+    check_component (sym, c, &lock_comp, &event_comp);
+
+  sym->attr.zero_comp = (sym->components == NULL);
+
+  /* Allow parse_union to find this structure to add to its list of maps.  */
+  if (block == ST_MAP)
+    gfc_new_block = gfc_current_block ();
+
+  pop_state ();
+}
+
+
 /* Parse a derived type.  */
 
 static void
@@ -2762,170 +3220,7 @@
    */
   sym = gfc_current_block ();
   for (c = sym->components; c; c = c->next)
-    {
-      bool coarray, lock_type, event_type, allocatable, pointer;
-      coarray = lock_type = event_type = allocatable = pointer = false;
-
-      /* Look for allocatable components.  */
-      if (c->attr.allocatable
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.allocatable)
-	  || (c->ts.type == BT_DERIVED && !c->attr.pointer
-	      && c->ts.u.derived->attr.alloc_comp))
-	{
-	  allocatable = true;
-	  sym->attr.alloc_comp = 1;
-	}
-
-      /* Look for pointer components.  */
-      if (c->attr.pointer
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.class_pointer)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))
-	{
-	  pointer = true;
-	  sym->attr.pointer_comp = 1;
-	}
-
-      /* Look for procedure pointer components.  */
-      if (c->attr.proc_pointer
-	  || (c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->attr.proc_pointer_comp))
-	sym->attr.proc_pointer_comp = 1;
-
-      /* Looking for coarray components.  */
-      if (c->attr.codimension
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.codimension))
-	{
-	  coarray = true;
-	  sym->attr.coarray_comp = 1;
-	}
-
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
-	  && !c->attr.pointer)
-	{
-	  coarray = true;
-	  sym->attr.coarray_comp = 1;
-	}
-
-      /* Looking for lock_type components.  */
-      if ((c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->ts.u.derived->from_intmod
-		 == INTMOD_ISO_FORTRAN_ENV
-	      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
-		 == ISOFORTRAN_LOCK_TYPE)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp
-	      && !allocatable && !pointer))
-	{
-	  lock_type = 1;
-	  lock_comp = c;
-	  sym->attr.lock_comp = 1;
-	}
-
-      /* Looking for event_type components.  */
-      if ((c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->ts.u.derived->from_intmod
-		 == INTMOD_ISO_FORTRAN_ENV
-	      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
-		 == ISOFORTRAN_EVENT_TYPE)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.event_comp
-	      && !allocatable && !pointer))
-	{
-	  event_type = 1;
-	  event_comp = c;
-	  sym->attr.event_comp = 1;
-	}
-
-      /* Check for F2008, C1302 - and recall that pointers may not be coarrays
-	 (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
-	 unless there are nondirect [allocatable or pointer] components
-	 involved (cf. 1.3.33.1 and 1.3.33.3).  */
-
-      if (pointer && !coarray && lock_type)
-	gfc_error ("Component %s at %L of type LOCK_TYPE must have a "
-		   "codimension or be a subcomponent of a coarray, "
-		   "which is not possible as the component has the "
-		   "pointer attribute", c->name, &c->loc);
-      else if (pointer && !coarray && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.lock_comp)
-	gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
-		   "of type LOCK_TYPE, which must have a codimension or be a "
-		   "subcomponent of a coarray", c->name, &c->loc);
-
-      if (lock_type && allocatable && !coarray)
-	gfc_error ("Allocatable component %s at %L of type LOCK_TYPE must have "
-		   "a codimension", c->name, &c->loc);
-      else if (lock_type && allocatable && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.lock_comp)
-	gfc_error ("Allocatable component %s at %L must have a codimension as "
-		   "it has a noncoarray subcomponent of type LOCK_TYPE",
-		   c->name, &c->loc);
-
-      if (sym->attr.coarray_comp && !coarray && lock_type)
-	gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
-		   "subcomponent of type LOCK_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as already a coarray "
-		   "subcomponent exists)", c->name, &c->loc, sym->name);
-
-      if (sym->attr.lock_comp && coarray && !lock_type)
-	gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
-		   "subcomponent of type LOCK_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as %s at %L has a codimension or a "
-		   "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
-		   sym->name, c->name, &c->loc);
-
-      /* Similarly for EVENT TYPE.  */
-
-      if (pointer && !coarray && event_type)
-	gfc_error ("Component %s at %L of type EVENT_TYPE must have a "
-		   "codimension or be a subcomponent of a coarray, "
-		   "which is not possible as the component has the "
-		   "pointer attribute", c->name, &c->loc);
-      else if (pointer && !coarray && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.event_comp)
-	gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
-		   "of type EVENT_TYPE, which must have a codimension or be a "
-		   "subcomponent of a coarray", c->name, &c->loc);
-
-      if (event_type && allocatable && !coarray)
-	gfc_error ("Allocatable component %s at %L of type EVENT_TYPE must have "
-		   "a codimension", c->name, &c->loc);
-      else if (event_type && allocatable && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.event_comp)
-	gfc_error ("Allocatable component %s at %L must have a codimension as "
-		   "it has a noncoarray subcomponent of type EVENT_TYPE",
-		   c->name, &c->loc);
-
-      if (sym->attr.coarray_comp && !coarray && event_type)
-	gfc_error ("Noncoarray component %s at %L of type EVENT_TYPE or with "
-		   "subcomponent of type EVENT_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as already a coarray "
-		   "subcomponent exists)", c->name, &c->loc, sym->name);
-
-      if (sym->attr.event_comp && coarray && !event_type)
-	gfc_error ("Noncoarray component %s at %L of type EVENT_TYPE or with "
-		   "subcomponent of type EVENT_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as %s at %L has a codimension or a "
-		   "coarray subcomponent)", event_comp->name, &event_comp->loc,
-		   sym->name, c->name, &c->loc);
-
-      /* Look for private components.  */
-      if (sym->component_access == ACCESS_PRIVATE
-	  || c->attr.access == ACCESS_PRIVATE
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))
-	sym->attr.private_comp = 1;
-    }
+    check_component (sym, c, &lock_comp, &event_comp);
 
   if (!seen_component)
     sym->attr.zero_comp = 1;
@@ -3348,8 +3643,10 @@
     case ST_PARAMETER:
     case ST_PUBLIC:
     case ST_PRIVATE:
+    case ST_STRUCTURE_DECL:
     case ST_DERIVED_DECL:
     case_decl:
+    case_omp_decl:
 declSt:
       if (!verify_st_order (&ss, st, false))
 	{
@@ -3364,6 +3661,10 @@
 	  parse_interface ();
 	  break;
 
+        case ST_STRUCTURE_DECL:
+          parse_struct_map (ST_STRUCTURE_DECL);
+          break;
+
 	case ST_DERIVED_DECL:
 	  parse_derived ();
 	  break;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/parse.h gcc-6-20160721/gcc/fortran/parse.h
--- gcc-6.1.0/gcc/fortran/parse.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/parse.h	2016-05-14 19:52:46.000000000 +0000
@@ -28,6 +28,7 @@
   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBMODULE, COMP_SUBROUTINE,
   COMP_FUNCTION, COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED,
   COMP_DERIVED_CONTAINS, COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,
+  COMP_STRUCTURE, COMP_UNION, COMP_MAP,
   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,
   COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT
 };
@@ -58,6 +59,8 @@
 
 #define gfc_current_block() (gfc_state_stack->sym)
 #define gfc_current_state() (gfc_state_stack->state)
+#define gfc_comp_struct(s) \
+  ((s) == COMP_DERIVED || (s) == COMP_STRUCTURE || (s) == COMP_MAP)
 
 int gfc_check_do_variable (gfc_symtree *);
 bool gfc_find_state (gfc_compile_state);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/primary.c gcc-6-20160721/gcc/fortran/primary.c
--- gcc-6.1.0/gcc/fortran/primary.c	2016-02-07 20:15:55.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/primary.c	2016-05-14 19:52:46.000000000 +0000
@@ -1883,11 +1883,12 @@
 		   bool ppc_arg)
 {
   char name[GFC_MAX_SYMBOL_LEN + 1];
-  gfc_ref *substring, *tail;
+  gfc_ref *substring, *tail, *tmp;
   gfc_component *component;
   gfc_symbol *sym = primary->symtree->n.sym;
   match m;
   bool unknown;
+  char sep;
 
   tail = NULL;
 
@@ -1972,25 +1973,31 @@
   if (equiv_flag)
     return MATCH_YES;
 
-  if (sym->ts.type == BT_UNKNOWN && gfc_peek_ascii_char () == '%'
+  /* With DEC extensions, member separator may be '.' or '%'.  */
+  sep = gfc_peek_ascii_char ();
+  m = gfc_match_member_sep (sym);
+  if (m == MATCH_ERROR)
+    return MATCH_ERROR;
+
+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES
       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)
     gfc_set_default_type (sym, 0, sym->ns);
 
-  if (sym->ts.type == BT_UNKNOWN && gfc_match_char ('%') == MATCH_YES)
+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES)
     {
       gfc_error ("Symbol %qs at %C has no IMPLICIT type", sym->name);
       return MATCH_ERROR;
     }
   else if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)
-	   && gfc_match_char ('%') == MATCH_YES)
+           && m == MATCH_YES)
     {
-      gfc_error ("Unexpected %<%%%> for nonderived-type variable %qs at %C",
-		 sym->name);
+      gfc_error ("Unexpected %<%c%> for nonderived-type variable %qs at %C",
+		 sep, sym->name);
       return MATCH_ERROR;
     }
 
   if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)
-      || gfc_match_char ('%') != MATCH_YES)
+      || m != MATCH_YES)
     goto check_substring;
 
   sym = sym->ts.u.derived;
@@ -2061,15 +2068,24 @@
 	  break;
 	}
 
-      component = gfc_find_component (sym, name, false, false);
+      component = gfc_find_component (sym, name, false, false, &tmp);
       if (component == NULL)
 	return MATCH_ERROR;
 
-      tail = extend_ref (primary, tail);
-      tail->type = REF_COMPONENT;
+      /* Extend the reference chain determined by gfc_find_component.  */
+      if (primary->ref == NULL)
+        primary->ref = tmp;
+      else
+        {
+          /* Set by the for loop below for the last component ref.  */
+          gcc_assert (tail != NULL);
+          tail->next = tmp;
+        }
 
-      tail->u.c.component = component;
-      tail->u.c.sym = sym;
+      /* The reference chain may be longer than one hop for union
+         subcomponents; find the new tail.  */
+      for (tail = tmp; tail->next; tail = tail->next)
+        ;
 
       primary->ts = component->ts;
 
@@ -2119,7 +2135,7 @@
 	}
 
       if ((component->ts.type != BT_DERIVED && component->ts.type != BT_CLASS)
-	  || gfc_match_char ('%') != MATCH_YES)
+	  || gfc_match_member_sep (component->ts.u.derived) != MATCH_YES)
 	break;
 
       sym = component->ts.u.derived;
@@ -2127,7 +2143,7 @@
 
 check_substring:
   unknown = false;
-  if (primary->ts.type == BT_UNKNOWN && sym->attr.flavor != FL_DERIVED)
+  if (primary->ts.type == BT_UNKNOWN && !gfc_fl_struct (sym->attr.flavor))
     {
       if (gfc_get_default_type (sym->name, sym->ns)->type == BT_CHARACTER)
        {
@@ -2548,11 +2564,11 @@
       /* Find the current component in the structure definition and check
 	     its access is not private.  */
       if (comp)
-	this_comp = gfc_find_component (sym, comp->name, false, false);
+	this_comp = gfc_find_component (sym, comp->name, false, false, NULL);
       else
 	{
 	  this_comp = gfc_find_component (sym, (const char *)comp_tail->name,
-					  false, false);
+					  false, false, NULL);
 	  comp = NULL; /* Reset needed!  */
 	}
 
@@ -2596,7 +2612,7 @@
           if (comp && comp == sym->components
                 && sym->attr.extension
 		&& comp_tail->val
-                && (comp_tail->val->ts.type != BT_DERIVED
+                && (!gfc_bt_struct (comp_tail->val->ts.type)
                       ||
                     comp_tail->val->ts.u.derived != this_comp->ts.u.derived))
             {
@@ -2697,7 +2713,7 @@
   e->symtree = symtree;
   e->expr_type = EXPR_FUNCTION;
 
-  gcc_assert (sym->attr.flavor == FL_DERIVED
+  gcc_assert (gfc_fl_struct (sym->attr.flavor)
 	      && symtree->n.sym->attr.flavor == FL_PROCEDURE);
   e->value.function.esym = sym;
   e->symtree->n.sym->attr.generic = 1;
@@ -2795,15 +2811,29 @@
   if (m != MATCH_YES)
     return m;
 
-  if (gfc_find_state (COMP_INTERFACE)
-      && !gfc_current_ns->has_import_set)
-    i = gfc_get_sym_tree (name, NULL, &symtree, false);
-  else
-    i = gfc_get_ha_sym_tree (name, &symtree);
-
-  if (i)
+  /* Check if the symbol exists.  */
+  if (gfc_find_sym_tree (name, NULL, 1, &symtree))
     return MATCH_ERROR;
 
+  /* If the symbol doesn't exist, create it unless the name matches a FL_STRUCT
+     type. For derived types we create a generic symbol which links to the
+     derived type symbol; STRUCTUREs are simpler and must not conflict with
+     variables.  */
+  if (!symtree)
+    if (gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree))
+      return MATCH_ERROR;
+  if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)
+    {
+      if (gfc_find_state (COMP_INTERFACE)
+          && !gfc_current_ns->has_import_set)
+        i = gfc_get_sym_tree (name, NULL, &symtree, false);
+      else
+        i = gfc_get_ha_sym_tree (name, &symtree);
+      if (i)
+        return MATCH_ERROR;
+    }
+
+
   sym = symtree->n.sym;
   e = NULL;
   where = gfc_current_locus;
@@ -2914,6 +2944,7 @@
 
       break;
 
+    case FL_STRUCT:
     case FL_DERIVED:
       sym = gfc_use_derived (sym);
       if (sym == NULL)
@@ -3054,10 +3085,12 @@
 	 via an IMPLICIT statement.  This can't wait for the
 	 resolution phase.  */
 
-      if (gfc_peek_ascii_char () == '%'
+      old_loc = gfc_current_locus;
+      if (gfc_match_member_sep (sym) == MATCH_YES
 	  && sym->ts.type == BT_UNKNOWN
 	  && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)
 	gfc_set_default_type (sym, 0, sym->ns);
+      gfc_current_locus = old_loc;
 
       /* If the symbol has a (co)dimension attribute, the expression is a
 	 variable.  */
@@ -3210,13 +3243,19 @@
       break;
 
     generic_function:
-      gfc_get_sym_tree (name, NULL, &symtree, false);	/* Can't fail */
+      /* Look for symbol first; if not found, look for STRUCTURE type symbol
+         specially. Creates a generic symbol for derived types.  */
+      gfc_find_sym_tree (name, NULL, 1, &symtree);
+      if (!symtree)
+        gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree);
+      if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)
+        gfc_get_sym_tree (name, NULL, &symtree, false); /* Can't fail */
 
       e = gfc_get_expr ();
       e->symtree = symtree;
       e->expr_type = EXPR_FUNCTION;
 
-      if (sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  e->value.function.esym = sym;
 	  e->symtree->n.sym->attr.generic = 1;
@@ -3260,10 +3299,10 @@
 static match
 match_variable (gfc_expr **result, int equiv_flag, int host_flag)
 {
-  gfc_symbol *sym;
+  gfc_symbol *sym, *dt_sym;
   gfc_symtree *st;
   gfc_expr *expr;
-  locus where;
+  locus where, old_loc;
   match m;
 
   /* Since nothing has any business being an lvalue in a module
@@ -3294,6 +3333,17 @@
   sym->attr.implied_index = 0;
 
   gfc_set_sym_referenced (sym);
+
+  /* STRUCTUREs may share names with variables, but derived types may not.  */
+  if (sym->attr.flavor == FL_PROCEDURE && sym->generic
+      && (dt_sym = gfc_find_dt_in_generic (sym)))
+    {
+      if (dt_sym->attr.flavor == FL_DERIVED)
+        gfc_error ("Derived type '%s' cannot be used as a variable at %C",
+                   sym->name);
+      return MATCH_ERROR;
+    }
+
   switch (sym->attr.flavor)
     {
     case FL_VARIABLE:
@@ -3379,11 +3429,13 @@
 	implicit_ns = gfc_current_ns;
       else
 	implicit_ns = sym->ns;
-
-      if (gfc_peek_ascii_char () == '%'
+	
+      old_loc = gfc_current_locus;
+      if (gfc_match_member_sep (sym) == MATCH_YES
 	  && sym->ts.type == BT_UNKNOWN
 	  && gfc_get_default_type (sym->name, implicit_ns)->type == BT_DERIVED)
 	gfc_set_default_type (sym, 0, implicit_ns);
+      gfc_current_locus = old_loc;
     }
 
   expr = gfc_get_expr ();
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/resolve.c gcc-6-20160721/gcc/fortran/resolve.c
--- gcc-6.1.0/gcc/fortran/resolve.c	2016-04-04 10:32:32.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/resolve.c	2016-06-01 18:46:11.000000000 +0000
@@ -535,7 +535,7 @@
 find_arglists (gfc_symbol *sym)
 {
   if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns
-      || sym->attr.flavor == FL_DERIVED || sym->attr.intrinsic)
+      || gfc_fl_struct (sym->attr.flavor) || sym->attr.intrinsic)
     return;
 
   resolve_formal_arglist (sym);
@@ -1116,6 +1116,7 @@
 
 
 static bool resolve_fl_derived0 (gfc_symbol *sym);
+static bool resolve_fl_struct (gfc_symbol *sym);
 
 
 /* Resolve all of the elements of a structure constructor and make sure that
@@ -1132,8 +1133,13 @@
 
   t = true;
 
-  if (expr->ts.type == BT_DERIVED)
-    resolve_fl_derived0 (expr->ts.u.derived);
+  if (expr->ts.type == BT_DERIVED || expr->ts.type == BT_UNION)
+    {
+      if (expr->ts.u.derived->attr.flavor == FL_DERIVED)
+        resolve_fl_derived0 (expr->ts.u.derived);
+      else
+        resolve_fl_struct (expr->ts.u.derived);
+    }
 
   cons = gfc_constructor_first (expr->value.constructor);
 
@@ -1561,7 +1567,7 @@
   gfc_namespace* real_context;
 
   if (sym->attr.flavor == FL_PROGRAM
-      || sym->attr.flavor == FL_DERIVED)
+      || gfc_fl_struct (sym->attr.flavor))
     return false;
 
   gcc_assert (sym->attr.flavor == FL_PROCEDURE);
@@ -2548,7 +2554,7 @@
 generic:
       if (!intr)
 	for (intr = sym->generic; intr; intr = intr->next)
-	  if (intr->sym->attr.flavor == FL_DERIVED)
+	  if (gfc_fl_struct (intr->sym->attr.flavor))
 	    break;
 
       if (sym->ns->parent == NULL)
@@ -5715,7 +5721,7 @@
 	continue;
 
       if ((ref->u.c.component->ts.type == BT_CLASS
-	     || (check_types && ref->u.c.component->ts.type == BT_DERIVED))
+	     || (check_types && gfc_bt_struct (ref->u.c.component->ts.type)))
 	  && ref->u.c.component->attr.flavor != FL_PROCEDURE)
 	{
 	  declared = ref->u.c.component->ts.u.derived;
@@ -5978,7 +5984,7 @@
 	 is present.  */
       ts = expr->ts;
       declared = ts.u.derived;
-      c = gfc_find_component (declared, "_vptr", true, true);
+      c = gfc_find_component (declared, "_vptr", true, true, NULL);
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
@@ -6025,14 +6031,14 @@
     return false;
 
   /* Weed out cases of the ultimate component being a derived type.  */
-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)
+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
       return resolve_compcall (e, NULL);
     }
 
-  c = gfc_find_component (declared, "_data", true, true);
+  c = gfc_find_component (declared, "_data", true, true, NULL);
   declared = c->ts.u.derived;
 
   /* Treat the call as if it is a typebound procedure, in order to roll
@@ -6111,7 +6117,7 @@
 	 that any delays in resolution are corrected and that the vtab
 	 is present.  */
       declared = expr->ts.u.derived;
-      c = gfc_find_component (declared, "_vptr", true, true);
+      c = gfc_find_component (declared, "_vptr", true, true, NULL);
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
@@ -6156,7 +6162,7 @@
   get_declared_from_expr (&class_ref, &new_ref, code->expr1, true);
 
   /* Weed out cases of the ultimate component being a derived type.  */
-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)
+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
@@ -7140,7 +7146,7 @@
       gfc_typespec ts;
       gfc_expr *init_e;
 
-      if (code->ext.alloc.ts.type == BT_DERIVED)
+      if (gfc_bt_struct (code->ext.alloc.ts.type))
 	ts = code->ext.alloc.ts;
       else
 	ts = e->ts;
@@ -7148,7 +7154,7 @@
       if (ts.type == BT_CLASS)
 	ts = ts.u.derived->components->ts;
 
-      if (ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&ts)))
+      if (gfc_bt_struct (ts.type) && (init_e = gfc_default_initializer (&ts)))
 	{
 	  gfc_code *init_st = gfc_get_code (EXEC_INIT_ASSIGN);
 	  init_st->loc = code->loc;
@@ -7282,7 +7288,7 @@
 	  sym = a->expr->symtree->n.sym;
 
 	  /* TODO - check derived type components.  */
-	  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
+	  if (gfc_bt_struct (sym->ts.type) || sym->ts.type == BT_CLASS)
 	    continue;
 
 	  if ((ar->start[i] != NULL
@@ -8220,7 +8226,7 @@
 	  if (!gfc_build_class_symbol (&sym->ts, &attr, &as))
 	    gcc_unreachable ();
 	  /* Make sure the _vptr is set.  */
-	  c = gfc_find_component (sym->ts.u.derived, "_vptr", true, true);
+	  c = gfc_find_component (sym->ts.u.derived, "_vptr", true, true, NULL);
 	  if (c->ts.u.derived == NULL)
 	    c->ts.u.derived = gfc_find_derived_vtab (sym->ts.u.derived);
 	  CLASS_DATA (sym)->attr.pointer = 1;
@@ -9911,7 +9917,7 @@
 
   for (c= derived->components; c; c = c->next)
     {
-      if ((c->ts.type != BT_DERIVED
+      if ((!gfc_bt_struct (c->ts.type)
 	    || c->attr.pointer
 	    || c->attr.allocatable
 	    || c->attr.proc_pointer_comp
@@ -10051,7 +10057,7 @@
 
       /* The intrinsic assignment does the right thing for pointers
 	 of all kinds and allocatable components.  */
-      if (comp1->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (comp1->ts.type)
 	  || comp1->attr.pointer
 	  || comp1->attr.allocatable
 	  || comp1->attr.proc_pointer_comp
@@ -11433,7 +11439,7 @@
       gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 0, &s);
       if (s && s->attr.generic)
 	s = gfc_find_dt_in_generic (s);
-      if (s && s->attr.flavor != FL_DERIVED)
+      if (s && !gfc_fl_struct (s->attr.flavor))
 	{
 	  gfc_error ("The type %qs cannot be host associated at %L "
 		     "because it is blocked by an incompatible object "
@@ -11959,17 +11965,17 @@
 	goto check_formal;
 
       /* Check the procedure characteristics.  */
-      if (sym->attr.pure != iface->attr.pure)
+      if (sym->attr.elemental != iface->attr.elemental)
 	{
-	  gfc_error ("Mismatch in PURE attribute between MODULE "
+	  gfc_error ("Mismatch in ELEMENTAL attribute between MODULE "
 		     "PROCEDURE at %L and its interface in %s",
 		     &sym->declared_at, module_name);
 	  return false;
 	}
 
-      if (sym->attr.elemental != iface->attr.elemental)
+      if (sym->attr.pure != iface->attr.pure)
 	{
-	  gfc_error ("Mismatch in ELEMENTAL attribute between MODULE "
+	  gfc_error ("Mismatch in PURE attribute between MODULE "
 		     "PROCEDURE at %L and its interface in %s",
 		     &sym->declared_at, module_name);
 	  return false;
@@ -12733,7 +12739,8 @@
       }
 
   /* Try to find a name collision with an inherited component.  */
-  if (super_type && gfc_find_component (super_type, stree->name, true, true))
+  if (super_type && gfc_find_component (super_type, stree->name, true, true,
+                                        NULL))
     {
       gfc_error ("Procedure %qs at %L has the same name as an inherited"
 		 " component of %qs",
@@ -12881,7 +12888,7 @@
 
   for (c = derived->components; c; c = c->next)
     {
-      if (c->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (c->ts.type)
 	  || c->attr.pointer
 	  || c->attr.allocatable
 	  || c->attr.proc_pointer_comp
@@ -12907,435 +12914,498 @@
 }
 
 
-/* Resolve the components of a derived type. This does not have to wait until
-   resolution stage, but can be done as soon as the dt declaration has been
-   parsed.  */
+/* Resolve a single component of a derived type or structure.  */
 
 static bool
-resolve_fl_derived0 (gfc_symbol *sym)
+resolve_component (gfc_component *c, gfc_symbol *sym)
 {
-  gfc_symbol* super_type;
-  gfc_component *c;
+  gfc_symbol *super_type;
 
-  if (sym->attr.unlimited_polymorphic)
+  if (c->attr.artificial)
     return true;
 
-  super_type = gfc_get_derived_super_type (sym);
+  /* F2008, C442.  */
+  if ((!sym->attr.is_class || c != sym->components)
+      && c->attr.codimension
+      && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
+    {
+      gfc_error ("Coarray component %qs at %L must be allocatable with "
+                 "deferred shape", c->name, &c->loc);
+      return false;
+    }
 
-  /* F2008, C432.  */
-  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)
+  /* F2008, C443.  */
+  if (c->attr.codimension && c->ts.type == BT_DERIVED
+      && c->ts.u.derived->ts.is_iso_c)
     {
-      gfc_error ("As extending type %qs at %L has a coarray component, "
-		 "parent type %qs shall also have one", sym->name,
-		 &sym->declared_at, super_type->name);
+      gfc_error ("Component %qs at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) "
+                 "shall not be a coarray", c->name, &c->loc);
       return false;
     }
 
-  /* Ensure the extended type gets resolved before we do.  */
-  if (super_type && !resolve_fl_derived0 (super_type))
-    return false;
+  /* F2008, C444.  */
+  if (gfc_bt_struct (c->ts.type) && c->ts.u.derived->attr.coarray_comp
+      && (c->attr.codimension || c->attr.pointer || c->attr.dimension
+          || c->attr.allocatable))
+    {
+      gfc_error ("Component %qs at %L with coarray component "
+                 "shall be a nonpointer, nonallocatable scalar",
+                 c->name, &c->loc);
+      return false;
+    }
 
-  /* An ABSTRACT type must be extensible.  */
-  if (sym->attr.abstract && !gfc_type_is_extensible (sym))
+  /* F2008, C448.  */
+  if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))
     {
-      gfc_error ("Non-extensible derived-type %qs at %L must not be ABSTRACT",
-		 sym->name, &sym->declared_at);
+      gfc_error ("Component %qs at %L has the CONTIGUOUS attribute but "
+                 "is not an array pointer", c->name, &c->loc);
       return false;
     }
 
-  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components
-			   : sym->components;
+  if (c->attr.proc_pointer && c->ts.interface)
+    {
+      gfc_symbol *ifc = c->ts.interface;
 
-  bool success = true;
+      if (!sym->attr.vtype && !check_proc_interface (ifc, &c->loc))
+        {
+          c->tb->error = 1;
+          return false;
+        }
 
-  for ( ; c != NULL; c = c->next)
+      if (ifc->attr.if_source || ifc->attr.intrinsic)
+        {
+          /* Resolve interface and copy attributes.  */
+          if (ifc->formal && !ifc->formal_ns)
+            resolve_symbol (ifc);
+          if (ifc->attr.intrinsic)
+            gfc_resolve_intrinsic (ifc, &ifc->declared_at);
+
+          if (ifc->result)
+            {
+              c->ts = ifc->result->ts;
+              c->attr.allocatable = ifc->result->attr.allocatable;
+              c->attr.pointer = ifc->result->attr.pointer;
+              c->attr.dimension = ifc->result->attr.dimension;
+              c->as = gfc_copy_array_spec (ifc->result->as);
+              c->attr.class_ok = ifc->result->attr.class_ok;
+            }
+          else
+            {
+              c->ts = ifc->ts;
+              c->attr.allocatable = ifc->attr.allocatable;
+              c->attr.pointer = ifc->attr.pointer;
+              c->attr.dimension = ifc->attr.dimension;
+              c->as = gfc_copy_array_spec (ifc->as);
+              c->attr.class_ok = ifc->attr.class_ok;
+            }
+          c->ts.interface = ifc;
+          c->attr.function = ifc->attr.function;
+          c->attr.subroutine = ifc->attr.subroutine;
+
+          c->attr.pure = ifc->attr.pure;
+          c->attr.elemental = ifc->attr.elemental;
+          c->attr.recursive = ifc->attr.recursive;
+          c->attr.always_explicit = ifc->attr.always_explicit;
+          c->attr.ext_attr |= ifc->attr.ext_attr;
+          /* Copy char length.  */
+          if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)
+            {
+              gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);
+              if (cl->length && !cl->resolved
+                  && !gfc_resolve_expr (cl->length))
+                {
+                  c->tb->error = 1;
+                  return false;
+                }
+              c->ts.u.cl = cl;
+            }
+        }
+    }
+  else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)
     {
-      if (c->attr.artificial)
-	continue;
+      /* Since PPCs are not implicitly typed, a PPC without an explicit
+         interface must be a subroutine.  */
+      gfc_add_subroutine (&c->attr, c->name, &c->loc);
+    }
 
-      /* F2008, C442.  */
-      if ((!sym->attr.is_class || c != sym->components)
-	  && c->attr.codimension
-	  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
-	{
-	  gfc_error ("Coarray component %qs at %L must be allocatable with "
-		     "deferred shape", c->name, &c->loc);
-	  success = false;
-	  continue;
-	}
+  /* Procedure pointer components: Check PASS arg.  */
+  if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0
+      && !sym->attr.vtype)
+    {
+      gfc_symbol* me_arg;
 
-      /* F2008, C443.  */
-      if (c->attr.codimension && c->ts.type == BT_DERIVED
-	  && c->ts.u.derived->ts.is_iso_c)
-	{
-	  gfc_error ("Component %qs at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) "
-		     "shall not be a coarray", c->name, &c->loc);
-	  success = false;
-	  continue;
-	}
+      if (c->tb->pass_arg)
+        {
+          gfc_formal_arglist* i;
 
-      /* F2008, C444.  */
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
-	  && (c->attr.codimension || c->attr.pointer || c->attr.dimension
-	      || c->attr.allocatable))
-	{
-	  gfc_error ("Component %qs at %L with coarray component "
-		     "shall be a nonpointer, nonallocatable scalar",
-		     c->name, &c->loc);
-	  success = false;
-	  continue;
-	}
+          /* If an explicit passing argument name is given, walk the arg-list
+            and look for it.  */
 
-      /* F2008, C448.  */
-      if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))
-	{
-	  gfc_error ("Component %qs at %L has the CONTIGUOUS attribute but "
-		     "is not an array pointer", c->name, &c->loc);
-	  success = false;
-	  continue;
-	}
+          me_arg = NULL;
+          c->tb->pass_arg_num = 1;
+          for (i = c->ts.interface->formal; i; i = i->next)
+            {
+              if (!strcmp (i->sym->name, c->tb->pass_arg))
+                {
+                  me_arg = i->sym;
+                  break;
+                }
+              c->tb->pass_arg_num++;
+            }
 
-      if (c->attr.proc_pointer && c->ts.interface)
-	{
-	  gfc_symbol *ifc = c->ts.interface;
+          if (!me_arg)
+            {
+              gfc_error ("Procedure pointer component %qs with PASS(%s) "
+                         "at %L has no argument %qs", c->name,
+                         c->tb->pass_arg, &c->loc, c->tb->pass_arg);
+              c->tb->error = 1;
+              return false;
+            }
+        }
+      else
+        {
+          /* Otherwise, take the first one; there should in fact be at least
+            one.  */
+          c->tb->pass_arg_num = 1;
+          if (!c->ts.interface->formal)
+            {
+              gfc_error ("Procedure pointer component %qs with PASS at %L "
+                         "must have at least one argument",
+                         c->name, &c->loc);
+              c->tb->error = 1;
+              return false;
+            }
+          me_arg = c->ts.interface->formal->sym;
+        }
 
-	  if (!sym->attr.vtype && !check_proc_interface (ifc, &c->loc))
-	    {
-	      c->tb->error = 1;
-	      success = false;
-	      continue;
-	    }
+      /* Now check that the argument-type matches.  */
+      gcc_assert (me_arg);
+      if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)
+          || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)
+          || (me_arg->ts.type == BT_CLASS
+              && CLASS_DATA (me_arg)->ts.u.derived != sym))
+        {
+          gfc_error ("Argument %qs of %qs with PASS(%s) at %L must be of"
+                     " the derived type %qs", me_arg->name, c->name,
+                     me_arg->name, &c->loc, sym->name);
+          c->tb->error = 1;
+          return false;
+        }
 
-	  if (ifc->attr.if_source || ifc->attr.intrinsic)
-	    {
-	      /* Resolve interface and copy attributes.  */
-	      if (ifc->formal && !ifc->formal_ns)
-		resolve_symbol (ifc);
-	      if (ifc->attr.intrinsic)
-		gfc_resolve_intrinsic (ifc, &ifc->declared_at);
+      /* Check for C453.  */
+      if (me_arg->attr.dimension)
+        {
+          gfc_error ("Argument %qs of %qs with PASS(%s) at %L "
+                     "must be scalar", me_arg->name, c->name, me_arg->name,
+                     &c->loc);
+          c->tb->error = 1;
+          return false;
+        }
 
-	      if (ifc->result)
-		{
-		  c->ts = ifc->result->ts;
-		  c->attr.allocatable = ifc->result->attr.allocatable;
-		  c->attr.pointer = ifc->result->attr.pointer;
-		  c->attr.dimension = ifc->result->attr.dimension;
-		  c->as = gfc_copy_array_spec (ifc->result->as);
-		  c->attr.class_ok = ifc->result->attr.class_ok;
-		}
-	      else
-		{
-		  c->ts = ifc->ts;
-		  c->attr.allocatable = ifc->attr.allocatable;
-		  c->attr.pointer = ifc->attr.pointer;
-		  c->attr.dimension = ifc->attr.dimension;
-		  c->as = gfc_copy_array_spec (ifc->as);
-		  c->attr.class_ok = ifc->attr.class_ok;
-		}
-	      c->ts.interface = ifc;
-	      c->attr.function = ifc->attr.function;
-	      c->attr.subroutine = ifc->attr.subroutine;
-
-	      c->attr.pure = ifc->attr.pure;
-	      c->attr.elemental = ifc->attr.elemental;
-	      c->attr.recursive = ifc->attr.recursive;
-	      c->attr.always_explicit = ifc->attr.always_explicit;
-	      c->attr.ext_attr |= ifc->attr.ext_attr;
-	      /* Copy char length.  */
-	      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)
-		{
-		  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);
-		  if (cl->length && !cl->resolved
-		      && !gfc_resolve_expr (cl->length))
-		    {
-		      c->tb->error = 1;
-		      success = false;
-		      continue;
-		    }
-		  c->ts.u.cl = cl;
-		}
-	    }
-	}
-      else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)
-	{
-	  /* Since PPCs are not implicitly typed, a PPC without an explicit
-	     interface must be a subroutine.  */
-	  gfc_add_subroutine (&c->attr, c->name, &c->loc);
-	}
+      if (me_arg->attr.pointer)
+        {
+          gfc_error ("Argument %qs of %qs with PASS(%s) at %L "
+                     "may not have the POINTER attribute", me_arg->name,
+                     c->name, me_arg->name, &c->loc);
+          c->tb->error = 1;
+          return false;
+        }
 
-      /* Procedure pointer components: Check PASS arg.  */
-      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0
-	  && !sym->attr.vtype)
-	{
-	  gfc_symbol* me_arg;
+      if (me_arg->attr.allocatable)
+        {
+          gfc_error ("Argument %qs of %qs with PASS(%s) at %L "
+                     "may not be ALLOCATABLE", me_arg->name, c->name,
+                     me_arg->name, &c->loc);
+          c->tb->error = 1;
+          return false;
+        }
 
-	  if (c->tb->pass_arg)
-	    {
-	      gfc_formal_arglist* i;
+      if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)
+        {
+          gfc_error ("Non-polymorphic passed-object dummy argument of %qs"
+                     " at %L", c->name, &c->loc);
+          return false;
+        }
 
-	      /* If an explicit passing argument name is given, walk the arg-list
-		and look for it.  */
+    }
 
-	      me_arg = NULL;
-	      c->tb->pass_arg_num = 1;
-	      for (i = c->ts.interface->formal; i; i = i->next)
-		{
-		  if (!strcmp (i->sym->name, c->tb->pass_arg))
-		    {
-		      me_arg = i->sym;
-		      break;
-		    }
-		  c->tb->pass_arg_num++;
-		}
+  /* Check type-spec if this is not the parent-type component.  */
+  if (((sym->attr.is_class
+        && (!sym->components->ts.u.derived->attr.extension
+            || c != sym->components->ts.u.derived->components))
+       || (!sym->attr.is_class
+           && (!sym->attr.extension || c != sym->components)))
+      && !sym->attr.vtype
+      && !resolve_typespec_used (&c->ts, &c->loc, c->name))
+    return false;
 
-	      if (!me_arg)
-		{
-		  gfc_error ("Procedure pointer component %qs with PASS(%s) "
-			     "at %L has no argument %qs", c->name,
-			     c->tb->pass_arg, &c->loc, c->tb->pass_arg);
-		  c->tb->error = 1;
-		  success = false;
-		  continue;
-		}
-	    }
-	  else
-	    {
-	      /* Otherwise, take the first one; there should in fact be at least
-		one.  */
-	      c->tb->pass_arg_num = 1;
-	      if (!c->ts.interface->formal)
-		{
-		  gfc_error ("Procedure pointer component %qs with PASS at %L "
-			     "must have at least one argument",
-			     c->name, &c->loc);
-		  c->tb->error = 1;
-		  success = false;
-		  continue;
-		}
-	      me_arg = c->ts.interface->formal->sym;
-	    }
+  super_type = gfc_get_derived_super_type (sym);
 
-	  /* Now check that the argument-type matches.  */
-	  gcc_assert (me_arg);
-	  if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)
-	      || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)
-	      || (me_arg->ts.type == BT_CLASS
-		  && CLASS_DATA (me_arg)->ts.u.derived != sym))
-	    {
-	      gfc_error ("Argument %qs of %qs with PASS(%s) at %L must be of"
-			 " the derived type %qs", me_arg->name, c->name,
-			 me_arg->name, &c->loc, sym->name);
-	      c->tb->error = 1;
-	      success = false;
-	      continue;
-	    }
+  /* If this type is an extension, set the accessibility of the parent
+     component.  */
+  if (super_type
+      && ((sym->attr.is_class
+           && c == sym->components->ts.u.derived->components)
+          || (!sym->attr.is_class && c == sym->components))
+      && strcmp (super_type->name, c->name) == 0)
+    c->attr.access = super_type->attr.access;
+
+  /* If this type is an extension, see if this component has the same name
+     as an inherited type-bound procedure.  */
+  if (super_type && !sym->attr.is_class
+      && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))
+    {
+      gfc_error ("Component %qs of %qs at %L has the same name as an"
+                 " inherited type-bound procedure",
+                 c->name, sym->name, &c->loc);
+      return false;
+    }
 
-	  /* Check for C453.  */
-	  if (me_arg->attr.dimension)
-	    {
-	      gfc_error ("Argument %qs of %qs with PASS(%s) at %L "
-			 "must be scalar", me_arg->name, c->name, me_arg->name,
-			 &c->loc);
-	      c->tb->error = 1;
-	      success = false;
-	      continue;
-	    }
+  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
+        && !c->ts.deferred)
+    {
+     if (c->ts.u.cl->length == NULL
+         || (!resolve_charlen(c->ts.u.cl))
+         || !gfc_is_constant_expr (c->ts.u.cl->length))
+       {
+         gfc_error ("Character length of component %qs needs to "
+                    "be a constant specification expression at %L",
+                    c->name,
+                    c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
+         return false;
+       }
+    }
 
-	  if (me_arg->attr.pointer)
-	    {
-	      gfc_error ("Argument %qs of %qs with PASS(%s) at %L "
-			 "may not have the POINTER attribute", me_arg->name,
-			 c->name, me_arg->name, &c->loc);
-	      c->tb->error = 1;
-	      success = false;
-	      continue;
-	    }
+  if (c->ts.type == BT_CHARACTER && c->ts.deferred
+      && !c->attr.pointer && !c->attr.allocatable)
+    {
+      gfc_error ("Character component %qs of %qs at %L with deferred "
+                 "length must be a POINTER or ALLOCATABLE",
+                 c->name, sym->name, &c->loc);
+      return false;
+    }
 
-	  if (me_arg->attr.allocatable)
-	    {
-	      gfc_error ("Argument %qs of %qs with PASS(%s) at %L "
-			 "may not be ALLOCATABLE", me_arg->name, c->name,
-			 me_arg->name, &c->loc);
-	      c->tb->error = 1;
-	      success = false;
-	      continue;
-	    }
+  /* Add the hidden deferred length field.  */
+  if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function
+      && !sym->attr.is_class)
+    {
+      char name[GFC_MAX_SYMBOL_LEN+9];
+      gfc_component *strlen;
+      sprintf (name, "_%s_length", c->name);
+      strlen = gfc_find_component (sym, name, true, true, NULL);
+      if (strlen == NULL)
+        {
+          if (!gfc_add_component (sym, name, &strlen))
+            return false;
+          strlen->ts.type = BT_INTEGER;
+          strlen->ts.kind = gfc_charlen_int_kind;
+          strlen->attr.access = ACCESS_PRIVATE;
+          strlen->attr.artificial = 1;
+        }
+    }
 
-	  if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)
-	    {
-	      gfc_error ("Non-polymorphic passed-object dummy argument of %qs"
-			 " at %L", c->name, &c->loc);
-	      success = false;
-	      continue;
-	    }
+  if (c->ts.type == BT_DERIVED
+      && sym->component_access != ACCESS_PRIVATE
+      && gfc_check_symbol_access (sym)
+      && !is_sym_host_assoc (c->ts.u.derived, sym->ns)
+      && !c->ts.u.derived->attr.use_assoc
+      && !gfc_check_symbol_access (c->ts.u.derived)
+      && !gfc_notify_std (GFC_STD_F2003, "the component %qs is a "
+                          "PRIVATE type and cannot be a component of "
+                          "%qs, which is PUBLIC at %L", c->name,
+                          sym->name, &sym->declared_at))
+    return false;
 
-	}
+  if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)
+    {
+      gfc_error ("Polymorphic component %s at %L in SEQUENCE or BIND(C) "
+                 "type %s", c->name, &c->loc, sym->name);
+      return false;
+    }
 
-      /* Check type-spec if this is not the parent-type component.  */
-      if (((sym->attr.is_class
-	    && (!sym->components->ts.u.derived->attr.extension
-		|| c != sym->components->ts.u.derived->components))
-	   || (!sym->attr.is_class
-	       && (!sym->attr.extension || c != sym->components)))
-	  && !sym->attr.vtype
-	  && !resolve_typespec_used (&c->ts, &c->loc, c->name))
-	return false;
+  if (sym->attr.sequence)
+    {
+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)
+        {
+          gfc_error ("Component %s of SEQUENCE type declared at %L does "
+                     "not have the SEQUENCE attribute",
+                     c->ts.u.derived->name, &sym->declared_at);
+          return false;
+        }
+    }
 
-      /* If this type is an extension, set the accessibility of the parent
-	 component.  */
-      if (super_type
-	  && ((sym->attr.is_class
-	       && c == sym->components->ts.u.derived->components)
-	      || (!sym->attr.is_class && c == sym->components))
-	  && strcmp (super_type->name, c->name) == 0)
-	c->attr.access = super_type->attr.access;
-
-      /* If this type is an extension, see if this component has the same name
-	 as an inherited type-bound procedure.  */
-      if (super_type && !sym->attr.is_class
-	  && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))
-	{
-	  gfc_error ("Component %qs of %qs at %L has the same name as an"
-		     " inherited type-bound procedure",
-		     c->name, sym->name, &c->loc);
-	  return false;
-	}
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)
+    c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);
+  else if (c->ts.type == BT_CLASS && c->attr.class_ok
+           && CLASS_DATA (c)->ts.u.derived->attr.generic)
+    CLASS_DATA (c)->ts.u.derived
+                    = gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);
 
-      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
-	    && !c->ts.deferred)
-	{
-	 if (c->ts.u.cl->length == NULL
-	     || (!resolve_charlen(c->ts.u.cl))
-	     || !gfc_is_constant_expr (c->ts.u.cl->length))
-	   {
-	     gfc_error ("Character length of component %qs needs to "
-			"be a constant specification expression at %L",
-			c->name,
-			c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
-	     return false;
-	   }
-	}
+  if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype
+      && c->attr.pointer && c->ts.u.derived->components == NULL
+      && !c->ts.u.derived->attr.zero_comp)
+    {
+      gfc_error ("The pointer component %qs of %qs at %L is a type "
+                 "that has not been declared", c->name, sym->name,
+                 &c->loc);
+      return false;
+    }
 
-      if (c->ts.type == BT_CHARACTER && c->ts.deferred
-	  && !c->attr.pointer && !c->attr.allocatable)
-	{
-	  gfc_error ("Character component %qs of %qs at %L with deferred "
-		     "length must be a POINTER or ALLOCATABLE",
-		     c->name, sym->name, &c->loc);
-	  return false;
-	}
+  if (c->ts.type == BT_CLASS && c->attr.class_ok
+      && CLASS_DATA (c)->attr.class_pointer
+      && CLASS_DATA (c)->ts.u.derived->components == NULL
+      && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp
+      && !UNLIMITED_POLY (c))
+    {
+      gfc_error ("The pointer component %qs of %qs at %L is a type "
+                 "that has not been declared", c->name, sym->name,
+                 &c->loc);
+      return false;
+    }
 
-      /* Add the hidden deferred length field.  */
-      if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function
-	  && !sym->attr.is_class)
-	{
-	  char name[GFC_MAX_SYMBOL_LEN+9];
-	  gfc_component *strlen;
-	  sprintf (name, "_%s_length", c->name);
-	  strlen = gfc_find_component (sym, name, true, true);
-	  if (strlen == NULL)
-	    {
-	      if (!gfc_add_component (sym, name, &strlen))
-		return false;
-	      strlen->ts.type = BT_INTEGER;
-	      strlen->ts.kind = gfc_charlen_int_kind;
-	      strlen->attr.access = ACCESS_PRIVATE;
-	      strlen->attr.artificial = 1;
-	    }
-	}
+  /* C437.  */
+  if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE
+      && (!c->attr.class_ok
+          || !(CLASS_DATA (c)->attr.class_pointer
+               || CLASS_DATA (c)->attr.allocatable)))
+    {
+      gfc_error ("Component %qs with CLASS at %L must be allocatable "
+                 "or pointer", c->name, &c->loc);
+      /* Prevent a recurrence of the error.  */
+      c->ts.type = BT_UNKNOWN;
+      return false;
+    }
 
-      if (c->ts.type == BT_DERIVED
-	  && sym->component_access != ACCESS_PRIVATE
-	  && gfc_check_symbol_access (sym)
-	  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)
-	  && !c->ts.u.derived->attr.use_assoc
-	  && !gfc_check_symbol_access (c->ts.u.derived)
-	  && !gfc_notify_std (GFC_STD_F2003, "the component %qs is a "
-			      "PRIVATE type and cannot be a component of "
-			      "%qs, which is PUBLIC at %L", c->name,
-			      sym->name, &sym->declared_at))
-	return false;
+  /* Ensure that all the derived type components are put on the
+     derived type list; even in formal namespaces, where derived type
+     pointer components might not have been declared.  */
+  if (c->ts.type == BT_DERIVED
+        && c->ts.u.derived
+        && c->ts.u.derived->components
+        && c->attr.pointer
+        && sym != c->ts.u.derived)
+    add_dt_to_dt_list (c->ts.u.derived);
 
-      if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)
-	{
-	  gfc_error ("Polymorphic component %s at %L in SEQUENCE or BIND(C) "
-		     "type %s", c->name, &c->loc, sym->name);
-	  return false;
-	}
+  if (!gfc_resolve_array_spec (c->as,
+                               !(c->attr.pointer || c->attr.proc_pointer
+                                 || c->attr.allocatable)))
+    return false;
 
-      if (sym->attr.sequence)
-	{
-	  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)
-	    {
-	      gfc_error ("Component %s of SEQUENCE type declared at %L does "
-			 "not have the SEQUENCE attribute",
-			 c->ts.u.derived->name, &sym->declared_at);
-	      return false;
-	    }
-	}
+  if (c->initializer && !sym->attr.vtype
+      && !gfc_check_assign_symbol (sym, c, c->initializer))
+    return false;
 
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)
-	c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);
-      else if (c->ts.type == BT_CLASS && c->attr.class_ok
-	       && CLASS_DATA (c)->ts.u.derived->attr.generic)
-	CLASS_DATA (c)->ts.u.derived
-			= gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);
+  return true;
+}
 
-      if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype
-	  && c->attr.pointer && c->ts.u.derived->components == NULL
-	  && !c->ts.u.derived->attr.zero_comp)
-	{
-	  gfc_error ("The pointer component %qs of %qs at %L is a type "
-		     "that has not been declared", c->name, sym->name,
-		     &c->loc);
-	  return false;
-	}
 
-      if (c->ts.type == BT_CLASS && c->attr.class_ok
-	  && CLASS_DATA (c)->attr.class_pointer
-	  && CLASS_DATA (c)->ts.u.derived->components == NULL
-	  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp
-	  && !UNLIMITED_POLY (c))
-	{
-	  gfc_error ("The pointer component %qs of %qs at %L is a type "
-		     "that has not been declared", c->name, sym->name,
-		     &c->loc);
-	  return false;
-	}
+/* Be nice about the locus for a structure expression - show the locus of the
+   first non-null sub-expression if we can.  */
 
-      /* C437.  */
-      if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE
-	  && (!c->attr.class_ok
-	      || !(CLASS_DATA (c)->attr.class_pointer
-		   || CLASS_DATA (c)->attr.allocatable)))
-	{
-	  gfc_error ("Component %qs with CLASS at %L must be allocatable "
-		     "or pointer", c->name, &c->loc);
-	  /* Prevent a recurrence of the error.  */
-	  c->ts.type = BT_UNKNOWN;
-	  return false;
-	}
+static locus *
+cons_where (gfc_expr *struct_expr)
+{
+  gfc_constructor *cons;
 
-      /* Ensure that all the derived type components are put on the
-	 derived type list; even in formal namespaces, where derived type
-	 pointer components might not have been declared.  */
-      if (c->ts.type == BT_DERIVED
-	    && c->ts.u.derived
-	    && c->ts.u.derived->components
-	    && c->attr.pointer
-	    && sym != c->ts.u.derived)
-	add_dt_to_dt_list (c->ts.u.derived);
+  gcc_assert (struct_expr && struct_expr->expr_type == EXPR_STRUCTURE);
 
-      if (!gfc_resolve_array_spec (c->as,
-				   !(c->attr.pointer || c->attr.proc_pointer
-				     || c->attr.allocatable)))
-	return false;
+  cons = gfc_constructor_first (struct_expr->value.constructor);
+  for (; cons; cons = gfc_constructor_next (cons))
+    {
+      if (cons->expr && cons->expr->expr_type != EXPR_NULL)
+        return &cons->expr->where;
+    }
 
-      if (c->initializer && !sym->attr.vtype
-	  && !gfc_check_assign_symbol (sym, c, c->initializer))
-	return false;
+  return &struct_expr->where;
+}
+
+/* Resolve the components of a structure type. Much less work than derived
+   types.  */
+
+static bool
+resolve_fl_struct (gfc_symbol *sym)
+{
+  gfc_component *c;
+  gfc_expr *init = NULL;
+  bool success;
+
+  /* Make sure UNIONs do not have overlapping initializers.  */
+  if (sym->attr.flavor == FL_UNION)
+    {
+      for (c = sym->components; c; c = c->next)
+        {
+          if (init && c->initializer)
+            {
+              gfc_error ("Conflicting initializers in union at %L and %L",
+                         cons_where (init), cons_where (c->initializer));
+              gfc_free_expr (c->initializer);
+              c->initializer = NULL;
+            }
+          if (init == NULL)
+            init = c->initializer;
+        }
     }
 
+  success = true;
+  for (c = sym->components; c; c = c->next)
+    if (!resolve_component (c, sym))
+      success = false;
+
+  if (!success)
+    return false;
+
+  if (sym->components)
+    add_dt_to_dt_list (sym);
+
+  return true;
+}
+
+
+/* Resolve the components of a derived type. This does not have to wait until
+   resolution stage, but can be done as soon as the dt declaration has been
+   parsed.  */
+
+static bool
+resolve_fl_derived0 (gfc_symbol *sym)
+{
+  gfc_symbol* super_type;
+  gfc_component *c;
+  bool success;
+
+  if (sym->attr.unlimited_polymorphic)
+    return true;
+
+  super_type = gfc_get_derived_super_type (sym);
+
+  /* F2008, C432.  */
+  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)
+    {
+      gfc_error ("As extending type %qs at %L has a coarray component, "
+		 "parent type %qs shall also have one", sym->name,
+		 &sym->declared_at, super_type->name);
+      return false;
+    }
+
+  /* Ensure the extended type gets resolved before we do.  */
+  if (super_type && !resolve_fl_derived0 (super_type))
+    return false;
+
+  /* An ABSTRACT type must be extensible.  */
+  if (sym->attr.abstract && !gfc_type_is_extensible (sym))
+    {
+      gfc_error ("Non-extensible derived-type %qs at %L must not be ABSTRACT",
+		 sym->name, &sym->declared_at);
+      return false;
+    }
+
+  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components
+			   : sym->components;
+
+  success = true;
+  for ( ; c != NULL; c = c->next)
+    if (!resolve_component (c, sym))
+      success = false;
+
   if (!success)
     return false;
 
@@ -13396,8 +13466,8 @@
   if (sym->attr.is_class && sym->ts.u.derived == NULL)
     {
       /* Fix up incomplete CLASS symbols.  */
-      gfc_component *data = gfc_find_component (sym, "_data", true, true);
-      gfc_component *vptr = gfc_find_component (sym, "_vptr", true, true);
+      gfc_component *data = gfc_find_component (sym, "_data", true, true, NULL);
+      gfc_component *vptr = gfc_find_component (sym, "_vptr", true, true, NULL);
 
       /* Nothing more to do for unlimited polymorphic entities.  */
       if (data->ts.u.derived->attr.unlimited_polymorphic)
@@ -13616,6 +13686,11 @@
     return;
   sym->resolved = 1;
 
+  /* No symbol will ever have union type; only components can be unions.
+     Union type declaration symbols have type BT_UNKNOWN but flavor FL_UNION
+     (just like derived type declaration symbols have flavor FL_DERIVED). */
+  gcc_assert (sym->ts.type != BT_UNION);
+
   if (sym->attr.artificial)
     return;
 
@@ -13687,6 +13762,10 @@
   if (sym->attr.flavor == FL_DERIVED && !resolve_fl_derived (sym))
     return;
 
+  else if ((sym->attr.flavor == FL_STRUCT || sym->attr.flavor == FL_UNION)
+           && !resolve_fl_struct (sym))
+    return;
+
   /* Symbols that are module procedures with results (functions) have
      the types and array specification copied for type checking in
      procedures that call them, as well as for saving to a module
@@ -15030,7 +15109,7 @@
 
   for (; c ; c = c->next)
     {
-      if (c->ts.type == BT_DERIVED
+      if (gfc_bt_struct (c->ts.type)
 	  && (!resolve_equivalence_derived(c->ts.u.derived, sym, e)))
 	return false;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/scanner.c gcc-6-20160721/gcc/fortran/scanner.c
--- gcc-6.1.0/gcc/fortran/scanner.c	2016-03-19 20:28:38.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/scanner.c	2016-05-27 01:05:21.000000000 +0000
@@ -1556,6 +1556,7 @@
 not_continuation:
   c = '\n';
   gfc_current_locus = old_loc;
+  end_flag = 0;
 
 done:
   if (c == '\n')
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/symbol.c gcc-6-20160721/gcc/fortran/symbol.c
--- gcc-6.1.0/gcc/fortran/symbol.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/symbol.c	2016-05-14 19:52:46.000000000 +0000
@@ -40,6 +40,7 @@
   minit ("VARIABLE", FL_VARIABLE), minit ("PARAMETER", FL_PARAMETER),
   minit ("LABEL", FL_LABEL), minit ("PROCEDURE", FL_PROCEDURE),
   minit ("DERIVED", FL_DERIVED), minit ("NAMELIST", FL_NAMELIST),
+  minit ("UNION", FL_UNION), minit ("STRUCTURE", FL_STRUCT),
   minit (NULL, -1)
 };
 
@@ -444,7 +445,7 @@
 	  case FL_BLOCK_DATA:
 	  case FL_MODULE:
 	  case FL_LABEL:
-	  case FL_DERIVED:
+	  case_fl_struct:
 	  case FL_PARAMETER:
             a1 = gfc_code2string (flavors, attr->flavor);
             a2 = save;
@@ -740,7 +741,7 @@
 
       break;
 
-    case FL_DERIVED:
+    case_fl_struct:
       conf2 (dummy);
       conf2 (pointer);
       conf2 (target);
@@ -1579,7 +1580,7 @@
 {
 
   if ((f == FL_PROGRAM || f == FL_BLOCK_DATA || f == FL_MODULE
-       || f == FL_PARAMETER || f == FL_LABEL || f == FL_DERIVED
+       || f == FL_PARAMETER || f == FL_LABEL || gfc_fl_struct(f)
        || f == FL_NAMELIST) && check_used (attr, name, where))
     return false;
 
@@ -2048,6 +2049,11 @@
 {
   gfc_component *p, *tail;
 
+  /* Check for existing components with the same name, but not for union
+     components or containers. Unions and maps are anonymous so they have
+     unique internal names which will never conflict.
+     Don't use gfc_find_component here because it calls gfc_use_derived,
+     but the derived type may not be fully defined yet. */
   tail = NULL;
 
   for (p = sym->components; p; p = p->next)
@@ -2063,7 +2069,8 @@
     }
 
   if (sym->attr.extension
-	&& gfc_find_component (sym->components->ts.u.derived, name, true, true))
+	&& gfc_find_component (sym->components->ts.u.derived,
+                               name, true, true, NULL))
     {
       gfc_error ("Component %qs at %C already in the parent type "
 		 "at %L", name, &sym->components->ts.u.derived->declared_at);
@@ -2154,7 +2161,7 @@
       return NULL;
     }
 
-  if (s == NULL || s->attr.flavor != FL_DERIVED)
+  if (s == NULL || !gfc_fl_struct (s->attr.flavor))
     goto bad;
 
   /* Get rid of symbol sym, translating all references to s.  */
@@ -2188,28 +2195,113 @@
 }
 
 
+/* Find the component with the given name in the union type symbol.
+   If ref is not NULL it will be set to the chain of components through which
+   the component can actually be accessed. This is necessary for unions because
+   intermediate structures may be maps, nested structures, or other unions,
+   all of which may (or must) be 'anonymous' to user code.  */
+
+static gfc_component *
+find_union_component (gfc_symbol *un, const char *name,
+                      bool noaccess, gfc_ref **ref)
+{
+  gfc_component *m, *check;
+  gfc_ref *sref, *tmp;
+
+  for (m = un->components; m; m = m->next)
+    {
+      check = gfc_find_component (m->ts.u.derived, name, noaccess, true, &tmp);
+      if (check == NULL)
+        continue;
+
+      /* Found component somewhere in m; chain the refs together.  */
+      if (ref)
+        {
+          /* Map ref. */
+          sref = gfc_get_ref ();
+          sref->type = REF_COMPONENT;
+          sref->u.c.component = m;
+          sref->u.c.sym = m->ts.u.derived;
+          sref->next = tmp;
+
+          *ref = sref;
+        }
+      /* Other checks (such as access) were done in the recursive calls.  */
+      return check;
+    }
+  return NULL;
+}
+
+
 /* Given a derived type node and a component name, try to locate the
    component structure.  Returns the NULL pointer if the component is
    not found or the components are private.  If noaccess is set, no access
-   checks are done.  */
+   checks are done.  If silent is set, an error will not be generated if
+   the component cannot be found or accessed.
+   
+   If ref is not NULL, *ref is set to represent the chain of components
+   required to get to the ultimate component.
+
+   If the component is simply a direct subcomponent, or is inherited from a
+   parent derived type in the given derived type, this is a single ref with its
+   component set to the returned component.
+
+   Otherwise, *ref is constructed as a chain of subcomponents. This occurs
+   when the component is found through an implicit chain of nested union and
+   map components. Unions and maps are "anonymous" substructures in FORTRAN
+   which cannot be explicitly referenced, but the reference chain must be
+   considered as in C for backend translation to correctly compute layouts.
+   (For example, x.a may refer to x->(UNION)->(MAP)->(UNION)->(MAP)->a).  */
 
 gfc_component *
 gfc_find_component (gfc_symbol *sym, const char *name,
-		    bool noaccess, bool silent)
+		    bool noaccess, bool silent, gfc_ref **ref)
 {
-  gfc_component *p;
+  gfc_component *p, *check;
+  gfc_ref *sref = NULL, *tmp = NULL;
 
   if (name == NULL || sym == NULL)
     return NULL;
 
-  sym = gfc_use_derived (sym);
+  if (sym->attr.flavor == FL_DERIVED)
+    sym = gfc_use_derived (sym);
+  else
+    gcc_assert (gfc_fl_struct (sym->attr.flavor));
 
   if (sym == NULL)
     return NULL;
 
+  /* Handle UNIONs specially - mutually recursive with gfc_find_component. */
+  if (sym->attr.flavor == FL_UNION)
+    return find_union_component (sym, name, noaccess, ref);
+
+  if (ref) *ref = NULL;
   for (p = sym->components; p; p = p->next)
-    if (strcmp (p->name, name) == 0)
-      break;
+    {
+      /* Nest search into union's maps. */
+      if (p->ts.type == BT_UNION)
+        {
+          check = find_union_component (p->ts.u.derived, name, noaccess, &tmp);
+          if (check != NULL)
+            {
+              /* Union ref. */
+              if (ref)
+                {
+                  sref = gfc_get_ref ();
+                  sref->type = REF_COMPONENT;
+                  sref->u.c.component = p;
+                  sref->u.c.sym = p->ts.u.derived;
+                  sref->next = tmp;
+                  *ref = sref;
+                }
+              return check;
+            }
+        }
+      else if (strcmp (p->name, name) == 0)
+        break;
+
+      continue;
+    }
 
   if (p && sym->attr.use_assoc && !noaccess)
     {
@@ -2231,7 +2323,7 @@
 	&& sym->components->ts.type == BT_DERIVED)
     {
       p = gfc_find_component (sym->components->ts.u.derived, name,
-			      noaccess, silent);
+			      noaccess, silent, ref);
       /* Do not overwrite the error.  */
       if (p == NULL)
 	return p;
@@ -2241,6 +2333,25 @@
     gfc_error ("%qs at %C is not a member of the %qs structure",
 	       name, sym->name);
 
+  /* Component was found; build the ultimate component reference. */
+  if (p != NULL && ref)
+    {
+      tmp = gfc_get_ref ();
+      tmp->type = REF_COMPONENT;
+      tmp->u.c.component = p;
+      tmp->u.c.sym = sym;
+      /* Link the final component ref to the end of the chain of subrefs. */
+      if (sref)
+        {
+          *ref = sref;
+          for (; sref->next; sref = sref->next)
+            ;
+          sref->next = tmp;
+        }
+      else
+        *ref = tmp;
+    }
+
   return p;
 }
 
@@ -3338,11 +3449,9 @@
 	  /* The derived type is saved in the symtree with the first
 	     letter capitalized; the all lower-case version to the
 	     derived type contains its associated generic function.  */
-	  if (p->attr.flavor == FL_DERIVED)
-	    gfc_delete_symtree (&p->ns->sym_root, gfc_get_string ("%c%s",
-                        (char) TOUPPER ((unsigned char) p->name[0]),
-                        &p->name[1]));
-	  else
+	  if (gfc_fl_struct (p->attr.flavor))
+	    gfc_delete_symtree (&p->ns->sym_root,gfc_dt_upper_string (p->name));
+          else
 	    gfc_delete_symtree (&p->ns->sym_root, p->name);
 
 	  gfc_release_symbol (p);
@@ -4526,10 +4635,7 @@
 	      const char *hidden_name;
 	      gfc_interface *intr, *head;
 
-	      hidden_name = gfc_get_string ("%c%s",
-					    (char) TOUPPER ((unsigned char)
-							      tmp_sym->name[0]),
-					    &tmp_sym->name[1]);
+	      hidden_name = gfc_dt_upper_string (tmp_sym->name);
 	      tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,
 					      hidden_name);
 	      gcc_assert (tmp_symtree == NULL);
@@ -4740,6 +4846,8 @@
   bool is_class2 = (ts2->type == BT_CLASS);
   bool is_derived1 = (ts1->type == BT_DERIVED);
   bool is_derived2 = (ts2->type == BT_DERIVED);
+  bool is_union1 = (ts1->type == BT_UNION);
+  bool is_union2 = (ts2->type == BT_UNION);
 
   if (is_class1
       && ts1->u.derived->components
@@ -4749,10 +4857,11 @@
 	  || ts1->u.derived->attr.unlimited_polymorphic))
     return 1;
 
-  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2)
+  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2
+      && !is_union1 && !is_union2)
     return (ts1->type == ts2->type);
 
-  if (is_derived1 && is_derived2)
+  if ((is_derived1 && is_derived2) || (is_union1 && is_union1))
     return gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);
 
   if (is_derived1 && is_class2)
@@ -4821,12 +4930,12 @@
 {
   gfc_interface *intr = NULL;
 
-  if (!sym || sym->attr.flavor == FL_DERIVED)
+  if (!sym || gfc_fl_struct (sym->attr.flavor))
     return sym;
 
   if (sym->attr.generic)
     for (intr = sym->generic; intr; intr = intr->next)
-      if (intr->sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (intr->sym->attr.flavor))
         break;
   return intr ? intr->sym : NULL;
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-array.c gcc-6-20160721/gcc/fortran/trans-array.c
--- gcc-6.1.0/gcc/fortran/trans-array.c	2016-04-04 09:32:28.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-array.c	2016-06-05 18:09:27.000000000 +0000
@@ -6376,7 +6376,12 @@
       stmtCleanup = gfc_finish_block (&cleanup);
 
       /* Only do the cleanup if the array was repacked.  */
-      tmp = build_fold_indirect_ref_loc (input_location, dumdesc);
+      if (is_classarray)
+	/* For a class array the dummy array descriptor is in the _class
+	   component.  */
+	tmp = gfc_class_data_get (dumdesc);
+      else
+	tmp = build_fold_indirect_ref_loc (input_location, dumdesc);
       tmp = gfc_conv_descriptor_data_get (tmp);
       tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,
 			     tmp, tmpdesc);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-decl.c gcc-6-20160721/gcc/fortran/trans-decl.c
--- gcc-6.1.0/gcc/fortran/trans-decl.c	2016-03-28 09:05:01.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-decl.c	2016-07-20 13:24:19.000000000 +0000
@@ -732,6 +732,7 @@
       st = NULL;
       s = NULL;
 
+      /* Check for a symbol with the same name. */
       if (gsym)
 	gfc_find_symbol (sym->name, gsym->ns, 0, &s);
 
@@ -748,22 +749,37 @@
 	  st->n.sym = sym;
 	  sym->refs++;
 	}
-      else if (sym->attr.flavor == FL_DERIVED)
+      else if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  if (s && s->attr.flavor == FL_PROCEDURE)
 	    {
 	      gfc_interface *intr;
 	      gcc_assert (s->attr.generic);
 	      for (intr = s->generic; intr; intr = intr->next)
-		if (intr->sym->attr.flavor == FL_DERIVED)
+		if (gfc_fl_struct (intr->sym->attr.flavor))
 		  {
 		    s = intr->sym;
 		    break;
 		  }
     	    }
 
-	  if (!s->backend_decl)
-	    s->backend_decl = gfc_get_derived_type (s);
+          /* Normally we can assume that s is a derived-type symbol since it
+             shares a name with the derived-type sym. However if sym is a
+             STRUCTURE, it may in fact share a name with any other basic type
+             variable. If s is in fact of derived type then we can continue
+             looking for a duplicate type declaration.  */
+          if (sym->attr.flavor == FL_STRUCT && s->ts.type == BT_DERIVED)
+            {
+              s = s->ts.u.derived;
+            }
+
+	  if (gfc_fl_struct (s->attr.flavor) && !s->backend_decl)
+            {
+              if (s->attr.flavor == FL_UNION)
+                s->backend_decl = gfc_get_union_type (s);
+              else
+                s->backend_decl = gfc_get_derived_type (s);
+            }
 	  gfc_copy_dt_decls_ifequal (s, sym, true);
 	  return true;
 	}
@@ -2384,7 +2400,7 @@
 	 Thus, we will use a hidden argument in that case.  */
       else if (f->sym->attr.optional && f->sym->attr.value
 	       && !f->sym->attr.dimension && f->sym->ts.type != BT_CLASS
-	       && f->sym->ts.type != BT_DERIVED)
+	       && !gfc_bt_struct (f->sym->ts.type))
 	{
           tree tmp;
           strcpy (&name[1], f->sym->name);
@@ -4596,7 +4612,7 @@
       && sym->ts.type == BT_DERIVED)
     sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));
 
-  if (sym->attr.flavor == FL_DERIVED
+  if (gfc_fl_struct (sym->attr.flavor)
       && sym->backend_decl
       && TREE_CODE (sym->backend_decl) == RECORD_TYPE)
     {
@@ -4839,7 +4855,7 @@
     }
   else switch (ts->type)
     {
-    case BT_DERIVED:
+    case_bt_struct:
       if (expr->expr_type != EXPR_STRUCTURE)
 	return false;
       cm = expr->ts.u.derived->components;
@@ -6260,7 +6276,7 @@
 			gfc_finish_block (&cleanup));
 
   /* Add all the decls we created during processing.  */
-  decl = saved_function_decls;
+  decl = nreverse (saved_function_decls);
   while (decl)
     {
       tree next;
@@ -6319,7 +6335,7 @@
 	 function has already called cgraph_create_node, which also created
 	 the cgraph node for this function.  */
       if (!has_coarray_vars || flag_coarray != GFC_FCOARRAY_LIB)
-	(void) cgraph_node::create (fndecl);
+	(void) cgraph_node::get_create (fndecl);
     }
   else
     cgraph_node::finalize_function (fndecl, true);
@@ -6452,7 +6468,7 @@
   if (flag_coarray == GFC_FCOARRAY_LIB && has_coarray_vars)
     generate_coarray_init (ns);
 
-  decl = saved_local_decls;
+  decl = nreverse (saved_local_decls);
   while (decl)
     {
       tree next;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-expr.c gcc-6-20160721/gcc/fortran/trans-expr.c
--- gcc-6.1.0/gcc/fortran/trans-expr.c	2016-03-29 16:54:24.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-expr.c	2016-07-16 03:54:12.000000000 +0000
@@ -2297,6 +2297,7 @@
   tree tmp;
   tree decl;
   tree field;
+  tree context;
 
   c = ref->u.c.component;
 
@@ -2307,15 +2308,20 @@
   field = c->backend_decl;
   gcc_assert (field && TREE_CODE (field) == FIELD_DECL);
   decl = se->expr;
+  context = DECL_FIELD_CONTEXT (field);
 
   /* Components can correspond to fields of different containing
      types, as components are created without context, whereas
      a concrete use of a component has the type of decl as context.
      So, if the type doesn't match, we search the corresponding
      FIELD_DECL in the parent type.  To not waste too much time
-     we cache this result in norestrict_decl.  */
-
-  if (DECL_FIELD_CONTEXT (field) != TREE_TYPE (decl))
+     we cache this result in norestrict_decl.
+     On the other hand, if the context is a UNION or a MAP (a
+     RECORD_TYPE within a UNION_TYPE) always use the given FIELD_DECL.  */
+
+  if (context != TREE_TYPE (decl) 
+      && !(   TREE_CODE (TREE_TYPE (field)) == UNION_TYPE /* Field is union */
+           || TREE_CODE (context) == UNION_TYPE))         /* Field is map */
     {
       tree f2 = c->norestrict_decl;
       if (!f2 || DECL_FIELD_CONTEXT (f2) != TREE_TYPE (decl))
@@ -6715,7 +6721,7 @@
     {
       switch (ts->type)
 	{
-	case BT_DERIVED:
+	case_bt_struct:
 	case BT_CLASS:
 	  gfc_init_se (&se, NULL);
 	  if (ts->type == BT_CLASS && expr->expr_type == EXPR_NULL)
@@ -6860,7 +6866,7 @@
   gfc_add_modify (&block, dest, se.expr);
 
   /* Deal with arrays of derived types with allocatable components.  */
-  if (cm->ts.type == BT_DERIVED
+  if (gfc_bt_struct (cm->ts.type)
 	&& cm->ts.u.derived->attr.alloc_comp)
     tmp = gfc_copy_alloc_comp (cm->ts.u.derived,
 			       se.expr, dest,
@@ -7033,7 +7039,7 @@
       /* Ensure that cm->ts.u.cl->backend_decl is a componentref to _%s_length
 	 component.  */
       sprintf (name, "_%s_length", cm->name);
-      strlen = gfc_find_component (sym, name, true, true);
+      strlen = gfc_find_component (sym, name, true, true, NULL);
       lhs_cl_size = fold_build3_loc (input_location, COMPONENT_REF,
 				     gfc_charlen_type_node,
 				     TREE_OPERAND (comp, 0),
@@ -7245,7 +7251,7 @@
 			fold_convert (TREE_TYPE (tmp), se.expr));
       gfc_add_block_to_block (&block, &se.post);
     }
-  else if (expr->ts.type == BT_DERIVED && expr->ts.f90_type != BT_VOID)
+  else if (gfc_bt_struct (expr->ts.type) && expr->ts.f90_type != BT_VOID)
     {
       if (expr->expr_type != EXPR_STRUCTURE)
 	{
@@ -7352,7 +7358,6 @@
     {
       gfc_se se, lse;
 
-      gcc_assert (cm->backend_decl == NULL);
       gfc_init_se (&se, NULL);
       gfc_init_se (&lse, NULL);
       gfc_conv_expr (&se, gfc_constructor_first (expr->value.constructor)->expr);
@@ -7416,6 +7421,24 @@
       return;
     }
 
+  /* Though unions appear to have multiple map components, they must only
+     have a single initializer since each map overlaps. TODO: squash map
+     constructors?  */
+  if (expr->ts.type == BT_UNION)
+    {
+      c = gfc_constructor_first (expr->value.constructor);
+      cm = c->n.component;
+      val = gfc_conv_initializer (c->expr, &expr->ts,
+                                  TREE_TYPE (cm->backend_decl),
+                                  cm->attr.dimension, cm->attr.pointer,
+                                  cm->attr.proc_pointer);
+      val = unshare_expr_without_location (val);
+
+      /* Append it to the constructor list.  */
+      CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
+      goto finish;
+    }
+
   cm = expr->ts.u.derived->components;
 
   for (c = gfc_constructor_first (expr->value.constructor);
@@ -7462,6 +7485,7 @@
 	  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
 	}
     }
+finish:
   se->expr = build_constructor (type, v);
   if (init)
     TREE_CONSTANT (se->expr) = 1;
@@ -8246,7 +8270,7 @@
       gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,
 			     rse->expr, ts.kind);
     }
-  else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)
+  else if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)
     {
       tree tmp_var = NULL_TREE;
       cond = NULL_TREE;
@@ -8299,7 +8323,7 @@
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (ts.type == BT_DERIVED || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -9503,7 +9527,7 @@
     case BT_CHARACTER:
       return false;
 
-    case BT_DERIVED:
+    case_bt_struct:
       return !expr->ts.u.derived->attr.alloc_comp;
 
     default:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-io.c gcc-6-20160721/gcc/fortran/trans-io.c
--- gcc-6.1.0/gcc/fortran/trans-io.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-io.c	2016-05-14 19:52:46.000000000 +0000
@@ -1685,7 +1685,7 @@
       gfc_add_expr_to_block (block, tmp);
     }
 
-  if (ts->type == BT_DERIVED && ts->u.derived->components)
+  if (gfc_bt_struct (ts->type) && ts->u.derived->components)
     {
       gfc_component *cmp;
 
@@ -2211,7 +2211,7 @@
 
       break;
 
-    case BT_DERIVED:
+    case_bt_struct:
       if (ts->u.derived->components == NULL)
 	return;
 
@@ -2330,7 +2330,7 @@
 	  gcc_assert (ref && ref->type == REF_ARRAY);
 	}
 
-      if (expr->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (expr->ts.type)
 	    && ref && ref->next == NULL
 	    && !is_subref_array (expr))
 	{
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-openmp.c gcc-6-20160721/gcc/fortran/trans-openmp.c
--- gcc-6.1.0/gcc/fortran/trans-openmp.c	2016-03-17 15:07:54.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-openmp.c	2016-07-02 10:24:41.000000000 +0000
@@ -61,6 +61,7 @@
       if (GFC_DECL_GET_SCALAR_POINTER (decl)
 	  || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)
 	  || GFC_DECL_CRAY_POINTEE (decl)
+	  || GFC_DECL_ASSOCIATE_VAR_P (decl)
 	  || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))
 	return false;
 
@@ -2180,6 +2181,8 @@
 		  tree decl = gfc_get_symbol_decl (n->sym);
 		  if (gfc_omp_privatize_by_reference (decl))
 		    decl = build_fold_indirect_ref (decl);
+		  else if (DECL_P (decl))
+		    TREE_ADDRESSABLE (decl) = 1;
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))
 		    {
 		      tree type = TREE_TYPE (decl);
@@ -3497,7 +3500,8 @@
       construct_clauses.independent = false;
       construct_clauses.tile_list = NULL;
       construct_clauses.lists[OMP_LIST_PRIVATE] = NULL;
-      construct_clauses.lists[OMP_LIST_REDUCTION] = NULL;
+      if (construct_code == OACC_KERNELS)
+	construct_clauses.lists[OMP_LIST_REDUCTION] = NULL;
       oacc_clauses = gfc_trans_omp_clauses (&block, &construct_clauses,
 					    code->loc);
     }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-stmt.c gcc-6-20160721/gcc/fortran/trans-stmt.c
--- gcc-6.1.0/gcc/fortran/trans-stmt.c	2016-03-28 09:05:01.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-stmt.c	2016-07-13 16:09:57.000000000 +0000
@@ -5694,9 +5694,11 @@
 	  tmp = gfc_get_char_type (code->ext.alloc.ts.kind);
 	  tmp = TYPE_SIZE_UNIT (tmp);
 	  tmp = fold_convert (TREE_TYPE (se_sz.expr), tmp);
+	  gfc_add_block_to_block (&block, &se_sz.pre);
 	  expr3_esize = fold_build2_loc (input_location, MULT_EXPR,
 					 TREE_TYPE (se_sz.expr),
 					 tmp, se_sz.expr);
+	  expr3_esize = gfc_evaluate_now (expr3_esize, &block);
 	}
     }
 
@@ -5895,6 +5897,7 @@
 		 source= or mold= expression.  */
 	      gfc_init_se (&se_sz, NULL);
 	      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);
+	      gfc_add_block_to_block (&block, &se_sz.pre);
 	      gfc_add_modify (&block, al_len,
 			      fold_convert (TREE_TYPE (al_len),
 					    se_sz.expr));
@@ -5979,11 +5982,19 @@
 		 specified by a type spec for deferred length character
 		 arrays or unlimited polymorphic objects without a
 		 source= or mold= expression.  */
-	      gfc_init_se (&se_sz, NULL);
-	      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);
-	      gfc_add_modify (&block, al_len,
-			      fold_convert (TREE_TYPE (al_len),
-					    se_sz.expr));
+	      if (expr3_esize == NULL_TREE || code->ext.alloc.ts.kind != 1)
+		{
+		  gfc_init_se (&se_sz, NULL);
+		  gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);
+		  gfc_add_block_to_block (&block, &se_sz.pre);
+		  gfc_add_modify (&block, al_len,
+				  fold_convert (TREE_TYPE (al_len),
+						se_sz.expr));
+		}
+	      else
+		gfc_add_modify (&block, al_len,
+				fold_convert (TREE_TYPE (al_len),
+					      expr3_esize));
 	    }
 	  else
 	    /* No length information needed, because type to allocate
@@ -6275,7 +6286,7 @@
 	{
 	  gfc_ref *ref;
 
-	  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp
+	  if (gfc_bt_struct (expr->ts.type) && expr->ts.u.derived->attr.alloc_comp
 	      && !gfc_is_finalizable (expr->ts.u.derived, NULL))
 	    {
 	      gfc_ref *last = NULL;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/fortran/trans-types.c gcc-6-20160721/gcc/fortran/trans-types.c
--- gcc-6.1.0/gcc/fortran/trans-types.c	2016-02-27 11:57:16.000000000 +0000
+++ gcc-6-20160721/gcc/fortran/trans-types.c	2016-05-14 19:52:46.000000000 +0000
@@ -1101,6 +1101,10 @@
 					     gfc_index_one_node);
       break;
 
+    case BT_UNION:
+      basetype = gfc_get_union_type (spec->u.derived);
+      break;
+
     case BT_DERIVED:
     case BT_CLASS:
       basetype = gfc_get_derived_type (spec->u.derived);
@@ -2314,7 +2318,9 @@
   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)
     {
       to_cm->backend_decl = from_cm->backend_decl;
-      if (from_cm->ts.type == BT_DERIVED
+      if (from_cm->ts.type == BT_UNION)
+        gfc_get_union_type (to_cm->ts.u.derived);
+      else if (from_cm->ts.type == BT_DERIVED
 	  && (!from_cm->attr.pointer || from_gsym))
 	gfc_get_derived_type (to_cm->ts.u.derived);
       else if (from_cm->ts.type == BT_CLASS
@@ -2349,6 +2355,62 @@
 }
 
 
+/* Build a tree node for a union type. Requires building each map
+   structure which is an element of the union. */
+
+tree
+gfc_get_union_type (gfc_symbol *un)
+{
+    gfc_component *map = NULL;
+    tree typenode = NULL, map_type = NULL, map_field = NULL;
+    tree *chain = NULL;
+
+    if (un->backend_decl)
+      {
+        if (TYPE_FIELDS (un->backend_decl) || un->attr.proc_pointer_comp)
+          return un->backend_decl;
+        else
+          typenode = un->backend_decl;
+      }
+    else
+      {
+        typenode = make_node (UNION_TYPE);
+        TYPE_NAME (typenode) = get_identifier (un->name);
+      }
+
+    /* Add each contained MAP as a field. */
+    for (map = un->components; map; map = map->next)
+      {
+        gcc_assert (map->ts.type == BT_DERIVED);
+
+        /* The map's type node, which is defined within this union's context. */
+        map_type = gfc_get_derived_type (map->ts.u.derived);
+        TYPE_CONTEXT (map_type) = typenode;
+
+        /* The map field's declaration. */
+        map_field = gfc_add_field_to_struct(typenode, get_identifier(map->name),
+                                            map_type, &chain);
+        if (map->loc.lb)
+          gfc_set_decl_location (map_field, &map->loc);
+        else if (un->declared_at.lb)
+          gfc_set_decl_location (map_field, &un->declared_at);
+
+        DECL_PACKED (map_field) |= TYPE_PACKED (typenode);
+        DECL_NAMELESS(map_field) = true;
+
+        /* We should never clobber another backend declaration for this map,
+           because each map component is unique. */
+        if (!map->backend_decl)
+          map->backend_decl = map_field;
+      }
+
+    un->backend_decl = typenode;
+    gfc_finish_type (typenode);
+
+    return typenode;
+}
+
+
 /* Build a tree node for a derived type.  If there are equal
    derived types, with different local names, these are built
    at the same time.  If an equal derived type has been built
@@ -2491,6 +2553,9 @@
      will be built and so we can return the type.  */
   for (c = derived->components; c; c = c->next)
     {
+      if (c->ts.type == BT_UNION && c->ts.u.derived->backend_decl == NULL)
+        c->ts.u.derived->backend_decl = gfc_get_union_type (c->ts.u.derived);
+
       if (c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)
 	continue;
 
@@ -2520,7 +2585,10 @@
     return derived->backend_decl;
 
   /* Build the type member list. Install the newly created RECORD_TYPE
-     node as DECL_CONTEXT of each FIELD_DECL.  */
+     node as DECL_CONTEXT of each FIELD_DECL. In this case we must go
+     through only the top-level linked list of components so we correctly
+     build UNION_TYPE nodes for BT_UNION components. MAPs and other nested
+     types are built as part of gfc_get_union_type.  */
   for (c = derived->components; c; c = c->next)
     {
       /* Prevent infinite recursion, when the procedure pointer type is
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/function.c gcc-6-20160721/gcc/function.c
--- gcc-6.1.0/gcc/function.c	2016-01-08 16:01:12.000000000 +0000
+++ gcc-6-20160721/gcc/function.c	2016-06-22 13:15:48.000000000 +0000
@@ -3314,6 +3314,8 @@
 	  set_mem_attributes (parmreg, parm, 1);
 	}
 
+      /* We need to preserve an address based on VIRTUAL_STACK_VARS_REGNUM for
+	 the debug info in case it is not legitimate.  */
       if (GET_MODE (parmreg) != GET_MODE (rtl))
 	{
 	  rtx tempreg = gen_reg_rtx (GET_MODE (rtl));
@@ -3323,7 +3325,8 @@
 			     all->last_conversion_insn);
 	  emit_move_insn (tempreg, rtl);
 	  tempreg = convert_to_mode (GET_MODE (parmreg), tempreg, unsigned_p);
-	  emit_move_insn (parmreg, tempreg);
+	  emit_move_insn (MEM_P (parmreg) ? copy_rtx (parmreg) : parmreg,
+			  tempreg);
 	  all->first_conversion_insn = get_insns ();
 	  all->last_conversion_insn = get_last_insn ();
 	  end_sequence ();
@@ -3331,7 +3334,7 @@
 	  did_conversion = true;
 	}
       else
-	emit_move_insn (parmreg, rtl);
+	emit_move_insn (MEM_P (parmreg) ? copy_rtx (parmreg) : parmreg, rtl);
 
       rtl = parmreg;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/gcc.c gcc-6-20160721/gcc/gcc.c
--- gcc-6.1.0/gcc/gcc.c	2016-02-19 22:18:38.000000000 +0000
+++ gcc-6-20160721/gcc/gcc.c	2016-06-30 14:39:10.000000000 +0000
@@ -7667,12 +7667,14 @@
 	      for (unsigned j = 0; e->values[j].arg != NULL; j++)
 		{
 		  char *with_arg = concat (opt_text, e->values[j].arg, NULL);
-		  add_misspelling_candidates (m_option_suggestions, with_arg);
+		  add_misspelling_candidates (m_option_suggestions, option,
+					      with_arg);
 		  free (with_arg);
 		}
 	    }
 	  else
-	    add_misspelling_candidates (m_option_suggestions, opt_text);
+	    add_misspelling_candidates (m_option_suggestions, option,
+					opt_text);
 	  break;
 
 	case OPT_fsanitize_:
@@ -7696,7 +7698,8 @@
 		/* Add with_arg and all of its variant spellings e.g.
 		   "-fno-sanitize=address" to candidates (albeit without
 		   leading dashes).  */
-		add_misspelling_candidates (m_option_suggestions, with_arg);
+		add_misspelling_candidates (m_option_suggestions, option,
+					    with_arg);
 		free (with_arg);
 	      }
 	  }
Only in gcc-6.1.0/gcc: gengtype-lex.c
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/genmodes.c gcc-6-20160721/gcc/genmodes.c
--- gcc-6.1.0/gcc/genmodes.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/genmodes.c	2016-06-27 18:25:58.000000000 +0000
@@ -66,6 +66,7 @@
 				   this mode as a component.  */
   struct mode_data *next_cont;  /* Next mode in that list.  */
 
+  struct mode_data *complex;	/* complex type with mode as component.  */
   const char *file;		/* file and line of definition, */
   unsigned int line;		/* for error reporting */
   unsigned int counter;		/* Rank ordering of modes */
@@ -83,7 +84,7 @@
 static const struct mode_data blank_mode = {
   0, "<unknown>", MAX_MODE_CLASS,
   -1U, -1U, -1U, -1U,
-  0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0,
   "<unknown>", 0, 0, 0, 0, false, 0
 };
 
@@ -472,6 +473,7 @@
 
       c = new_mode (cclass, buf, file, line);
       c->component = m;
+      m->complex = c;
     }
 }
 
@@ -1381,6 +1383,22 @@
 }
 
 static void
+emit_mode_complex (void)
+{
+  int c;
+  struct mode_data *m;
+
+  print_decl ("unsigned char", "mode_complex", "NUM_MACHINE_MODES");
+
+  for_all_modes (c, m)
+    tagged_printf ("%smode",
+		   m->complex ? m->complex->name : void_mode->name,
+		   m->name);
+
+  print_closer ();
+}
+
+static void
 emit_mode_mask (void)
 {
   int c;
@@ -1745,6 +1763,7 @@
   emit_mode_size ();
   emit_mode_nunits ();
   emit_mode_wider ();
+  emit_mode_complex ();
   emit_mode_mask ();
   emit_mode_inner ();
   emit_mode_unit_size ();
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/gimple-fold.c gcc-6-20160721/gcc/gimple-fold.c
--- gcc-6.1.0/gcc/gimple-fold.c	2016-01-26 15:51:51.000000000 +0000
+++ gcc-6-20160721/gcc/gimple-fold.c	2016-07-19 17:33:58.000000000 +0000
@@ -795,22 +795,21 @@
 	    {
 	      tree src_base, dest_base, fn;
 	      HOST_WIDE_INT src_offset = 0, dest_offset = 0;
-	      HOST_WIDE_INT size = -1;
-	      HOST_WIDE_INT maxsize = -1;
-	      bool reverse;
+	      HOST_WIDE_INT maxsize;
 
 	      srcvar = TREE_OPERAND (src, 0);
-	      src_base = get_ref_base_and_extent (srcvar, &src_offset,
-						  &size, &maxsize, &reverse);
+	      src_base = get_addr_base_and_unit_offset (srcvar, &src_offset);
+	      if (src_base == NULL)
+		src_base = srcvar;
 	      destvar = TREE_OPERAND (dest, 0);
-	      dest_base = get_ref_base_and_extent (destvar, &dest_offset,
-						   &size, &maxsize, &reverse);
+	      dest_base = get_addr_base_and_unit_offset (destvar,
+							 &dest_offset);
+	      if (dest_base == NULL)
+		dest_base = destvar;
 	      if (tree_fits_uhwi_p (len))
 		maxsize = tree_to_uhwi (len);
 	      else
 		maxsize = -1;
-	      src_offset /= BITS_PER_UNIT;
-	      dest_offset /= BITS_PER_UNIT;
 	      if (SSA_VAR_P (src_base)
 		  && SSA_VAR_P (dest_base))
 		{
@@ -3039,10 +3038,25 @@
 		}
 	      if (targets.length () == 1)
 		{
-		  gimple_call_set_fndecl (stmt, targets[0]->decl);
+		  tree fndecl = targets[0]->decl;
+		  gimple_call_set_fndecl (stmt, fndecl);
 		  changed = true;
+		  /* If changing the call to __cxa_pure_virtual
+		     or similar noreturn function, adjust gimple_call_fntype
+		     too.  */
+		  if ((gimple_call_flags (stmt) & ECF_NORETURN)
+		      && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl)))
+		      && TYPE_ARG_TYPES (TREE_TYPE (fndecl))
+		      && (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))
+			  == void_type_node))
+		    gimple_call_set_fntype (stmt, TREE_TYPE (fndecl));
 		  /* If the call becomes noreturn, remove the lhs.  */
-		  if (lhs && (gimple_call_flags (stmt) & ECF_NORETURN))
+		  if (lhs
+		      && (gimple_call_flags (stmt) & ECF_NORETURN)
+		      && (VOID_TYPE_P (TREE_TYPE (gimple_call_fntype (stmt)))
+			  || ((TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (lhs)))
+			       == INTEGER_CST)
+			      && !TREE_ADDRESSABLE (TREE_TYPE (lhs)))))
 		    {
 		      if (TREE_CODE (lhs) == SSA_NAME)
 			{
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/gimple.c gcc-6-20160721/gcc/gimple.c
--- gcc-6.1.0/gcc/gimple.c	2016-03-11 12:28:50.000000000 +0000
+++ gcc-6-20160721/gcc/gimple.c	2016-06-10 09:45:51.000000000 +0000
@@ -1355,7 +1355,8 @@
   if (gimple_call_internal_p (c1))
     return (gimple_call_internal_p (c2)
 	    && gimple_call_internal_fn (c1) == gimple_call_internal_fn (c2)
-	    && !gimple_call_internal_unique_p (as_a <const gcall *> (c1)));
+	    && (!gimple_call_internal_unique_p (as_a <const gcall *> (c1))
+		|| c1 == c2));
   else
     return (gimple_call_fn (c1) == gimple_call_fn (c2)
 	    || (gimple_call_fndecl (c1)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/gimplify.c gcc-6-20160721/gcc/gimplify.c
--- gcc-6.1.0/gcc/gimplify.c	2016-04-13 12:27:52.000000000 +0000
+++ gcc-6-20160721/gcc/gimplify.c	2016-06-21 07:09:57.000000000 +0000
@@ -6894,6 +6894,11 @@
 		{
 		  while (TREE_CODE (decl) == COMPONENT_REF)
 		    decl = TREE_OPERAND (decl, 0);
+		  if (TREE_CODE (decl) == INDIRECT_REF
+		      && DECL_P (TREE_OPERAND (decl, 0))
+		      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))
+			  == REFERENCE_TYPE))
+		    decl = TREE_OPERAND (decl, 0);
 		}
 	      if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue, fb_lvalue)
 		  == GS_ERROR)
@@ -6909,9 +6914,11 @@
 		      break;
 		    }
 
-		  if (TYPE_SIZE_UNIT (TREE_TYPE (decl)) == NULL
-		      || (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (decl)))
-			  != INTEGER_CST))
+		  tree stype = TREE_TYPE (decl);
+		  if (TREE_CODE (stype) == REFERENCE_TYPE)
+		    stype = TREE_TYPE (stype);
+		  if (TYPE_SIZE_UNIT (stype) == NULL
+		      || TREE_CODE (TYPE_SIZE_UNIT (stype)) != INTEGER_CST)
 		    {
 		      error_at (OMP_CLAUSE_LOCATION (c),
 				"mapping field %qE of variable length "
@@ -6951,6 +6958,14 @@
 		  base = get_inner_reference (base, &bitsize, &bitpos, &offset,
 					      &mode, &unsignedp, &reversep,
 					      &volatilep, false);
+		  tree orig_base = base;
+		  if ((TREE_CODE (base) == INDIRECT_REF
+		       || (TREE_CODE (base) == MEM_REF
+			   && integer_zerop (TREE_OPERAND (base, 1))))
+		      && DECL_P (TREE_OPERAND (base, 0))
+		      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0)))
+			  == REFERENCE_TYPE))
+		    base = TREE_OPERAND (base, 0);
 		  gcc_assert (base == decl
 			      && (offset == NULL_TREE
 				  || TREE_CODE (offset) == INTEGER_CST));
@@ -6964,7 +6979,10 @@
 		      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),
 						 OMP_CLAUSE_MAP);
 		      OMP_CLAUSE_SET_MAP_KIND (l, GOMP_MAP_STRUCT);
-		      OMP_CLAUSE_DECL (l) = decl;
+		      if (orig_base != base)
+			OMP_CLAUSE_DECL (l) = unshare_expr (orig_base);
+		      else
+			OMP_CLAUSE_DECL (l) = decl;
 		      OMP_CLAUSE_SIZE (l) = size_int (1);
 		      if (struct_map_to_clause == NULL)
 			struct_map_to_clause = new hash_map<tree, tree>;
@@ -7006,6 +7024,18 @@
 			  *list_p = l;
 			  list_p = &OMP_CLAUSE_CHAIN (l);
 			}
+		      if (orig_base != base && code == OMP_TARGET)
+			{
+			  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),
+						      OMP_CLAUSE_MAP);
+			  enum gomp_map_kind mkind
+			    = GOMP_MAP_FIRSTPRIVATE_REFERENCE;
+			  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);
+			  OMP_CLAUSE_DECL (c2) = decl;
+			  OMP_CLAUSE_SIZE (c2) = size_zero_node;
+			  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (l);
+			  OMP_CLAUSE_CHAIN (l) = c2;
+			}
 		      flags = GOVD_MAP | GOVD_EXPLICIT;
 		      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)
 			flags |= GOVD_SEEN;
@@ -7024,8 +7054,12 @@
 			o1 = 0;
 		      if (bitpos)
 			o1 = o1 + bitpos / BITS_PER_UNIT;
-		      for (sc = &OMP_CLAUSE_CHAIN (*osc);
-			   *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))
+		      sc = &OMP_CLAUSE_CHAIN (*osc);
+		      if (*sc != c
+			  && (OMP_CLAUSE_MAP_KIND (*sc)
+			      == GOMP_MAP_FIRSTPRIVATE_REFERENCE)) 
+			sc = &OMP_CLAUSE_CHAIN (*sc);
+		      for (; *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))
 			if (ptr && sc == prev_list_p)
 			  break;
 			else if (TREE_CODE (OMP_CLAUSE_DECL (*sc))
@@ -7061,6 +7095,15 @@
 							&mode, &unsignedp,
 							&reversep, &volatilep,
 							false);
+			    if ((TREE_CODE (base) == INDIRECT_REF
+				 || (TREE_CODE (base) == MEM_REF
+				     && integer_zerop (TREE_OPERAND (base,
+								     1))))
+				&& DECL_P (TREE_OPERAND (base, 0))
+				&& (TREE_CODE (TREE_TYPE (TREE_OPERAND (base,
+									0)))
+				    == REFERENCE_TYPE))
+			      base = TREE_OPERAND (base, 0);
 			    if (base != decl)
 			      break;
 			    if (scp)
@@ -8224,7 +8267,13 @@
 	case OMP_CLAUSE_VECTOR:
 	case OMP_CLAUSE_AUTO:
 	case OMP_CLAUSE_SEQ:
+	  break;
+
 	case OMP_CLAUSE_TILE:
+	  /* We're not yet making use of the information provided by OpenACC
+	     tile clauses.  Discard these here, to simplify later middle end
+	     processing.  */
+	  remove = true;
 	  break;
 
 	default:
@@ -8785,7 +8834,10 @@
 						  decl, false))
 		    ;
 		  else if (outer->region_type != ORT_COMBINED_PARALLEL)
-		    outer = NULL;
+		    {
+		      omp_notice_variable (outer, decl, true);
+		      outer = NULL;
+		    }
 		  if (outer)
 		    {
 		      n = splay_tree_lookup (outer->variables,
@@ -8868,7 +8920,10 @@
 						  decl, false))
 		    ;
 		  else if (outer->region_type != ORT_COMBINED_PARALLEL)
-		    outer = NULL;
+		    {
+		      omp_notice_variable (outer, decl, true);
+		      outer = NULL;
+		    }
 		  if (outer)
 		    {
 		      n = splay_tree_lookup (outer->variables,
@@ -8946,7 +9001,12 @@
 	       || (ort == ORT_SIMD
 		   && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1))
 	{
+	  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;
+	  /* Make sure omp_add_variable is not called on it prematurely.
+	     We call it ourselves a few lines later.  */
+	  gimplify_omp_ctxp = NULL;
 	  var = create_tmp_var (TREE_TYPE (decl), get_name (decl));
+	  gimplify_omp_ctxp = ctx;
 	  TREE_OPERAND (t, 0) = var;
 
 	  gimplify_seq_add_stmt (&for_body, gimple_build_assign (decl, var));
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/graphite-isl-ast-to-gimple.c gcc-6-20160721/gcc/graphite-isl-ast-to-gimple.c
--- gcc-6.1.0/gcc/graphite-isl-ast-to-gimple.c	2016-04-22 11:09:22.000000000 +0000
+++ gcc-6-20160721/gcc/graphite-isl-ast-to-gimple.c	2016-05-31 07:27:23.000000000 +0000
@@ -1075,9 +1075,7 @@
 static bool
 bb_contains_loop_phi_nodes (basic_block bb)
 {
-  gcc_assert (EDGE_COUNT (bb->preds) <= 2);
-
-  if (bb->preds->length () == 1)
+  if (EDGE_COUNT (bb->preds) != 2)
     return false;
 
   unsigned depth = loop_depth (bb->loop_father);
@@ -1792,7 +1790,6 @@
 	b1 = b2;
     }
 
-  gcc_assert (b1);
   return b1;
 }
 
@@ -2481,13 +2478,14 @@
 
   gcc_assert (!bb_contains_loop_close_phi_nodes (bb));
 
+  /* TODO: Handle cond phi nodes with more than 2 predecessors.  */
+  if (EDGE_COUNT (bb->preds) != 2)
+    return false;
+
   if (dump_file)
     fprintf (dump_file, "[codegen] copying cond phi nodes in bb_%d.\n",
 	     new_bb->index);
 
-  /* Cond phi nodes should have exactly two arguments.  */
-  gcc_assert (2 == EDGE_COUNT (bb->preds));
-
   for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);
        gsi_next (&psi))
     {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/graphite-scop-detection.c gcc-6-20160721/gcc/graphite-scop-detection.c
--- gcc-6.1.0/gcc/graphite-scop-detection.c	2016-03-16 09:19:23.000000000 +0000
+++ gcc-6-20160721/gcc/graphite-scop-detection.c	2016-05-07 07:02:36.000000000 +0000
@@ -1722,8 +1722,7 @@
 build_cross_bb_scalars_def (scop_p scop, tree def, basic_block def_bb,
 			     vec<tree> *writes)
 {
-  gcc_assert (def);
-  if (!is_gimple_reg (def))
+  if (!def || !is_gimple_reg (def))
     return;
 
   /* Do not gather scalar variables that can be analyzed by SCEV as they can be
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/hsa-gen.c gcc-6-20160721/gcc/hsa-gen.c
--- gcc-6.1.0/gcc/hsa-gen.c	2016-04-04 08:46:51.000000000 +0000
+++ gcc-6-20160721/gcc/hsa-gen.c	2016-05-23 11:54:52.000000000 +0000
@@ -203,9 +203,13 @@
 {
   m_decl = decl;
   m_type = hsa_type_for_tree_type (TREE_TYPE (decl), &m_dim, false);
-
   if (hsa_seen_error ())
-    m_seen_error = true;
+    {
+      m_seen_error = true;
+      return;
+    }
+
+  m_align = MAX (m_align, hsa_natural_alignment (m_type));
 }
 
 /* Constructor of class representing global HSA function/kernel information and
@@ -929,6 +933,14 @@
 				BRIG_LINKAGE_PROGRAM, true,
 				BRIG_ALLOCATION_PROGRAM, align);
 	  hsa_cfun->m_global_symbols.safe_push (sym);
+	  sym->fillup_for_decl (decl);
+	  if (sym->m_align > align)
+	    {
+	      sym->m_seen_error = true;
+	      HSA_SORRY_ATV (EXPR_LOCATION (decl),
+			     "HSA specification requires that %E is at least "
+			     "naturally aligned", decl);
+	    }
 	}
       else
 	{
@@ -944,12 +956,11 @@
 	  sym = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_PRIVATE,
 				BRIG_LINKAGE_FUNCTION);
 	  sym->m_align = align;
+	  sym->fillup_for_decl (decl);
 	  hsa_cfun->m_private_variables.safe_push (sym);
 	}
 
-      sym->fillup_for_decl (decl);
       sym->m_name = hsa_get_declaration_name (decl);
-
       *slot = sym;
       return sym;
     }
@@ -3471,6 +3482,12 @@
   basic_block default_label_bb = label_to_block_fn (func,
 						    CASE_LABEL (default_label));
 
+  if (!gimple_seq_empty_p (phi_nodes (default_label_bb)))
+    {
+      default_label_bb = split_edge (find_edge (e->dest, default_label_bb));
+      hsa_init_new_bb (default_label_bb);
+    }
+
   make_edge (e->src, default_label_bb, EDGE_FALSE_VALUE);
 
   hsa_cfun->m_modified_cfg = true;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ipa-chkp.c gcc-6-20160721/gcc/ipa-chkp.c
--- gcc-6.1.0/gcc/ipa-chkp.c	2016-03-16 16:50:18.000000000 +0000
+++ gcc-6-20160721/gcc/ipa-chkp.c	2016-06-20 11:35:02.000000000 +0000
@@ -207,7 +207,13 @@
   /* For functions with body versioning will make a copy of arguments.
      For functions with no body we need to do it here.  */
   if (!gimple_has_body_p (fndecl))
-    DECL_ARGUMENTS (new_decl) = copy_list (DECL_ARGUMENTS (fndecl));
+    {
+      tree arg;
+
+      DECL_ARGUMENTS (new_decl) = copy_list (DECL_ARGUMENTS (fndecl));
+      for (arg = DECL_ARGUMENTS (new_decl); arg; arg = DECL_CHAIN (arg))
+	DECL_CONTEXT (arg) = new_decl;
+    }
 
   /* We are going to modify attributes list and therefore should
      make own copy.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ipa-icf.c gcc-6-20160721/gcc/ipa-icf.c
--- gcc-6.1.0/gcc/ipa-icf.c	2016-04-22 11:09:22.000000000 +0000
+++ gcc-6-20160721/gcc/ipa-icf.c	2016-05-19 08:09:11.000000000 +0000
@@ -2258,6 +2258,8 @@
 
       varpool_node::create_alias (alias_var->decl, decl);
       alias->resolve_alias (original);
+      if (DECL_PT_UID_SET_P (original->decl))
+	SET_DECL_PT_UID (alias->decl, DECL_PT_UID (original->decl));
 
       if (dump_file)
 	fprintf (dump_file, "Unified; Variable alias has been created.\n\n");
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ipa-inline-analysis.c gcc-6-20160721/gcc/ipa-inline-analysis.c
--- gcc-6.1.0/gcc/ipa-inline-analysis.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/ipa-inline-analysis.c	2016-07-13 12:19:44.000000000 +0000
@@ -216,13 +216,14 @@
   bool by_ref;
 };
 
-/* Add condition to condition list CONDS.  AGGPOS describes whether the used
-   oprand is loaded from an aggregate and where in the aggregate it is.  It can
-   be NULL, which means this not a load from an aggregate.  */
+/* Add condition to condition list SUMMARY. OPERAND_NUM, SIZE, CODE and VAL
+   correspond to fields of condition structure.  AGGPOS describes whether the
+   used operand is loaded from an aggregate and where in the aggregate it is.
+   It can be NULL, which means this not a load from an aggregate.  */
 
 static struct predicate
 add_condition (struct inline_summary *summary, int operand_num,
-	       struct agg_position_info *aggpos,
+	       HOST_WIDE_INT size, struct agg_position_info *aggpos,
 	       enum tree_code code, tree val)
 {
   int i;
@@ -248,6 +249,7 @@
   for (i = 0; vec_safe_iterate (summary->conds, i, &c); i++)
     {
       if (c->operand_num == operand_num
+	  && c->size == size
 	  && c->code == code
 	  && c->val == val
 	  && c->agg_contents == agg_contents
@@ -264,6 +266,7 @@
   new_cond.agg_contents = agg_contents;
   new_cond.by_ref = by_ref;
   new_cond.offset = offset;
+  new_cond.size = size;
   vec_safe_push (summary->conds, new_cond);
   return single_cond_predicate (i + predicate_first_dynamic_condition);
 }
@@ -867,21 +870,25 @@
 	  clause |= 1 << (i + predicate_first_dynamic_condition);
 	  continue;
 	}
-      if (c->code == IS_NOT_CONSTANT || c->code == CHANGED)
+      if (c->code == CHANGED)
 	continue;
 
-      if (operand_equal_p (TYPE_SIZE (TREE_TYPE (c->val)),
-			   TYPE_SIZE (TREE_TYPE (val)), 0))
+      if (tree_to_shwi (TYPE_SIZE (TREE_TYPE (val))) != c->size)
 	{
-	  val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);
+	  clause |= 1 << (i + predicate_first_dynamic_condition);
+	  continue;
+	}
+      if (c->code == IS_NOT_CONSTANT)
+	continue;
 
-	  res = val
-	    ? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)
-	    : NULL;
+      val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);
+      res = val
+	? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)
+	: NULL;
+
+      if (res && integer_zerop (res))
+	continue;
 
-	  if (res && integer_zerop (res))
-	    continue;
-	}
       clause |= 1 << (i + predicate_first_dynamic_condition);
     }
   return clause;
@@ -1515,16 +1522,21 @@
 }
 
 /* If OP refers to value of function parameter, return the corresponding
-   parameter.  */
+   parameter.  If non-NULL, the size of the memory load (or the SSA_NAME of the
+   PARM_DECL) will be stored to *SIZE_P in that case too.  */
 
 static tree
-unmodified_parm_1 (gimple *stmt, tree op)
+unmodified_parm_1 (gimple *stmt, tree op, HOST_WIDE_INT *size_p)
 {
   /* SSA_NAME referring to parm default def?  */
   if (TREE_CODE (op) == SSA_NAME
       && SSA_NAME_IS_DEFAULT_DEF (op)
       && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)
-    return SSA_NAME_VAR (op);
+    {
+      if (size_p)
+	*size_p = tree_to_shwi (TYPE_SIZE (TREE_TYPE (op)));
+      return SSA_NAME_VAR (op);
+    }
   /* Non-SSA parm reference?  */
   if (TREE_CODE (op) == PARM_DECL)
     {
@@ -1535,18 +1547,24 @@
       walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,
 			  NULL);
       if (!modified)
-	return op;
+	{
+	  if (size_p)
+	    *size_p = tree_to_shwi (TYPE_SIZE (TREE_TYPE (op)));
+	  return op;
+	}
     }
   return NULL_TREE;
 }
 
 /* If OP refers to value of function parameter, return the corresponding
-   parameter.  Also traverse chains of SSA register assignments.  */
+   parameter.  Also traverse chains of SSA register assignments.  If non-NULL,
+   the size of the memory load (or the SSA_NAME of the PARM_DECL) will be
+   stored to *SIZE_P in that case too.  */
 
 static tree
-unmodified_parm (gimple *stmt, tree op)
+unmodified_parm (gimple *stmt, tree op, HOST_WIDE_INT *size_p)
 {
-  tree res = unmodified_parm_1 (stmt, op);
+  tree res = unmodified_parm_1 (stmt, op, size_p);
   if (res)
     return res;
 
@@ -1554,23 +1572,25 @@
       && !SSA_NAME_IS_DEFAULT_DEF (op)
       && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))
     return unmodified_parm (SSA_NAME_DEF_STMT (op),
-			    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)));
+			    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)),
+			    size_p);
   return NULL_TREE;
 }
 
 /* If OP refers to a value of a function parameter or value loaded from an
    aggregate passed to a parameter (either by value or reference), return TRUE
-   and store the number of the parameter to *INDEX_P and information whether
-   and how it has been loaded from an aggregate into *AGGPOS.  INFO describes
-   the function parameters, STMT is the statement in which OP is used or
-   loaded.  */
+   and store the number of the parameter to *INDEX_P, the access size into
+   *SIZE_P, and information whether and how it has been loaded from an
+   aggregate into *AGGPOS.  INFO describes the function parameters, STMT is the
+   statement in which OP is used or loaded.  */
 
 static bool
 unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,
 				  gimple *stmt, tree op, int *index_p,
+				  HOST_WIDE_INT *size_p,
 				  struct agg_position_info *aggpos)
 {
-  tree res = unmodified_parm_1 (stmt, op);
+  tree res = unmodified_parm_1 (stmt, op, size_p);
 
   gcc_checking_assert (aggpos);
   if (res)
@@ -1591,14 +1611,14 @@
       stmt = SSA_NAME_DEF_STMT (op);
       op = gimple_assign_rhs1 (stmt);
       if (!REFERENCE_CLASS_P (op))
-	return unmodified_parm_or_parm_agg_item (fbi, stmt, op, index_p,
+	return unmodified_parm_or_parm_agg_item (fbi, stmt, op, index_p, size_p,
 						 aggpos);
     }
 
   aggpos->agg_contents = true;
   return ipa_load_from_parm_agg (fbi, fbi->info->descriptors,
 				 stmt, op, index_p, &aggpos->offset,
-				 NULL, &aggpos->by_ref);
+				 size_p, &aggpos->by_ref);
 }
 
 /* See if statement might disappear after inlining.
@@ -1649,7 +1669,7 @@
 	    inner_lhs = lhs;
 
 	  /* Reads of parameter are expected to be free.  */
-	  if (unmodified_parm (stmt, inner_rhs))
+	  if (unmodified_parm (stmt, inner_rhs, NULL))
 	    rhs_free = true;
 	  /* Match expressions of form &this->field. Those will most likely
 	     combine with something upstream after inlining.  */
@@ -1659,7 +1679,7 @@
 	      if (TREE_CODE (op) == PARM_DECL)
 		rhs_free = true;
 	      else if (TREE_CODE (op) == MEM_REF
-		       && unmodified_parm (stmt, TREE_OPERAND (op, 0)))
+		       && unmodified_parm (stmt, TREE_OPERAND (op, 0), NULL))
 		rhs_free = true;
 	    }
 
@@ -1672,7 +1692,7 @@
 	  /* Reads of parameters passed by reference
 	     expected to be free (i.e. optimized out after inlining).  */
 	  if (TREE_CODE (inner_rhs) == MEM_REF
-	      && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0)))
+	      && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0), NULL))
 	    rhs_free = true;
 
 	  /* Copying parameter passed by reference into gimple register is
@@ -1713,7 +1733,7 @@
 	  if (TREE_CODE (inner_lhs) == PARM_DECL
 	      || TREE_CODE (inner_lhs) == RESULT_DECL
 	      || (TREE_CODE (inner_lhs) == MEM_REF
-		  && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0))
+		  && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0), NULL)
 		      || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME
 			  && SSA_NAME_VAR (TREE_OPERAND (inner_lhs, 0))
 			  && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND
@@ -1744,6 +1764,7 @@
   gimple *last;
   tree op;
   int index;
+  HOST_WIDE_INT size;
   struct agg_position_info aggpos;
   enum tree_code code, inverted_code;
   edge e;
@@ -1760,7 +1781,7 @@
   /* TODO: handle conditionals like
      var = op0 < 4;
      if (var != 0).  */
-  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))
+  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))
     {
       code = gimple_cond_code (last);
       inverted_code = invert_tree_comparison (code, HONOR_NANS (op));
@@ -1774,9 +1795,10 @@
 	     unordered one.  Be sure it is not confused with NON_CONSTANT.  */
 	  if (this_code != ERROR_MARK)
 	    {
-	      struct predicate p = add_condition
-		 (summary, index, &aggpos, this_code,
-		  unshare_expr_without_location (gimple_cond_rhs (last)));
+	      struct predicate p
+		= add_condition (summary, index, size, &aggpos, this_code,
+				 unshare_expr_without_location
+				 (gimple_cond_rhs (last)));
 	      e->aux = edge_predicate_pool.allocate ();
 	      *(struct predicate *) e->aux = p;
 	    }
@@ -1803,11 +1825,12 @@
       || gimple_call_num_args (set_stmt) != 1)
     return;
   op2 = gimple_call_arg (set_stmt, 0);
-  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &aggpos))
+  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &size,
+					 &aggpos))
     return;
   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)
     {
-      struct predicate p = add_condition (summary, index, &aggpos,
+      struct predicate p = add_condition (summary, index, size, &aggpos,
 					  IS_NOT_CONSTANT, NULL_TREE);
       e->aux = edge_predicate_pool.allocate ();
       *(struct predicate *) e->aux = p;
@@ -1826,6 +1849,7 @@
   gimple *lastg;
   tree op;
   int index;
+  HOST_WIDE_INT size;
   struct agg_position_info aggpos;
   edge e;
   edge_iterator ei;
@@ -1837,7 +1861,7 @@
     return;
   gswitch *last = as_a <gswitch *> (lastg);
   op = gimple_switch_index (last);
-  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))
+  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))
     return;
 
   FOR_EACH_EDGE (e, ei, bb->succs)
@@ -1862,14 +1886,14 @@
       if (!min && !max)
 	p = true_predicate ();
       else if (!max)
-	p = add_condition (summary, index, &aggpos, EQ_EXPR,
+	p = add_condition (summary, index, size, &aggpos, EQ_EXPR,
 			   unshare_expr_without_location (min));
       else
 	{
 	  struct predicate p1, p2;
-	  p1 = add_condition (summary, index, &aggpos, GE_EXPR,
+	  p1 = add_condition (summary, index, size, &aggpos, GE_EXPR,
 			      unshare_expr_without_location (min));
-	  p2 = add_condition (summary, index, &aggpos, LE_EXPR,
+	  p2 = add_condition (summary, index, size, &aggpos, LE_EXPR,
 			      unshare_expr_without_location (max));
 	  p = and_predicates (summary->conds, &p1, &p2);
 	}
@@ -1970,13 +1994,14 @@
 {
   tree parm;
   int index;
+  HOST_WIDE_INT size;
 
   while (UNARY_CLASS_P (expr))
     expr = TREE_OPERAND (expr, 0);
 
-  parm = unmodified_parm (NULL, expr);
+  parm = unmodified_parm (NULL, expr, &size);
   if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)
-    return add_condition (summary, index, NULL, CHANGED, NULL_TREE);
+    return add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);
   if (is_gimple_min_invariant (expr))
     return false_predicate ();
   if (TREE_CODE (expr) == SSA_NAME)
@@ -2037,6 +2062,7 @@
   struct predicate op_non_const;
   bool is_load;
   int base_index;
+  HOST_WIDE_INT size;
   struct agg_position_info aggpos;
 
   /* What statments might be optimized away
@@ -2060,7 +2086,7 @@
       tree op;
       gcc_assert (gimple_assign_single_p (stmt));
       op = gimple_assign_rhs1 (stmt);
-      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index,
+      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index, &size,
 					     &aggpos))
 	return p;
     }
@@ -2071,7 +2097,7 @@
      adding conditionals.  */
   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)
     {
-      tree parm = unmodified_parm (stmt, use);
+      tree parm = unmodified_parm (stmt, use, NULL);
       /* For arguments we can build a condition.  */
       if (parm && ipa_get_param_decl_index (fbi->info, parm) >= 0)
 	continue;
@@ -2086,18 +2112,19 @@
 
   if (is_load)
     op_non_const =
-      add_condition (summary, base_index, &aggpos, CHANGED, NULL);
+      add_condition (summary, base_index, size, &aggpos, CHANGED, NULL);
   else
     op_non_const = false_predicate ();
   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)
     {
-      tree parm = unmodified_parm (stmt, use);
+      HOST_WIDE_INT size;
+      tree parm = unmodified_parm (stmt, use, &size);
       int index;
 
       if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)
 	{
 	  if (index != base_index)
-	    p = add_condition (summary, index, NULL, CHANGED, NULL_TREE);
+	    p = add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);
 	  else
 	    continue;
 	}
@@ -2950,6 +2977,18 @@
 	  node->local.can_change_signature = !e;
 	}
     }
+
+  /* Functions called by instrumentation thunk can't change signature
+     because instrumentation thunk modification is not supported.  */
+  if (node->local.can_change_signature)
+    for (e = node->callers; e; e = e->next_caller)
+      if (e->caller->thunk.thunk_p
+	  && e->caller->thunk.add_pointer_bounds_args)
+	{
+	  node->local.can_change_signature = false;
+	  break;
+	}
+
   estimate_function_body_sizes (node, early);
 
   for (e = node->callees; e; e = e->next_callee)
@@ -3377,7 +3416,8 @@
 		    ap.by_ref = c->by_ref;
 		    cond_predicate = add_condition (info,
 						    operand_map[c->operand_num],
-						    &ap, c->code, c->val);
+						    c->size, &ap, c->code,
+						    c->val);
 		  }
 	      }
 	    /* Fixed conditions remains same, construct single
@@ -4236,6 +4276,7 @@
 	{
 	  struct condition c;
 	  c.operand_num = streamer_read_uhwi (&ib);
+	  c.size = streamer_read_uhwi (&ib);
 	  c.code = (enum tree_code) streamer_read_uhwi (&ib);
 	  c.val = stream_read_tree (&ib, data_in);
 	  bp = streamer_read_bitpack (&ib);
@@ -4400,6 +4441,7 @@
 	  for (i = 0; vec_safe_iterate (info->conds, i, &c); i++)
 	    {
 	      streamer_write_uhwi (ob, c->operand_num);
+	      streamer_write_uhwi (ob, c->size);
 	      streamer_write_uhwi (ob, c->code);
 	      stream_write_tree (ob, c->val, true);
 	      bp = bitpack_create (ob->main_stream);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ipa-inline-transform.c gcc-6-20160721/gcc/ipa-inline-transform.c
--- gcc-6.1.0/gcc/ipa-inline-transform.c	2016-03-26 10:08:47.000000000 +0000
+++ gcc-6-20160721/gcc/ipa-inline-transform.c	2016-06-30 08:46:30.000000000 +0000
@@ -334,7 +334,6 @@
       if (dump_file)
 	fprintf (dump_file, "Dropping flag_strict_aliasing on %s:%i\n",
 		 to->name (), to->order);
-      build_optimization_node (&opts);
       DECL_FUNCTION_SPECIFIC_OPTIMIZATION (to->decl)
 	 = build_optimization_node (&opts);
     }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ipa-inline.h gcc-6-20160721/gcc/ipa-inline.h
--- gcc-6.1.0/gcc/ipa-inline.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/ipa-inline.h	2016-05-19 14:56:35.000000000 +0000
@@ -34,6 +34,8 @@
   /* If agg_contents is set, this is the offset from which the used data was
      loaded.  */
   HOST_WIDE_INT offset;
+  /* Size of the access reading the data (or the PARM_DECL SSA_NAME).  */
+  HOST_WIDE_INT size;
   tree val;
   int operand_num;
   ENUM_BITFIELD(tree_code) code : 16;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ipa-prop.c gcc-6-20160721/gcc/ipa-prop.c
--- gcc-6.1.0/gcc/ipa-prop.c	2016-03-29 12:36:39.000000000 +0000
+++ gcc-6-20160721/gcc/ipa-prop.c	2016-05-19 15:00:12.000000000 +0000
@@ -1414,6 +1414,9 @@
   bool check_ref, by_ref;
   ao_ref r;
 
+  if (PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS) == 0)
+    return;
+
   /* The function operates in three stages.  First, we prepare check_ref, r,
      arg_base and arg_offset based on what is actually passed as an actual
      argument.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ira-build.c gcc-6-20160721/gcc/ira-build.c
--- gcc-6.1.0/gcc/ira-build.c	2016-02-11 23:53:54.000000000 +0000
+++ gcc-6-20160721/gcc/ira-build.c	2016-07-18 13:01:12.000000000 +0000
@@ -2251,7 +2251,7 @@
 	     );
       }
   qsort (sorted_loops, n, sizeof (ira_loop_tree_node_t), loop_compare_func);
-  for (i = 0; n - i + 1 > IRA_MAX_LOOPS_NUM; i++)
+  for (i = 0; i < n - IRA_MAX_LOOPS_NUM; i++)
     {
       sorted_loops[i]->to_remove_p = true;
       if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/java/ChangeLog gcc-6-20160721/gcc/java/ChangeLog
--- gcc-6.1.0/gcc/java/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/java/ChangeLog	2016-04-28 16:21:41.000000000 +0000
@@ -1,3 +1,13 @@
+2016-04-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR java/70839
+	* decl.c (parse_version): Remove minor handling.
+
+2016-04-28  Matthias Klose  <doko@ubuntu.com>
+
+	* decl.c (parse_version): Don't encode the minor version in the abi
+	version.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/java/decl.c gcc-6-20160721/gcc/java/decl.c
--- gcc-6.1.0/gcc/java/decl.c	2016-02-08 15:36:16.000000000 +0000
+++ gcc-6-20160721/gcc/java/decl.c	2016-04-28 16:21:41.000000000 +0000
@@ -507,7 +507,7 @@
 parse_version (void)
 {
   const char *p = version_string;
-  unsigned int major = 0, minor = 0;
+  unsigned int major = 0;
   unsigned int abi_version;
 
   /* Skip leading junk.  */
@@ -525,13 +525,6 @@
   gcc_assert (*p == '.' && ISDIGIT (p[1]));
   ++p;
 
-  /* Extract minor version.  */
-  while (ISDIGIT (*p))
-    {
-      minor = minor * 10 + *p - '0';
-      ++p;
-    }
-
   if (flag_indirect_dispatch)
     {
       abi_version = GCJ_CURRENT_BC_ABI_VERSION;
@@ -540,9 +533,9 @@
   else /* C++ ABI */
     {
       /* Implicit in this computation is the idea that we won't break the
-	 old-style binary ABI in a sub-minor release (e.g., from 4.0.0 to
-	 4.0.1).  */
-      abi_version = 100000 * major + 1000 * minor;
+	 old-style binary ABI in a minor release (e.g., from 6.1.0 to
+	 6.2.0).  */
+      abi_version = 100000 * major;
     }
   if (flag_bootstrap_classes)
     abi_version |= FLAG_BOOTSTRAP_LOADER;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/lto-streamer.h gcc-6-20160721/gcc/lto-streamer.h
--- gcc-6.1.0/gcc/lto-streamer.h	2016-02-15 09:30:31.000000000 +0000
+++ gcc-6-20160721/gcc/lto-streamer.h	2016-05-19 14:56:35.000000000 +0000
@@ -129,7 +129,7 @@
      form followed by the data for the string.  */
 
 #define LTO_major_version 5
-#define LTO_minor_version 0
+#define LTO_minor_version 1
 
 typedef unsigned char	lto_decl_flags_t;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/machmode.h gcc-6-20160721/gcc/machmode.h
--- gcc-6.1.0/gcc/machmode.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/machmode.h	2016-06-27 18:25:58.000000000 +0000
@@ -269,6 +269,10 @@
 extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];
 #define GET_MODE_2XWIDER_MODE(MODE) ((machine_mode) mode_2xwider[MODE])
 
+/* Get the complex mode from the component mode.  */
+extern const unsigned char mode_complex[NUM_MACHINE_MODES];
+#define GET_MODE_COMPLEX_MODE(MODE) ((machine_mode) mode_complex[MODE])
+
 /* Return the mode for data of a given size SIZE and mode class CLASS.
    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.
    The value is BLKmode if no other mode is found.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/match.pd gcc-6-20160721/gcc/match.pd
--- gcc-6.1.0/gcc/match.pd	2016-04-05 21:33:37.000000000 +0000
+++ gcc-6-20160721/gcc/match.pd	2016-07-07 07:30:04.000000000 +0000
@@ -844,12 +844,16 @@
   (ne (bit_and:c (bit_not @0) @1) integer_zerop)
   (if (INTEGRAL_TYPE_P (TREE_TYPE (@1))
        && TYPE_PRECISION (TREE_TYPE (@1)) == 1)
-   (lt @0 @1)))
+   (if (TYPE_UNSIGNED (TREE_TYPE (@1)))
+    (lt @0 @1)
+    (gt @0 @1))))
 (simplify
   (ne (bit_ior:c (bit_not @0) @1) integer_zerop)
   (if (INTEGRAL_TYPE_P (TREE_TYPE (@1))
        && TYPE_PRECISION (TREE_TYPE (@1)) == 1)
-   (le @0 @1)))
+   (if (TYPE_UNSIGNED (TREE_TYPE (@1)))
+    (le @0 @1)
+    (ge @0 @1))))
 
 /* ~~x -> x */
 (simplify
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/omp-low.c gcc-6-20160721/gcc/omp-low.c
--- gcc-6.1.0/gcc/omp-low.c	2016-04-15 11:49:39.000000000 +0000
+++ gcc-6-20160721/gcc/omp-low.c	2016-07-11 20:43:11.000000000 +0000
@@ -2186,7 +2186,6 @@
 	case OMP_CLAUSE_GANG:
 	case OMP_CLAUSE_WORKER:
 	case OMP_CLAUSE_VECTOR:
-	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE_INDEPENDENT:
 	case OMP_CLAUSE_AUTO:
 	case OMP_CLAUSE_SEQ:
@@ -2200,10 +2199,8 @@
 	  break;
 
 	case OMP_CLAUSE_DEVICE_RESIDENT:
+	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE__CACHE_:
-	  sorry ("Clause not supported yet");
-	  break;
-
 	default:
 	  gcc_unreachable ();
 	}
@@ -2360,7 +2357,6 @@
 	case OMP_CLAUSE_GANG:
 	case OMP_CLAUSE_WORKER:
 	case OMP_CLAUSE_VECTOR:
-	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE_INDEPENDENT:
 	case OMP_CLAUSE_AUTO:
 	case OMP_CLAUSE_SEQ:
@@ -2368,10 +2364,8 @@
 	  break;
 
 	case OMP_CLAUSE_DEVICE_RESIDENT:
+	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE__CACHE_:
-	  sorry ("Clause not supported yet");
-	  break;
-
 	default:
 	  gcc_unreachable ();
 	}
@@ -4481,8 +4475,9 @@
 		  if (new_var == NULL_TREE)
 		    new_var = maybe_lookup_decl_in_outer_ctx (var, ctx);
 		  x = builtin_decl_explicit (BUILT_IN_ASSUME_ALIGNED);
-		  x = build_call_expr_loc (clause_loc, x, 2, new_var,
-					   omp_clause_aligned_alignment (c));
+		  tree alarg = omp_clause_aligned_alignment (c);
+		  alarg = fold_convert_loc (clause_loc, size_type_node, alarg);
+		  x = build_call_expr_loc (clause_loc, x, 2, new_var, alarg);
 		  x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);
 		  x = build2 (MODIFY_EXPR, TREE_TYPE (new_var), new_var, x);
 		  gimplify_and_add (x, ilist);
@@ -4495,8 +4490,9 @@
 		  t = maybe_lookup_decl_in_outer_ctx (var, ctx);
 		  t = build_fold_addr_expr_loc (clause_loc, t);
 		  t2 = builtin_decl_explicit (BUILT_IN_ASSUME_ALIGNED);
-		  t = build_call_expr_loc (clause_loc, t2, 2, t,
-					   omp_clause_aligned_alignment (c));
+		  tree alarg = omp_clause_aligned_alignment (c);
+		  alarg = fold_convert_loc (clause_loc, size_type_node, alarg);
+		  t = build_call_expr_loc (clause_loc, t2, 2, t, alarg);
 		  t = fold_convert_loc (clause_loc, ptype, t);
 		  x = create_tmp_var (ptype);
 		  t = build2 (MODIFY_EXPR, ptype, x, t);
@@ -13356,9 +13352,15 @@
       make_edge (else_bb, new_bb, EDGE_FALLTHRU);
 
       device = tmp_var;
+      gsi = gsi_last_bb (new_bb);
+    }
+  else
+    {
+      gsi = gsi_last_bb (new_bb);
+      device = force_gimple_operand_gsi (&gsi, device, true, NULL_TREE,
+					 true, GSI_SAME_STMT);
     }
 
-  gsi = gsi_last_bb (new_bb);
   t = gimple_omp_target_data_arg (entry_stmt);
   if (t == NULL)
     {
@@ -13680,6 +13682,9 @@
   tree new_parm_decl = copy_node (DECL_ARGUMENTS (kern_fndecl));
   DECL_CONTEXT (new_parm_decl) = kern_fndecl;
   DECL_ARGUMENTS (kern_fndecl) = new_parm_decl;
+  gcc_assert (VOID_TYPE_P (TREE_TYPE (DECL_RESULT (kern_fndecl))));
+  DECL_RESULT (kern_fndecl) = copy_node (DECL_RESULT (kern_fndecl));
+  DECL_CONTEXT (DECL_RESULT (kern_fndecl)) = kern_fndecl;
   struct function *kern_cfun = DECL_STRUCT_FUNCTION (kern_fndecl);
   kern_cfun->curr_properties = cfun->curr_properties;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/opts-common.c gcc-6-20160721/gcc/opts-common.c
--- gcc-6.1.0/gcc/opts-common.c	2016-02-12 17:39:27.000000000 +0000
+++ gcc-6-20160721/gcc/opts-common.c	2016-06-30 14:39:10.000000000 +0000
@@ -373,8 +373,9 @@
    to specific options.  We want to do the reverse: to find all the ways
    that a user could validly spell an option.
 
-   Given valid OPT_TEXT (with a leading dash), add it and all of its valid
-   variant spellings to CANDIDATES, each without a leading dash.
+   Given valid OPT_TEXT (with a leading dash) for OPTION, add it and all
+   of its valid variant spellings to CANDIDATES, each without a leading
+   dash.
 
    For example, given "-Wabi-tag", the following are added to CANDIDATES:
      "Wabi-tag"
@@ -386,9 +387,11 @@
 
 void
 add_misspelling_candidates (auto_vec<char *> *candidates,
+			    const struct cl_option *option,
 			    const char *opt_text)
 {
   gcc_assert (candidates);
+  gcc_assert (option);
   gcc_assert (opt_text);
   candidates->safe_push (xstrdup (opt_text + 1));
   for (unsigned i = 0; i < ARRAY_SIZE (option_map); i++)
@@ -397,6 +400,9 @@
       const char *new_prefix = option_map[i].new_prefix;
       size_t new_prefix_len = strlen (new_prefix);
 
+      if (option->cl_reject_negative && option_map[i].negated)
+	continue;
+
       if (strncmp (opt_text, new_prefix, new_prefix_len) == 0)
 	{
 	  char *alternative = concat (opt0 + 1, opt_text + new_prefix_len,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/opts.h gcc-6-20160721/gcc/opts.h
--- gcc-6.1.0/gcc/opts.h	2016-02-16 23:12:19.000000000 +0000
+++ gcc-6-20160721/gcc/opts.h	2016-06-30 14:39:10.000000000 +0000
@@ -417,6 +417,7 @@
 } sanitizer_opts[];
 
 extern void add_misspelling_candidates (auto_vec<char *> *candidates,
+					const struct cl_option *option,
 					const char *base_option);
 
 #endif
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/sched-deps.c gcc-6-20160721/gcc/sched-deps.c
--- gcc-6.1.0/gcc/sched-deps.c	2016-03-21 07:52:05.000000000 +0000
+++ gcc-6-20160721/gcc/sched-deps.c	2016-05-20 15:38:24.000000000 +0000
@@ -2709,9 +2709,12 @@
 	return;
       }
 
-    /* Force pending stores to memory in case a trap handler needs them.  */
+    /* Force pending stores to memory in case a trap handler needs them.
+       Also force pending loads from memory; loads and stores can segfault
+       and the signal handler won't be triggered if the trap insn was moved
+       above load or store insn.  */
     case TRAP_IF:
-      flush_pending_lists (deps, insn, true, false);
+      flush_pending_lists (deps, insn, true, true);
       break;
 
     case PREFETCH:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/stor-layout.c gcc-6-20160721/gcc/stor-layout.c
--- gcc-6.1.0/gcc/stor-layout.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/stor-layout.c	2016-06-27 18:25:58.000000000 +0000
@@ -49,11 +49,6 @@
    The value is measured in bits.  */
 unsigned int maximum_field_alignment = TARGET_DEFAULT_PACK_STRUCT * BITS_PER_UNIT;
 
-/* Nonzero if all REFERENCE_TYPEs are internal and hence should be allocated
-   in the address spaces' address_mode, not pointer_mode.   Set only by
-   internal_reference_types called only by a front end.  */
-static int reference_types_internal = 0;
-
 static tree self_referential_size (tree);
 static void finalize_record_size (record_layout_info);
 static void finalize_type_size (tree);
@@ -62,15 +57,6 @@
 			     HOST_WIDE_INT, tree);
 extern void debug_rli (record_layout_info);
 
-/* Show that REFERENCE_TYPES are internal and should use address_mode.
-   Called only by front end.  */
-
-void
-internal_reference_types (void)
-{
-  reference_types_internal = 1;
-}
-
 /* Given a size SIZE that may not be a constant, return a SAVE_EXPR
    to serve as the actual size-expression for a type or decl.  */
 
@@ -2161,10 +2147,8 @@
     case COMPLEX_TYPE:
       TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));
       SET_TYPE_MODE (type,
-		     mode_for_size (2 * TYPE_PRECISION (TREE_TYPE (type)),
-				    (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE
-				     ? MODE_COMPLEX_FLOAT : MODE_COMPLEX_INT),
-				     0));
+		     GET_MODE_COMPLEX_MODE (TYPE_MODE (TREE_TYPE (type))));
+
       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));
       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));
       break;
@@ -2245,12 +2229,6 @@
     case REFERENCE_TYPE:
       {
 	machine_mode mode = TYPE_MODE (type);
-	if (TREE_CODE (type) == REFERENCE_TYPE && reference_types_internal)
-	  {
-	    addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));
-	    mode = targetm.addr_space.address_mode (as);
-	  }
-
 	TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (mode));
 	TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));
 	TYPE_UNSIGNED (type) = 1;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/stor-layout.h gcc-6-20160721/gcc/stor-layout.h
--- gcc-6.1.0/gcc/stor-layout.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/stor-layout.h	2016-04-28 10:49:13.000000000 +0000
@@ -22,7 +22,6 @@
 
 extern void set_min_and_max_values_for_integral_type (tree, int, signop);
 extern void fixup_signed_type (tree);
-extern void internal_reference_types (void);
 extern unsigned int update_alignment_for_field (record_layout_info, tree,
                                                 unsigned int);
 extern record_layout_info start_record_layout (tree);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/ChangeLog gcc-6-20160721/gcc/testsuite/ChangeLog
--- gcc-6.1.0/gcc/testsuite/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/ChangeLog	2016-07-21 18:24:48.000000000 +0000
@@ -1,3 +1,1274 @@
+2016-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71728
+	* g++.dg/other/pr71728.C: New test.
+
+	PR c++/71941
+	* g++.dg/gomp/pr71941.C: New test.
+
+2016-07-21  Patrick Palka  <ppalka@gcc.gnu.org>
+
+	PR c++/70822
+	PR c++/70106
+	* g++.dg/cpp1y/auto-fn32.C: New test.
+	* g++.dg/cpp1y/paren4.C: New test.
+
+2016-07-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71909
+	* g++.dg/parse/pr71909.C: New test.
+	* g++.dg/tm/pr71909.C: New test.
+
+2016-07-20  Martin Jambor  <mjambor@suse.cz>
+
+        PR fortran/71688
+        gfortran.dg/pr71688.f90: New test.
+
+2016-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/71916
+	* gcc.c-torture/compile/pr71916.c: New test.
+
+	PR middle-end/71874
+	* g++.dg/torture/pr71874.C: New test.
+
+	Backported from mainline
+	2016-07-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71835
+	* g++.dg/conversion/ambig3.C: New test.
+
+	PR c++/71828
+	* g++.dg/cpp0x/constexpr-71828.C: New test.
+
+	PR c++/71822
+	* g++.dg/template/defarg21.C: New test.
+
+	PR c++/71871
+	* g++.dg/ext/vector31.C: New test.
+
+	2016-07-07  Jakub Jelinek  <jakub@redhat.com>
+		    Kai Tietz  <ktietz70@googlemail.com>
+
+	PR c++/70869
+	PR c++/71054
+	* g++.dg/cpp0x/pr70869.C: New test.
+	* g++.dg/cpp0x/pr71054.C: New test.
+
+2016-07-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from mainline
+	2016-07-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71493
+	* gcc.target/powerpc/pr71493-1.c: New test.
+	* gcc.target/powerpc/pr71493-2.c: Likewise.
+
+2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nolrl-1.c: New test.
+
+2016-07-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk:
+	PR fortran/71764
+	* gfortran.dg/pr71764.f90: New test.
+
+2016-07-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* g++.dg/pr70098.C: Remove XFAIL for powerpc64_no_dm.
+	* gcc.target/powerpc/pr71763.c: Likewise.
+
+2016-07-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/divkc3-1.c: Require p8vector support.
+	* gcc.target/powerpc/mulkc3-1.c: Likewise.
+
+2016-07-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/divkc3-1.c: New.
+	* gcc.target/powerpc/mulkc3-1.c: New.
+
+2016-07-14  Alan Modra  <amodra@gmail.com>
+
+	PR target/71733
+	* gcc.target/powerpc/p9-novsx.c: New.
+
+2016-07-13  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	Backport from trunk:
+	PR fortran/71623
+	* gfortran.dg/deferred_character_17.f90: New test.
+
+2016-07-13  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r238086.
+	2016-07-07  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR ipa/71624
+	* g++.dg/pr71624.C: New test.
+
+2016-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-05  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	            Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/signbit-1.c: New test.
+	* gcc.target/powerpc/signbit-2.c: New test.
+	* gcc.target/powerpc/signbit-3.c: New test.
+
+2016-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71805
+	* gcc.target/powerpc/pr71805.c: New test.
+
+2016-07-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2016-07-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/70098
+	PR target/71763
+	* gcc.target/powerpc/pr71763.c: New file.
+
+2016-07-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71758
+	* c-c++-common/gomp/pr71758.c: New test.
+	* gfortran.dg/gomp/pr71758.f90: New test.
+
+	PR tree-optimization/71823
+	* gcc.dg/vect/pr71823.c: New test.
+
+2016-07-11  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	Backport from mainline r238055.
+	2016-07-06  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	PR tree-optimization/71518
+        * gcc.dg/pr71518.c: New test.
+
+2016-07-09  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk:
+	PR fortran/71783
+	* gfortran.dg/dependency_46.f90:  New test.
+
+2016-07-08  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from trunk:
+	2016-07-08  Cesar Philippidis  <cesar@codesourcery.com>
+
+	* gfortran.dg/goacc/pr71704.f90: New test.
+
+2016-07-08  Martin Liska  <mliska@suse.cz>
+
+	Backported from mainline
+	2016-07-08  Martin Liska  <mliska@suse.cz>
+
+	* gcc.dg/torture/pr71606.c: New test.
+
+2016-07-08  Jiong Wang  <jiong.wang@arm.com>
+
+	Back port from the trunk
+	2016-07-08  Jiong Wang  <jiong.wang@arm.com>
+
+	* gcc.target/aarch64/simd/vminmaxnm_1.c: New.
+
+2016-07-08  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-07-08  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71806
+	* gcc.target/powerpc/p9-lxvx-stxvx-3.c: Add -mfloat128 option.
+
+2016-07-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from the trunk
+	2016-07-01  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71720
+	* gcc.target/powerpc/pr71720.c: New test.
+
+2016-07-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline r237885
+	2016-06-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/dfp/dfp.exp: New dejagnu test script.
+	* gcc.target/powerpc/dfp/dtstsfi-0.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-1.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-10.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-11.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-12.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-13.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-14.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-15.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-16.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-17.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-18.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-19.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-2.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-20.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-21.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-22.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-23.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-24.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-25.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-26.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-27.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-28.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-29.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-3.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-30.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-31.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-32.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-33.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-34.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-35.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-36.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-37.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-38.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-39.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-4.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-40.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-41.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-42.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-43.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-44.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-45.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-46.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-47.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-48.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-49.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-5.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-50.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-51.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-52.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-53.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-54.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-55.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-56.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-57.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-58.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-59.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-6.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-60.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-61.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-62.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-63.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-64.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-65.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-66.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-67.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-68.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-69.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-7.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-70.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-71.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-72.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-73.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-74.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-75.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-76.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-77.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-78.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-79.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-8.c: New test.
+	* gcc.target/powerpc/dfp/dtstsfi-9.c: New test.
+
+2016-07-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-06-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64516
+	* gcc.dg/align-3.c: New testcase.
+
+2016-07-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-05-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71264
+	* gcc.dg/vect/pr71264.c: New testcase.
+
+	2016-06-07  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/71423
+	* gcc.dg/torture/pr71423.c: New testcase.
+
+	2016-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71521
+	* gcc.dg/tree-ssa/vrp101.c: New testcase.
+
+	2016-06-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71452
+	* gcc.dg/torture/pr71452.c: New testcase.
+
+	2016-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/71522
+	* gcc.dg/torture/pr71522.c: New testcase.
+
+2016-07-06  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	Backport from mainline
+	2016-07-06  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	PR target/50739	
+	* gcc.target/avr/pr50739.c: New test.
+
+2016-07-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-01  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.dg/const-float128-ped.c: Require __float128 effective
+	target and options.
+	* gcc.dg/const-float128.c: Likewise.
+	* gcc.dg/torture/float128-cmp-invalid.c: Require
+	__float128 and base_quadfloat_support effective targets, and
+	__float128 options.
+	* gcc.dg/torture/float128-div-underflow.c: Likewise.
+	* gcc.dg/torture/float128-extend-nan.c: Likewise.
+	* gcc.dg/torture/fp-int-convert-float128-timode-2.c: Likewise.
+	* gcc.dg/torture/fp-int-convert-float128-timode-3.c: Likewise.
+	* gcc.dg/torture/fp-int-convert-float128-timode.c: Likewise.
+	* lib/target-supports.exp (check_effective_target___float128):
+	New.
+	(add_options_for___float128): New.
+	(check_effective_target_base_quadword_support): New.
+
+2016-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71739
+	* g++.dg/cpp0x/pr71739.C: New test.
+
+2016-07-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2016-06-27  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/71670
+	* gcc.target/powerpc/pr71670.c: New testcase.
+
+2016-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/71687
+	* gfortran.dg/gomp/pr71687.f90: New test.
+
+	2016-06-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/71704
+	* gfortran.dg/gomp/pr71704.f90: New test.
+
+	PR fortran/71705
+	* gfortran.dg/gomp/pr71705.f90: New test.
+
+	2016-06-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/71685
+	* gcc.dg/pr71685.c: New test.
+
+	2016-06-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71626
+	* gcc.c-torture/execute/pr71626-1.c: New test.
+	* gcc.c-torture/execute/pr71626-2.c: New test.
+
+	2016-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/71559
+	* gcc.target/i386/sse2-pr71559.c: New test.
+	* gcc.target/i386/avx-pr71559.c: New test.
+	* gcc.target/i386/avx512f-pr71559.c: New test.
+
+2016-07-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from trunk r237659
+	2016-06-21  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/darn-0.c: Add dejagnu directives to disable
+	test if effective-target is not powerpc_p9vector_ok, or if a -mcpu
+	override other than -mcpu=power9 command-line option is specified,
+	or if the target operating system is aix.
+	* gcc.target/powerpc/darn-1.c: Likewise.
+	* gcc.target/powerpc/darn-2.c: Likewise.
+	* gcc.target/powerpc/vslv-0.c: Add dejagnu directives to disable
+	test if effective-target is not powerpc_p9vector_ok or if the
+	target operating system is aix.
+	* gcc.target/powerpc/vslv-1.c: Likewise.
+	* gcc.target/powerpc/vsrv-0.c: Likewise.
+	* gcc.target/powerpc/vsrv-1.c: Likewise.
+
+2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from trunk
+	2016-06-27  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/71656
+	* gcc.target/powerpc/pr71656-1.c: New test.
+	* gcc.target/powerpc/pr71656-2.c: New test.
+
+2016-07-01  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-06-24  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/abs128-1.c: New.
+	* gcc.target/powerpc/copysign128-1.c: New.
+	* gcc.target/powerpc/inf128-1.c: New.
+	* gcc.target/powerpc/nan128-1.c: New.
+
+	Backport from mainline
+	2016-06-28  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/abs128-1.c: Require VSX.
+	* gcc.target/powerpc/copysign128-1.c: Likewise.
+	* gcc.target/powerpc/inf128-1.c: Likewise.
+	* gcc.target/powerpc/nan128-1.c: Likewise.
+
+2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from trunk
+	2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/71698
+	* gcc.target/powerpc/pr71698.c: New test.
+
+2016-07-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from trunk r236992
+	2016-06-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/vslv-0.c: New test.
+	* gcc.target/powerpc/vslv-1.c: New test.
+	* gcc.target/powerpc/vsrv-0.c: New test.
+	* gcc.target/powerpc/vsrv-1.c: New test.
+
+2016-06-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from trunk r237390
+	2016-06-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	Backport from trunk r237646
+	2016-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/vadsdu-0.c: New test.
+	* gcc.target/powerpc/vadsdu-1.c: New test.
+	* gcc.target/powerpc/vadsdu-2.c: New test.
+	* gcc.target/powerpc/vadsdu-3.c: New test.
+	* gcc.target/powerpc/vadsdu-4.c: New test.
+	* gcc.target/powerpc/vadsdu-5.c: New test.
+	* gcc.target/powerpc/vadsdub-1.c: New test.
+	* gcc.target/powerpc/vadsdub-2.c: New test.
+	* gcc.target/powerpc/vadsduh-1.c: New test.
+	* gcc.target/powerpc/vadsduh-2.c: New test.
+	* gcc.target/powerpc/vadsduw-1.c: New test.
+	* gcc.target/powerpc/vadsduw-2.c: New test.
+
+2016-06-30  David Malcolm  <dmalcolm@redhat.com>
+
+	Backport from trunk r237880.
+	2016-06-30  David Malcolm  <dmalcolm@redhat.com>
+
+	PR driver/71651
+	* gcc.dg/spellcheck-options-12.c: New test case.
+
+2016-06-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71693
+	* gcc.c-torture/compile/pr71693.c: New test.
+
+2016-06-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Back port from trunk
+	2016-06-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	* gfortran.dg/goacc/asyncwait-2.f95: Updated expected diagnostics.
+	* gfortran.dg/goacc/asyncwait-3.f95: Likewise.
+	* gfortran.dg/goacc/asyncwait-4.f95: Add test coverage.
+
+2016-06-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/70673
+	* gfortran.dg/pr70673.f90: New test.
+
+2016-06-27  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/float128-complex-1.c: New tests for complex
+	__float128.
+	* gcc.target/powerpc/float128-complex-2.c: Likewise.
+
+2016-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71647
+	* gcc.target/i386/pr71647.c: New test.
+
+2016-06-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/guality/param-5.c: New test.
+
+2016-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71588
+	* gcc.dg/pr71558.c: New test.
+
+	Backported from mainline
+	2016-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71581
+	* gcc.dg/pr71581.c: New test.
+
+	2016-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71528
+	* g++.dg/opt/pr71528.C: New test.
+
+2016-06-20  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r237484.
+	2016-06-15  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR middle-end/71529
+	* gcc.target/i386/pr71529.C: New test.
+
+2016-06-20  Georg-Johann Lay  <avr@gjlay.de>
+	    Pitchumani Sivanupandi  <pitchumani.s@atmel.com>
+
+	Backport from 2016-06-20 trunk r237589, r236558.
+
+	PR target/71103
+	* gcc.target/avr/pr71103.c: New test.
+	* gcc.target/avr/torture/pr71103-2.c: New test.
+
+2016-06-16  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-06-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+	* gcc.target/powerpc/vsx-elemrev-2.c: Change effective target
+	requirements, and disable for AIX for now.
+	* gcc.target/powerpc/vsx-elemrev-4.c: Likewise.
+
+2016-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/71554
+	* gcc.c-torture/execute/pr71554.c: New test.
+
+2016-06-14  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70572
+	* g++.dg/cpp1y/auto-fn31.C: New.
+
+2016-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71516
+	* g++.dg/init/pr71516.C: New test.
+
+	Backported from mainline
+	2016-06-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71494
+	* gcc.c-torture/execute/pr71494.c: New test.
+
+	PR c/68657
+	* gcc.target/i386/pr68657.c: New test.
+
+	2016-06-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71448
+	* g++.dg/torture/pr71448.C: New test.
+
+	2016-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71405
+	* g++.dg/torture/pr71405.C: New test.
+
+2016-06-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/71498
+	* c-c++-common/ubsan/bounds-13.c: New test.
+
+2016-06-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/renaming10.ad[sb]: New test.
+
+2016-06-12  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR target/60751
+	* gfortran.dg/comma_IO_extension_1.f90: New test.
+	* gfortran.dg/comma_IO_extension_2.f90: Likewise.
+	* gfortran.dg/array_constructor_49.f90: Remove extra comma in WRITE
+	statement.
+	* gfortran.dg/graphite/pr38083.f90: Likewise.
+	* gfortran.dg/guality/pr41558.f90: Likewise.
+	* gfortran.dg/integer_exponentiation_6.F90: Likewise and add
+	missing format.
+
+2016-06-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/case_character.adb: New test.
+
+2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/71373
+	Backport from trunk r237291:
+	2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+		    Cesar Philippidis  <cesar@codesourcery.com>
+
+	* gcc.dg/goacc/nested-function-1.c: New file.
+	* gcc.dg/goacc/nested-function-2.c: Likewise.
+	* gcc.dg/goacc/pr71373.c: Likewise.
+	* gfortran.dg/goacc/cray-2.f95: Likewise.
+	* gfortran.dg/goacc/loop-1-2.f95: Likewise.
+	* gfortran.dg/goacc/loop-3-2.f95: Likewise.
+	* gfortran.dg/goacc/cray.f95: Update.
+	* gfortran.dg/goacc/loop-1.f95: Likewise.
+	* gfortran.dg/goacc/loop-3.f95: Likewise.
+	* gfortran.dg/goacc/subroutines.f90: Update, and rename to...
+	* gfortran.dg/goacc/nested-function-1.f90: ... this new file.
+
+	Backport from trunk r237291:
+	* c-c++-common/goacc/combined-directives.c: XFAIL tree scanning
+	for OpenACC tile clauses.
+	* gfortran.dg/goacc/combined-directives.f90: Likewise.
+
+	PR c/71381
+	Backport from trunk r237290:
+	* c-c++-common/goacc/cache-1.c: Update.  Move invalid usage tests
+	to...
+	* c-c++-common/goacc/cache-2.c: ... this new file.
+	* gfortran.dg/goacc/cache-1.f95: Move invalid usage tests to...
+	* gfortran.dg/goacc/cache-2.f95: ... this new file.
+	* gfortran.dg/goacc/coarray.f95: Update OpenACC cache directive
+	usage.
+	* gfortran.dg/goacc/cray.f95: Likewise.
+	* gfortran.dg/goacc/loop-1.f95: Likewise.
+
+2016-06-09  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-31  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/p9-splat-4.c: New test.
+
+	Back port from trunk
+	2016-05-31  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/71186
+	* gcc.target/powerpc/pr71186.c: New test.
+
+	Back port from trunk
+	2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/p9-splat-1.c: New tests for ISA 3.0 word
+	splat operations and the XXSPLTIB instruction.
+	* gcc.target/powerpc/p9-splat-2.c: Likewise.
+	* gcc.target/powerpc/p9-splat-3.c: Likewise.
+	* gcc.target/powerpc/pr47755.c: Allow vspltisw in addition to
+	xxlxor to clear a register.
+
+2016-06-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71442
+	* g++.dg/cpp0x/Wunused-variable-1.C: New test.
+
+2016-06-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2016-06-06  Jose E. Marchesi  <jose.marchesi@oracle.com>
+
+	* gcc.target/sparc/vis4misc.c: New file.
+	* gcc.target/sparc/fpcmp.c: Likewise.
+	* gcc.target/sparc/fpcmpu.c: Likewise.
+
+2016-06-08  Ilya Verbin  <ilya.verbin@intel.com>
+
+	Backport from mainline
+	2016-05-25  Ilya Verbin  <ilya.verbin@intel.com>
+
+	* gcc.target/i386/avx512f-ceil-vec-1.c: New test.
+	* gcc.target/i386/avx512f-ceil-vec-2.c: New test.
+	* gcc.target/i386/avx512f-ceilf-sfix-vec-1.c: New test.
+	* gcc.target/i386/avx512f-ceilf-sfix-vec-2.c: New test.
+	* gcc.target/i386/avx512f-ceilf-vec-1.c: New test.
+	* gcc.target/i386/avx512f-ceilf-vec-2.c: New test.
+	* gcc.target/i386/avx512f-floor-vec-1.c: New test.
+	* gcc.target/i386/avx512f-floor-vec-2.c: New test.
+	* gcc.target/i386/avx512f-floorf-sfix-vec-1.c: New test.
+	* gcc.target/i386/avx512f-floorf-sfix-vec-2.c: New test.
+	* gcc.target/i386/avx512f-floorf-vec-1.c: New test.
+	* gcc.target/i386/avx512f-floorf-vec-2.c: New test.
+	* gcc.target/i386/avx512f-rint-sfix-vec-1.c: New test.
+	* gcc.target/i386/avx512f-rint-sfix-vec-2.c: New test.
+	* gcc.target/i386/avx512f-rintf-sfix-vec-1.c: New test.
+	* gcc.target/i386/avx512f-rintf-sfix-vec-2.c: New test.
+	* gcc.target/i386/avx512f-round-sfix-vec-1.c: New test.
+	* gcc.target/i386/avx512f-round-sfix-vec-2.c: New test.
+	* gcc.target/i386/avx512f-roundf-sfix-vec-1.c: New test.
+	* gcc.target/i386/avx512f-roundf-sfix-vec-2.c: New test.
+	* gcc.target/i386/avx512f-trunc-vec-1.c: New test.
+	* gcc.target/i386/avx512f-trunc-vec-2.c: New test.
+	* gcc.target/i386/avx512f-truncf-vec-1.c: New test.
+	* gcc.target/i386/avx512f-truncf-vec-2.c: New test.
+
+2016-06-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/71389
+	* g++.dg/pr71389.C: New test.
+
+2016-06-06  Jakub Jelinek  <jakub@redhat.com>
+	    Patrick Palka  <ppalka@gcc.gnu.org>
+
+	PR c++/70847
+	PR c++/71330
+	PR c++/71393
+	* g++.dg/opt/pr70847.C: New test.
+	* g++.dg/ubsan/pr70847.C: New test.
+	* g++.dg/ubsan/pr71393.C: New test.
+
+2016-06-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71259
+	* gcc.dg/vect/pr71259.c: New test.
+
+2016-06-05  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/69659
+	* gfortran.dg/class_array_22.f03: New test.
+
+2016-06-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/70957
+	* gcc.target/powerpc/vsx-elemrev-2.c: Require p9vector hardware
+	support.
+	* gcc.target/powerpc/vsx-elemrev-4.c: Likewise.
+
+2016-06-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71387
+	* g++.dg/opt/pr71387.C: New test.
+
+2016-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-26  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/p9-minmax-1.c: New tests for ISA 3.0
+	floating point min/max/comparison instructions.
+	* gcc.target/powerpc/p9-minmax-2.c: Likewise.
+
+2016-06-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71372
+	* c-c++-common/pr71372.c: New test.
+
+2016-06-02  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Back port from trunk
+	2016-05-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/darn-0.c: New test.
+	* gcc.target/powerpc/darn-1.c: New test.
+	* gcc.target/powerpc/darn-2.c: New test.
+
+2016-06-02  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70972
+	* g++.dg/cpp0x/inh-ctor20.C: New.
+	* g++.dg/cpp0x/inh-ctor21.C: Likewise.
+
+2016-06-02  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* g++.dg/cpp1y/lambda-generic-static1.C: Use target c++14.
+	* g++.dg/cpp1y/lambda-generic-static2.C: Likewise.
+
+2016-06-01  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2016-05-23  Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/p9-permute.c: Run test on big endian as well
+	as little endian.
+
+	Back port from trunk
+	2016-05-23  Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/p9-vpermr.c: New test for ISA 3.0 vpermr
+	support.
+
+	Back port from trunk
+	2016-05-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/p9-vparity.c: New file to check ISA 3.0
+	vector parity built-in functions.
+	* gcc.target/powerpc/ctz-3.c: New file to check ISA 3.0 vector
+	count trailing zeros automatic vectorization.
+	* gcc.target/powerpc/ctz-4.c: New file to check ISA 3.0 vector
+	count trailing zeros built-in functions.
+
+	Back port from trunk
+	2016-05-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/p9-vneg.c: New test for ISA 3.0 VNEGW/VNEGD
+	instructions.
+
+	Back port from trunk
+	2016-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/dform-3.c: New test for ISA 3.0 vector d-form
+	support.
+	* gcc.target/powerpc/dform-1.c: Add -mlra option to silence
+	warning when using -mvsx-timode.
+	* gcc.target/powerpc/p8vector-int128-1.c: Likewise.
+	* gcc.target/powerpc/dform-2.c: Likewise.
+	* gcc.target/powerpc/pr68805.c: Likewise.
+
+2016-06-01  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/71156
+	* gfortran.dg/submodule_14.f08: Add missing recursive prefix
+	to the module procedure declaration.
+	* gfortran.dg/submodule_16.f08: New test.
+
+2016-06-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/71371
+	* c-c++-common/gomp/pr71371.c: New test.
+
+	* gfortran.dg/gomp/order-1.f90: New test.
+	* gfortran.dg/gomp/order-2.f90: New test.
+
+2016-06-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt56.ad[sb]: New test.
+
+2016-05-31  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/71306
+	* g++.dg/warn/Wplacement-new-size-3.C: New test.
+
+2016-05-31  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR debug/71057
+	* g++.dg/debug/pr71057.C: New testcase.
+
+2016-05-31  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71056
+	* gcc.target/arm/pr71056.c: New test.
+
+2016-05-31  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-31  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69068
+	* gcc.dg/graphite/pr69068.c: New test.
+
+2016-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71349
+	* c-c++-common/gomp/clauses-1.c (bar): Add dd argument.  Add
+	nowait depend(inout: dd[0]) clauses where permitted.
+
+2016-05-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-04-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-elemrev-1.c: New.
+	* gcc.target/powerpc/vsx-elemrev-2.c: New.
+	* gcc.target/powerpc/vsx-elemrev-3.c: New.
+	* gcc.target/powerpc/vsx-elemrev-4.c: New.
+
+2016-05-30  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-30  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/graphite/pr69067.c (main): Remove superfluous argument in call
+	to ce.
+
+2016-05-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/iamcu/args.h (clear_non_sret_int_hardware_registers):
+	Use correct register when clearing %edx.
+
+2016-05-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/71002
+	* g++.dg/torture/pr71002.C: New testcase.
+
+	2016-05-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/71071
+	* gcc.dg/pr71071.c: New test.
+
+2016-05-30  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-30  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69067
+	* gcc.dg/graphite/pr69067.c: New test.
+
+2016-05-29  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/71105
+	* g++.dg/cpp0x/lambda/lambda-conv11.C: New.
+	* g++.dg/cpp1y/lambda-conv1.C: Likewise.
+	* g++.dg/cpp1y/lambda-conv2.C: Likewise.
+
+2016-05-27  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236810.
+	2016-05-27  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR middle-end/71279
+	* gcc.dg/pr71279.c: New test.
+
+2016-05-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/66461
+	* gfortran.dg/unexpected_eof.f: New test
+
+2016-05-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt55.ad[sb]: New test.
+
+2016-05-24  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/71147
+	* g++.dg/ext/flexary16.C: New test.
+
+2016-05-24  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/69872
+	* g++.dg/warn/Wno-narrowing1.C: New.
+
+2016-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71257
+	* g++.dg/vect/simd-clone-6.cc: New test.
+	* g++.dg/gomp/declare-simd-6.C: New test.
+
+2016-05-23  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/70884
+	* gcc.dg/tree-ssa/pr70919.c: New test.
+
+2016-05-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71210
+	* g++.dg/opt/pr71210-1.C: New test.
+	* g++.dg/opt/pr71210-2.C: New test.
+
+	PR fortran/71204
+	* gfortran.dg/pr71204.f90: New test.
+
+2016-05-19  David Malcolm  <dmalcolm@redhat.com>
+
+	Backport from trunk r236483.
+	PR c++/71184
+	* g++.dg/pr71184.C: New test case.
+
+2016-05-19  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2016-05-19  Marek Polacek  <polacek@redhat.com>
+
+	PR tree-optimization/71031
+	* gcc.dg/tree-ssa/vrp100.c: New test.
+
+2016-05-19  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+	2016-05-19  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* c-c++-common/pr69669.c: Check the used mode.
+
+2016-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/70646
+	* gcc.dg/ipa/pr70646.c: New test.
+
+2016-05-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/71100
+	* g++.dg/opt/pr71100.C: New test.
+
+2016-05-18  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70466
+	* g++.dg/template/pr70466-1.C: New.
+	* g++.dg/template/pr70466-2.C: Likewise.
+
+2016-05-18  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline r236377.
+	2016-05-19  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/aarch64/noplt_3.c: Scan for "br\t".
+	* gcc.target/aarch64/tail_indirect_call_1.c: Scan for "br\t",
+	"blr\t" and switch to scan-assembler-times.
+
+2016-05-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-05-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70809
+	* gcc.target/aarch64/pr70809_1.c: New test.
+
+2016-05-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-05-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/pr70963.c: Require at least power8 at both
+	compile and run time.
+
+2016-05-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/69603
+	* gfortran.dg/pr69603.f90: New testcase.
+
+2016-05-14  Fritz Reese  <fritzoreese@gmail.com>
+
+	Backport from trunk: r235999, r236241, r236242
+	* gfortran.dg/dec_union_4.f90: Fix endian issue.
+
+	PR fortran/71047
+	* gfortran.dg/pr71047.f08: New test.
+
+	PR fortran/56226
+	* gfortran.dg/dec_structure_1.f90: New testcase.
+	* gfortran.dg/dec_structure_2.f90: Ditto.
+	* gfortran.dg/dec_structure_3.f90: Ditto.
+	* gfortran.dg/dec_structure_4.f90: Ditto.
+	* gfortran.dg/dec_structure_5.f90: Ditto.
+	* gfortran.dg/dec_structure_6.f90: Ditto.
+	* gfortran.dg/dec_structure_7.f90: Ditto.
+	* gfortran.dg/dec_structure_8.f90: Ditto.
+	* gfortran.dg/dec_structure_9.f90: Ditto.
+	* gfortran.dg/dec_structure_10.f90: Ditto.
+	* gfortran.dg/dec_structure_11.f90: Ditto.
+	* gfortran.dg/dec_union_1.f90: Ditto.
+	* gfortran.dg/dec_union_2.f90: Ditto.
+	* gfortran.dg/dec_union_3.f90: Ditto.
+	* gfortran.dg/dec_union_4.f90: Ditto.
+	* gfortran.dg/dec_union_5.f90: Ditto.
+	* gfortran.dg/dec_union_6.f90: Ditto.
+	* gfortran.dg/dec_union_7.f90: Ditto.
+
+2016-05-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.dg/vect/tree-vect.h (check_vect): Handle AVX2,
+	remove XOP handling.
+	* gcc.dg/vect/pr66636.c (foo): Add __attribute__((noinline,noclone)).
+
+2016-05-13  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-04-27  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/70760
+	* g++.dg/ipa/ipa-pta-2.C: New testcase.
+
+	2016-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/70931
+	* gfortran.dg/pr70931.f90: New testcase.
+
+	2016-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/70941
+	* gcc.dg/torture/pr70941.c: New testcase.
+
+	2016-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/70941
+	* gcc.dg/torture/pr70941.c (abort): Remove prototype.
+	(a, b, c, d): Change type from char to signed char.
+	(main): Compare against (signed char) -1634678893 instead of
+	hardcoded -109.  Use __builtin_abort instead of abort.
+
+2016-05-12  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236171.
+	2016-05-12  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR tree-optimization/71006
+	* gcc.dg/pr71006.c: New test.
+
+2016-05-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-05-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70830
+	* gcc.target/arm/interrupt-1.c: Change dg-compile to dg-assemble.
+	Add -save-temps to dg-options.
+	Scan for ldmfd rather than pop instruction.
+	* gcc.target/arm/interrupt-2.c: Likewise.
+	* gcc.target/arm/pr70830.c: New test.
+
+2016-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/70855
+	* gfortran.dg/gomp/pr70855.f90: New test.
+
+2016-05-11  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236088.
+	2016-05-10  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR middle-end/70877
+	* gcc.target/i386/pr70877.c: New test.
+
+2016-05-11  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r236086.
+	2016-05-10  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	PR tree-optimization/70876
+	* gcc.target/i386/pr70876.c: New test.
+
+2016-05-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-05-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/70963
+	* gcc.target/powerpc/pr70963.c: New.
+
+2016-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-05-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/70916
+	* gcc.c-torture/compile/pr70916.c: New test.
+
+2016-05-10  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	Backport from mainline r235962.
+	2016-05-06  Yuri Rumyantsev  <ysrumyan@gmail.com>
+
+	PR debug/70935
+	* gcc.dg/torture/pr70935.c: New test.
+
+2016-05-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/fabsneg-1.c New test.
+
+2016-05-07  Tom de Vries  <tom@codesourcery.com>
+
+	backport:
+	2016-05-07  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/70956
+	* gcc.dg/graphite/pr70956.c: New test.
+
+2016-05-06  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2016-05-06  Marek Polacek  <polacek@redhat.com>
+
+	PR sanitizer/70875
+	* gcc.dg/ubsan/bounds-3.c: New test.
+
+2016-05-06  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2016-04-29  Marek Polacek  <polacek@redhat.com>
+
+	PR sanitizer/70342
+	* g++.dg/ubsan/null-7.C: New test.
+
+2016-05-03  Pierre-Marie de Rodat  <derodat@adacore.com>
+
+	* gnat.dg/debug5.adb: New testcase.
+
+2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR middle-end/70626
+	* c-c++-common/goacc/combined-reduction.c: New test.
+	* gfortran.dg/goacc/reduction-2.f95: Add check for kernels reductions.
+
+2016-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/70858
+	* gcc.target/i386/pr70858.c: New test.
+
+2016-04-28  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/70540
+	* g++.dg/cpp0x/auto48.C: New.
+
+2016-04-27  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	* gfortran.dg/submodule_14.f08: Add cleanup-submodules.
+	* gfortran.dg/submodule_15.f08: Likewise.
+
+2016-04-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2016-04-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/70750
+	* gcc.target/i386/pr70750-1.c: New test.
+	* gcc.target/i386/pr70750-2.c: Likewise.
+
+2016-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/70712
+	* c-c++-common/asan/pr70712.c: New test.
+
+2016-04-21  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	PR target/70728
+	* gcc.target/i386/pr70728.c: New test.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/asan/pr70712.c gcc-6-20160721/gcc/testsuite/c-c++-common/asan/pr70712.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/asan/pr70712.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/asan/pr70712.c	2016-04-27 12:23:50.000000000 +0000
@@ -0,0 +1,32 @@
+/* PR sanitizer/70712 */
+/* { dg-do run } */
+
+struct __attribute__((aligned (64))) S
+{
+  char s[4];
+};
+
+struct T
+{
+  char t[8];
+  char u[480];
+
+};
+
+__attribute__((noinline, noclone)) void
+foo (struct T *p, struct S *q)
+{
+  __builtin_memset (p->t, '\0', sizeof (p->t));
+  __builtin_memset (p->u, '\0', sizeof (p->u));
+  __builtin_memset (q->s, '\0', sizeof (q->s));
+}
+
+int
+main ()
+{
+  struct S s;
+  struct T t;
+  foo (&t, &s);
+  asm volatile ("" : : "r" (&t), "r" (&s) : "memory");
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/cache-1.c gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/cache-1.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/cache-1.c	2015-01-15 20:11:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/cache-1.c	2016-06-10 09:46:04.000000000 +0000
@@ -1,3 +1,7 @@
+/* OpenACC cache directive: valid usage.  */
+/* For execution testing, this file is "#include"d from
+   libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c.  */
+
 int
 main (int argc, char **argv)
 {
@@ -21,57 +25,31 @@
         int n = 1;
         const int len = n;
 
-#pragma acc cache /* { dg-error "expected '\\\(' before end of line" } */
-
-#pragma acc cache a[0:N] /* { dg-error "expected '\\\(' before 'a'" } */
-	/* { dg-bogus "expected end of line before 'a'" "" { xfail c++ } 26 } */
-
-#pragma acc cache (a) /* { dg-error "expected '\\\['" } */
-
-#pragma acc cache ( /* { dg-error "expected (identifier|unqualified-id) before end of line" } */
-
-#pragma acc cache () /* { dg-error "expected (identifier|unqualified-id) before '\\\)' token" } */
-
-#pragma acc cache (,) /* { dg-error "expected (identifier|unqualified-id) before '(,|\\\))' token" } */
-
-#pragma acc cache (a[0:N] /* { dg-error "expected '\\\)' before end of line" } */
-
-#pragma acc cache (a[0:N],) /* { dg-error "expected (identifier|unqualified-id) before '(,|\\\))' token" "" { xfail c } } */
-
-#pragma acc cache (a[0:N]) copyin (a[0:N]) /* { dg-error "expected end of line before 'copyin'" } */
-
-#pragma acc cache () /* { dg-error "expected (identifier|unqualified-id) before '\\\)' token" } */
-
-#pragma acc cache (a[0:N] b[0:N]) /* { dg-error "expected '\\\)' before 'b'" } */
-
-#pragma acc cache (a[0:N] b[0:N}) /* { dg-error "expected '\\\)' before 'b'" } */
-	/* { dg-bogus "expected end of line before '\\\}' token" "" { xfail c++ } 47 } */
-
-#pragma acc cache (a[0:N] /* { dg-error "expected '\\\)' before end of line" } */
-
-#pragma acc cache (a[ii]) /* { dg-error "'ii' is not a constant" } */
-
-#pragma acc cache (a[idx:n]) /* { dg-error "'n' is not a constant" } */
-
-#pragma acc cache (a[0:N]) ( /* { dg-error "expected end of line before '\\(' token" } */
-
-#pragma acc cache (a[0:N]) ii /* { dg-error "expected end of line before 'ii'" } */
-
-#pragma acc cache (a[0:N] ii) /* { dg-error "expected '\\)' before 'ii'" } */
-
+	/* Have at it, GCC!  */
 #pragma acc cache (a[0:N])
-
 #pragma acc cache (a[0:N], a[0:N])
-
 #pragma acc cache (a[0:N], b[0:N])
-
 #pragma acc cache (a[0])
-
 #pragma acc cache (a[0], a[1], b[0:N])
-
+#pragma acc cache (a[i - 5])
+#pragma acc cache (a[i + 5:len])
+#pragma acc cache (a[i + 5:len - 1])
+#pragma acc cache (b[i])
+#pragma acc cache (b[i:len])
+#pragma acc cache (a[ii])
+#pragma acc cache (a[ii:len])
+#pragma acc cache (b[ii - 1])
+#pragma acc cache (b[ii - 1:len])
+#pragma acc cache (b[i - ii + 1])
+#pragma acc cache (b[i + ii - 1:len])
+#pragma acc cache (b[i * ii - 1:len + 1])
+#pragma acc cache (a[idx + 2])
+#pragma acc cache (a[idx:len + 2])
 #pragma acc cache (a[idx])
-
 #pragma acc cache (a[idx:len])
+#pragma acc cache (a[idx + 2:len])
+#pragma acc cache (a[idx + 2 + i:len])
+#pragma acc cache (a[idx + 2 + i + ii:len])
 
         b[ii] = a[ii];
     }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/cache-2.c gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/cache-2.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/cache-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/cache-2.c	2016-06-10 09:46:04.000000000 +0000
@@ -0,0 +1,57 @@
+/* OpenACC cache directive: invalid usage.  */
+
+int
+main (int argc, char **argv)
+{
+#define N   2
+    int a[N], b[N];
+    int i;
+
+    for (i = 0; i < N; i++)
+    {
+        a[i] = 3;
+        b[i] = 0;
+    }
+
+#pragma acc parallel copyin (a[0:N]) copyout (b[0:N])
+{
+    int ii;
+
+    for (ii = 0; ii < N; ii++)
+    {
+        const int idx = ii;
+        int n = 1;
+        const int len = n;
+
+#pragma acc cache /* { dg-error "expected '\\\(' before end of line" } */
+#pragma acc cache a[0:N] /* { dg-error "expected '\\\(' before 'a'" } */
+	/* { dg-bogus "expected end of line before 'a'" "" { xfail c++ } 27 } */
+#pragma acc cache (a) /* { dg-error "expected '\\\['" } */
+#pragma acc cache ( /* { dg-error "expected (identifier|unqualified-id) before end of line" } */
+#pragma acc cache () /* { dg-error "expected (identifier|unqualified-id) before '\\\)' token" } */
+#pragma acc cache (,) /* { dg-error "expected (identifier|unqualified-id) before '(,|\\\))' token" } */
+#pragma acc cache (a[0:N] /* { dg-error "expected '\\\)' before end of line" } */
+#pragma acc cache (a[0:N],) /* { dg-error "expected (identifier|unqualified-id) before '(,|\\\))' token" "" { xfail c } } */
+#pragma acc cache (a[0:N]) copyin (a[0:N]) /* { dg-error "expected end of line before 'copyin'" } */
+#pragma acc cache () /* { dg-error "expected (identifier|unqualified-id) before '\\\)' token" } */
+#pragma acc cache (a[0:N] b[0:N]) /* { dg-error "expected '\\\)' before 'b'" } */
+#pragma acc cache (a[0:N] b[0:N}) /* { dg-error "expected '\\\)' before 'b'" } */
+	/* { dg-bogus "expected end of line before '\\\}' token" "" { xfail c++ } 38 } */
+#pragma acc cache (a[0:N] /* { dg-error "expected '\\\)' before end of line" } */
+#pragma acc cache (a[0:N]) ( /* { dg-error "expected end of line before '\\(' token" } */
+#pragma acc cache (a[0:N]) ii /* { dg-error "expected end of line before 'ii'" } */
+#pragma acc cache (a[0:N] ii) /* { dg-error "expected '\\)' before 'ii'" } */
+
+        b[ii] = a[ii];
+    }
+}
+
+
+    for (i = 0; i < N; i++)
+    {
+        if (a[i] != b[i])
+            __builtin_abort ();
+    }
+
+    return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/combined-directives.c gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/combined-directives.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/combined-directives.c	2016-03-30 15:08:47.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/combined-directives.c	2016-06-10 09:46:18.000000000 +0000
@@ -111,6 +111,7 @@
 // { dg-final { scan-tree-dump-times "acc loop vector" 2 "gimple" } }
 // { dg-final { scan-tree-dump-times "acc loop seq" 2 "gimple" } }
 // { dg-final { scan-tree-dump-times "acc loop auto" 2 "gimple" } }
-// { dg-final { scan-tree-dump-times "acc loop tile.2, 3" 2 "gimple" } }
+// XFAILed: OpenACC tile clauses are discarded during gimplification.
+// { dg-final { scan-tree-dump-times "acc loop tile.2, 3" 2 "gimple" { xfail *-*-* } } }
 // { dg-final { scan-tree-dump-times "acc loop independent private.i" 2 "gimple" } }
 // { dg-final { scan-tree-dump-times "private.z" 2 "gimple" } }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/combined-reduction.c gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/combined-reduction.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/goacc/combined-reduction.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/goacc/combined-reduction.c	2016-04-29 17:37:55.000000000 +0000
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-fopenacc -fdump-tree-gimple" } */
+
+#include <assert.h>
+
+int
+main ()
+{
+  int i, v1 = 0, n = 100;
+
+#pragma acc parallel loop reduction(+:v1)
+  for (i = 0; i < n; i++)
+    v1++;
+
+  assert (v1 == n);
+
+#pragma acc kernels loop reduction(+:v1)
+  for (i = 0; i < n; i++)
+    v1++;
+
+  assert (v1 == n);
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "omp target oacc_parallel reduction.+:v1. map.tofrom:v1" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "acc loop reduction.+:v1. private.i." 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "omp target oacc_kernels map.force_tofrom:n .len: 4.. map.force_tofrom:v1 .len: 4.." 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "acc loop reduction.+:v1. private.i." 1 "gimple" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/gomp/clauses-1.c gcc-6-20160721/gcc/testsuite/c-c++-common/gomp/clauses-1.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/gomp/clauses-1.c	2016-03-07 18:39:51.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/gomp/clauses-1.c	2016-05-30 21:40:04.000000000 +0000
@@ -34,7 +34,7 @@
 
 void
 bar (int d, int m, int i1, int i2, int p, int *idp, int s,
-     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q)
+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd)
 {
   #pragma omp for simd \
     private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait \
@@ -63,29 +63,30 @@
   }
   #pragma omp target parallel \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
-    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)
+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \
+    nowait depend(inout: dd[0])
     ;
   #pragma omp target parallel for \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \
-    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)
+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ll++;
   #pragma omp target parallel for simd \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \
     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \
-    safelen(8) simdlen(4) aligned(q: 32)
+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ll++;
   #pragma omp target teams \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
-    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)
+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0])
     ;
   #pragma omp target teams distribute \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \
-    collapse(1) dist_schedule(static, 16)
+    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ;
   #pragma omp target teams distribute parallel for \
@@ -93,7 +94,7 @@
     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \
     collapse(1) dist_schedule(static, 16) \
     if (parallel: i2) num_threads (nth) proc_bind(spread) \
-    lastprivate (l) schedule(static, 4)
+    lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ll++;
   #pragma omp target teams distribute parallel for simd \
@@ -102,19 +103,20 @@
     collapse(1) dist_schedule(static, 16) \
     if (parallel: i2) num_threads (nth) proc_bind(spread) \
     lastprivate (l) schedule(static, 4) \
-    safelen(8) simdlen(4) aligned(q: 32)
+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ll++;
   #pragma omp target teams distribute simd \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \
     collapse(1) dist_schedule(static, 16) \
-    safelen(8) simdlen(4) aligned(q: 32)
+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ll++;
   #pragma omp target simd \
     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \
-    safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r)
+    safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) \
+     nowait depend(inout: dd[0])
   for (int i = 0; i < 64; i++)
     ll++;
   #pragma omp taskloop simd \
@@ -128,7 +130,7 @@
     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r)
   for (int i = 0; i < 64; i++)
     ll++;
-  #pragma omp target
+  #pragma omp target nowait depend(inout: dd[0])
   #pragma omp teams distribute \
     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \
     collapse(1) dist_schedule(static, 16)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/gomp/pr71371.c gcc-6-20160721/gcc/testsuite/c-c++-common/gomp/pr71371.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/gomp/pr71371.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/gomp/pr71371.c	2016-06-01 14:29:04.000000000 +0000
@@ -0,0 +1,25 @@
+/* PR middle-end/71371 */
+/* { dg-do compile } */
+
+void baz (int *);
+
+void
+foo (void)
+{
+  int i;
+  #pragma omp taskloop
+  for (i = 0; i < 100; i++)
+    baz (&i);
+}
+
+void
+bar (void)
+{
+  int i;
+  #pragma omp parallel
+  {
+    #pragma omp for
+    for (i = 0; i < 100; i++)
+      baz (&i);
+  }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/gomp/pr71758.c gcc-6-20160721/gcc/testsuite/c-c++-common/gomp/pr71758.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/gomp/pr71758.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/gomp/pr71758.c	2016-07-11 20:43:11.000000000 +0000
@@ -0,0 +1,10 @@
+/* PR middle-end/71758 */
+
+void
+foo (int *p)
+{
+  long long i = 0;
+  #pragma omp target device (i)
+  ;
+  #pragma omp target update device (i) to (p[0])
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/pr69669.c gcc-6-20160721/gcc/testsuite/c-c++-common/pr69669.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/pr69669.c	2016-02-04 22:17:05.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/pr69669.c	2016-05-19 17:38:51.000000000 +0000
@@ -1,5 +1,6 @@
 /* PR c/69669 */
 /* { dg-do compile } */
+/* { dg-options "-fdump-rtl-final" } */
 
 enum __attribute__((mode(QI))) E { F = 1 };
 
@@ -8,3 +9,5 @@
 {
   *x = (enum E) y;
 }
+
+/* { dg-final { scan-rtl-dump-times "mem:QI" 1 "final" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/pr71372.c gcc-6-20160721/gcc/testsuite/c-c++-common/pr71372.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/pr71372.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/pr71372.c	2016-06-02 16:43:04.000000000 +0000
@@ -0,0 +1,14 @@
+/* PR c++/71372 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+void
+foo (volatile int *p, int q)
+{
+  *(volatile int *)p = 0;
+  *(p + (q - q) + 1) = 0;
+  *(p + (q - q) + 2) = 0;
+  *(p + (q - q) + 3) = 0;
+}
+
+/* { dg-final { scan-tree-dump-times " ={v} " 4 "optimized" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/c-c++-common/ubsan/bounds-13.c gcc-6-20160721/gcc/testsuite/c-c++-common/ubsan/bounds-13.c
--- gcc-6.1.0/gcc/testsuite/c-c++-common/ubsan/bounds-13.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/c-c++-common/ubsan/bounds-13.c	2016-06-13 21:08:36.000000000 +0000
@@ -0,0 +1,31 @@
+/* PR sanitizer/71498 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=bounds -Wno-array-bounds" } */
+
+struct S { int a[100]; int b, c; } s;
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  return s.a[x];
+}
+
+__attribute__((noinline, noclone)) int
+bar (int x)
+{
+  static int *d = &s.a[99];
+  asm volatile ("" : : "r" (&d));
+  return s.a[x];
+}
+
+int
+main ()
+{
+  volatile int a = 0;
+  a += foo (100);
+  a += bar (100);
+  return 0;
+}
+
+/* { dg-output "index 100 out of bounds for type 'int \\\[100\\\]'\[^\n\r]*(\n|\r\n|\r)" } */
+/* { dg-output "\[^\n\r]*index 100 out of bounds for type 'int \\\[100\\\]'\[^\n\r]*(\n|\r\n|\r)" } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/diagnostic1.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/diagnostic1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/diagnostic1.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/diagnostic1.C	2016-07-21 06:18:06.000000000 +0000
@@ -1,16 +1,30 @@
 // PR c++/67159
 // { dg-options "-std=c++1z -fconcepts" }
 
+template <class T, class U>
+concept bool SameAs = __is_same_as(T, U);
+
 template <class T>
-concept bool R = requires (T& t) {
+concept bool R1 = requires (T& t) {
   { t.begin() } -> T
+  { t.end() } -> SameAs<T*>;
+};
+
+template <class T>
+concept bool R2 = requires (T& t) {
+  { t.end() } -> SameAs<T*>;
 };
 
 struct foo {
   int* begin();
+  int* end();
 };
 
-R{T}
+R1{T}
 constexpr bool f() { return true; }
 
+R2{T}
+constexpr bool g() { return true; }
+
 static_assert(f<foo>());	// { dg-error "" }
+static_assert(g<foo>());	// { dg-error "" }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/dr1430.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/dr1430.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/dr1430.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/dr1430.C	2016-07-21 06:18:06.000000000 +0000
@@ -24,11 +24,19 @@
     return decltype(check<T, U, Args...>())::value;
   }
 
+template <typename T, typename U, typename... Args>
+  concept bool Similar = true;
+
 template <typename... Args>
-requires Same<Args...>()	// { dg-error "concept" }
+requires Same<Args...>() // { dg-error "invalid reference" }
   void foo( Args... args ) {}
 
+template <typename... Args>
+requires Similar<Args...> // { dg-error "invalid reference" }
+  void bar( Args... args ) {}
+
 int main()
 {
-  foo(1, 2, 3);			// { dg-error "" }
+  foo(1, 2, 3); // { dg-error "cannot call" }
+  bar(1, 2, 3); // { dg-error "cannot call" }
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/expression2.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/expression2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/expression2.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/expression2.C	2016-07-21 06:18:06.000000000 +0000
@@ -31,12 +31,12 @@
 int main()
 {
   f1(s); // { dg-error "cannot call" }
-  f2(s); // { dg-error "cannot call" }
+  f2(s); // { dg-error "" }
 
   // When used in non-SFINAE contexts, make sure that we fail
   // the constraint check before emitting the access check
   // failures. The context is being presented constistently
   // in both cases.
   static_assert(C1<S>(), ""); // { dg-error "failed" }
-  static_assert(C2<S>(), ""); // { dg-error "failed" }
+  static_assert(C2<S>(), ""); // { dg-error "" }
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req19.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req19.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req19.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req19.C	2016-07-21 06:18:06.000000000 +0000
@@ -0,0 +1,13 @@
+// { dg-options "-std=c++1z -fconcepts" }
+
+struct B
+{
+  template <class T> void f(T t)
+    requires requires (T tt) { tt; }
+  { }
+};
+
+int main()
+{
+  B().f(42);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req20.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req20.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req20.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req20.C	2016-07-21 06:18:06.000000000 +0000
@@ -0,0 +1,19 @@
+// { dg-options "-std=c++1z -fconcepts" }
+
+template <class T> concept bool C = true;
+
+template <class T>
+requires C<typename T::foo>
+void f(T t) { }
+
+void f(...);
+
+template <class T>
+requires C<T>
+void g(T t) { }
+
+int main()
+{
+  f(42);
+  g(42);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req4.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req4.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req4.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req4.C	2016-07-21 06:18:06.000000000 +0000
@@ -9,10 +9,10 @@
 template<typename T> constexpr fool p2() { return {}; }
 
 template<typename T>
-  concept bool C() { return p1<T>() && p2<T>(); } // { dg-error "does not have type" }
+  concept bool C() { return p1<T>() && p2<T>(); }
 
 template<C T> void f(T x) { }
 
 int main() {
-  f(0); // { dg-error "cannot call" }
+  f(0); // { dg-error "cannot call|uses overloaded operator" }
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req5.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req5.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req5.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req5.C	2016-07-21 06:18:06.000000000 +0000
@@ -9,10 +9,10 @@
 template<typename T> constexpr fool p2() { return {}; }
 
 template<typename T>
-  concept bool C() { return p1<T>() && p2<T>(); } // { dg-error "does not have type" }
+  concept bool C() { return p1<T>() && p2<T>(); }
 
 template<C T> void f(T x) { }
 
 int main() {
-  f(0); // { dg-error "cannot call" }
+  f(0); // { dg-error "cannot call|uses overloaded operator" }
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req6.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req6.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/req6.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/req6.C	2016-07-21 06:18:06.000000000 +0000
@@ -7,7 +7,12 @@
   concept bool C1() { return X(); }
 
 template<C1 T>
-  void h(T) { } // { dg-error "not|bool" }
+  void h(T) { } // OK until used.
+
+void f()
+{
+  h(0); // { dg-error "does not have|cannot call" }
+}
 
 template<typename T>
   concept bool C2() { return X() == X(); } // OK
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/var-templ1.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/var-templ1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/var-templ1.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/var-templ1.C	2016-07-21 06:18:06.000000000 +0000
@@ -13,4 +13,4 @@
 constexpr bool f() { return false; }
 
 static_assert(f<void>());
-static_assert(v<void>);		// { dg-error "constraints" }
+static_assert(v<void>);		// { dg-error "invalid" }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/concepts/variadic2.C gcc-6-20160721/gcc/testsuite/g++.dg/concepts/variadic2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/concepts/variadic2.C	2016-03-08 22:30:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/concepts/variadic2.C	2016-07-21 06:18:06.000000000 +0000
@@ -4,10 +4,13 @@
 template <class T> concept bool Constructable = requires { T(); };
 template <class T> concept bool Both = Copyable<T> && Constructable<T>;
 
-template <Copyable... Ts> void f(Ts...) { }
-template <Both... Ts> void f(Ts...) { }
+template <Copyable... Ts>
+constexpr int f(Ts...) { return 0; } // #1
+
+template <Both... Ts>
+constexpr int f(Ts...) { return 1; }     // #2
 
 int main()
 {
-  f(42);
+  static_assert(f(42) == 1);
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/conversion/ambig3.C gcc-6-20160721/gcc/testsuite/g++.dg/conversion/ambig3.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/conversion/ambig3.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/conversion/ambig3.C	2016-07-19 08:46:26.000000000 +0000
@@ -0,0 +1,13 @@
+// PR c++/71835
+// { dg-do compile }
+
+typedef void T (int);
+struct A { operator T * (); };	// { dg-message "candidate" }
+struct B { operator T * (); };	// { dg-message "candidate" }
+struct C : A, B {} c;
+
+void
+foo ()
+{
+  c (0);		// { dg-error "is ambiguous" }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/Wunused-variable-1.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/Wunused-variable-1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/Wunused-variable-1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/Wunused-variable-1.C	2016-06-08 18:00:30.000000000 +0000
@@ -0,0 +1,37 @@
+// PR c++/71442
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wunused-variable" }
+
+struct C
+{
+  template<typename... Ts>
+  int operator()(Ts &&...)
+  {
+    return sizeof...(Ts);
+  }
+};
+
+int
+foo ()
+{
+  C {} (1, 1L, 1LL, 1.0);
+}
+
+template<int N>
+void
+bar ()
+{
+  char a;		// { dg-warning "unused variable" }
+  short b;		// { dg-warning "unused variable" }
+  int c;		// { dg-warning "unused variable" }
+  long d;		// { dg-warning "unused variable" }
+  long long e;		// { dg-warning "unused variable" }
+  float f;		// { dg-warning "unused variable" }
+  double g;		// { dg-warning "unused variable" }
+}
+
+void
+baz ()
+{
+  bar <0> ();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/alias-decl-55.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/alias-decl-55.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/alias-decl-55.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/alias-decl-55.C	2016-07-21 06:14:57.000000000 +0000
@@ -0,0 +1,23 @@
+// PR c++/71718
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+class A : T{};
+
+template <typename T>
+using sp = A<T>;
+
+struct Base {};
+
+template <typename T, int num = 1>
+const sp<T>
+rec() 			// { dg-error "depth" }
+{
+  return rec<T, num - 1>();
+}
+
+static void f(void) {
+  rec<Base>();
+}
+
+// { dg-prune-output "compilation terminated" }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/alignas7.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/alignas7.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/alignas7.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/alignas7.C	2016-07-21 06:15:51.000000000 +0000
@@ -0,0 +1,13 @@
+// PR c++/71513
+// { dg-do compile { target c++11 } }
+
+template < int N, typename T >
+struct A
+{
+  enum alignas (N) E : T;
+};
+
+#define SA(X) static_assert((X), #X)
+
+constexpr int al = alignof(double);
+SA(alignof(A<al,char>::E) == al);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/auto48.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/auto48.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/auto48.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/auto48.C	2016-04-28 09:58:45.000000000 +0000
@@ -0,0 +1,8 @@
+// PR c++/70540
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  auto f = [&] { return f; };  // { dg-error "before deduction" }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-71828.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-71828.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-71828.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-71828.C	2016-07-19 08:44:04.000000000 +0000
@@ -0,0 +1,5 @@
+// PR c++/71828
+// { dg-do compile { target c++11 } }
+
+constexpr _Complex int a { 1, 2 };
+static_assert (& __imag a != &__real a, "");
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-array16.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-array16.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-array16.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-array16.C	2016-05-31 21:36:46.000000000 +0000
@@ -0,0 +1,23 @@
+// PR c++/71166
+// { dg-do compile { target c++11 } }
+
+struct Foo { int value; };
+
+constexpr Foo MakeFoo() { return Foo{0}; }
+
+struct Bar {
+	Foo color = MakeFoo();
+};
+
+struct BarContainer {
+	Bar array[1];
+};
+
+Foo X ()
+{
+  return MakeFoo ();
+}
+
+void Foo() {
+	new BarContainer();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-array17.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-array17.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-array17.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-array17.C	2016-07-21 06:16:17.000000000 +0000
@@ -0,0 +1,61 @@
+// PR c++/71092
+// { dg-do compile { target c++11 } }
+
+template <typename _Default> struct A { using type = _Default; };
+template <typename _Default, template <typename> class>
+using __detected_or = A<_Default>;
+template <typename _Default, template <typename> class _Op>
+using __detected_or_t = typename __detected_or<_Default, _Op>::type;
+template <typename _Tp> struct B { typedef _Tp value_type; };
+struct C {
+  template <typename _Tp> using __pointer = typename _Tp::pointer;
+};
+template <typename _Alloc> struct J : C {
+  using pointer = __detected_or_t<typename _Alloc::value_type *, __pointer>;
+};
+template <typename _T1> void _Construct(_T1 *) { new _T1; }
+struct D {
+  template <typename _ForwardIterator, typename _Size>
+  static _ForwardIterator __uninit_default_n(_ForwardIterator p1, _Size) {
+    _Construct(p1);
+  }
+};
+template <typename _ForwardIterator, typename _Size>
+void __uninitialized_default_n(_ForwardIterator p1, _Size) {
+  D::__uninit_default_n(p1, 0);
+}
+template <typename _ForwardIterator, typename _Size, typename _Tp>
+void __uninitialized_default_n_a(_ForwardIterator p1, _Size, _Tp) {
+  __uninitialized_default_n(p1, 0);
+}
+template <typename> struct __shared_ptr {
+  constexpr __shared_ptr() : _M_ptr(), _M_refcount() {}
+  int _M_ptr;
+  int _M_refcount;
+};
+template <typename _Alloc> struct F {
+  typedef _Alloc _Tp_alloc_type;
+  struct G {
+    typename J<_Tp_alloc_type>::pointer _M_start;
+    G(_Tp_alloc_type);
+  };
+  F(int, _Alloc p2) : _M_impl(p2) {}
+  G _M_impl;
+};
+template <typename _Tp, typename _Alloc = B<_Tp>> struct K : F<_Alloc> {
+  typedef _Alloc allocator_type;
+  K(int, allocator_type p2 = allocator_type()) : F<_Alloc>(0, p2) {
+    __uninitialized_default_n_a(this->_M_impl._M_start, 0, 0);
+  }
+};
+struct H {
+  H();
+  struct I {
+    __shared_ptr<int> trigger[1];
+  };
+  __shared_ptr<int> resetTrigger_;
+  K<I> states_;
+  __shared_ptr<int> triggerManager_;
+};
+__shared_ptr<int> a;
+H::H() : states_(0), triggerManager_(a) {}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem6.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem6.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem6.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem6.C	2016-07-21 06:16:24.000000000 +0000
@@ -0,0 +1,13 @@
+// PR c++/71896
+// { dg-do compile { target c++11 } }
+
+struct Foo {
+  int x;
+};
+
+constexpr bool compare(int Foo::*t) { return t == &Foo::x; }
+
+constexpr bool b = compare(&Foo::x);
+
+#define SA(X) static_assert ((X),#X)
+SA(b);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-recursion2.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-recursion2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/constexpr-recursion2.C	2016-03-23 18:23:04.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/constexpr-recursion2.C	2016-05-24 03:37:10.000000000 +0000
@@ -1,5 +1,6 @@
 // PR c++/70344
 // { dg-do compile { target c++11 } }
+// { dg-options -O }
 
 struct Z
 {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/conv-tmpl1.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/conv-tmpl1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/conv-tmpl1.C	2015-10-23 00:51:14.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/conv-tmpl1.C	2016-07-21 06:16:11.000000000 +0000
@@ -1,3 +1,4 @@
+// Test for Core 2189.
 // { dg-do compile { target c++11 } }
 
 template <class T>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/decltype65.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/decltype65.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/decltype65.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/decltype65.C	2016-07-21 06:15:58.000000000 +0000
@@ -0,0 +1,11 @@
+// PR c++/71511
+// { dg-do compile { target c++11 } }
+
+template < typename T >
+class A
+{
+  static int i;
+};
+
+//okay: template < typename T > int A <T>::i = 100;
+template < typename T > int decltype (A < T > ())::i = 100; // { dg-error "decltype" }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/inh-ctor20.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/inh-ctor20.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/inh-ctor20.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/inh-ctor20.C	2016-06-02 11:30:44.000000000 +0000
@@ -0,0 +1,16 @@
+// PR c++/70972
+// { dg-do compile { target c++11 } }
+
+struct moveonly {
+    moveonly(moveonly&&) = default;
+    moveonly() = default;
+};
+
+struct A {
+    A(moveonly) {}
+};
+struct B : A {
+    using A::A;
+};
+
+B b(moveonly{});
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/inh-ctor21.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/inh-ctor21.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/inh-ctor21.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/inh-ctor21.C	2016-06-02 11:30:44.000000000 +0000
@@ -0,0 +1,19 @@
+// PR c++/70972
+// { dg-do run { target c++11 } }
+
+struct abort_on_copy{
+    abort_on_copy(abort_on_copy&&) = default;
+    abort_on_copy(const abort_on_copy&) { __builtin_abort(); }
+    abort_on_copy() = default;
+};
+
+struct A {
+    A(abort_on_copy) {}
+};
+struct B : A {
+    using A::A;
+};
+
+int main() {
+    B b(abort_on_copy{});
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/initlist-template1.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/initlist-template1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/initlist-template1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/initlist-template1.C	2016-07-21 06:14:51.000000000 +0000
@@ -0,0 +1,15 @@
+// PR c++/70824
+// { dg-do compile { target c++11 } }
+
+#include <initializer_list>
+
+constexpr
+int
+max(std::initializer_list<int> __l)
+{ return *__l.begin(); }
+
+template <class Src>
+void
+a() {
+  const int v =  max({1});
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv11.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv11.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv11.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv11.C	2016-05-29 08:27:07.000000000 +0000
@@ -0,0 +1,10 @@
+// PR c++/71105
+// { dg-do compile { target c++11 } }
+
+void foo()
+{
+  int i;
+  static_cast<void(*)()>([i]{});  // { dg-error "invalid static_cast" }
+  static_cast<void(*)()>([=]{});  // { dg-error "invalid static_cast" }
+  static_cast<void(*)()>([&]{});  // { dg-error "invalid static_cast" }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice16.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice16.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice16.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice16.C	2016-07-21 06:16:30.000000000 +0000
@@ -0,0 +1,8 @@
+// PR c++/70781
+// { dg-do compile { target c++11 } }
+
+template < typename T >
+void foo ()
+{
+  T ([=] (S) { [=] {}; }); 	// { dg-error "" }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/pr70869.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/pr70869.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/pr70869.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/pr70869.C	2016-07-19 08:39:12.000000000 +0000
@@ -0,0 +1,25 @@
+// PR c++/70869
+// { dg-do run { target c++11 } }
+
+#include <initializer_list>
+
+struct A
+{
+  int f () { return 1; }
+  int g () { return 2; }
+  int h () { return 3; }
+};
+
+int
+main ()
+{
+  int cnt = 0;
+  for (const auto &m : { &A::f, &A::g, &A::h })
+    {
+      A a;
+      if ((a.*m) () != ++cnt)
+	__builtin_abort ();
+    }
+  if (cnt != 3)
+    __builtin_abort ();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/pr71054.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/pr71054.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/pr71054.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/pr71054.C	2016-07-19 08:39:12.000000000 +0000
@@ -0,0 +1,21 @@
+// PR c++/71054
+// { dg-do compile { target c++11 } }
+
+#include <initializer_list>
+
+template <typename D, typename T = decltype (&D::U)>
+struct S
+{
+  struct A
+  {
+    int a;
+    int b;
+    T p;
+  };
+  S () { std::initializer_list<A> a{ {0, 0, &D::V} }; }
+};
+struct R {
+  void V (int);
+  void U (int);
+};
+S<R> b;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/pr71739.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/pr71739.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/pr71739.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/pr71739.C	2016-07-04 17:33:50.000000000 +0000
@@ -0,0 +1,5 @@
+// PR c++/71739
+// { dg-do compile { target c++11 } }
+
+template <int N> struct alignas(N) A;
+template <int N> struct alignas(N) A {};
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/range-for31.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/range-for31.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/range-for31.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/range-for31.C	2016-07-21 06:15:43.000000000 +0000
@@ -0,0 +1,9 @@
+// PR c++/71604
+// { dg-do compile { target c++11 } }
+
+void foo ()
+{
+  int a[2] = { 1, 2 };
+  for (struct S { S (int) {} } S : a) // { dg-error "types may not be defined" }
+    ;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/range-for8.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/range-for8.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/range-for8.C	2014-03-07 20:01:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/range-for8.C	2016-07-21 06:15:43.000000000 +0000
@@ -7,9 +7,9 @@
 
 void test()
 {
-    for (struct S { } *x : { (S*)0, (S*)0 } )
+    for (struct S { } *x : { (S*)0, (S*)0 } ) // { dg-error "types may not be defined" }
         ;
 
-    for (struct S { } x : { S(), S() } )
+    for (struct S { } x : { S(), S() } ) // { dg-error "types may not be defined" }
         ;
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/sfinae57.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/sfinae57.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/sfinae57.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/sfinae57.C	2016-07-21 06:16:04.000000000 +0000
@@ -0,0 +1,16 @@
+// PR c++/71495
+// { dg-do compile { target c++11 } }
+
+struct A;
+template <class T> void f(T);	// { dg-bogus "initializing" }
+template <class T> T&& declval();
+struct B
+{
+  template <class T, class U> static decltype(f<T>(declval<U>())) g(int);
+  template <class T, class U> void g(...);
+} b;
+
+int main()
+{
+  b.g<A,A>(42);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle1a.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle1a.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle1a.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle1a.C	2016-07-21 06:15:04.000000000 +0000
@@ -0,0 +1,12 @@
+// Test for sZ mangling.
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_Z1fIJidEEv1AIXstDpT_EE" } }
+// { dg-options -fabi-version=9 }
+
+template <int I> struct A { };
+template <typename... Ts> void f(A<sizeof...(Ts)>);
+
+int main()
+{
+  f<int,double>(A<2>());
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle2a.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle2a.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle2a.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle2a.C	2016-07-21 06:15:04.000000000 +0000
@@ -0,0 +1,19 @@
+// Testcase from cxx-abi-dev.
+// { dg-do compile { target c++11 } }
+// { dg-options "-fabi-version=9" }
+
+struct A {
+  template<int...T> using N = int[sizeof...(T)];
+  template<int...A> void f(N<A...> &);
+
+  template<typename...T> using M = int[sizeof...(T)];
+  template<typename...A> void g(M<A...> &);
+};
+void g(A a)
+{
+  int arr[3];
+  // { dg-final { scan-assembler "_ZN1A1fIJLi1ELi2ELi3EEEEvRAszspT__i" } }
+  a.f<1,2,3>(arr);
+  // { dg-final { scan-assembler "_ZN1A1gIJiiiEEEvRAstDpT__i" } }
+  a.g<int,int,int>(arr);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3.C	2016-07-21 06:15:04.000000000 +0000
@@ -0,0 +1,10 @@
+// Testcase from cxx-abi-dev.
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZN1A1fIJiiEiJiiiEEEvRAsPDpT_T0_DpT1_E_iS3_S5_" } }
+
+struct A {
+  template<typename...T> using N = int[sizeof...(T)];
+  template<typename...A, typename B, typename...C>
+      void f(N<A..., B, C...> &, B, C...);
+};
+void g(A a) { int arr[6]; a.f<int, int>(arr, 1, 2, 3, 4); }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3a.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3a.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3a.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp0x/variadic-mangle3a.C	2016-07-21 06:15:04.000000000 +0000
@@ -0,0 +1,11 @@
+// Testcase from cxx-abi-dev.
+// { dg-do compile { target c++11 } }
+// { dg-options -fabi-version=9 }
+// { dg-final { scan-assembler "_ZN1A1fIJiiEiJiiiEEEvRAstDpT1__iT0_S2_" } }
+
+struct A {
+  template<typename...T> using N = int[sizeof...(T)];
+  template<typename...A, typename B, typename...C>
+      void f(N<A..., B, C...> &, B, C...);
+};
+void g(A a) { int arr[6]; a.f<int, int>(arr, 1, 2, 3, 4); }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/auto-fn31.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/auto-fn31.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/auto-fn31.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/auto-fn31.C	2016-06-14 20:55:08.000000000 +0000
@@ -0,0 +1,7 @@
+// PR c++/70572
+// { dg-do compile { target c++14 } }
+
+void foo ()
+{
+  decltype (auto) a = foo;  // { dg-error "initializer" }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/auto-fn32.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/auto-fn32.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/auto-fn32.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/auto-fn32.C	2016-07-21 06:29:32.000000000 +0000
@@ -0,0 +1,33 @@
+// { dg-do compile { target c++14 } }
+
+template<class,class> struct same_type;
+template<class T> struct same_type<T,T> {};
+
+struct A
+{
+  static int b;
+  int c;
+
+  template <int>
+  decltype(auto) f() { return A::c; }
+
+  template <int>
+  decltype(auto) g() { return (A::c); }
+};
+
+A a;
+
+template <int>
+decltype(auto) f() { return A::b; }
+
+template <int>
+decltype(auto) g() { return (A::b); }
+
+int main()
+{
+  same_type<decltype(f<0>()), int>();
+  same_type<decltype(g<0>()), int&>();
+
+  same_type<decltype(a.f<0>()), int>();
+  same_type<decltype(a.g<0>()), int&>();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C	2016-03-28 17:22:49.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C	2016-07-05 17:55:36.000000000 +0000
@@ -77,10 +77,10 @@
 #  error "__cpp_attributes != 200809"
 #endif
 
-#ifndef __cpp_rvalue_reference
-#  error "__cpp_rvalue_reference"
-#elif __cpp_rvalue_reference != 200610
-#  error "__cpp_rvalue_reference != 200610"
+#ifndef __cpp_rvalue_references
+#  error "__cpp_rvalue_references"
+#elif __cpp_rvalue_references != 200610
+#  error "__cpp_rvalue_references != 200610"
 #endif
 
 #ifndef __cpp_variadic_templates
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C	2016-03-28 17:22:49.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C	2016-07-05 17:55:36.000000000 +0000
@@ -70,10 +70,10 @@
 #  error "__cpp_attributes != 200809"
 #endif
 
-#ifndef __cpp_rvalue_reference
-#  error "__cpp_rvalue_reference"
-#elif __cpp_rvalue_reference != 200610
-#  error "__cpp_rvalue_reference != 200610"
+#ifndef __cpp_rvalue_references
+#  error "__cpp_rvalue_references"
+#elif __cpp_rvalue_references != 200610
+#  error "__cpp_rvalue_references != 200610"
 #endif
 
 #ifndef __cpp_variadic_templates
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C	2015-09-21 15:50:30.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C	2016-07-05 17:55:36.000000000 +0000
@@ -42,8 +42,8 @@
 #  error "__cpp_attributes" // { dg-error "error" }
 #endif
 
-#ifndef __cpp_rvalue_reference
-#  error "__cpp_rvalue_reference" // { dg-error "error" }
+#ifndef __cpp_rvalue_references
+#  error "__cpp_rvalue_references" // { dg-error "error" }
 #endif
 
 #ifndef __cpp_variadic_templates
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-conv1.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-conv1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-conv1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-conv1.C	2016-05-29 08:27:07.000000000 +0000
@@ -0,0 +1,13 @@
+// PR c++/71105
+// { dg-do compile { target c++14 } }
+
+void foo()
+{
+  int i;
+  static_cast<void(*)(int)>([i](auto){});  // { dg-error "invalid static_cast" }
+  static_cast<void(*)(int)>([=](auto){});  // { dg-error "invalid static_cast" }
+  static_cast<void(*)(int)>([&](auto){});  // { dg-error "invalid static_cast" }
+  static_cast<float(*)(float)>([i](auto x){ return x; });  // { dg-error "invalid static_cast" }
+  static_cast<float(*)(float)>([=](auto x){ return x; });  // { dg-error "invalid static_cast" }
+  static_cast<float(*)(float)>([&](auto x){ return x; });  // { dg-error "invalid static_cast" }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-conv2.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-conv2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-conv2.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-conv2.C	2016-05-29 08:27:07.000000000 +0000
@@ -0,0 +1,23 @@
+// PR c++/71105
+// { dg-do compile { target c++14 } }
+
+template <typename T> T declval();
+template <typename, typename> struct is_same
+{ static constexpr bool value = false; };
+template <typename T> struct is_same<T, T>
+{ static constexpr bool value = true; };
+
+template <class F>
+struct indirected : F {
+  indirected(F f) : F(f) {}
+  template <class I>
+  auto operator()(I i) -> decltype(declval<F&>()(*i)) {
+    return static_cast<F&>(*this)(*i);
+  }
+};
+
+int main() {
+  auto f = [=](auto i) { return i + i; };
+  auto i = indirected<decltype(f)>{f};
+  static_assert(is_same<decltype(i(declval<int*>())), int>::value, "");
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv2.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv2.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv2.C	2016-07-21 06:16:11.000000000 +0000
@@ -0,0 +1,26 @@
+// PR c++/71117
+// { dg-do compile { target c++14 } }
+
+template <class T> T&& declval() noexcept;
+template <class, class>
+constexpr bool is_same = false;
+template <class T>
+constexpr bool is_same<T, T> = true;
+
+template <class F>
+struct indirected : F {
+    indirected(F f) : F(f) {}
+    template <class I>
+    auto operator()(I i) -> decltype(declval<F&>()(*i)) {
+        return static_cast<F&>(*this)(*i);
+    }
+};
+
+int main() {
+    auto f = [](auto rng) {
+        static_assert(is_same<decltype(rng), int>, "");
+        return 42;
+    };
+    indirected<decltype(f)> i(f);
+    static_assert(is_same<decltype(i(declval<int*>())), int>, "");
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv3.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv3.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv3.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-conv3.C	2016-07-21 06:16:11.000000000 +0000
@@ -0,0 +1,10 @@
+// PR c++/70942
+// { dg-do compile { target c++14 } }
+
+int main()
+{
+    int x = 0;
+    [](auto&& xv){
+        static_cast<decltype(xv)>(xv) = 1;
+    }(x);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static1.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static1.C	2016-06-02 09:49:43.000000000 +0000
@@ -0,0 +1,13 @@
+// PR c++/70735
+// { dg-do run { target c++14 } }
+
+int main()
+{
+  static int a;
+  auto f = [](auto) { return a; };
+  if (f(0) != 0)
+    __builtin_abort();
+  a = 1;
+  if (f(0) != 1)
+    __builtin_abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static2.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static2.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/lambda-generic-static2.C	2016-06-02 09:49:43.000000000 +0000
@@ -0,0 +1,19 @@
+// PR c++/70735
+// { dg-do run { target c++14 } }
+
+template <class T>
+static void g()
+{
+  static int a;
+  auto f = [](auto) { return a; };
+  if (f(0) != 0)
+    __builtin_abort();
+  a = 1;
+  if (f(0) != 1)
+    __builtin_abort();
+}
+
+int main()
+{
+  g<int>();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/paren4.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/paren4.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/paren4.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/paren4.C	2016-07-21 06:29:32.000000000 +0000
@@ -0,0 +1,14 @@
+// PR c++/70822
+// { dg-do compile { target c++14 } }
+
+struct a
+{
+  static int b;
+};
+
+template <typename>
+void
+foo ()
+{
+  &(a::b);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ39.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ39.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ39.C	2015-08-05 17:56:14.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ39.C	2016-05-31 21:36:34.000000000 +0000
@@ -1,5 +1,5 @@
 // PR c++/66260
-// { dg-do compile { target c++14 } }
+// { dg-do assemble { target c++14 } }
 
 template <class>
 constexpr bool foo = false;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ39a.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ39a.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ39a.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ39a.C	2016-05-31 21:36:34.000000000 +0000
@@ -0,0 +1,27 @@
+// PR c++/66260
+// { dg-do compile { target c++14 } }
+
+template <class>
+bool foo = false;
+template <>
+bool foo<int> = true;
+template <class T, int N>
+bool foo<T[N]> = foo<T>;
+
+#define assert(X) if (!(X)) __builtin_abort();
+
+int main()
+{
+  // { dg-final { scan-assembler "_Z3fooIiE" } }
+  assert(foo<int>);
+  // { dg-final { scan-assembler "_Z3fooIdE" } }
+  assert(!foo<double>);
+  // { dg-final { scan-assembler "_Z3fooIA3_iE" } }
+  assert(foo<int[3]>);
+  // { dg-final { scan-assembler "_Z3fooIA3_dE" } }
+  assert(!foo<double[3]>);
+  // { dg-final { scan-assembler "_Z3fooIA2_A5_A3_iE" } }
+  assert(foo<int[2][5][3]>);
+  // { dg-final { scan-assembler "_Z3fooIA2_A5_A3_dE" } }
+  assert(!foo<double[2][5][3]>);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ51.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ51.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ51.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ51.C	2016-05-31 21:36:34.000000000 +0000
@@ -0,0 +1,11 @@
+// PR c++/60095
+// { dg-do link { target c++14 } }
+
+template <class>
+constexpr bool b = false;
+template<typename T>
+constexpr bool b<T*> = true;
+int main() {
+    b<int*>;
+    b<double*>;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ52.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ52.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1y/var-templ52.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1y/var-templ52.C	2016-05-31 21:36:34.000000000 +0000
@@ -0,0 +1,14 @@
+// PR c++/69515
+// { dg-do link { target c++14 } }
+
+struct A { A(int = 0) {} };
+
+template<class...> class meow;
+
+template<typename T> A foo;
+template<typename... Ts> A foo<meow<Ts...>> = 1;
+
+auto&& a = foo<meow<int>>;
+auto&& b = foo<meow<int, int>>;
+
+int main() {}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C	2016-03-28 17:22:49.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C	2016-07-05 17:55:36.000000000 +0000
@@ -58,10 +58,10 @@
 #  error "__cpp_attributes != 200809"
 #endif
 
-#ifndef __cpp_rvalue_reference
-#  error "__cpp_rvalue_reference"
-#elif __cpp_rvalue_reference != 200610
-#  error "__cpp_rvalue_reference != 200610"
+#ifndef __cpp_rvalue_references
+#  error "__cpp_rvalue_references"
+#elif __cpp_rvalue_references != 200610
+#  error "__cpp_rvalue_references != 200610"
 #endif
 
 #ifndef __cpp_variadic_templates
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/cpp1z/fold-mangle.C gcc-6-20160721/gcc/testsuite/g++.dg/cpp1z/fold-mangle.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/cpp1z/fold-mangle.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/cpp1z/fold-mangle.C	2016-07-21 06:15:23.000000000 +0000
@@ -0,0 +1,20 @@
+// PR c++/71711
+// { dg-options -std=c++1z }
+
+template < int > struct A {};
+template < int ... N > void unary_left (A < (... + N) >);
+template < int ... N > void unary_right (A < (N + ...) >);
+template < int ... N > void binary_left (A < (42 + ... + N) >);
+template < int ... N > void binary_right (A < (N + ... + 42) >);
+
+void bar ()
+{
+  // { dg-final { scan-assembler "_Z10unary_leftIJLi1ELi2ELi3EEEv1AIXflplT_EE" } }
+  unary_left < 1, 2, 3 > ({});
+  // { dg-final { scan-assembler "_Z11unary_rightIJLi1ELi2ELi3EEEv1AIXfrplT_EE" } }
+  unary_right < 1, 2, 3 > ({});
+  // { dg-final { scan-assembler "_Z11binary_leftIJLi1ELi2ELi3EEEv1AIXfLplLi42ET_EE" } }
+  binary_left < 1, 2, 3 > ({});
+  // { dg-final { scan-assembler "_Z12binary_rightIJLi1ELi2ELi3EEEv1AIXfRplT_Li42EEE" } }
+  binary_right < 1, 2, 3 > ({});
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/debug/pr71057.C gcc-6-20160721/gcc/testsuite/g++.dg/debug/pr71057.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/debug/pr71057.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/debug/pr71057.C	2016-05-31 09:58:50.000000000 +0000
@@ -0,0 +1,12 @@
+// { dg-do compile }
+// { dg-options "-g" }
+template <typename _Tp> using decay_t = _Tp;
+template <typename> struct A;
+template <typename> struct B { B(A<int>); };
+template <typename> struct C {
+      template <typename U> using constructor = B<decay_t<U>>;
+        typedef constructor<int> dummy;
+};
+template <typename> struct D {};
+C<int> a;
+D<B<int>> fn1() { fn1, a; }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/ext/flexary16.C gcc-6-20160721/gcc/testsuite/g++.dg/ext/flexary16.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/ext/flexary16.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/ext/flexary16.C	2016-05-25 16:01:24.000000000 +0000
@@ -0,0 +1,37 @@
+// PR c++/71147 - [6 Regression] Flexible array member wrongly rejected
+//   in template
+// { dg-do compile }
+
+template <typename>
+struct container
+{
+  struct elem {
+    unsigned u;
+  };
+
+  struct incomplete {
+    int x;
+    elem array[];
+  };
+};
+
+unsigned f (container<void>::incomplete* i)
+{
+  return i->array [0].u;
+}
+
+
+template <typename T>
+struct D: container<T>
+{
+  struct S {
+    int x;
+    typename container<T>::elem array[];
+  };
+};
+
+
+unsigned g (D<void>::S *s)
+{
+  return s->array [0].u;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/ext/vector31.C gcc-6-20160721/gcc/testsuite/g++.dg/ext/vector31.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/ext/vector31.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/ext/vector31.C	2016-07-19 08:40:37.000000000 +0000
@@ -0,0 +1,29 @@
+// PR c++/71871
+// { dg-do compile }
+
+typedef unsigned int V __attribute__ ((__vector_size__ (32)));
+
+template <int N>
+void
+foo (V *x)
+{
+  V a = *x;
+  a = a ? a : -1;
+  *x = a;
+}
+
+template <typename T>
+void
+bar (T *x)
+{
+  T a = *x;
+  a = a ? a : -1;
+  *x = a;
+}
+
+void
+test (V *x, V *y)
+{
+  foo<0> (x);
+  bar<V> (y);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/gomp/declare-simd-6.C gcc-6-20160721/gcc/testsuite/g++.dg/gomp/declare-simd-6.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/gomp/declare-simd-6.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/gomp/declare-simd-6.C	2016-05-24 16:27:12.000000000 +0000
@@ -0,0 +1,37 @@
+// PR c++/71257
+// { dg-do compile }
+// { dg-options "-fopenmp-simd" }
+
+struct S { int a; };
+#pragma omp declare simd linear(val(a):2)
+int f1 (int &a);
+#pragma omp declare simd linear(uval(a):2)
+unsigned short f2 (unsigned short &a);
+#pragma omp declare simd linear(ref(a):1)
+int f3 (long long int &a);
+#pragma omp declare simd linear(a:1)
+int f4 (int &a);
+#pragma omp declare simd linear(val(a))
+int f5 (int a);
+#pragma omp declare simd linear(uval(a):2)		// { dg-error "modifier applied to non-reference variable" }
+int f6 (unsigned short a);
+#pragma omp declare simd linear(ref(a):1)		// { dg-error "modifier applied to non-reference variable" }
+int f7 (unsigned long int a);
+#pragma omp declare simd linear(a:1)
+int f8 (int a);
+#pragma omp declare simd linear(val(a):2)		// { dg-error "applied to non-integral non-pointer variable" }
+int f9 (S &a);
+#pragma omp declare simd linear(uval(a):2)		// { dg-error "applied to non-integral non-pointer variable" }
+int f10 (S &a);
+#pragma omp declare simd linear(ref(a):1)		// { dg-bogus "applied to non-integral non-pointer variable" }
+int f11 (S &a);
+#pragma omp declare simd linear(a:1)			// { dg-error "applied to non-integral non-pointer variable" }
+int f12 (S &a);
+#pragma omp declare simd linear(val(a))			// { dg-error "applied to non-integral non-pointer variable" }
+int f13 (S a);
+#pragma omp declare simd linear(uval(a):2)		// { dg-error "modifier applied to non-reference variable" }
+int f14 (S a);
+#pragma omp declare simd linear(ref(a):1)		// { dg-error "modifier applied to non-reference variable" }
+int f15 (S a);
+#pragma omp declare simd linear(a:1)			// { dg-error "applied to non-integral non-pointer variable" }
+int f16 (S a);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/gomp/pr71941.C gcc-6-20160721/gcc/testsuite/g++.dg/gomp/pr71941.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/gomp/pr71941.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/gomp/pr71941.C	2016-07-21 07:13:42.000000000 +0000
@@ -0,0 +1,22 @@
+// PR c++/71941
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+struct A { A (); A (A &); ~A (); };
+
+template <int N>
+struct B
+{
+  struct C { A a; C () : a () {} };
+  C c;
+  void foo ();
+};
+
+void
+bar ()
+{
+  B<0> b;
+#pragma omp task
+  for (int i = 0; i < 2; i++)
+    b.foo ();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/init/pr71516.C gcc-6-20160721/gcc/testsuite/g++.dg/init/pr71516.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/init/pr71516.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/init/pr71516.C	2016-06-14 14:47:17.000000000 +0000
@@ -0,0 +1,10 @@
+// PR c++/71516
+// { dg-do compile }
+
+struct A;	// { dg-message "forward declaration of" }
+struct B
+{ 
+  static A a;
+};
+A B::a = A();	// { dg-error "has initializer but incomplete type|invalid use of incomplete type" }
+struct A {};
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/ipa/ipa-pta-2.C gcc-6-20160721/gcc/testsuite/g++.dg/ipa/ipa-pta-2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/ipa/ipa-pta-2.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/ipa/ipa-pta-2.C	2016-05-13 13:22:42.000000000 +0000
@@ -0,0 +1,37 @@
+// { dg-do run }
+// { dg-options "-O2 -fipa-pta" }
+
+extern "C" void abort (void);
+
+struct Y { ~Y(); int i; };
+
+Y::~Y () {}
+
+static Y __attribute__((noinline)) foo ()
+{
+  Y res;
+  res.i = 3;
+  return res;
+}
+
+static Y __attribute__((noinline)) bar ()
+{
+  Y res;
+  res.i = 42;
+  return res;
+}
+
+static Y (*fn) ();
+
+int a;
+int main()
+{
+  if (a)
+    fn = foo;
+  else
+    fn = bar;
+  Y res = fn ();
+  if (res.i != 42)
+    abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/lookup/scoped10.C gcc-6-20160721/gcc/testsuite/g++.dg/lookup/scoped10.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/lookup/scoped10.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/lookup/scoped10.C	2016-05-31 21:36:28.000000000 +0000
@@ -0,0 +1,5 @@
+namespace A { }
+namespace N { struct A; }
+using namespace N;
+
+struct ::A *p;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/lookup/scoped9.C gcc-6-20160721/gcc/testsuite/g++.dg/lookup/scoped9.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/lookup/scoped9.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/lookup/scoped9.C	2016-05-31 21:36:28.000000000 +0000
@@ -0,0 +1,10 @@
+// PR c++/71173
+
+namespace foo {
+  namespace bar {
+    class foo {};
+  }
+  class baz {};
+}
+using namespace foo::bar;
+::foo::baz mybaz;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr70847.C gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr70847.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr70847.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr70847.C	2016-06-06 20:11:54.000000000 +0000
@@ -0,0 +1,11 @@
+// PR c++/70847
+// { dg-do compile }
+
+struct D { virtual D& f(); };
+
+void
+g()
+{
+  D d;
+  d.f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71100.C gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71100.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71100.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71100.C	2016-05-18 21:24:16.000000000 +0000
@@ -0,0 +1,18 @@
+// PR c++/71100
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct D { ~D (); };
+struct E { D foo () { throw 1; } };
+
+inline void
+bar (D (E::*f) (), E *o)
+{
+  (o->*f) ();
+}
+
+void
+baz (E *o)
+{
+  bar (&E::foo, o);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71210-1.C gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71210-1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71210-1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71210-1.C	2016-05-20 19:06:09.000000000 +0000
@@ -0,0 +1,14 @@
+// PR c++/71210
+// { dg-do compile }
+// { dg-options "-O2" }
+
+#include <typeinfo>
+
+void f1 (const std::type_info&) __attribute__((noreturn));
+struct S1 { ~S1 (); };
+struct S2
+{
+  virtual S1 f2 () const { f1 (typeid (*this)); }
+  S1 f3 () const { return f2 (); }
+};
+void f4 () { S2 a; a.f3 (); }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71210-2.C gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71210-2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71210-2.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71210-2.C	2016-05-20 19:06:09.000000000 +0000
@@ -0,0 +1,23 @@
+// PR c++/71210
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct C { int a; int b; C (); ~C (); };
+
+namespace
+{
+  struct A
+  {
+    A () {}
+    virtual C bar (int) = 0;
+    C baz (int x) { return bar (x); }
+  };
+}
+
+A *a;
+
+void
+foo ()
+{
+  C c = a->baz (0);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71387.C gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71387.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71387.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71387.C	2016-06-03 11:01:39.000000000 +0000
@@ -0,0 +1,52 @@
+// PR middle-end/71387
+// { dg-do compile }
+// { dg-options "-Og" }
+
+struct A
+{
+  A ();
+  inline A (const A &);
+};
+
+struct B
+{
+  explicit B (unsigned long) : b(0), c(1) {}
+  A a;
+  unsigned long b;
+  int c;
+};
+
+struct C {};
+
+struct D
+{
+  explicit D (const C *) {}
+};
+
+struct E : public D
+{
+  E (const C *x) : D(x) {}
+  virtual A foo () const = 0;
+  virtual A bar () const = 0;
+};
+
+struct F : public B
+{
+  inline void baz ();
+  F (const E *);
+  const E *f;
+};
+
+inline void
+F::baz ()
+{
+  if (b == 0)
+    a = f->bar ();
+  else
+    a = f->foo ();
+}
+
+F::F (const E *) : B(4)
+{
+  baz ();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71528.C gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71528.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/opt/pr71528.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/opt/pr71528.C	2016-06-21 07:02:59.000000000 +0000
@@ -0,0 +1,23 @@
+// PR c++/71528
+// { dg-do run }
+// { dg-options "-O2" }
+
+extern int &x;
+int y;
+
+int &
+foo ()
+{
+  return y;
+}
+
+int &x = foo ();
+
+int
+main ()
+{
+  if (&x != &y)
+    __builtin_abort ();
+}
+
+extern int &x;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/other/i386-10.C gcc-6-20160721/gcc/testsuite/g++.dg/other/i386-10.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/other/i386-10.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/other/i386-10.C	2016-05-31 21:36:22.000000000 +0000
@@ -0,0 +1,12 @@
+// { dg-do compile { target i?86-*-* x86_64-*-* } }
+// { dg-options -maes }
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+
+int main()
+{
+    const char index = 1;
+    __m128i r = { };
+
+    r = __builtin_ia32_aeskeygenassist128 (r, (int)(index));
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/other/pr71728.C gcc-6-20160721/gcc/testsuite/g++.dg/other/pr71728.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/other/pr71728.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/other/pr71728.C	2016-07-21 18:24:48.000000000 +0000
@@ -0,0 +1,11 @@
+// PR c++/71728
+// { dg-do compile }
+// { dg-options "-std=gnu++14 -Wall" }
+
+int
+foo ()
+{
+  if (({ goto test; test: 1; }) != 1)
+    return 1;
+  return 2;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/parse/pr71909.C gcc-6-20160721/gcc/testsuite/g++.dg/parse/pr71909.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/parse/pr71909.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/parse/pr71909.C	2016-07-20 14:05:00.000000000 +0000
@@ -0,0 +1,22 @@
+// PR c++/71909
+// { dg-do compile }
+
+struct S
+{
+  S () try : m (0) {}
+  catch (...) {}
+  void foo () try {}
+  catch (int) {}
+  catch (...) {}
+  int m;
+};
+
+struct T
+{
+  T () : m (0) {}
+  catch (...) {}	// { dg-error "expected unqualified-id before" }
+  void foo () {}
+  catch (int) {}	// { dg-error "expected unqualified-id before" }
+  catch (...) {}	// { dg-error "expected unqualified-id before" }
+  int m;
+};
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/pr70098.C gcc-6-20160721/gcc/testsuite/g++.dg/pr70098.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/pr70098.C	2016-03-14 14:18:44.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/pr70098.C	2016-07-15 20:58:23.000000000 +0000
@@ -2,8 +2,6 @@
 // { dg-do compile }
 // { dg-options -O2 }
 // { dg-require-effective-target c++11 }
-// { dg-xfail-if "PR70098" { lp64 && powerpc64_no_dm } }
-// { dg-prune-output ".*internal compiler error.*" }
 
 template < typename > struct traits;
 template < typename, int _Rows, int _Cols, int = 0, int = _Rows,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/pr71184.C gcc-6-20160721/gcc/testsuite/g++.dg/pr71184.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/pr71184.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/pr71184.C	2016-05-19 18:56:47.000000000 +0000
@@ -0,0 +1 @@
+operator new[ // { dg-error "expected type-specifier before 'new'" }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/pr71389.C gcc-6-20160721/gcc/testsuite/g++.dg/pr71389.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/pr71389.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/pr71389.C	2016-06-07 15:16:44.000000000 +0000
@@ -0,0 +1,23 @@
+// { dg-do compile { target i?86-*-* x86_64-*-* } }
+// { dg-options "-std=c++11 -O3 -march=ivybridge" }
+
+#include <functional>
+
+extern int le_s6, le_s9, le_s11;
+long foo_v14[16][16];
+
+void fn1() {
+  std::array<std::array<int, 16>, 16> v13;
+  for (; le_s6;)
+    for (int k1 = 2; k1 < 4; k1 = k1 + 1) {
+      for (int n1 = 0; n1 < le_s9; n1 = 8) {
+        *foo_v14[6] = 20923310;
+        for (int i2 = n1; i2 < n1 + 8; i2 = i2 + 1)
+          v13.at(5).at(i2 + 6 - n1) = 306146921;
+      }
+
+      for (int l2 = 0; l2 < le_s11; l2 = l2 + 1)
+          *(l2 + v13.at(5).begin()) = 306146921;
+    }
+  v13.at(le_s6 - 4);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/pr71624.C gcc-6-20160721/gcc/testsuite/g++.dg/pr71624.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/pr71624.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/pr71624.C	2016-07-13 12:19:44.000000000 +0000
@@ -0,0 +1,35 @@
+/* PR71624 */
+// { dg-do compile { target i?86-*-* x86_64-*-* } }
+/* { dg-options "-fcheck-pointer-bounds -mmpx -O2" } */
+
+class c1
+{
+public:
+  virtual int fn1 () const;
+  int fn2 (const int *) const;
+};
+
+class c2
+{
+  int fn1 ();
+  c1 obj;
+};
+
+int
+c1::fn1 () const
+{
+  return 0;
+}
+
+int
+c1::fn2 (const int *) const
+{
+  return this->fn1 ();
+}
+
+int
+c2::fn1 ()
+{
+  return obj.fn2 (0);
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/template/defarg21.C gcc-6-20160721/gcc/testsuite/g++.dg/template/defarg21.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/template/defarg21.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/template/defarg21.C	2016-07-19 08:42:12.000000000 +0000
@@ -0,0 +1,21 @@
+// PR c++/71822
+// { dg-do compile }
+
+int bar (int);
+
+template <typename T>
+struct A
+{
+  explicit A (int x = bar (sizeof (T)));
+};
+
+struct B
+{
+  A <int> b[2];
+};
+
+void
+baz ()
+{
+  B b;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/template/friend62.C gcc-6-20160721/gcc/testsuite/g++.dg/template/friend62.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/template/friend62.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/template/friend62.C	2016-05-31 21:36:40.000000000 +0000
@@ -0,0 +1,16 @@
+// PR c++/71227
+// { dg-options "" }
+
+class A {
+  public:
+    template<typename T>
+      friend int f(int x, T v) { // { dg-message "declaration" }
+        return x + v;
+      }
+};
+
+
+template<>
+int f(int x, int v) {		// { dg-warning "friend" }
+  return x + v;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/template/pr70466-1.C gcc-6-20160721/gcc/testsuite/g++.dg/template/pr70466-1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/template/pr70466-1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/template/pr70466-1.C	2016-05-18 17:17:03.000000000 +0000
@@ -0,0 +1,27 @@
+// PR c++/70466
+
+template < class T, class T >  // { dg-error "conflicting" }
+class A
+{
+public:
+  explicit A (T (S::*f) ()) {}  // { dg-error "expected" }
+};
+
+template < class T, class S > 
+A < T, S > foo (T (S::*f) ())
+{
+  return A < T, S > (f);
+}
+
+class B
+{
+public:
+  void bar () {}
+};
+
+int
+main ()
+{
+  foo (&B::bar);
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/template/pr70466-2.C gcc-6-20160721/gcc/testsuite/g++.dg/template/pr70466-2.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/template/pr70466-2.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/template/pr70466-2.C	2016-05-18 17:17:03.000000000 +0000
@@ -0,0 +1,25 @@
+// PR c++/70466
+
+template < class T, class S >
+struct A
+{
+  explicit A (...) {}
+};
+
+template < class T, class S >
+A < T, S > foo (T (S::*f) ())
+{
+  return A < T, S > (f);
+}
+
+struct B
+{
+  void bar () {}
+};
+
+int
+main ()
+{
+  foo (&B::bar);
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/tm/pr71909.C gcc-6-20160721/gcc/testsuite/g++.dg/tm/pr71909.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/tm/pr71909.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/tm/pr71909.C	2016-07-20 14:05:00.000000000 +0000
@@ -0,0 +1,18 @@
+// PR c++/71909
+// { dg-do compile { target c++11 } }
+// { dg-options "-fgnu-tm" }
+
+struct S
+{
+  S () __transaction_atomic [[outer]] try : m {0} {} catch (int) {} catch (...) {}
+  int m;
+};
+
+struct T
+{
+  T () __transaction_atomic __attribute__((outer)) try : m {0} {} catch (int) {} catch (...) {}
+  int m;
+};
+
+void foo () __transaction_atomic [[outer]] try {} catch (int) {} catch (...) {}
+void bar () __transaction_atomic __attribute__((outer)) try {} catch (int) {} catch (...) {}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71002.C gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71002.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71002.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71002.C	2016-05-30 14:00:18.000000000 +0000
@@ -0,0 +1,160 @@
+// { dg-do run }
+
+using size_t = __SIZE_TYPE__;
+
+inline void* operator new(size_t, void* p) noexcept
+{ return p; }
+
+inline void operator delete(void*, void*)
+{ }
+
+struct long_t
+{
+  size_t is_short : 1;
+  size_t length   : (__SIZEOF_SIZE_T__ * __CHAR_BIT__ - 1);
+  size_t capacity;
+  char* pointer;
+};
+
+union long_raw_t {
+  unsigned char data[sizeof(long_t)];
+  struct __attribute__((aligned(alignof(long_t)))) { } align;
+};
+
+struct short_header
+{
+  unsigned char is_short : 1;
+  unsigned char length   : (__CHAR_BIT__ - 1);
+};
+
+struct short_t
+{
+  short_header h;
+  char data[23];
+};
+
+union repr_t
+{
+  long_raw_t  r;
+  short_t     s;
+
+  const short_t& short_repr() const
+  { return s; }
+
+  const long_t& long_repr() const
+  { return *static_cast<const long_t*>(static_cast<const void*>(&r)); }
+
+  short_t& short_repr()
+  { return s;  }
+
+  long_t& long_repr()
+  { return *static_cast<long_t*>(static_cast<void*>(&r)); }
+};
+
+class string
+{
+public:
+  string()
+  {
+    short_t& s = m_repr.short_repr();
+    s.h.is_short = 1;
+    s.h.length = 0;
+    s.data[0] = '\0';
+  }
+
+  string(const char* str)
+  {
+    size_t length = __builtin_strlen(str);
+    if (length + 1 > 23) {
+      long_t& l = m_repr.long_repr();
+      l.is_short = 0;
+      l.length = length;
+      l.capacity = length + 1;
+      l.pointer = new char[l.capacity];
+      __builtin_memcpy(l.pointer, str, length + 1);
+    } else {
+      short_t& s = m_repr.short_repr();
+      s.h.is_short = 1;
+      s.h.length = length;
+      __builtin_memcpy(s.data, str, length + 1);
+    }
+  }
+
+  string(string&& other)
+    : string{}
+  {
+    swap_data(other);
+  }
+
+  ~string()
+  {
+    if (!is_short()) {
+      delete[] m_repr.long_repr().pointer;
+    }
+  }
+
+  size_t length() const
+  { return is_short() ? short_length() : long_length(); }
+
+private:
+  bool is_short() const
+  { return m_repr.s.h.is_short != 0; }
+
+  size_t short_length() const
+  { return m_repr.short_repr().h.length; }
+
+  size_t long_length() const
+  { return m_repr.long_repr().length; }
+
+  void swap_data(string& other)
+  {
+    if (is_short()) {
+      if (other.is_short()) {
+        repr_t tmp(m_repr);
+        m_repr = other.m_repr;
+        other.m_repr = tmp;
+      } else {
+        short_t short_backup(m_repr.short_repr());
+        m_repr.short_repr().~short_t();
+        ::new(&m_repr.long_repr()) long_t(other.m_repr.long_repr());
+        other.m_repr.long_repr().~long_t();
+        ::new(&other.m_repr.short_repr()) short_t(short_backup);
+      }
+    } else {
+      if (other.is_short()) {
+        short_t short_backup(other.m_repr.short_repr());
+        other.m_repr.short_repr().~short_t();
+        ::new(&other.m_repr.long_repr()) long_t(m_repr.long_repr());
+        m_repr.long_repr().~long_t();
+        ::new(&m_repr.short_repr()) short_t(short_backup);
+      } else {
+        long_t tmp(m_repr.long_repr());
+        m_repr.long_repr() = other.m_repr.long_repr();
+        other.m_repr.long_repr() = tmp;
+      }
+    }
+  }
+
+  repr_t m_repr;
+};
+
+struct foo
+{
+  __attribute__((noinline))
+  foo(string str)
+    : m_str{static_cast<string&&>(str)},
+      m_len{m_str.length()}
+  { }
+
+  string m_str;
+  size_t m_len;
+};
+
+int main()
+{
+  foo f{"the quick brown fox jumps over the lazy dog"};
+  if (f.m_len == 0) {
+    __builtin_abort();
+  }
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71405.C gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71405.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71405.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71405.C	2016-06-14 14:42:46.000000000 +0000
@@ -0,0 +1,22 @@
+// PR tree-optimization/71405
+// { dg-do compile }
+
+struct C
+{
+  C () {}
+  int i;
+};
+
+void *
+operator new (__SIZE_TYPE__ x, void *y)
+{
+  return y;
+}
+
+int
+main ()
+{
+  int a;
+  new (&a) C;
+  return a; 
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71448.C gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71448.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71448.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71448.C	2016-06-14 14:43:42.000000000 +0000
@@ -0,0 +1,27 @@
+// PR c++/71448
+// { dg-do compile }
+// { dg-additional-options "-std=c++11" }
+
+static constexpr const char foo[] = "foo";
+static constexpr const char *bar = "bar";
+
+static_assert ((foo + 3 - foo) == 3, "check");
+static_assert (foo + 2 != foo, "check");
+static_assert (foo + 2 >= foo, "check");
+static_assert (3 + foo >= foo, "check");
+static_assert (foo <= foo + 2, "check");
+static_assert (foo <= 3 + foo, "check");
+static_assert (foo + 2 > foo, "check");
+static_assert (3 + foo > foo, "check");
+static_assert (foo < 2 + foo, "check");
+static_assert (foo < foo + 3, "check");
+static_assert ((bar + 3 - bar) == 3, "check");
+static_assert (bar + 2 != bar, "check");
+static_assert (2 + bar >= bar, "check");
+static_assert (bar + 3 >= bar, "check");
+static_assert (bar <= bar + 2, "check");
+static_assert (bar <= 3 + bar, "check");
+static_assert (bar + 2 > bar, "check");
+static_assert (3 + bar > bar, "check");
+static_assert (bar < 2 + bar, "check");
+static_assert (bar < bar + 3, "check");
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71452.C gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71452.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71452.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71452.C	2016-07-07 07:30:04.000000000 +0000
@@ -0,0 +1,10 @@
+// { dg-do run }
+
+int main()
+{
+  bool b;
+  *(char *)&b = 123;
+  if (*(char *)&b != 123)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71874.C gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71874.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/torture/pr71874.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/torture/pr71874.C	2016-07-19 17:33:58.000000000 +0000
@@ -0,0 +1,12 @@
+// PR middle-end/71874
+// { dg-do run }
+
+int
+main ()
+{
+  char str[] = "abcdefghijklmnopqrstuvwxyzABCDEF";
+  __builtin_memmove (str + 20, str + 15, 11);
+  if (__builtin_strcmp (str, "abcdefghijklmnopqrstpqrstuvwxyzF") != 0)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/ubsan/null-7.C gcc-6-20160721/gcc/testsuite/g++.dg/ubsan/null-7.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/ubsan/null-7.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/ubsan/null-7.C	2016-05-06 10:50:03.000000000 +0000
@@ -0,0 +1,24 @@
+// PR sanitizer/70342
+// { dg-do compile }
+// { dg-options "-fsanitize=null" }
+
+class A {};
+class B {
+public:
+  B(A);
+};
+class C {
+public:
+  C operator<<(B);
+};
+class D {
+  D(const int &);
+  C m_blackList;
+};
+D::D(const int &) {
+  m_blackList << A() << A() << A() << A() << A() << A() << A() << A() << A()
+              << A() << A() << A() << A() << A() << A() << A() << A() << A()
+              << A() << A() << A() << A() << A() << A() << A() << A() << A()
+              << A() << A() << A() << A() << A() << A() << A() << A() << A()
+              << A() << A() << A() << A() << A() << A() << A() << A() << A();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/ubsan/pr70847.C gcc-6-20160721/gcc/testsuite/g++.dg/ubsan/pr70847.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/ubsan/pr70847.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/ubsan/pr70847.C	2016-06-06 20:11:54.000000000 +0000
@@ -0,0 +1,11 @@
+// PR c++/70847
+// { dg-do compile }
+
+struct D { virtual D& f(); };
+
+void
+g()
+{
+  D d;
+  d.f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f().f();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/ubsan/pr71393.C gcc-6-20160721/gcc/testsuite/g++.dg/ubsan/pr71393.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/ubsan/pr71393.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/ubsan/pr71393.C	2016-06-06 20:11:54.000000000 +0000
@@ -0,0 +1,14 @@
+// PR c++/71393
+// { dg-do compile }
+// { dg-options "-fsanitize=undefined" }
+
+struct B { B &operator << (long); };
+struct A { A (); long a, b, c, d, e, f; };
+
+A::A ()
+{
+  B q;
+  q << 0 << a << 0 << b << 0 << (b / a) << 0 << c << 0 << (c / a) << 0
+    << d << 0 << (d / a) << 0 << e << 0 << (e / a) << 0 << f << 0
+    << (f / a) << 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/vect/simd-clone-6.cc gcc-6-20160721/gcc/testsuite/g++.dg/vect/simd-clone-6.cc
--- gcc-6.1.0/gcc/testsuite/g++.dg/vect/simd-clone-6.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/vect/simd-clone-6.cc	2016-05-24 16:27:12.000000000 +0000
@@ -0,0 +1,43 @@
+// PR c++/71257
+// { dg-require-effective-target vect_simd_clones }
+// { dg-additional-options "-fopenmp-simd -fno-inline" }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+
+#include "../../gcc.dg/vect/tree-vect.h"
+
+#define N 1024
+struct S { int a; };
+int c[N], e[N], f[N];
+S d[N];
+
+#pragma omp declare simd linear(ref(b, c) : 1)
+int
+foo (int a, S &b, int &c)
+{
+  return a + b.a + c;
+}
+
+void
+do_main ()
+{
+  int i;
+  for (i = 0; i < N; i++)
+    {
+      c[i] = i;
+      d[i].a = 2 * i;
+      f[i] = 3 * i;
+    }
+  #pragma omp simd
+  for (i = 0; i < N; i++)
+    e[i] = foo (c[i], d[i], f[i]);
+  for (i = 0; i < N; i++)
+    if (e[i] != 6 * i)
+      __builtin_abort ();
+}
+
+int
+main ()
+{
+  check_vect ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/warn/Wno-narrowing1.C gcc-6-20160721/gcc/testsuite/g++.dg/warn/Wno-narrowing1.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/warn/Wno-narrowing1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/warn/Wno-narrowing1.C	2016-05-24 16:44:09.000000000 +0000
@@ -0,0 +1,7 @@
+// PR c++/69872
+// { dg-options "-Wall -Wextra -pedantic -Wno-narrowing" }
+
+struct s { int x, y; };
+short offsets[1] = {
+  ((char*) &(((struct s*)16)->y) - (char *)16),  // { dg-bogus "note" }
+};
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/g++.dg/warn/Wplacement-new-size-3.C gcc-6-20160721/gcc/testsuite/g++.dg/warn/Wplacement-new-size-3.C
--- gcc-6.1.0/gcc/testsuite/g++.dg/warn/Wplacement-new-size-3.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/g++.dg/warn/Wplacement-new-size-3.C	2016-05-31 17:24:22.000000000 +0000
@@ -0,0 +1,40 @@
+// PR c++/71306 - bogus -Wplacement-new with an array element
+// { dg-do compile }
+// { dg-options "-Wplacement-new" }
+
+void* operator new (__SIZE_TYPE__, void *p) { return p; }
+
+struct S64 { char c [64]; };
+
+S64 s2 [2];
+S64* ps2 [2];
+S64* ps2_2 [2][2];
+
+void* pv2 [2];
+
+void f ()
+{
+  char a [2][sizeof (S64)];
+
+  new (a) S64;
+  new (a [0]) S64;
+  new (a [1]) S64;
+
+  // Verify there is no warning with buffers of sufficient size.
+  new (&s2 [0]) S64;
+  new (&s2 [1]) S64;
+
+  // ..and no warning with pointers to buffers of unknown size.
+  new (ps2 [0]) S64;
+  new (ps2 [1]) S64;
+
+  // But a warning when using the ps2_2 array itself as opposed
+  // to the pointers it's elements might point to.
+  new (ps2_2 [0]) S64;	// { dg-warning "placement new" }
+  new (ps2_2 [1]) S64;	// { dg-warning "placement new" }
+
+  // ..and no warning again with pointers to buffers of unknown
+  // size.
+  new (pv2 [0]) S64;
+  new (pv2 [1]) S64;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/compile/pr70916.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/compile/pr70916.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/compile/pr70916.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/compile/pr70916.c	2016-05-10 16:59:04.000000000 +0000
@@ -0,0 +1,28 @@
+/* PR tree-optimization/70916 */
+
+int a, b, c, d, i, k;
+int static *e = &b, *j;
+int **f;
+int static ***g = &f;
+int *h;
+void
+fn1 ()
+{
+  for (;;)
+    {
+      int l[1] = { };
+      int m = (__UINTPTR_TYPE__) l;
+      for (; d; d--)
+	{
+	  int ****n;
+	  int *****o = &n;
+	  i = a & 7 ? : a;
+	  *e = (((*o = &g) != (int ****) g) < h[c], 0) || k;
+	  if (*e)
+	    {
+	      **n = &j;
+	      *e = (__UINTPTR_TYPE__) h;
+	    }
+	}
+    }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/compile/pr71693.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/compile/pr71693.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/compile/pr71693.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/compile/pr71693.c	2016-06-30 09:02:53.000000000 +0000
@@ -0,0 +1,10 @@
+/* PR middle-end/71693 */
+
+unsigned short v;
+
+void
+foo (int x)
+{
+  v = ((((unsigned short) (0x0001 | (x & 0x0070) | 0x0100) & 0x00ffU) << 8)
+       | (((unsigned short) (0x0001 | (x & 0x0070) | 0x0100) >> 8) & 0x00ffU));
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/compile/pr71916.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/compile/pr71916.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/compile/pr71916.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/compile/pr71916.c	2016-07-19 19:55:54.000000000 +0000
@@ -0,0 +1,36 @@
+/* PR rtl-optimization/71916 */
+
+int a, b, c, d, f, g;
+short h;
+
+short
+foo (short p1)
+{
+  return a >= 2 || p1 > 7 >> a ? p1 : p1 << a;
+}
+
+void
+bar (void)
+{
+  for (;;)
+    {
+      int i, j[3];
+      h = b >= 2 ? d : d >> b;
+      if (foo (f > h ^ c))
+	{
+	  d = 0;
+	  while (f <= 2)
+	    {
+	      char k[2];
+	      for (;;)
+		k[i++] = 7;
+	    }
+	}
+      else
+	for (;;)
+	  g = j[2];
+      if (g)
+	for (;;)
+	  ;
+    }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71494.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71494.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71494.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71494.c	2016-06-14 14:45:23.000000000 +0000
@@ -0,0 +1,22 @@
+/* PR middle-end/71494 */
+
+int
+main ()
+{
+  void *label = &&out;
+  int i = 0;
+  void test (void)
+  {
+    label = &&out2;
+    goto *label;
+   out2:;
+    i++;
+  }
+  goto *label;
+ out:
+  i += 2;
+  test ();
+  if (i != 3)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71554.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71554.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71554.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71554.c	2016-06-16 10:21:43.000000000 +0000
@@ -0,0 +1,28 @@
+/* PR target/71554 */
+
+int v;
+
+__attribute__ ((noinline, noclone)) void
+bar (void)
+{
+  v++;
+}
+
+__attribute__ ((noinline, noclone))
+void
+foo (unsigned int x)
+{
+  signed int y = ((-__INT_MAX__ - 1) / 2);
+  signed int r;
+  if (__builtin_mul_overflow (x, y, &r))
+    bar ();
+}
+
+int
+main ()
+{
+  foo (2);
+  if (v)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71626-1.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71626-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71626-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71626-1.c	2016-07-02 10:21:24.000000000 +0000
@@ -0,0 +1,19 @@
+/* PR middle-end/71626 */
+
+typedef __INTPTR_TYPE__ V __attribute__((__vector_size__(sizeof (__INTPTR_TYPE__))));
+
+__attribute__((noinline, noclone)) V
+foo ()
+{
+  V v = { (__INTPTR_TYPE__) foo };
+  return v;
+}
+
+int
+main ()
+{
+  V v = foo ();
+  if (v[0] != (__INTPTR_TYPE__) foo)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71626-2.c gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71626-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.c-torture/execute/pr71626-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.c-torture/execute/pr71626-2.c	2016-07-02 10:21:24.000000000 +0000
@@ -0,0 +1,4 @@
+/* PR middle-end/71626 */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+#include "pr71626-1.c"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/align-3.c gcc-6-20160721/gcc/testsuite/gcc.dg/align-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/align-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/align-3.c	2016-07-07 11:37:24.000000000 +0000
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-rtl-expand" } */
+
+typedef struct { char a[2]; } __attribute__((__packed__)) TU2;
+unsigned short get16_unaligned(const void *p) {
+    unsigned short v;
+    *(TU2 *)(void *)(&v) = *(const TU2 *)p;
+    return v;
+}
+
+/* { dg-final { scan-rtl-dump "MEM\[^\n\r\]*A8\\\]" "expand" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/const-float128-ped.c gcc-6-20160721/gcc/testsuite/gcc.dg/const-float128-ped.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/const-float128-ped.c	2008-07-02 18:54:04.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/const-float128-ped.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,5 +1,7 @@
 /* Test 'q' suffix with -pedantic on __float128 type constants.  */
-/* { dg-do compile { target ia64-*-* i?86-*-* x86_64-*-* } } */
+/* { dg-do compile } */
+/* { dg-require-effective-target __float128 } */
 /* { dg-options "-pedantic" } */
+/* { dg-add-options __float128 } */
 
 __float128 a = 123.456789q; /* { dg-warning "non-standard suffix on floating constant" } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/const-float128.c gcc-6-20160721/gcc/testsuite/gcc.dg/const-float128.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/const-float128.c	2008-07-02 18:54:04.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/const-float128.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,6 +1,8 @@
 /* Test 'q' and 'Q' suffixes on __float128 type constants.  */
-/* { dg-do compile { target ia64-*-* i?86-*-* x86_64-*-* } } */
+/* { dg-do compile } */
+/* { dg-require-effective-target __float128 } */
 /* { dg-options "" } */
+/* { dg-add-options __float128 } */
 
 __float128 a = 123.456789q;
 __float128 b = 123.456789Q;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/debug/dwarf2/pr71855.c gcc-6-20160721/gcc/testsuite/gcc.dg/debug/dwarf2/pr71855.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/debug/dwarf2/pr71855.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/debug/dwarf2/pr71855.c	2016-07-19 19:31:24.000000000 +0000
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -g -dA" } */
+
+// Test that there is only one DW_TAG_unspecified_parameters DIE.
+
+void
+foo (const char *format, ...)
+{
+}
+
+// { dg-final { scan-assembler-times "DIE.*DW_TAG_unspecified_parameters" 1 } }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/goacc/nested-function-1.c gcc-6-20160721/gcc/testsuite/gcc.dg/goacc/nested-function-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/goacc/nested-function-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/goacc/nested-function-1.c	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,100 @@
+/* Exercise nested function decomposition, gcc/tree-nested.c.  */
+/* See gcc/testsuite/gfortran.dg/goacc/nested-function-1.f90 for the Fortran
+   version.  */
+
+int main ()
+{
+#define N 100
+  int nonlocal_arg;
+  int nonlocal_a[N];
+  int nonlocal_i;
+  int nonlocal_j;
+
+  for (int i = 0; i < N; ++i)
+    nonlocal_a[i] = 5;
+  nonlocal_arg = 5;
+
+  void local ()
+  {
+    int local_i;
+    int local_arg;
+    int local_a[N];
+    int local_j;
+
+    for (int i = 0; i < N; ++i)
+      local_a[i] = 5;
+    local_arg = 5;
+
+#pragma acc kernels loop \
+  gang(num:local_arg) worker(local_arg) vector(local_arg) \
+  wait async(local_arg)
+    for (local_i = 0; local_i < N; ++local_i)
+      {
+#pragma acc cache (local_a[local_i:5])
+	local_a[local_i] = 100;
+#pragma acc loop seq tile(*)
+	for (local_j = 0; local_j < N; ++local_j)
+	  ;
+#pragma acc loop auto independent tile(1)
+	for (local_j = 0; local_j < N; ++local_j)
+	  ;
+      }
+
+#pragma acc kernels loop \
+  gang(static:local_arg) worker(local_arg) vector(local_arg) \
+  wait(local_arg, local_arg + 1, local_arg + 2) async
+    for (local_i = 0; local_i < N; ++local_i)
+      {
+#pragma acc cache (local_a[local_i:4])
+	local_a[local_i] = 100;
+#pragma acc loop seq tile(1)
+	for (local_j = 0; local_j < N; ++local_j)
+	  ;
+#pragma acc loop auto independent tile(*)
+	for (local_j = 0; local_j < N; ++local_j)
+	  ;
+      }
+  }
+
+  void nonlocal ()
+  {
+    for (int i = 0; i < N; ++i)
+      nonlocal_a[i] = 5;
+    nonlocal_arg = 5;
+
+#pragma acc kernels loop \
+  gang(num:nonlocal_arg) worker(nonlocal_arg) vector(nonlocal_arg) \
+  wait async(nonlocal_arg)
+    for (nonlocal_i = 0; nonlocal_i < N; ++nonlocal_i)
+      {
+#pragma acc cache (nonlocal_a[nonlocal_i:3])
+	nonlocal_a[nonlocal_i] = 100;
+#pragma acc loop seq tile(2)
+	for (nonlocal_j = 0; nonlocal_j < N; ++nonlocal_j)
+	  ;
+#pragma acc loop auto independent tile(3)
+	for (nonlocal_j = 0; nonlocal_j < N; ++nonlocal_j)
+	  ;
+      }
+
+#pragma acc kernels loop \
+  gang(static:nonlocal_arg) worker(nonlocal_arg) vector(nonlocal_arg) \
+  wait(nonlocal_arg, nonlocal_arg + 1, nonlocal_arg + 2) async
+    for (nonlocal_i = 0; nonlocal_i < N; ++nonlocal_i)
+      {
+#pragma acc cache (nonlocal_a[nonlocal_i:2])
+	nonlocal_a[nonlocal_i] = 100;
+#pragma acc loop seq tile(*)
+	for (nonlocal_j = 0; nonlocal_j < N; ++nonlocal_j)
+	  ;
+#pragma acc loop auto independent tile(*)
+	for (nonlocal_j = 0; nonlocal_j < N; ++nonlocal_j)
+	  ;
+      }
+  }
+
+  local ();
+  nonlocal ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/goacc/nested-function-2.c gcc-6-20160721/gcc/testsuite/gcc.dg/goacc/nested-function-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/goacc/nested-function-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/goacc/nested-function-2.c	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,45 @@
+/* Exercise nested function decomposition, gcc/tree-nested.c.  */
+
+int
+main (void)
+{
+  int j = 0, k = 6, l = 7, m = 8;
+  void simple (void)
+  {
+    int i;
+#pragma acc parallel
+    {
+#pragma acc loop
+      for (i = 0; i < m; i+= k)
+	j = (m + i - j) * l;
+    }
+  }
+  void collapse (void)
+  {
+    int x, y, z;
+#pragma acc parallel
+    {
+#pragma acc loop collapse (3)
+      for (x = 0; x < k; x++)
+	for (y = -5; y < l; y++)
+	  for (z = 0; z < m; z++)
+	    j += x + y + z;
+    }
+  }
+  void reduction (void)
+  {
+    int x, y, z;
+#pragma acc parallel reduction (+:j)
+    {
+#pragma acc loop reduction (+:j) collapse (3)
+      for (x = 0; x < k; x++)
+	for (y = -5; y < l; y++)
+	  for (z = 0; z < m; z++)
+	    j += x + y + z;
+    }
+  }
+  simple();
+  collapse();
+  reduction();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/goacc/pr71373.c gcc-6-20160721/gcc/testsuite/gcc.dg/goacc/pr71373.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/goacc/pr71373.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/goacc/pr71373.c	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,41 @@
+/* Unintentional nested function usage.  */
+/* Due to missing right braces '}', the following functions are parsed as
+   nested functions.  This ran into an ICE.  */
+
+void foo (void)
+{
+  #pragma acc parallel
+  {
+    #pragma acc loop independent
+    for (int i = 0; i < 16; i++)
+      ;
+  // Note right brace '}' commented out here.
+  //}
+}
+void bar (void)
+{
+}
+
+// Adding right brace '}' here, to make this compile.
+}
+
+
+// ..., and the other way round:
+
+void BAR (void)
+{
+// Note right brace '}' commented out here.
+//}
+
+void FOO (void)
+{
+  #pragma acc parallel
+  {
+    #pragma acc loop independent
+    for (int i = 0; i < 16; i++)
+      ;
+  }
+}
+
+// Adding right brace '}' here, to make this compile.
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/graphite/pr69067.c gcc-6-20160721/gcc/testsuite/gcc.dg/graphite/pr69067.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/graphite/pr69067.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/graphite/pr69067.c	2016-05-30 15:54:06.000000000 +0000
@@ -0,0 +1,28 @@
+/* { dg-do link } */
+/* { dg-options " -O1 -floop-nest-optimize" } */
+/* { dg-additional-options "-flto" { target lto } } */
+
+int a1, c1, cr, kt;
+int aa[2];
+
+int
+ce (void)
+{
+  while (a1 < 1)
+    {
+      int g8;
+      for (g8 = 0; g8 < 3; ++g8)
+	if (c1 != 0)
+	  cr = aa[a1 * 2] = kt;
+      for (c1 = 0; c1 < 2; ++c1)
+	aa[c1] = cr;
+      ++a1;
+    }
+  return 0;
+}
+
+int
+main (void)
+{
+  return ce ();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/graphite/pr69068.c gcc-6-20160721/gcc/testsuite/gcc.dg/graphite/pr69068.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/graphite/pr69068.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/graphite/pr69068.c	2016-05-31 07:27:23.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fgraphite-identity" } */
+
+int qo;
+int zh[2];
+
+void
+td (void)
+{
+  int ly, en;
+  for (ly = 0; ly < 2; ++ly)
+    for (en = 0; en < 2; ++en)
+      zh[en] = ((qo == 0) || (((qo * 2) != 0))) ? 1 : -1;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/graphite/pr70956.c gcc-6-20160721/gcc/testsuite/gcc.dg/graphite/pr70956.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/graphite/pr70956.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/graphite/pr70956.c	2016-05-07 07:02:36.000000000 +0000
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fgraphite-identity" } */
+
+#include "../tree-ssa/vrp66.c"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/guality/param-5.c gcc-6-20160721/gcc/testsuite/gcc.dg/guality/param-5.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/guality/param-5.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/guality/param-5.c	2016-06-22 14:36:16.000000000 +0000
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+/* { dg-options "-g" } */
+/* { dg-skip-if "" { *-*-* }  { "*" } { "-O0" } } */
+
+typedef __UINTPTR_TYPE__ uintptr_t;
+
+typedef struct { uintptr_t pa; uintptr_t pb; } fatp_t
+  __attribute__ ((aligned (2 * __alignof__ (uintptr_t))));
+
+__attribute__((noinline, noclone)) void
+clear_stack (void)
+{
+  char a[128 * 1024 + 128];
+
+  __builtin_memset (a + 128 * 1024, 0, 128);
+}
+
+__attribute__((noinline, noclone)) void
+foo (fatp_t str, int count)
+{
+  char a[128 * 1024];
+
+  if (count > 0)
+    foo (str, count - 1);
+  clear_stack ();
+  count--;  /* BREAK */
+}
+
+int
+main (void)
+{
+  fatp_t ptr = { 31415927, 27182818 };
+  foo (ptr, 1);
+  return 0;
+}
+
+/* { dg-final { gdb-test 26 "str.pa" "31415927" } } */
+/* { dg-final { gdb-test 26 "str.pb" "27182818" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/ipa/pr70646.c gcc-6-20160721/gcc/testsuite/gcc.dg/ipa/pr70646.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/ipa/pr70646.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/ipa/pr70646.c	2016-05-19 14:56:35.000000000 +0000
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#pragma GCC optimize("no-unit-at-a-time")
+
+typedef unsigned char u8;
+typedef unsigned long long u64;
+
+static inline __attribute__((always_inline)) u64 __swab64p(const u64 *p)
+{
+ return (__builtin_constant_p((u64)(*p)) ? ((u64)( (((u64)(*p) & (u64)0x00000000000000ffULL) << 56) | (((u64)(*p) & (u64)0x000000000000ff00ULL) << 40) | (((u64)(*p) & (u64)0x0000000000ff0000ULL) << 24) | (((u64)(*p) & (u64)0x00000000ff000000ULL) << 8) | (((u64)(*p) & (u64)0x000000ff00000000ULL) >> 8) | (((u64)(*p) & (u64)0x0000ff0000000000ULL) >> 24) | (((u64)(*p) & (u64)0x00ff000000000000ULL) >> 40) | (((u64)(*p) & (u64)0xff00000000000000ULL) >> 56))) : __builtin_bswap64(*p));
+}
+
+static inline u64 wwn_to_u64(void *wwn)
+{
+ return __swab64p(wwn);
+}
+
+void __attribute__((noinline,noclone)) broken(u64* shost)
+{
+ u8 node_name[8] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+ *shost = wwn_to_u64(node_name);
+}
+
+void __attribute__((noinline,noclone)) dummy(void)
+{
+ __builtin_abort();
+}
+
+int main(int argc, char* argv[])
+{
+ u64 v;
+
+ broken(&v);
+
+ if(v != (u64)-1)
+  __builtin_abort();
+
+ return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71006.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71006.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71006.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71006.c	2016-05-12 14:07:13.000000000 +0000
@@ -0,0 +1,16 @@
+/* PR target/71006 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftree-vectorize" } */
+
+unsigned char uu, gu, e2;
+
+void
+fs (void)
+{
+  char *nq = (char *)&gu, *k4 = (char *)&gu;
+  while (*k4 < 1)
+    {
+      uu += (*nq != 0 || e2 != 0);
+      ++*k4;
+    }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71071.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71071.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71071.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71071.c	2016-05-30 14:00:18.000000000 +0000
@@ -0,0 +1,12 @@
+/* PR bootstrap/71071 */
+/* { dg-do compile } *
+/* { dg-options "-O2" } */
+
+struct S { unsigned b : 1; } a;
+
+void
+foo ()
+{
+  if (a.b)
+    ;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71279.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71279.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71279.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71279.c	2016-05-27 10:43:34.000000000 +0000
@@ -0,0 +1,14 @@
+/* PR middle-end/71279 */
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+/* { dg-additional-options "-march=knl" { target { i?86-*-* x86_64-*-* } } } */
+
+extern int a, b;
+long c[1][1][1];
+long d[1][1];
+
+void fn1 ()
+{
+  for (int e = 0; e < b; e = e + 1)
+    *(e + **c) = (a && *d[1]) - 1;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71518.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71518.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71518.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71518.c	2016-07-11 15:21:20.000000000 +0000
@@ -0,0 +1,25 @@
+/* PR tree-optimization/71518 */
+/* { dg-options "-O3" } */
+
+int a, *b[9], c, d, e; 
+
+static int
+fn1 ()
+{
+  for (c = 6; c >= 0; c--)
+    for (d = 0; d < 2; d++)
+      {
+        b[d * 2 + c] = 0;
+        e = a > 1 ? : 0;
+        if (e == 2) 
+          return 0;
+      }
+  return 0;
+}
+
+int
+main ()
+{
+  fn1 ();
+  return 0; 
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71558.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71558.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71558.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71558.c	2016-06-21 07:15:36.000000000 +0000
@@ -0,0 +1,17 @@
+/* PR tree-optimization/71588 */
+
+/* strcpy must not be pure, but make sure we don't ICE even when
+   it is declared incorrectly.  */
+char *strcpy (char *, const char *) __attribute__ ((__pure__));
+__SIZE_TYPE__ strlen (const char *);
+void *malloc (__SIZE_TYPE__);
+
+char a[20];
+
+char *
+foo (void)
+{
+  __SIZE_TYPE__ b = strlen (a);
+  char *c = malloc (b);
+  return strcpy (c, a);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71581.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71581.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71581.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71581.c	2016-06-21 07:13:52.000000000 +0000
@@ -0,0 +1,24 @@
+/* PR middle-end/71581 */
+/* { dg-do compile } */
+/* { dg-options "-Wuninitialized" } */
+
+_Complex float
+f1 (void)
+{
+  float x;
+  return x;	/* { dg-warning "is used uninitialized in this function" } */
+}
+
+_Complex double
+f2 (void)
+{
+  double x;
+  return x;	/* { dg-warning "is used uninitialized in this function" } */
+}
+
+_Complex int
+f3 (void)
+{
+  int x;
+  return x;	/* { dg-warning "is used uninitialized in this function" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/pr71685.c gcc-6-20160721/gcc/testsuite/gcc.dg/pr71685.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/pr71685.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/pr71685.c	2016-07-02 10:22:11.000000000 +0000
@@ -0,0 +1,6 @@
+/* PR c/71685 */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu11" } */
+
+extern struct S v, s;
+struct S { int t; int p[]; } v = { 4, 0 };
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/spellcheck-options-12.c gcc-6-20160721/gcc/testsuite/gcc.dg/spellcheck-options-12.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/spellcheck-options-12.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/spellcheck-options-12.c	2016-06-30 14:39:10.000000000 +0000
@@ -0,0 +1,7 @@
+/* Verify that we don't include -Wno- variants for options marked
+   with RejectNegative when considering hints for misspelled options
+   (PR driver/71651).  */
+
+/* { dg-do compile } */
+/* { dg-options "-fno-stack-protector-explicit" } */
+/* { dg-error "unrecognized command line option .-fno-stack-protector-explicit.; did you mean .-fstack-protector-explicit.." "" { target *-*-* } 0 } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c	2013-11-14 14:29:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,7 +1,10 @@
 /* Test for "invalid" exceptions from __float128 comparisons.  */
-/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */
+/* { dg-do run } */
 /* { dg-options "" } */
+/* { dg-require-effective-target __float128 } */
+/* { dg-require-effective-target base_quadfloat_support } */
 /* { dg-require-effective-target fenv_exceptions } */
+/* { dg-add-options __float128 } */
 
 #include <fenv.h>
 #include <stdlib.h>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/float128-div-underflow.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/float128-div-underflow.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/float128-div-underflow.c	2013-11-14 14:29:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/float128-div-underflow.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,7 +1,10 @@
 /* Test for spurious underflow from __float128 division.  */
-/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */
+/* { dg-do run } */
 /* { dg-options "" } */
+/* { dg-require-effective-target __float128 } */
+/* { dg-require-effective-target base_quadfloat_support } */
 /* { dg-require-effective-target fenv_exceptions } */
+/* { dg-add-options __float128 } */
 
 #include <fenv.h>
 #include <stdlib.h>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/float128-extend-nan.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/float128-extend-nan.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/float128-extend-nan.c	2013-11-14 14:29:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/float128-extend-nan.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,7 +1,10 @@
 /* Test extensions to __float128 quiet signaling NaNs.  */
-/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */
+/* { dg-do run } */
 /* { dg-options "-fsignaling-nans" } */
+/* { dg-require-effective-target __float128 } */
+/* { dg-require-effective-target base_quadfloat_support } */
 /* { dg-require-effective-target fenv_exceptions } */
+/* { dg-add-options __float128 } */
 
 #include <fenv.h>
 #include <float.h>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-2.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-2.c	2013-06-21 19:08:01.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-2.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,9 +1,12 @@
 /* Test floating-point conversions.  __float128 type with TImode: bug
    53317.  */
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
-/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */
+/* { dg-do run } */
+/* { dg-require-effective-target __float128 } */
+/* { dg-require-effective-target base_quadfloat_support } */
 /* { dg-require-effective-target int128 } */
 /* { dg-options "" } */
+/* { dg-add-options __float128 } */
 
 extern void abort (void);
 extern void exit (int);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c	2013-11-06 22:46:39.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,8 +1,11 @@
 /* Test for correct rounding of conversions from __int128 to
    __float128.  */
-/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */
+/* { dg-do run } */
+/* { dg-require-effective-target __float128 } */
+/* { dg-require-effective-target base_quadfloat_support } */
 /* { dg-require-effective-target int128 } */
 /* { dg-options "-frounding-math" } */
+/* { dg-add-options __float128 } */
 
 #include <fenv.h>
 #include <stdlib.h>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c	2009-02-12 17:33:18.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c	2016-07-05 17:54:02.000000000 +0000
@@ -1,7 +1,10 @@
 /* Test floating-point conversions.  __float128 type with TImode.  */
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
-/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */
+/* { dg-do run } */
+/* { dg-require-effective-target __float128 } */
+/* { dg-require-effective-target base_quadfloat_support } */
 /* { dg-options "" } */
+/* { dg-add-options __float128 } */
 
 #include "fp-int-convert.h"
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr70935.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr70935.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr70935.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr70935.c	2016-05-10 14:26:37.000000000 +0000
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -g" } */
+
+int d0, sj, v0, rp, zi;
+
+void
+zn(void)
+{
+  if (v0 != 0)
+    {
+      int *js, *r3;
+      int pm, gc;
+
+      for (gc = 0; gc < 1; ++gc)
+        {
+          sj = 1;
+          while (sj != 0)
+            ;
+        }
+      r3 = &pm;
+      *js = (long)&gc;
+ka:
+      for (d0 = 0; d0 < 2; ++d0)
+        {
+          d0 = zi;
+          if (zi)
+            for (pm = 2; pm != 0; --pm)
+              ;
+        }
+      while (*r3 != 0)
+        {
+          while (pm)
+            ;
+          ++r3;
+        }
+    }
+  rp = 0;
+  goto ka;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr70941.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr70941.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr70941.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr70941.c	2016-05-13 13:22:42.000000000 +0000
@@ -0,0 +1,12 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+signed char a = 0, b = 0, c = 0, d = 0;
+
+int main()
+{
+  a = -(b - 405418259) - ((d && c) ^ 2040097152);
+  if (a != (signed char) -1634678893)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71423.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71423.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71423.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71423.c	2016-07-07 07:30:04.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+struct S1
+{
+  int f1:1;
+};
+
+volatile struct S1 b = { 0 };
+
+int
+main ()
+{
+  char c = b.f1;
+  b.f1 = 1; 
+
+  if (b.f1 > -1 || c)
+    __builtin_abort (); 
+
+  return 0; 
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71452.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71452.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71452.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71452.c	2016-07-07 07:30:04.000000000 +0000
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+
+int main()
+{
+  _Bool b;
+  *(char *)&b = 123;
+  if (*(char *)&b != 123)
+    __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71522.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71522.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71522.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71522.c	2016-07-07 07:30:04.000000000 +0000
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+#if __SIZEOF_LONG_DOUBLE__ == 16
+#define STR "AAAAAAAAAAAAAAA"
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+#define STR "AAAAAAAAAAA"
+#elif __SIZEOF_LONG_DOUBLE__ == 8
+#define STR "AAAAAAA"
+#elif __SIZEOF_LONG_DOUBLE__ == 4
+#define STR "AAA"
+#else
+#define STR "A"
+#endif
+
+int main()
+{
+  long double d;
+  char s[sizeof d];
+
+  __builtin_memcpy(&d, STR, sizeof d);
+  __builtin_memcpy(&s, &d, sizeof s);
+
+  if (__builtin_strncmp (s, STR, sizeof s) != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71606.c gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71606.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/torture/pr71606.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/torture/pr71606.c	2016-07-08 20:20:23.000000000 +0000
@@ -0,0 +1,11 @@
+_Complex a;
+void fn1 ();
+
+int main () {
+  fn1 (a);
+  return 0;
+}
+
+void fn1 (__complex__ long double p1) {
+  __imag__ p1 = 6.0L;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/tree-ssa/pr70919.c gcc-6-20160721/gcc/testsuite/gcc.dg/tree-ssa/pr70919.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/tree-ssa/pr70919.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/tree-ssa/pr70919.c	2016-05-23 11:27:14.000000000 +0000
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O" } */
+
+#pragma pack(1)
+struct S0
+{
+  int f0:24;
+};
+
+struct S1
+{
+  int f1;
+} a;
+
+int b, c;
+
+char
+fn1 (struct S1 p1)
+{
+  return 0;
+}
+
+int
+main ()
+{
+  c = fn1 (a);
+  if (b)
+    {
+      struct S0 f[3][9] =
+	{ { { 0 }, { 0 }, { 1 }, { 1 }, { 0 }, { 0 }, { 0 }, { 1 }, { 1 } },
+	  { { 0 }, { 0 }, { 1 }, { 1 }, { 0 }, { 0 }, { 0 }, { 1 }, { 1 } },
+	  { { 0 }, { 0 }, { 1 }, { 1 }, { 0 }, { 0 }, { 0 }, { 1 }, { 1 } }
+	};
+      b = f[1][8].f0;
+    }
+  struct S0 g[3][9] =
+	{ { { 0 }, { 0 }, { 1 }, { 1 }, { 0 }, { 0 }, { 0 }, { 1 }, { 1 } },
+	  { { 0 }, { 0 }, { 1 }, { 1 }, { 0 }, { 0 }, { 0 }, { 1 }, { 1 } },
+	  { { 0 }, { 0 }, { 1 }, { 1 }, { 0 }, { 0 }, { 0 }, { 1 }, { 1 } }
+	};
+
+  if (g[1][8].f0 != 1)
+    __builtin_abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/tree-ssa/vrp100.c gcc-6-20160721/gcc/testsuite/gcc.dg/tree-ssa/vrp100.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/tree-ssa/vrp100.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/tree-ssa/vrp100.c	2016-05-19 18:42:31.000000000 +0000
@@ -0,0 +1,32 @@
+/* PR tree-optimization/71031 */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+
+int zj;
+int **yr;
+
+void
+nn (void)
+{
+  unsigned int od = 4;
+
+  for (;;)
+    {
+      int lk;
+
+      for (lk = 0; lk < 2; ++lk)
+        {
+          static int cm;
+
+          zj = 0;
+          if (od == 0)
+            return;
+          ++od;
+          for (cm = 0; cm < 2; ++cm)
+            {
+              --od;
+              **yr = 0;
+            }
+        }
+    }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/tree-ssa/vrp101.c gcc-6-20160721/gcc/testsuite/gcc.dg/tree-ssa/vrp101.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/tree-ssa/vrp101.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/tree-ssa/vrp101.c	2016-07-07 07:30:04.000000000 +0000
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+int x = 1;
+
+int main ()
+{
+  int t = (1/(1>=x))>>1;
+  if (t != 0) __builtin_abort();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "<bb 2>:\[\n\r \]*return 0;" "optimized" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/ubsan/bounds-3.c gcc-6-20160721/gcc/testsuite/gcc.dg/ubsan/bounds-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/ubsan/bounds-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/ubsan/bounds-3.c	2016-05-06 10:54:12.000000000 +0000
@@ -0,0 +1,22 @@
+/* PR sanitizer/70875 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=bounds" } */
+
+int
+foo (int n, int k)
+{
+  struct S
+  {
+    int i[n];
+    int value;
+  } s[2];
+  return s[k].value = 0;
+}
+
+int
+main ()
+{
+  return foo (2, 2);
+}
+
+/* { dg-output "index 2 out of bounds for type 'S \\\[2\\\]'" } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr66636.c gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr66636.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr66636.c	2015-06-23 13:56:34.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr66636.c	2016-05-14 09:25:41.000000000 +0000
@@ -6,7 +6,8 @@
 
 struct X { double x; double y; };
 
-void foo (struct X *x, double px, int s)
+void __attribute__((noinline,noclone))
+foo (struct X *x, double px, int s)
 {
   int i;
   for (i = 0; i < 256; ++i)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr71259.c gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr71259.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr71259.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr71259.c	2016-06-06 18:47:33.000000000 +0000
@@ -0,0 +1,28 @@
+/* PR tree-optimization/71259 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+
+#include "tree-vect.h"
+
+long a, b[1][44][2];
+long long c[44][17][2];
+
+int
+main ()
+{
+  int i, j, k;
+  check_vect ();
+  asm volatile ("" : : : "memory");
+  for (i = 0; i < 44; i++)
+    for (j = 0; j < 17; j++)
+      for (k = 0; k < 2; k++)
+	c[i][j][k] = (30995740 >= *(k + *(j + *b)) != (a != 8)) - 5105075050047261684;
+  asm volatile ("" : : : "memory");
+  for (i = 0; i < 44; i++) 
+    for (j = 0; j < 17; j++)
+      for (k = 0; k < 2; k++)
+	if (c[i][j][k] != -5105075050047261684)
+	  __builtin_abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr71264.c gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr71264.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr71264.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr71264.c	2016-07-07 07:30:04.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
+
+typedef unsigned char uint8_t;
+typedef uint8_t footype __attribute__((vector_size(4)));
+
+void test(uint8_t *ptr, uint8_t *mask)
+{
+  footype mv;
+  __builtin_memcpy(&mv, mask, sizeof(mv));
+  for (unsigned i = 0; i < 16; i += 4)
+    {
+      footype temp;
+      __builtin_memcpy(&temp, &ptr[i], sizeof(temp));
+      temp ^= mv;
+      __builtin_memcpy(&ptr[i], &temp, sizeof(temp));
+    }
+}
+
+/* { dg-final { scan-tree-dump "vectorized 1 loops in function" "vect" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr71823.c gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr71823.c
--- gcc-6.1.0/gcc/testsuite/gcc.dg/vect/pr71823.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/vect/pr71823.c	2016-07-11 20:39:44.000000000 +0000
@@ -0,0 +1,14 @@
+/* PR tree-optimization/71823 */
+/* { dg-do compile } */
+/* { dg-additional-options "-mfma" { target i?86-*-* x86_64-*-* } } */
+
+float a[4], b[4];
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 4; ++i)
+    b[i] = __builtin_fma (1024.0f, 1024.0f, a[i]);
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.dg/vect/tree-vect.h gcc-6-20160721/gcc/testsuite/gcc.dg/vect/tree-vect.h
--- gcc-6.1.0/gcc/testsuite/gcc.dg/vect/tree-vect.h	2015-07-08 20:29:26.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.dg/vect/tree-vect.h	2016-05-14 09:25:41.000000000 +0000
@@ -32,25 +32,26 @@
   asm volatile (".long 0x10000484");
 #elif defined(__i386__) || defined(__x86_64__)
   {
-    unsigned int a, b, c, d, want_level, want_c, want_d;
+    unsigned int a, b, c, d,
+      want_level, want_b = 0, want_c = 0, want_d = 0;
 
     /* Determine what instruction set we've been compiled for, and detect
        that we're running with it.  This allows us to at least do a compile
        check for, e.g. SSE4.1 when the machine only supports SSE2.  */
-# ifdef __XOP__
-    want_level = 0x80000001, want_c = bit_XOP, want_d = 0;
+# if defined(__AVX2__)
+    want_level = 7, want_b = bit_AVX2;
 # elif defined(__AVX__)
-    want_level = 1, want_c = bit_AVX, want_d = 0;
+    want_level = 1, want_c = bit_AVX;
 # elif defined(__SSE4_1__)
-    want_level = 1, want_c = bit_SSE4_1, want_d = 0;
+    want_level = 1, want_c = bit_SSE4_1;
 # elif defined(__SSSE3__)
-    want_level = 1, want_c = bit_SSSE3, want_d = 0;
+    want_level = 1, want_c = bit_SSSE3;
 # else
-    want_level = 1, want_c = 0, want_d = bit_SSE2;
+    want_level = 1, want_d = bit_SSE2;
 # endif
 
     if (!__get_cpuid (want_level, &a, &b, &c, &d)
-	|| ((c & want_c) | (d & want_d)) == 0)
+	|| ((b & want_b) | (c & want_c) | (d & want_d)) == 0)
       exit (0);
   }
 #elif defined(__sparc__)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/noplt_3.c gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/noplt_3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/noplt_3.c	2015-08-07 13:26:23.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/noplt_3.c	2016-05-18 12:38:15.000000000 +0000
@@ -16,5 +16,5 @@
   dec (a);
 }
 
-/* { dg-final { scan-assembler-times "br" 2 } } */
+/* { dg-final { scan-assembler-times "br\t" 2 } } */
 /* { dg-final { scan-assembler-not "b\t" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/pr70809_1.c gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/pr70809_1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/pr70809_1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/pr70809_1.c	2016-05-17 13:08:01.000000000 +0000
@@ -0,0 +1,18 @@
+/* PR target/70809.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize -ffp-contract=off -mtune=xgene1" } */
+
+/* Check that vector FMLS is not generated when contraction is disabled.  */
+
+void
+foo (float *__restrict__ __attribute__ ((aligned (16))) a,
+     float *__restrict__ __attribute__ ((aligned (16))) x,
+     float *__restrict__ __attribute__ ((aligned (16))) y,
+     float *__restrict__ __attribute__ ((aligned (16))) z)
+{
+  unsigned i = 0;
+  for (i = 0; i < 256; i++)
+    a[i] = x[i] - (y[i] * z[i]);
+}
+
+/* { dg-final { scan-assembler-not "fmls\tv.*" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/simd/vminmaxnm_1.c gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/simd/vminmaxnm_1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/simd/vminmaxnm_1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/simd/vminmaxnm_1.c	2016-07-08 15:41:31.000000000 +0000
@@ -0,0 +1,82 @@
+/* Test the `v[min|max]nm{q}_f*' AArch64 SIMD intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include "arm_neon.h"
+
+extern void abort ();
+
+#define CHECK(T, N, R, E) \
+  {\
+    int i = 0;\
+    for (; i < N; i++)\
+      if (* (T *) &R[i] != * (T *) &E[i])\
+	abort ();\
+  }
+
+int
+main (int argc, char **argv)
+{
+  float32x2_t f32x2_input1 = vdup_n_f32 (-1.0);
+  float32x2_t f32x2_input2 = vdup_n_f32 (0.0);
+  float32x2_t f32x2_exp_minnm  = vdup_n_f32 (-1.0);
+  float32x2_t f32x2_exp_maxnm  = vdup_n_f32 (0.0);
+  float32x2_t f32x2_ret_minnm  = vminnm_f32 (f32x2_input1, f32x2_input2);
+  float32x2_t f32x2_ret_maxnm  = vmaxnm_f32 (f32x2_input1, f32x2_input2);
+
+  CHECK (uint32_t, 2, f32x2_ret_minnm, f32x2_exp_minnm);
+  CHECK (uint32_t, 2, f32x2_ret_maxnm, f32x2_exp_maxnm);
+
+  f32x2_input1 = vdup_n_f32 (__builtin_nanf (""));
+  f32x2_input2 = vdup_n_f32 (1.0);
+  f32x2_exp_minnm  = vdup_n_f32 (1.0);
+  f32x2_exp_maxnm  = vdup_n_f32 (1.0);
+  f32x2_ret_minnm  = vminnm_f32 (f32x2_input1, f32x2_input2);
+  f32x2_ret_maxnm  = vmaxnm_f32 (f32x2_input1, f32x2_input2);
+
+  CHECK (uint32_t, 2, f32x2_ret_minnm, f32x2_exp_minnm);
+  CHECK (uint32_t, 2, f32x2_ret_maxnm, f32x2_exp_maxnm);
+
+  float32x4_t f32x4_input1 = vdupq_n_f32 (-1024.0);
+  float32x4_t f32x4_input2 = vdupq_n_f32 (77.0);
+  float32x4_t f32x4_exp_minnm  = vdupq_n_f32 (-1024.0);
+  float32x4_t f32x4_exp_maxnm  = vdupq_n_f32 (77.0);
+  float32x4_t f32x4_ret_minnm  = vminnmq_f32 (f32x4_input1, f32x4_input2);
+  float32x4_t f32x4_ret_maxnm  = vmaxnmq_f32 (f32x4_input1, f32x4_input2);
+
+  CHECK (uint32_t, 4, f32x4_ret_minnm, f32x4_exp_minnm);
+  CHECK (uint32_t, 4, f32x4_ret_maxnm, f32x4_exp_maxnm);
+
+  f32x4_input1 = vdupq_n_f32 (-__builtin_nanf (""));
+  f32x4_input2 = vdupq_n_f32 (-1.0);
+  f32x4_exp_minnm  = vdupq_n_f32 (-1.0);
+  f32x4_exp_maxnm  = vdupq_n_f32 (-1.0);
+  f32x4_ret_minnm  = vminnmq_f32 (f32x4_input1, f32x4_input2);
+  f32x4_ret_maxnm  = vmaxnmq_f32 (f32x4_input1, f32x4_input2);
+
+  CHECK (uint32_t, 4, f32x4_ret_minnm, f32x4_exp_minnm);
+  CHECK (uint32_t, 4, f32x4_ret_maxnm, f32x4_exp_maxnm);
+
+  float64x2_t f64x2_input1 = vdupq_n_f64 (1.23);
+  float64x2_t f64x2_input2 = vdupq_n_f64 (4.56);
+  float64x2_t f64x2_exp_minnm  = vdupq_n_f64 (1.23);
+  float64x2_t f64x2_exp_maxnm  = vdupq_n_f64 (4.56);
+  float64x2_t f64x2_ret_minnm  = vminnmq_f64 (f64x2_input1, f64x2_input2);
+  float64x2_t f64x2_ret_maxnm  = vmaxnmq_f64 (f64x2_input1, f64x2_input2);
+
+  CHECK (uint64_t, 2, f64x2_ret_minnm, f64x2_exp_minnm);
+  CHECK (uint64_t, 2, f64x2_ret_maxnm, f64x2_exp_maxnm);
+
+  f64x2_input1 = vdupq_n_f64 (-__builtin_nan (""));
+  f64x2_input2 = vdupq_n_f64 (1.0);
+  f64x2_exp_minnm  = vdupq_n_f64 (1.0);
+  f64x2_exp_maxnm  = vdupq_n_f64 (1.0);
+  f64x2_ret_minnm  = vminnmq_f64 (f64x2_input1, f64x2_input2);
+  f64x2_ret_maxnm  = vmaxnmq_f64 (f64x2_input1, f64x2_input2);
+
+  CHECK (uint64_t, 2, f64x2_ret_minnm, f64x2_exp_minnm);
+  CHECK (uint64_t, 2, f64x2_ret_maxnm, f64x2_exp_maxnm);
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/tail_indirect_call_1.c gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/tail_indirect_call_1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/aarch64/tail_indirect_call_1.c	2014-05-23 12:13:56.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/aarch64/tail_indirect_call_1.c	2016-05-18 12:38:15.000000000 +0000
@@ -3,8 +3,8 @@
 
 typedef void FP (int);
 
-/* { dg-final { scan-assembler "br" } } */
-/* { dg-final { scan-assembler-not "blr" } } */
+/* { dg-final { scan-assembler-times "br\t" 2 } } */
+/* { dg-final { scan-assembler-not "blr\t" } } */
 void
 f1 (FP fp, int n)
 {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/arm/interrupt-1.c gcc-6-20160721/gcc/testsuite/gcc.target/arm/interrupt-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/arm/interrupt-1.c	2015-11-06 18:43:15.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/arm/interrupt-1.c	2016-05-12 12:47:03.000000000 +0000
@@ -1,8 +1,8 @@
 /* Verify that prologue and epilogue are correct for functions with
    __attribute__ ((interrupt)).  */
-/* { dg-do compile } */
+/* { dg-do assemble } */
 /* { dg-require-effective-target arm_nothumb } */
-/* { dg-options "-O0 -marm" } */
+/* { dg-options "-O0 -marm -save-temps" } */
 
 /* This test is not valid when -mthumb.  */
 extern void bar (int);
@@ -14,4 +14,4 @@
 }
 
 /* { dg-final { scan-assembler "push\t{r0, r1, r2, r3, r4, fp, ip, lr}" } } */
-/* { dg-final { scan-assembler "pop\t{r0, r1, r2, r3, r4, fp, ip, pc}\\^" } } */
+/* { dg-final { scan-assembler "ldmfd\tsp!, {r0, r1, r2, r3, r4, fp, ip, pc}\\^" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/arm/interrupt-2.c gcc-6-20160721/gcc/testsuite/gcc.target/arm/interrupt-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/arm/interrupt-2.c	2015-11-06 18:43:15.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/arm/interrupt-2.c	2016-05-12 12:47:03.000000000 +0000
@@ -1,8 +1,8 @@
 /* Verify that prologue and epilogue are correct for functions with
    __attribute__ ((interrupt)).  */
-/* { dg-do compile } */
+/* { dg-do assemble } */
 /* { dg-require-effective-target arm_nothumb } */
-/* { dg-options "-O1 -marm" } */
+/* { dg-options "-O1 -marm -save-temps" } */
 
 /* This test is not valid when -mthumb.  */
 extern void bar (int);
@@ -16,4 +16,4 @@
 }
 
 /* { dg-final { scan-assembler "push\t{r0, r1, r2, r3, r4, r5, ip, lr}" } } */
-/* { dg-final { scan-assembler "pop\t{r0, r1, r2, r3, r4, r5, ip, pc}\\^" } } */
+/* { dg-final { scan-assembler "ldmfd\tsp!, {r0, r1, r2, r3, r4, r5, ip, pc}\\^" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/arm/pr70830.c gcc-6-20160721/gcc/testsuite/gcc.target/arm/pr70830.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/arm/pr70830.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/arm/pr70830.c	2016-05-12 12:47:03.000000000 +0000
@@ -0,0 +1,14 @@
+/* PR target/70830.  */
+/* { dg-do assemble } */
+/* { dg-require-effective-target arm_arm_ok } */
+/* { dg-options "-Os -marm -save-temps" } */
+
+/* This test is not valid when -mthumb.  */
+
+extern void prints (char *);
+
+void __attribute__ ((interrupt ("IRQ"))) dm3730_IRQHandler(void)
+{
+    prints("IRQ" );
+}
+/* { dg-final { scan-assembler "ldmfd\tsp!, {r0, r1, r2, r3, ip, pc}\\^" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/arm/pr71056.c gcc-6-20160721/gcc/testsuite/gcc.target/arm/pr71056.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/arm/pr71056.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/arm/pr71056.c	2016-05-31 08:29:39.000000000 +0000
@@ -0,0 +1,32 @@
+/* PR target/71056.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp3_ok } */
+/* { dg-options "-O3 -mfpu=vfpv3" } */
+
+/* Check that compiling for a non-NEON target doesn't try to introduce
+   a NEON vectorized builtin.  */
+
+extern char *buff;
+int f2 ();
+struct T1
+{
+  int reserved[2];
+  unsigned int ip;
+  unsigned short cs;
+  unsigned short rsrv2;
+};
+void
+f3 (const char *p)
+{
+  struct T1 x;
+  __builtin_memcpy (&x, p, sizeof (struct T1));
+  x.reserved[0] = __builtin_bswap32 (x.reserved[0]);
+  x.reserved[1] = __builtin_bswap32 (x.reserved[1]);
+  x.ip = __builtin_bswap32 (x.ip);
+  x.cs = x.cs << 8 | x.cs >> 8;
+  x.rsrv2 = x.rsrv2 << 8 | x.rsrv2 >> 8;
+  if (f2 ())
+    {
+      __builtin_memcpy (buff, "\n", 1);
+    }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/avr/pr50739.c gcc-6-20160721/gcc/testsuite/gcc.target/avr/pr50739.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/avr/pr50739.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/avr/pr50739.c	2016-07-06 13:53:36.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-fmerge-all-constants" } */
+
+char *ca = "123";
+
+const char a[] __attribute__((__progmem__))= "a";
+const char b[] __attribute__((__progmem__))= "b";
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/avr/pr71103.c gcc-6-20160721/gcc/testsuite/gcc.target/avr/pr71103.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/avr/pr71103.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/avr/pr71103.c	2016-06-20 11:20:27.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+struct ResponseStruct{                                                                                            
+    unsigned char responseLength;
+    char *response;
+};
+
+static char response[5];
+struct ResponseStruct something(){
+    struct ResponseStruct returnValue;
+    returnValue.responseLength = 5;
+    returnValue.response = response;
+    return returnValue;
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/avr/torture/pr71103-2.c gcc-6-20160721/gcc/testsuite/gcc.target/avr/torture/pr71103-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/avr/torture/pr71103-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/avr/torture/pr71103-2.c	2016-06-20 11:20:27.000000000 +0000
@@ -0,0 +1,118 @@
+/* Use -g0 so that this test case doesn't just fail because
+   of PR52472.  */
+
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99 -g0" } */
+
+struct S12
+{
+  char c;
+  const char *p;
+};
+
+struct S12f
+{
+  char c;
+  struct S12f (*f)(void);
+};
+
+struct S12labl
+{
+  char c;
+  void **labl;
+};
+
+struct S121
+{
+  char c;
+  const char *p;
+  char d;
+};
+
+const char str[5] = "abcd";
+
+struct S12 test_S12_0 (void)
+{
+  struct S12 s;
+  s.c = 'A';
+  s.p = str;
+  return s;
+}
+
+struct S12 test_S12_4 (void)
+{
+  struct S12 s;
+  s.c = 'A';
+  s.p = str + 4;
+  return s;
+}
+
+struct S12f test_S12f (void)
+{
+  struct S12f s;
+  s.c = 'A';
+  s.f = test_S12f;
+  return s;
+}
+
+struct S121 test_S121 (void)
+{
+  struct S121 s;
+  s.c = 'c';
+  s.p = str + 4;
+  s.d = 'd';
+  return s;
+}
+
+extern void use_S12lab (struct S12labl*);
+
+struct S12labl test_S12lab (void)
+{
+  struct S12labl s;
+labl:;
+  s.c = 'A';
+  s.labl = &&labl;
+  return s;
+}
+
+#ifdef __MEMX
+
+struct S13
+{
+  char c;
+  const __memx char *p;
+};
+
+const __memx char str_x[] = "abcd";
+
+struct S13 test_S13_0 (void)
+{
+  struct S13 s;
+  s.c = 'A';
+  s.p = str_x;
+  return s;
+}
+
+struct S13 test_S13_4a (void)
+{
+  struct S13 s;
+  s.c = 'A';
+  s.p = str_x + 4;
+  return s;
+}
+
+#ifdef __FLASH1
+
+const __flash1 char str_1[] = "abcd";
+
+struct S13 test_13_4b (void)
+{
+  struct S13 s;
+  s.c = 'A';
+  s.p = str_1 + 4;
+  return s;
+}
+
+#endif /* have __flash1 */
+#endif /* have __memx */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx-pr71559.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx-pr71559.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx-pr71559.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx-pr71559.c	2016-07-02 10:18:27.000000000 +0000
@@ -0,0 +1,8 @@
+/* PR target/71559 */
+/* { dg-do run { target avx } } */
+/* { dg-options "-O2 -ftree-vectorize -mavx" } */
+
+#include "avx-check.h"
+#define PR71559_TEST avx_test
+
+#include "sse2-pr71559.c"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (double *src)
+{
+  int i, sign = 1;
+  double f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  double a[NUM];
+  double r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = ceil (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != ceil (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceil-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-ceil-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscalepd\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  int r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = (int) ceilf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != (int) ceilf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-sfix-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-ceilf-sfix-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscaleps\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvttps2dq\[^\n\]+zmm\[0-9\].{7}(?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  float r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = ceilf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != ceilf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-ceilf-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-ceilf-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscaleps\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (double *src)
+{
+  int i, sign = 1;
+  double f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  double a[NUM];
+  double r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = floor (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != floor (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floor-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-floor-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscalepd\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  int r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = (int) floorf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != (int) floorf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-sfix-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-floorf-sfix-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscaleps\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvttps2dq\[^\n\]+zmm\[0-9\].{7}(?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  float r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = floorf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != floorf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-floorf-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-floorf-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscaleps\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-pr71559.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-pr71559.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-pr71559.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-pr71559.c	2016-07-02 10:18:27.000000000 +0000
@@ -0,0 +1,8 @@
+/* PR target/71559 */
+/* { dg-do run { target avx512f } } */
+/* { dg-options "-O2 -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-check.h"
+#define PR71559_TEST avx512f_test
+
+#include "sse2-pr71559.c"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (double *src)
+{
+  int i, sign = 1;
+  double f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  double a[NUM];
+  int r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = (int) rint (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != (int) rint (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rint-sfix-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-rint-sfix-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vcvtpd2dq\[^\n\]+ymm\[0-9\](?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vinserti64x4\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  int r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = (int) rintf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != (int) rintf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-rintf-sfix-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-rintf-sfix-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vcvtps2dq\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (double *src)
+{
+  int i, sign = 1;
+  double f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  double a[NUM];
+  int r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = (int) round (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != (int) round (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-round-sfix-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-round-sfix-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscalepd\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vcvttpd2dq\[^\n\]+zmm\[0-9\].{7}(?:\n|\[ \\t\]+#)" 2 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  int r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = (int) roundf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != (int) roundf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-roundf-sfix-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-roundf-sfix-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscaleps\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvttps2dq\[^\n\]+zmm\[0-9\].{7}(?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (double *src)
+{
+  int i, sign = 1;
+  double f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  double a[NUM];
+  double r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = trunc (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != trunc (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-trunc-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-trunc-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscalepd\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-1.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-skip-if "no M_PI" { vxworks_kernel } } */
+
+#define __NO_MATH_INLINES
+#include <math.h>
+#include "avx512f-check.h"
+
+#define NUM 64
+
+static void
+__attribute__((__target__("fpmath=sse")))
+init_src (float *src)
+{
+  int i, sign = 1;
+  float f = rand ();
+
+  for (i = 0; i < NUM; i++)
+    {
+      src[i] = (i + 1) * f * M_PI * sign;
+      if (i < (NUM / 2))
+	{
+          if ((i % 6) == 0)
+	    f = f * src[i];
+        }
+      else if (i == (NUM / 2))
+	f = rand ();
+      else if ((i % 6) == 0)
+	f = 1 / (f * (i + 1) * src[i] * M_PI * sign);
+      sign = -sign;
+    }
+}
+
+static void
+__attribute__((__target__("fpmath=387")))
+avx512f_test (void)
+{
+  float a[NUM];
+  float r[NUM];
+  int i;
+
+  init_src (a);
+
+  for (i = 0; i < NUM; i++)
+    r[i] = truncf (a[i]);
+
+  /* check results:  */
+  for (i = 0; i < NUM; i++)
+    if (r[i] != truncf (a[i]))
+      abort();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/avx512f-truncf-vec-2.c	2016-06-08 13:06:24.000000000 +0000
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math -ftree-vectorize -mavx512f" } */
+
+#include "avx512f-truncf-vec-1.c"
+
+/* { dg-final { scan-assembler-times "vrndscaleps\[^\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/fabsneg-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/fabsneg-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/fabsneg-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/fabsneg-1.c	2016-05-09 19:03:11.000000000 +0000
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O2 -mtune=nocona" } */
+
+double x;
+
+void
+__attribute__ ((noinline, noclone))
+test_fabs (double a)
+{
+  asm volatile ("" : "+r" (a));
+  x = __builtin_fabs (a);
+}
+
+void
+__attribute__ ((noinline, noclone))
+test_neg (double a)
+{
+  asm volatile ("" : "+r" (a));
+  x = -a;
+}
+
+int main ()
+{
+  test_fabs (-1.0);
+
+  if (x != 1.0)
+    __builtin_abort ();
+
+  test_neg (-1.0);
+
+  if (x != 1.0)
+    __builtin_abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/iamcu/args.h gcc-6-20160721/gcc/testsuite/gcc.target/i386/iamcu/args.h
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/iamcu/args.h	2015-06-30 16:46:45.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/iamcu/args.h	2016-05-30 14:53:28.000000000 +0000
@@ -30,7 +30,7 @@
 /* Clear all scratch integer registers, excluding the one used to return
    aggregate.  */
 #define clear_non_sret_int_hardware_registers \
-  asm __volatile__ ("xor %%edx, %%ebx\n\t" \
+  asm __volatile__ ("xor %%edx, %%edx\n\t" \
 		    "xor %%ecx, %%ecx\n\t" \
 		    ::: "edx", "ecx");
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr68657.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr68657.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr68657.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr68657.c	2016-06-14 14:44:28.000000000 +0000
@@ -0,0 +1,15 @@
+/* PR c/68657 */
+/* { dg-options "-mno-avx512f -Werror=psabi" } */
+
+typedef int V __attribute__((vector_size (64)));
+
+void foo (V x, V *y) {	/* { dg-error "AVX512F vector argument without AVX512F enabled" } */
+  *y = x;
+}
+
+V bar (V *x) {		/* { dg-error "AVX512F vector return without AVX512F enabled" } */
+  return *x;
+}
+
+/* { dg-message "The ABI for passing parameters with 64-byte alignment has changed" "" { target *-*-* } 6 } */
+/* { dg-message "some warnings being treated as errors" "" { target *-*-* } 0 } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70728.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70728.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70728.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70728.c	2016-04-27 12:09:45.000000000 +0000
@@ -0,0 +1,30 @@
+/* PR target/70728 */
+/* { dg-do compile } */
+/* { dg-options "-S -Ofast -march=knl" } */
+
+short a = -15726;
+int b = (int)-7003557328690506537LL;
+short c[5][5][3][6];
+char d[2][5][3][2][4];
+void fn1() {
+  for (int e = 0; e < 3; e = e + 1)
+    for (int f = 0; f < 2; f = f + 1)
+      for (int g = 0; g < 4; g = g + 1)
+        for (int h = 0; h < 3; h = h + 1)
+          for (int i = 0; i < 2; i = i + 1)
+            for (int j = 0; j < 4; j = j + 1)
+              d[f][g][h][i][j] =
+                  7 << (1236110361944357083 >> a + 15728) - 309027590486089270 >>
+                  (c[e][f][h][j] + 2147483647 << ~b - 7003557328690506536) -
+                      2147480981;
+}
+int main() {
+  for (int k = 0; k < 5; ++k)
+    for (int l = 0; l < 5; ++l)
+      for (int m = 0; m < 3; ++m)
+        for (int n = 0; n < 4; ++n)
+          c[k][l][m][n] = -2639;
+  fn1();
+}
+
+/* { dg-final { scan-assembler-not "sll\[ \\t\]+\[^\n\]*%\.mm(?:1\[6-9\]|\[2-3\]\[0-9\])" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70750-1.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70750-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70750-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70750-1.c	2016-04-27 13:35:03.000000000 +0000
@@ -0,0 +1,11 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O2" } */
+
+int
+f (int (**p) (void))
+{
+  return p[1]();
+}
+
+/* { dg-final { scan-assembler "jmp\[ \t\].*\\(%rdi\\)" { target { lp64 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]\\*%rax" { target { x32 } } } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70750-2.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70750-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70750-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70750-2.c	2016-04-27 13:35:03.000000000 +0000
@@ -0,0 +1,11 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O2" } */
+
+int
+f (int (**p) (void))
+{
+  return -p[1]();
+}
+
+/* { dg-final { scan-assembler "call\[ \t\].*\\(%rdi\\)" { target { lp64 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]\\*%rax" { target { x32 } } } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70858.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70858.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70858.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70858.c	2016-04-28 19:45:48.000000000 +0000
@@ -0,0 +1,45 @@
+/* PR target/70858 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlwp -mbmi -mtbm -mbmi2 -std=gnu11" } */
+
+void
+f1 (unsigned long long x, unsigned int y)
+{
+  __builtin_ia32_lwpval64 (x, y, 1);	/* { dg-warning "implicit declaration of function .__builtin_ia32_lwpval64." "" { target ia32 } } */
+}
+
+char
+f2 (unsigned long long x, unsigned int y)
+{
+  return __builtin_ia32_lwpins64 (x, y, 1);	/* { dg-warning "implicit declaration of function .__builtin_ia32_lwpins64." "" { target ia32 } } */
+}
+
+unsigned long long
+f3 (unsigned long long x, unsigned long long y)
+{
+  return __builtin_ia32_bextr_u64 (x, y);	/* { dg-warning "implicit declaration of function .__builtin_ia32_bextr_u64." "" { target ia32 } } */
+}
+
+unsigned long long
+f4 (unsigned long long x)
+{
+  return __builtin_ia32_bextri_u64 (x, 1);	/* { dg-warning "implicit declaration of function .__builtin_ia32_bextri_u64." "" { target ia32 } } */
+}
+
+unsigned long long
+f5 (unsigned long long x, unsigned long long y)
+{
+  return __builtin_ia32_bzhi_di (x, y);	/* { dg-warning "implicit declaration of function .__builtin_ia32_bzhi_di." "" { target ia32 } } */
+}
+
+unsigned long long
+f6 (unsigned long long x, unsigned long long y)
+{
+  return __builtin_ia32_pdep_di (x, y);	/* { dg-warning "implicit declaration of function .__builtin_ia32_pdep_di." "" { target ia32 } } */
+}
+
+unsigned long long
+f7 (unsigned long long x, unsigned long long y)
+{
+  return __builtin_ia32_pext_di (x, y);	/* { dg-warning "implicit declaration of function .__builtin_ia32_pext_di." "" { target ia32 } } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70876.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70876.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70876.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70876.c	2016-05-11 09:51:49.000000000 +0000
@@ -0,0 +1,13 @@
+/* { dg-do compile { target { ! x32 } } } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx -Wno-implicit-function-declaration" } */
+
+void f (char *s1, char *s2)
+{
+  int z = 5;
+
+  struct { char a[z]; } x;
+
+  s1[0] = s2[0];
+
+  foo (x, x);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70877.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70877.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr70877.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr70877.c	2016-05-11 09:55:55.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { ! x32 } } } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx" } */
+
+int foo(int);
+
+typedef struct {
+  double d;
+  int a;
+} str_t;
+
+void bar(double d, int i, str_t s)
+{
+  d = ((double (*) (int)) foo) (i); /* { dg-warning "function called through a non-compatible type" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr71529.C gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr71529.C
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr71529.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr71529.C	2016-06-20 11:35:02.000000000 +0000
@@ -0,0 +1,22 @@
+/* PR71529 */
+/* { dg-do compile { target { ! x32 } } } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx -O2" } */
+
+class c1
+{
+ public:
+  virtual ~c1 ();
+};
+
+class c2
+{
+ public:
+  virtual ~c2 ();
+};
+
+class c3 : c1, c2 { };
+
+int main (int, char **)
+{
+  c3 obj;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr71647.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr71647.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/pr71647.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/pr71647.c	2016-06-24 18:46:47.000000000 +0000
@@ -0,0 +1,32 @@
+/* PR tree-optimization/71647 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fopenmp-simd -mavx -mno-avx512f -fdump-tree-vect-details" } */
+
+void
+foo (double *a, double *b)
+{
+  int i;
+#pragma omp simd aligned(a,b:4*sizeof(double))
+  for (i = 0; i < 32768; i++)
+    a[i] += b[i];
+}
+
+void
+bar (double *a, double *b)
+{
+  int i;
+#pragma omp simd aligned(a,b:32)
+  for (i = 0; i < 32768; i++)
+    a[i] += b[i];
+}
+
+void
+baz (double *a, double *b)
+{
+  int i;
+#pragma omp simd aligned(a,b:32L)
+  for (i = 0; i < 32768; i++)
+    a[i] += b[i];
+}
+
+/* { dg-final { scan-tree-dump-not "Alignment of access forced using peeling" "vect" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/i386/sse2-pr71559.c gcc-6-20160721/gcc/testsuite/gcc.target/i386/sse2-pr71559.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/i386/sse2-pr71559.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/i386/sse2-pr71559.c	2016-07-02 10:18:27.000000000 +0000
@@ -0,0 +1,73 @@
+/* PR target/71559 */
+/* { dg-do run { target sse2 } } */
+/* { dg-options "-O2 -ftree-vectorize -msse2" } */
+
+#ifndef PR71559_TEST
+#include "sse2-check.h"
+#define PR71559_TEST sse2_test
+#endif
+
+#define N 16
+float a[N] = { 5.0f, -3.0f, 1.0f, __builtin_nanf (""), 9.0f, 7.0f, -3.0f, -9.0f,
+               -3.0f, -5.0f, -9.0f, __builtin_nanf (""), 0.5f, -0.5f, 0.0f, 0.0f };
+float b[N] = { -5.0f, 3.0f, 1.0f, 7.0f, 8.0f, 8.0f, -3.0f, __builtin_nanf (""),
+               -4.0f, -4.0f, -9.0f, __builtin_nanf (""), 0.0f, 0.0f, 0.0f, __builtin_nanf ("") };
+int c[N], d[N];
+
+#define FN(name, op) \
+void					\
+name (void)				\
+{					\
+  int i;				\
+  for (i = 0; i < N; i++)		\
+    c[i] = (op || d[i] > 37) ? 5 : 32;	\
+}
+FN (eq, a[i] == b[i])
+FN (ne, a[i] != b[i])
+FN (gt, a[i] > b[i])
+FN (ge, a[i] >= b[i])
+FN (lt, a[i] < b[i])
+FN (le, a[i] <= b[i])
+FN (unle, !__builtin_isgreater (a[i], b[i]))
+FN (unlt, !__builtin_isgreaterequal (a[i], b[i]))
+FN (unge, !__builtin_isless (a[i], b[i]))
+FN (ungt, !__builtin_islessequal (a[i], b[i]))
+FN (uneq, !__builtin_islessgreater (a[i], b[i]))
+FN (ordered, !__builtin_isunordered (a[i], b[i]))
+FN (unordered, __builtin_isunordered (a[i], b[i]))
+
+#define TEST(name, GT, LT, EQ, UO) \
+  name ();				\
+  for (i = 0; i < N; i++)		\
+    {					\
+      int v;				\
+      switch (i % 4)			\
+	{				\
+	case 0: v = GT ? 5 : 32; break;	\
+	case 1: v = LT ? 5 : 32; break;	\
+	case 2: v = EQ ? 5 : 32; break;	\
+	case 3: v = UO ? 5 : 32; break;	\
+	}				\
+      if (c[i] != v)			\
+	__builtin_abort ();		\
+    }
+
+void
+PR71559_TEST (void)
+{
+  int i;
+  asm volatile ("" : : "g" (a), "g" (b), "g" (c), "g" (d) : "memory");
+  TEST (eq, 0, 0, 1, 0)
+  TEST (ne, 1, 1, 0, 1)
+  TEST (gt, 1, 0, 0, 0)
+  TEST (ge, 1, 0, 1, 0)
+  TEST (lt, 0, 1, 0, 0)
+  TEST (le, 0, 1, 1, 0)
+  TEST (unle, 0, 1, 1, 1)
+  TEST (unlt, 0, 1, 0, 1)
+  TEST (unge, 1, 0, 1, 1)
+  TEST (ungt, 1, 0, 0, 1)
+  TEST (uneq, 0, 0, 1, 1)
+  TEST (ordered, 1, 1, 1, 0)
+  TEST (unordered, 0, 0, 0, 1)
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/abs128-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/abs128-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/abs128-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/abs128-1.c	2016-07-01 17:19:15.000000000 +0000
@@ -0,0 +1,61 @@
+/* { dg-do run { target { powerpc64*-*-* && vsx_hw } } } */
+/* { dg-options "-mfloat128 -mvsx" } */
+
+void abort ();
+
+typedef unsigned long long int uint64_t;
+
+typedef union
+{
+  __float128 value;
+
+  struct
+  {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    unsigned negative:1;
+    unsigned exponent:15;
+    unsigned quiet_nan:1;
+    uint64_t mant_high:47;
+    uint64_t mant_low:64;
+#else
+    uint64_t mant_low:64;
+    uint64_t mant_high:47;
+    unsigned quiet_nan:1;
+    unsigned exponent:15;
+    unsigned negative:1;
+#endif
+  } nan;
+
+} ieee854_float128;
+
+int
+main (int argc, int *argv[])
+{
+  ieee854_float128 x, z;
+
+  x.nan.negative = 1;
+  x.nan.exponent = 0x22;
+  x.nan.quiet_nan = 0;
+  x.nan.mant_high = 0x1234;
+  x.nan.mant_low = 0xabcdef;
+
+  z.value = __builtin_fabsq (x.value);
+
+  if (z.nan.negative != 0
+      || z.nan.exponent != 0x22
+      || z.nan.quiet_nan != 0
+      || z.nan.mant_high != 0x1234
+      || z.nan.mant_low != 0xabcdef)
+    abort ();
+
+  z.value = __builtin_fabsq (z.value);
+
+  if (z.nan.negative != 0
+      || z.nan.exponent != 0x22
+      || z.nan.quiet_nan != 0
+      || z.nan.mant_high != 0x1234
+      || z.nan.mant_low != 0xabcdef)
+    abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/copysign128-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/copysign128-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/copysign128-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/copysign128-1.c	2016-07-01 17:19:15.000000000 +0000
@@ -0,0 +1,58 @@
+/* { dg-do run { target { powerpc64*-*-* && vsx_hw } } } */
+/* { dg-options "-mfloat128 -mvsx" } */
+
+void abort ();
+
+typedef unsigned long long int uint64_t;
+
+typedef union
+{
+  __float128 value;
+
+  struct
+  {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    unsigned negative:1;
+    unsigned exponent:15;
+    unsigned quiet_nan:1;
+    uint64_t mant_high:47;
+    uint64_t mant_low:64;
+#else
+    uint64_t mant_low:64;
+    uint64_t mant_high:47;
+    unsigned quiet_nan:1;
+    unsigned exponent:15;
+    unsigned negative:1;
+#endif
+  } nan;
+
+} ieee854_float128;
+
+int
+main (int argc, int *argv[])
+{
+  ieee854_float128 x, y, z;
+
+  x.nan.negative = 0;
+  x.nan.exponent = 0x22;
+  x.nan.quiet_nan = 0;
+  x.nan.mant_high = 0x1234;
+  x.nan.mant_low = 0xabcdef;
+
+  y.nan.negative = 1;
+  y.nan.exponent = 0;
+  y.nan.quiet_nan = 0;
+  y.nan.mant_high = 0;
+  y.nan.mant_low = 0;
+
+  z.value = __builtin_copysignq (x.value, y.value);
+
+  if (z.nan.negative != 1
+      || z.nan.exponent != 0x22
+      || z.nan.quiet_nan != 0
+      || z.nan.mant_high != 0x1234
+      || z.nan.mant_low != 0xabcdef)
+    abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/ctz-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/ctz-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/ctz-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/ctz-3.c	2016-06-01 23:23:42.000000000 +0000
@@ -0,0 +1,62 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
+
+#ifndef SIZE
+#define SIZE 1024
+#endif
+
+#ifndef ALIGN
+#define ALIGN 32
+#endif
+
+#define ALIGN_ATTR __attribute__((__aligned__(ALIGN)))
+
+#define DO_BUILTIN(PREFIX, TYPE, CTZ)					\
+TYPE PREFIX ## _a[SIZE] ALIGN_ATTR;					\
+TYPE PREFIX ## _b[SIZE] ALIGN_ATTR;					\
+									\
+void									\
+PREFIX ## _ctz (void)							\
+{									\
+  unsigned long i;							\
+									\
+  for (i = 0; i < SIZE; i++)						\
+    PREFIX ## _a[i] = CTZ (PREFIX ## _b[i]);				\
+}
+
+#if !defined(DO_LONG_LONG) && !defined(DO_LONG) && !defined(DO_INT) && !defined(DO_SHORT) && !defined(DO_CHAR)
+#define DO_INT 1
+#endif
+
+#if DO_LONG_LONG
+/* At the moment, only int is auto vectorized.  */
+DO_BUILTIN (sll, long long,		__builtin_ctzll)
+DO_BUILTIN (ull, unsigned long long,	__builtin_ctzll)
+#endif
+
+#if defined(_ARCH_PPC64) && DO_LONG
+DO_BUILTIN (sl,  long,			__builtin_ctzl)
+DO_BUILTIN (ul,  unsigned long,		__builtin_ctzl)
+#endif
+
+#if DO_INT
+DO_BUILTIN (si,  int,			__builtin_ctz)
+DO_BUILTIN (ui,  unsigned int,		__builtin_ctz)
+#endif
+
+#if DO_SHORT
+DO_BUILTIN (ss,  short,			__builtin_ctz)
+DO_BUILTIN (us,  unsigned short,	__builtin_ctz)
+#endif
+
+#if DO_CHAR
+DO_BUILTIN (sc,  signed char,		__builtin_ctz)
+DO_BUILTIN (uc,  unsigned char,		__builtin_ctz)
+#endif
+
+/* { dg-final { scan-assembler-times "vctzw" 2 } } */
+/* { dg-final { scan-assembler-not "cnttzd" } } */
+/* { dg-final { scan-assembler-not "cnttzw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/ctz-4.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/ctz-4.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/ctz-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/ctz-4.c	2016-06-01 23:23:42.000000000 +0000
@@ -0,0 +1,110 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+#include <altivec.h>
+
+vector signed char
+count_trailing_zeros_v16qi_1s (vector signed char a)
+{
+  return vec_vctz (a);
+}
+
+vector signed char
+count_trailing_zeros_v16qi_2s (vector signed char a)
+{
+  return vec_vctzb (a);
+}
+
+vector unsigned char
+count_trailing_zeros_v16qi_1u (vector unsigned char a)
+{
+  return vec_vctz (a);
+}
+
+vector unsigned char
+count_trailing_zeros_v16qi_2u (vector unsigned char a)
+{
+  return vec_vctzb (a);
+}
+
+vector short
+count_trailing_zeros_v8hi_1s (vector short a)
+{
+  return vec_vctz (a);
+}
+
+vector short
+count_trailing_zeros_v8hi_2s (vector short a)
+{
+  return vec_vctzh (a);
+}
+
+vector unsigned short
+count_trailing_zeros_v8hi_1u (vector unsigned short a)
+{
+  return vec_vctz (a);
+}
+
+vector unsigned short
+count_trailing_zeros_v8hi_2u (vector unsigned short a)
+{
+  return vec_vctzh (a);
+}
+
+vector int
+count_trailing_zeros_v4si_1s (vector int a)
+{
+  return vec_vctz (a);
+}
+
+vector int
+count_trailing_zeros_v4si_2s (vector int a)
+{
+  return vec_vctzw (a);
+}
+
+vector unsigned int
+count_trailing_zeros_v4si_1u (vector unsigned int a)
+{
+  return vec_vctz (a);
+}
+
+vector unsigned int
+count_trailing_zeros_v4si_2u (vector unsigned int a)
+{
+  return vec_vctzw (a);
+}
+
+vector long long
+count_trailing_zeros_v2di_1s (vector long long a)
+{
+  return vec_vctz (a);
+}
+
+vector long long
+count_trailing_zeros_v2di_2s (vector long long a)
+{
+  return vec_vctzd (a);
+}
+
+vector unsigned long long
+count_trailing_zeros_v2di_1u (vector unsigned long long a)
+{
+  return vec_vctz (a);
+}
+
+vector unsigned long long
+count_trailing_zeros_v2di_2u (vector unsigned long long a)
+{
+  return vec_vctzd (a);
+}
+
+/* { dg-final { scan-assembler "vctzb" } } */
+/* { dg-final { scan-assembler "vctzd" } } */
+/* { dg-final { scan-assembler "vctzh" } } */
+/* { dg-final { scan-assembler "vctzw" } } */
+/* { dg-final { scan-assembler-not "cnttzd" } } */
+/* { dg-final { scan-assembler-not "cnttzw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/darn-0.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/darn-0.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/darn-0.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/darn-0.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int get_random ()
+{
+  return __builtin_darn_32 ();
+}
+
+/* { dg-final { scan-assembler	   "darn" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/darn-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/darn-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/darn-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/darn-1.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+long long get_conditioned_random ()
+{
+  return __builtin_darn ();
+}
+
+/* { dg-final { scan-assembler	   "darn" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/darn-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/darn-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/darn-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/darn-2.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+long long get_raw_random ()
+{
+  return __builtin_darn_raw ();
+}
+
+/* { dg-final { scan-assembler	   "darn" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dform-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dform-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dform-1.c	2015-11-25 22:49:41.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dform-1.c	2016-06-01 22:09:14.000000000 +0000
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-options "-mcpu=power9 -mpower9-dform -O2" } */
+/* { dg-options "-mcpu=power9 -mpower9-dform -O2 -mlra" } */
 
 #ifndef TYPE
 #define TYPE double
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dform-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dform-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dform-2.c	2015-11-25 22:49:41.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dform-2.c	2016-06-01 22:09:14.000000000 +0000
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-options "-mcpu=power9 -mpower9-dform -O2" } */
+/* { dg-options "-mcpu=power9 -mpower9-dform -O2 -mlra" } */
 
 #ifndef TYPE
 #define TYPE float
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dform-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dform-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dform-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dform-3.c	2016-06-01 22:15:47.000000000 +0000
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -mpower9-dform -O2 -mlra" } */
+
+#ifndef TYPE
+#define TYPE vector double
+#endif
+
+struct foo {
+  TYPE a, b, c, d;
+};
+
+/* Test whether ISA 3.0 vector d-form instructions are implemented.  */
+void
+add (struct foo *p)
+{
+  p->b = p->c + p->d;
+}
+
+/* Make sure we don't use direct moves to get stuff into GPR registers.  */
+void
+gpr (struct foo *p)
+{
+  TYPE x = p->c;
+
+  __asm__ (" # reg = %0" : "+r" (x));
+
+  p->b = x;
+}
+
+/* { dg-final { scan-assembler     "lxv "      } } */
+/* { dg-final { scan-assembler     "stxv "     } } */
+/* { dg-final { scan-assembler-not "lxvx "     } } */
+/* { dg-final { scan-assembler-not "stxvx "    } } */
+/* { dg-final { scan-assembler-not "mfvsrd "   } } */
+/* { dg-final { scan-assembler-not "mfvsrld "  } } */
+/* { dg-final { scan-assembler     "l\[dq\] "  } } */
+/* { dg-final { scan-assembler     "st\[dq\] " } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,39 @@
+# Copyright (C) 2014-2016 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Exit immediately if this isn't a PowerPC target.
+if { ![istarget powerpc*-*-*] && ![istarget rs6000-*-*] } then {
+  return
+}
+
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+  set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+load_lib torture-options.exp
+
+# Initialize.
+dg-init
+
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c*]] "" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-0.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-0.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-0.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-0.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-1.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_lt_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-10.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-10.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-10.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-10.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_dd (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-11.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-11.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-11.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-11.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_dd (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_lt_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-12.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-12.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-12.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-12.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_dd (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-13.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-13.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-13.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-13.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_lt_dd (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-14.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-14.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-14.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-14.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_dd (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-15.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-15.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-15.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-15.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_td (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-16.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-16.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-16.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-16.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_td (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_lt_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-17.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-17.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-17.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-17.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_td (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-18.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-18.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-18.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-18.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_lt_td (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-19.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-19.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-19.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-19.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt_td (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-2.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-20.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-20.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-20.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-20.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-21.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-21.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-21.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-21.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_gt_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-22.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-22.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-22.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-22.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-23.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-23.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-23.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-23.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_gt (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-24.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-24.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-24.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-24.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-25.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-25.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-25.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-25.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-26.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-26.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-26.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-26.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_gt_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-27.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-27.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-27.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-27.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-28.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-28.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-28.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-28.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_gt (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-29.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-29.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-29.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-29.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-3.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_lt (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-30.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-30.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-30.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-30.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_dd (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-31.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-31.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-31.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-31.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_dd (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_gt_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-32.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-32.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-32.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-32.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_dd (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-33.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-33.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-33.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-33.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_gt_dd (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-34.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-34.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-34.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-34.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_dd (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-35.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-35.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-35.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-35.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_td (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-36.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-36.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-36.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-36.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_td (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_gt_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-37.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-37.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-37.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-37.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_td (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-38.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-38.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-38.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-38.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_gt_td (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-39.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-39.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-39.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-39.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_gt_td (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-4.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-4.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-4.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-40.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-40.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-40.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-40.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-41.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-41.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-41.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-41.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_eq_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-42.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-42.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-42.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-42.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-43.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-43.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-43.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-43.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_eq (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-44.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-44.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-44.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-44.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-45.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-45.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-45.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-45.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-46.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-46.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-46.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-46.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_eq_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-47.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-47.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-47.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-47.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-48.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-48.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-48.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-48.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_eq (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-49.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-49.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-49.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-49.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-5.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-5.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-5.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-5.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-50.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-50.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-50.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-50.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_dd (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-51.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-51.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-51.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-51.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_dd (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_eq_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-52.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-52.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-52.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-52.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_dd (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-53.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-53.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-53.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-53.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_eq_dd (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-54.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-54.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-54.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-54.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_dd (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-55.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-55.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-55.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-55.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_td (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-56.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-56.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-56.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-56.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_td (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_eq_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-57.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-57.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-57.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-57.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_td (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-58.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-58.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-58.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-58.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_eq_td (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-59.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-59.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-59.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-59.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_eq_td (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-6.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-6.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-6.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-6.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_lt_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-60.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-60.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-60.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-60.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-61.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-61.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-61.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-61.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_ov_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-62.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-62.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-62.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-62.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-63.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-63.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-63.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-63.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_ov (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-64.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-64.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-64.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-64.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-65.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-65.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-65.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-65.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-66.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-66.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-66.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-66.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_ov_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-67.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-67.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-67.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-67.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-68.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-68.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-68.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-68.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_ov (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-69.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-69.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-69.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-69.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-7.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-7.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-7.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-7.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-70.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-70.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-70.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-70.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_dd (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-71.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-71.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-71.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-71.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_dd (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_ov_dd requires" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-72.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-72.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-72.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-72.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_dd (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-73.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-73.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-73.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-73.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p)
+{
+  _Decimal64 source = *p;
+
+  if (__builtin_dfp_dtstsfi_ov_dd (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfi" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-74.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-74.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-74.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-74.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal64 *p, unsigned int significance)
+{
+  _Decimal64 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_dd (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-75.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-75.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-75.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-75.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_td (5, source);
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-76.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-76.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-76.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-76.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_td (5, source);	/* { dg-error "Builtin function __builtin_dtstsfi_ov_td requires" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-77.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-77.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-77.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-77.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_td (65, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
+
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-78.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-78.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-78.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-78.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_ov_td (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-79.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-79.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-79.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-79.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_ov_td (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-8.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-8.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-8.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-8.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p)
+{
+  _Decimal128 source = *p;
+
+  if (__builtin_dfp_dtstsfi_lt (63, source))
+    return 3;
+  else
+    return 5;
+}
+
+/* { dg-final { scan-assembler	   "dtstsfiq" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-9.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-9.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-9.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/dfp/dtstsfi-9.c	2016-07-07 19:42:07.000000000 +0000
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+int doTestBCDSignificance (_Decimal128 *p, unsigned int significance)
+{
+  _Decimal128 source = *p;
+
+  return __builtin_dfp_dtstsfi_lt (significance, source);	/* { dg-error "argument 1 must be a 6-bit unsigned literal" } */
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/divkc3-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/divkc3-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/divkc3-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/divkc3-1.c	2016-07-15 20:22:23.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do run { target { powerpc64*-*-* && vsx_hw } } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-options "-mfloat128 -mvsx" } */
+
+void abort ();
+
+typedef __complex float __cfloat128 __attribute__((mode(KC)));
+
+__cfloat128 divide (__cfloat128 x, __cfloat128 y)
+{
+  return x / y;
+}
+
+__cfloat128 z, a;
+
+int main ()
+{
+  z = divide (5.0q + 5.0jq, 2.0q + 1.0jq);
+  a = 3.0q + 1.0jq;
+  if (z != a)
+    abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/float128-complex-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/float128-complex-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/float128-complex-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/float128-complex-1.c	2016-06-27 18:25:58.000000000 +0000
@@ -0,0 +1,157 @@
+/* { dg-do compile { target { powerpc*-*-linux* } } } */
+/* { dg-require-effective-target powerpc_float128_sw_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-O2 -mcpu=power7 -mfloat128" } */
+
+#ifndef NO_FLOAT
+typedef _Complex float	float_complex;
+extern float_complex cfloat1 (void);
+extern float_complex cfloat2 (void);
+
+#define FLOAT_ARG(NAME, OP)	ARG_OP(float, float_complex, NAME, OP)
+#define FLOAT_PTR(NAME, OP)	PTR_OP(float, float_complex, NAME, OP)
+#define FLOAT_CALL()		CALL_OP(float, float_complex, cfloat1, cfloat2)
+
+#else
+#define FLOAT_ARG(NAME, OP)
+#define FLOAT_PTR(NAME, OP)
+#define FLOAT_CALL()
+#endif
+
+#ifndef NO_DOUBLE
+typedef _Complex double	double_complex;
+extern double_complex cdouble1 (void);
+extern double_complex cdouble2 (void);
+
+#define DOUBLE_ARG(NAME, OP)	ARG_OP(double, double_complex, NAME, OP)
+#define DOUBLE_PTR(NAME, OP)	PTR_OP(double, double_complex, NAME, OP)
+#define DOUBLE_CALL()		CALL_OP(double, double_complex, cdouble1, cdouble2)
+
+#else
+#define DOUBLE_ARG(NAME, OP)
+#define DOUBLE_PTR(NAME, OP)
+#define DOUBLE_CALL()
+#endif
+
+#ifndef NO_FLOAT128
+#ifdef __VSX__
+typedef _Complex float __attribute__((mode(KC)))	float128_complex;
+#else
+typedef _Complex float __attribute__((mode(TC)))	float128_complex;
+#endif
+
+extern float128_complex cfloat128_1 (void);
+extern float128_complex cfloat128_2 (void);
+
+#define FLOAT128_ARG(NAME, OP)	ARG_OP(float128, float128_complex, NAME, OP)
+#define FLOAT128_PTR(NAME, OP)	PTR_OP(float128, float128_complex, NAME, OP)
+#define FLOAT128_CALL()		CALL_OP(float128, float128_complex, cfloat128_1, cfloat128_2)
+
+#else
+#define FLOAT128_ARG(NAME, OP)
+#define FLOAT128_PTR(NAME, OP)
+#define FLOAT128_CALL()
+#endif
+
+#ifndef NO_LDOUBLE
+typedef _Complex long double ldouble_complex;
+extern ldouble_complex cldouble1 (void);
+extern ldouble_complex cldouble2 (void);
+
+#define LDOUBLE_ARG(NAME, OP)	ARG_OP(ldouble, ldouble_complex, NAME, OP)
+#define LDOUBLE_PTR(NAME, OP)	PTR_OP(ldouble, ldouble_complex, NAME, OP)
+#define LDOUBLE_CALL()		CALL_OP(ldouble, ldouble_complex, cldouble1, cldouble2)
+
+#else
+#define LDOUBLE_ARG(NAME, OP)
+#define LDOUBLE_PTR(NAME, OP)
+#define LDOUBLE_CALL()
+#endif
+
+
+#define ARG_OP(SUFFIX, TYPE, NAME, OP)					\
+TYPE arg_ ## NAME ## _ ## SUFFIX (TYPE a, TYPE b)			\
+{									\
+  return a OP b;							\
+}
+
+#define PTR_OP(SUFFIX, TYPE, NAME, OP)					\
+void ptr_ ## NAME ## _ ## SUFFIX (TYPE *p, TYPE *a, TYPE *b)		\
+{									\
+  *p = *a OP *b;							\
+}
+
+#define CALL_OP(SUFFIX, TYPE, FUNC1, FUNC2)				\
+TYPE call_ ## SUFFIX (void)						\
+{									\
+  TYPE value1 = FUNC1 ();						\
+  TYPE value2 = FUNC2 ();						\
+  return value1 + value2;						\
+}
+
+#ifndef NO_ARG
+#ifndef NO_ADD
+FLOAT_ARG    (add, +)
+DOUBLE_ARG   (add, +)
+FLOAT128_ARG (add, +)
+LDOUBLE_ARG  (add, +)
+#endif
+
+#ifndef NO_SUB
+FLOAT_ARG    (sub, -)
+DOUBLE_ARG   (sub, -)
+FLOAT128_ARG (sub, -)
+LDOUBLE_ARG  (sub, -)
+#endif
+
+#ifndef NO_MUL
+FLOAT_ARG    (mul, *)
+DOUBLE_ARG   (mul, *)
+FLOAT128_ARG (mul, *)
+LDOUBLE_ARG  (mul, *)
+#endif
+
+#ifndef NO_DIV
+FLOAT_ARG    (div, /)
+DOUBLE_ARG   (div, /)
+FLOAT128_ARG (div, /)
+LDOUBLE_ARG  (div, /)
+#endif
+#endif
+
+#ifndef NO_PTR
+#ifndef NO_ADD
+FLOAT_PTR    (add, +)
+DOUBLE_PTR   (add, +)
+FLOAT128_PTR (add, +)
+LDOUBLE_PTR  (add, +)
+#endif
+
+#ifndef NO_SUB
+FLOAT_PTR    (sub, -)
+DOUBLE_PTR   (sub, -)
+FLOAT128_PTR (sub, -)
+LDOUBLE_PTR  (sub, -)
+#endif
+
+#ifndef NO_MUL
+FLOAT_PTR    (mul, *)
+DOUBLE_PTR   (mul, *)
+FLOAT128_PTR (mul, *)
+LDOUBLE_PTR  (mul, *)
+#endif
+
+#ifndef NO_DIV
+FLOAT_PTR    (div, /)
+DOUBLE_PTR   (div, /)
+FLOAT128_PTR (div, /)
+LDOUBLE_PTR  (div, /)
+#endif
+#endif
+
+#ifndef NO_CALL
+FLOAT_CALL    ()
+DOUBLE_CALL   ()
+FLOAT128_CALL ()
+LDOUBLE_CALL  ()
+#endif
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/float128-complex-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/float128-complex-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/float128-complex-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/float128-complex-2.c	2016-06-27 18:25:58.000000000 +0000
@@ -0,0 +1,160 @@
+/* { dg-do compile { target { powerpc*-*-linux* } } } */
+/* { dg-require-effective-target powerpc_float128_hw_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-O2 -mcpu=power9 -mfloat128 -mfloat128-hardware" } */
+
+#ifndef NO_FLOAT
+typedef _Complex float	float_complex;
+extern float_complex cfloat1 (void);
+extern float_complex cfloat2 (void);
+
+#define FLOAT_ARG(NAME, OP)	ARG_OP(float, float_complex, NAME, OP)
+#define FLOAT_PTR(NAME, OP)	PTR_OP(float, float_complex, NAME, OP)
+#define FLOAT_CALL()		CALL_OP(float, float_complex, cfloat1, cfloat2)
+
+#else
+#define FLOAT_ARG(NAME, OP)
+#define FLOAT_PTR(NAME, OP)
+#define FLOAT_CALL()
+#endif
+
+#ifndef NO_DOUBLE
+typedef _Complex double	double_complex;
+extern double_complex cdouble1 (void);
+extern double_complex cdouble2 (void);
+
+#define DOUBLE_ARG(NAME, OP)	ARG_OP(double, double_complex, NAME, OP)
+#define DOUBLE_PTR(NAME, OP)	PTR_OP(double, double_complex, NAME, OP)
+#define DOUBLE_CALL()		CALL_OP(double, double_complex, cdouble1, cdouble2)
+
+#else
+#define DOUBLE_ARG(NAME, OP)
+#define DOUBLE_PTR(NAME, OP)
+#define DOUBLE_CALL()
+#endif
+
+#ifndef NO_FLOAT128
+#ifdef __VSX__
+typedef _Complex float __attribute__((mode(KC)))	float128_complex;
+#else
+typedef _Complex float __attribute__((mode(TC)))	float128_complex;
+#endif
+
+extern float128_complex cfloat128_1 (void);
+extern float128_complex cfloat128_2 (void);
+
+#define FLOAT128_ARG(NAME, OP)	ARG_OP(float128, float128_complex, NAME, OP)
+#define FLOAT128_PTR(NAME, OP)	PTR_OP(float128, float128_complex, NAME, OP)
+#define FLOAT128_CALL()		CALL_OP(float128, float128_complex, cfloat128_1, cfloat128_2)
+
+#else
+#define FLOAT128_ARG(NAME, OP)
+#define FLOAT128_PTR(NAME, OP)
+#define FLOAT128_CALL()
+#endif
+
+#ifndef NO_LDOUBLE
+typedef _Complex long double ldouble_complex;
+extern ldouble_complex cldouble1 (void);
+extern ldouble_complex cldouble2 (void);
+
+#define LDOUBLE_ARG(NAME, OP)	ARG_OP(ldouble, ldouble_complex, NAME, OP)
+#define LDOUBLE_PTR(NAME, OP)	PTR_OP(ldouble, ldouble_complex, NAME, OP)
+#define LDOUBLE_CALL()		CALL_OP(ldouble, ldouble_complex, cldouble1, cldouble2)
+
+#else
+#define LDOUBLE_ARG(NAME, OP)
+#define LDOUBLE_PTR(NAME, OP)
+#define LDOUBLE_CALL()
+#endif
+
+
+#define ARG_OP(SUFFIX, TYPE, NAME, OP)					\
+TYPE arg_ ## NAME ## _ ## SUFFIX (TYPE a, TYPE b)			\
+{									\
+  return a OP b;							\
+}
+
+#define PTR_OP(SUFFIX, TYPE, NAME, OP)					\
+void ptr_ ## NAME ## _ ## SUFFIX (TYPE *p, TYPE *a, TYPE *b)		\
+{									\
+  *p = *a OP *b;							\
+}
+
+#define CALL_OP(SUFFIX, TYPE, FUNC1, FUNC2)				\
+TYPE call_ ## SUFFIX (void)						\
+{									\
+  TYPE value1 = FUNC1 ();						\
+  TYPE value2 = FUNC2 ();						\
+  return value1 + value2;						\
+}
+
+#ifndef NO_ARG
+#ifndef NO_ADD
+FLOAT_ARG    (add, +)
+DOUBLE_ARG   (add, +)
+FLOAT128_ARG (add, +)
+LDOUBLE_ARG  (add, +)
+#endif
+
+#ifndef NO_SUB
+FLOAT_ARG    (sub, -)
+DOUBLE_ARG   (sub, -)
+FLOAT128_ARG (sub, -)
+LDOUBLE_ARG  (sub, -)
+#endif
+
+#ifndef NO_MUL
+FLOAT_ARG    (mul, *)
+DOUBLE_ARG   (mul, *)
+FLOAT128_ARG (mul, *)
+LDOUBLE_ARG  (mul, *)
+#endif
+
+#ifndef NO_DIV
+FLOAT_ARG    (div, /)
+DOUBLE_ARG   (div, /)
+FLOAT128_ARG (div, /)
+LDOUBLE_ARG  (div, /)
+#endif
+#endif
+
+#ifndef NO_PTR
+#ifndef NO_ADD
+FLOAT_PTR    (add, +)
+DOUBLE_PTR   (add, +)
+FLOAT128_PTR (add, +)
+LDOUBLE_PTR  (add, +)
+#endif
+
+#ifndef NO_SUB
+FLOAT_PTR    (sub, -)
+DOUBLE_PTR   (sub, -)
+FLOAT128_PTR (sub, -)
+LDOUBLE_PTR  (sub, -)
+#endif
+
+#ifndef NO_MUL
+FLOAT_PTR    (mul, *)
+DOUBLE_PTR   (mul, *)
+FLOAT128_PTR (mul, *)
+LDOUBLE_PTR  (mul, *)
+#endif
+
+#ifndef NO_DIV
+FLOAT_PTR    (div, /)
+DOUBLE_PTR   (div, /)
+FLOAT128_PTR (div, /)
+LDOUBLE_PTR  (div, /)
+#endif
+#endif
+
+#ifndef NO_CALL
+FLOAT_CALL    ()
+DOUBLE_CALL   ()
+FLOAT128_CALL ()
+LDOUBLE_CALL  ()
+#endif
+
+/* { dg-final { scan-assembler "xsaddqp"  } } */
+/* { dg-final { scan-assembler "xssubqp"  } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/inf128-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/inf128-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/inf128-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/inf128-1.c	2016-07-01 17:19:15.000000000 +0000
@@ -0,0 +1,55 @@
+/* { dg-do run { target { powerpc64*-*-* && vsx_hw } } } */
+/* { dg-options "-mfloat128 -mvsx" } */
+
+void abort ();
+
+typedef unsigned long long int uint64_t;
+
+typedef union
+{
+  __float128 value;
+
+  struct
+  {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    unsigned negative:1;
+    unsigned exponent:15;
+    unsigned quiet_nan:1;
+    uint64_t mant_high:47;
+    uint64_t mant_low:64;
+#else
+    uint64_t mant_low:64;
+    uint64_t mant_high:47;
+    unsigned quiet_nan:1;
+    unsigned exponent:15;
+    unsigned negative:1;
+#endif
+  } nan;
+
+} ieee854_float128;
+
+int
+main (int argc, int *argv[])
+{
+  ieee854_float128 y;
+
+  y.value = __builtin_infq ();
+
+  if (y.nan.negative != 0
+      || y.nan.exponent != 0x7fff
+      || y.nan.quiet_nan != 0
+      || y.nan.mant_high != 0
+      || y.nan.mant_low != 0)
+    abort ();
+
+  y.value = __builtin_huge_valq ();
+
+  if (y.nan.negative != 0
+      || y.nan.exponent != 0x7fff
+      || y.nan.quiet_nan != 0
+      || y.nan.mant_high != 0
+      || y.nan.mant_low != 0)
+    abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/mulkc3-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/mulkc3-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/mulkc3-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/mulkc3-1.c	2016-07-15 20:22:23.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do run { target { powerpc64*-*-* && vsx_hw } } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-options "-mfloat128 -mvsx" } */
+
+void abort ();
+
+typedef __complex float __cfloat128 __attribute__((mode(KC)));
+
+__cfloat128 multiply (__cfloat128 x, __cfloat128 y)
+{
+  return x * y;
+}
+
+__cfloat128 z, a;
+
+int main ()
+{
+  z = multiply (2.0q + 1.0jq, 3.0q + 1.0jq);
+  a = 5.0q + 5.0jq;
+  if (z != a)
+    abort ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/nan128-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/nan128-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/nan128-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/nan128-1.c	2016-07-01 17:19:15.000000000 +0000
@@ -0,0 +1,77 @@
+/* { dg-do run { target { powerpc64*-*-* && vsx_hw } } } */
+/* { dg-options "-mfloat128 -mvsx" } */
+
+#include <stdio.h>
+
+void abort ();
+
+typedef unsigned long long int uint64_t;
+
+typedef union
+{
+  __float128 value;
+
+  struct
+  {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    unsigned negative:1;
+    unsigned exponent:15;
+    unsigned quiet_nan:1;
+    uint64_t mant_high:47;
+    uint64_t mant_low:64;
+#else
+    uint64_t mant_low:64;
+    uint64_t mant_high:47;
+    unsigned quiet_nan:1;
+    unsigned exponent:15;
+    unsigned negative:1;
+#endif
+  } nan;
+
+} ieee854_float128;
+
+int
+main (int argc, int *argv[])
+{
+  ieee854_float128 y;
+
+  y.value = __builtin_nanq ("1");
+
+  if (y.nan.negative != 0
+      || y.nan.exponent != 0x7fff
+      || y.nan.quiet_nan != 1
+      || y.nan.mant_high != 0
+      || y.nan.mant_low != 1)
+    abort ();
+
+  y.value = __builtin_nanq ("0x2ab3c");
+
+  if (y.nan.negative != 0
+      || y.nan.exponent != 0x7fff
+      || y.nan.quiet_nan != 1
+      || y.nan.mant_high != 0
+      || y.nan.mant_low != 0x2ab3c)
+    abort ();
+
+  y.value = __builtin_nansq ("1");
+
+  if (
+      y.nan.negative != 0
+      || y.nan.exponent != 0x7fff
+      || y.nan.quiet_nan != 0
+      || y.nan.mant_high != 0
+      || y.nan.mant_low != 1
+      )
+    abort ();
+
+  y.value = __builtin_nansq ("0x2ab3c");
+
+  if (y.nan.negative != 0
+      || y.nan.exponent != 0x7fff
+      || y.nan.quiet_nan != 0
+      || y.nan.mant_high != 0
+      || y.nan.mant_low != 0x2ab3c)
+    abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c	2014-11-04 12:09:50.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c	2016-06-01 22:09:14.000000000 +0000
@@ -2,7 +2,7 @@
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -mvsx-timode" } */
+/* { dg-options "-mcpu=power8 -O3 -mvsx-timode -mlra" } */
 
 #include <altivec.h>
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-3.c	2016-03-01 21:31:47.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-lxvx-stxvx-3.c	2016-07-08 14:51:44.000000000 +0000
@@ -1,6 +1,6 @@
 /* { dg-do compile { target { powerpc64le-*-* } } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-options "-mcpu=power9 -O3" } */
+/* { dg-options "-mcpu=power9 -O3 -mfloat128" } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-final { scan-assembler "lxvx" } } */
 /* { dg-final { scan-assembler "stxvx" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-minmax-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-minmax-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-minmax-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-minmax-1.c	2016-06-02 19:41:47.000000000 +0000
@@ -0,0 +1,171 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2 -mpower9-minmax -ffast-math" } */
+/* { dg-final { scan-assembler-not "fsel"      } } */
+/* { dg-final { scan-assembler     "xscmpeqdp" } } */
+/* { dg-final { scan-assembler     "xscmpgtdp" } } */
+/* { dg-final { scan-assembler     "xscmpgedp" } } */
+/* { dg-final { scan-assembler-not "xscmpodp"  } } */
+/* { dg-final { scan-assembler-not "xscmpudp"  } } */
+/* { dg-final { scan-assembler     "xsmaxcdp"  } } */
+/* { dg-final { scan-assembler-not "xsmaxdp"   } } */
+/* { dg-final { scan-assembler     "xsmincdp"  } } */
+/* { dg-final { scan-assembler-not "xsmindp"   } } */
+/* { dg-final { scan-assembler     "xxsel"     } } */
+
+double
+dbl_max1 (double a, double b)
+{
+  return (a >= b) ? a : b;
+}
+
+double
+dbl_max2 (double a, double b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_min1 (double a, double b)
+{
+  return (a < b) ? a : b;
+}
+
+double
+dbl_min2 (double a, double b)
+{
+  return (a <= b) ? a : b;
+}
+
+double
+dbl_cmp_eq (double a, double b, double c, double d)
+{
+  return (a == b) ? c : d;
+}
+
+double
+dbl_cmp_ne (double a, double b, double c, double d)
+{
+  return (a != b) ? c : d;
+}
+
+double
+dbl_cmp_gt (double a, double b, double c, double d)
+{
+  return (a > b) ? c : d;
+}
+
+double
+dbl_cmp_ge (double a, double b, double c, double d)
+{
+  return (a >= b) ? c : d;
+}
+
+double
+dbl_cmp_lt (double a, double b, double c, double d)
+{
+  return (a < b) ? c : d;
+}
+
+double
+dbl_cmp_le (double a, double b, double c, double d)
+{
+  return (a <= b) ? c : d;
+}
+
+float
+flt_max1 (float a, float b)
+{
+  return (a >= b) ? a : b;
+}
+
+float
+flt_max2 (float a, float b)
+{
+  return (a > b) ? a : b;
+}
+
+float
+flt_min1 (float a, float b)
+{
+  return (a < b) ? a : b;
+}
+
+float
+flt_min2 (float a, float b)
+{
+  return (a <= b) ? a : b;
+}
+
+float
+flt_cmp_eq (float a, float b, float c, float d)
+{
+  return (a == b) ? c : d;
+}
+
+float
+flt_cmp_ne (float a, float b, float c, float d)
+{
+  return (a != b) ? c : d;
+}
+
+float
+flt_cmp_gt (float a, float b, float c, float d)
+{
+  return (a > b) ? c : d;
+}
+
+float
+flt_cmp_ge (float a, float b, float c, float d)
+{
+  return (a >= b) ? c : d;
+}
+
+float
+flt_cmp_lt (float a, float b, float c, float d)
+{
+  return (a < b) ? c : d;
+}
+
+float
+flt_cmp_le (float a, float b, float c, float d)
+{
+  return (a <= b) ? c : d;
+}
+
+double
+dbl_flt_max1 (float a, float b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_flt_max2 (double a, float b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_flt_max3 (float a, double b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_flt_min1 (float a, float b)
+{
+  return (a < b) ? a : b;
+}
+
+double
+dbl_flt_min2 (double a, float b)
+{
+  return (a < b) ? a : b;
+}
+
+double
+dbl_flt_min3 (float a, double b)
+{
+  return (a < b) ? a : b;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-minmax-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-minmax-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-minmax-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-minmax-2.c	2016-06-02 19:41:47.000000000 +0000
@@ -0,0 +1,191 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2 -mpower9-minmax" } */
+/* { dg-final { scan-assembler-not "fsel"      } } */
+/* { dg-final { scan-assembler     "xscmpeqdp" } } */
+/* { dg-final { scan-assembler     "xscmpgtdp" } } */
+/* { dg-final { scan-assembler-not "xscmpodp"  } } */
+/* { dg-final { scan-assembler-not "xscmpudp"  } } */
+/* { dg-final { scan-assembler     "xsmaxcdp"  } } */
+/* { dg-final { scan-assembler-not "xsmaxdp"   } } */
+/* { dg-final { scan-assembler     "xsmincdp"  } } */
+/* { dg-final { scan-assembler-not "xsmindp"   } } */
+/* { dg-final { scan-assembler     "xxsel"     } } */
+
+/* Due to NaN support, <= and >= are not handled presently unless -ffast-math
+   is used.  At some point this will be fixed and the xscmpgedp instruction can
+   be generated normally. The <= and >= tests are bracketed with
+   #ifdef DO_GE_LE.  */
+
+#ifdef DO_GE_LE
+double
+dbl_max1 (double a, double b)
+{
+  return (a >= b) ? a : b;
+}
+#endif
+
+double
+dbl_max2 (double a, double b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_min1 (double a, double b)
+{
+  return (a < b) ? a : b;
+}
+
+#ifdef DO_GE_LE
+double
+dbl_min2 (double a, double b)
+{
+  return (a <= b) ? a : b;
+}
+#endif
+
+double
+dbl_cmp_eq (double a, double b, double c, double d)
+{
+  return (a == b) ? c : d;
+}
+
+double
+dbl_cmp_ne (double a, double b, double c, double d)
+{
+  return (a != b) ? c : d;
+}
+
+double
+dbl_cmp_gt (double a, double b, double c, double d)
+{
+  return (a > b) ? c : d;
+}
+
+#ifdef DO_GE_LE
+double
+dbl_cmp_ge (double a, double b, double c, double d)
+{
+  return (a >= b) ? c : d;
+}
+#endif
+
+double
+dbl_cmp_lt (double a, double b, double c, double d)
+{
+  return (a < b) ? c : d;
+}
+
+#ifdef DO_GE_LE
+double
+dbl_cmp_le (double a, double b, double c, double d)
+{
+  return (a <= b) ? c : d;
+}
+#endif
+
+#ifdef DO_GE_LE
+float
+flt_max1 (float a, float b)
+{
+  return (a >= b) ? a : b;
+}
+#endif
+
+float
+flt_max2 (float a, float b)
+{
+  return (a > b) ? a : b;
+}
+
+float
+flt_min1 (float a, float b)
+{
+  return (a < b) ? a : b;
+}
+
+#ifdef DO_GE_LE
+float
+flt_min2 (float a, float b)
+{
+  return (a <= b) ? a : b;
+}
+#endif
+
+float
+flt_cmp_eq (float a, float b, float c, float d)
+{
+  return (a == b) ? c : d;
+}
+
+float
+flt_cmp_ne (float a, float b, float c, float d)
+{
+  return (a != b) ? c : d;
+}
+
+float
+flt_cmp_gt (float a, float b, float c, float d)
+{
+  return (a > b) ? c : d;
+}
+
+#ifdef DO_GE_LE
+float
+flt_cmp_ge (float a, float b, float c, float d)
+{
+  return (a >= b) ? c : d;
+}
+#endif
+
+float
+flt_cmp_lt (float a, float b, float c, float d)
+{
+  return (a < b) ? c : d;
+}
+
+#ifdef DO_GE_LE
+float
+flt_cmp_le (float a, float b, float c, float d)
+{
+  return (a <= b) ? c : d;
+}
+#endif
+
+double
+dbl_flt_max1 (float a, float b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_flt_max2 (double a, float b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_flt_max3 (float a, double b)
+{
+  return (a > b) ? a : b;
+}
+
+double
+dbl_flt_min1 (float a, float b)
+{
+  return (a < b) ? a : b;
+}
+
+double
+dbl_flt_min2 (double a, float b)
+{
+  return (a < b) ? a : b;
+}
+
+double
+dbl_flt_min3 (float a, double b)
+{
+  return (a < b) ? a : b;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-permute.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-permute.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-permute.c	2016-03-01 21:31:47.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-permute.c	2016-06-01 23:23:42.000000000 +0000
@@ -1,4 +1,4 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-do compile { target { powerpc64*-*-* } } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
 /* { dg-options "-mcpu=power9 -O2" } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
@@ -17,5 +17,6 @@
   return vec_perm (a, b, mask);
 }
 
+/* expect xxpermr on little-endian, xxperm on big-endian */
 /* { dg-final { scan-assembler	   "xxperm" } } */
 /* { dg-final { scan-assembler-not "vperm"  } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-1.c	2016-06-09 23:28:23.000000000 +0000
@@ -0,0 +1,27 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+
+#include <altivec.h>
+
+vector int
+foo_r (int a)
+{
+  return (vector int) { a, a, a, a };		/* mtvsrws */
+}
+
+vector int
+foo_r2 (int a)
+{
+  return vec_splats (a);			/* mtvsrws */
+}
+
+vector int
+foo_p (int *a)
+{
+  return (vector int) { *a, *a, *a, *a };	/* lxvwsx */
+}
+
+/* { dg-final { scan-assembler-times "mtvsrws" 2 } } */
+/* { dg-final { scan-assembler-times "lxvwsx"  1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-2.c	2016-06-09 23:28:23.000000000 +0000
@@ -0,0 +1,38 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+
+#include <altivec.h>
+
+vector float
+foo_r (float a)
+{
+  return (vector float) { a, a, a, a };			/* xscvdpspn/xxspltw */
+}
+
+vector float
+foo_r2 (float a)
+{
+  return vec_splats (a);				/* xscvdpspn/xxspltw */
+}
+
+vector float
+foo_g (float *a)
+{
+  float f = *a;
+
+  __asm__ (" # %0" : "+r" (f));
+  return (vector float) { f, f, f, f };			/* mtvsrws */
+}
+
+vector float
+foo_p (float *a)
+{
+  return (vector float) { *a, *a, *a, *a };		/* lxvwsx */
+}
+
+/* { dg-final { scan-assembler-times "xscvdpspn" 2 } } */
+/* { dg-final { scan-assembler-times "xxspltw"   2 } } */
+/* { dg-final { scan-assembler-times "mtvsrws"   1 } } */
+/* { dg-final { scan-assembler-times "lxvwsx"    1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-3.c	2016-06-09 23:28:23.000000000 +0000
@@ -0,0 +1,61 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+
+#include <altivec.h>
+
+typedef vector signed char	v16qi_t;
+typedef vector short		v8hi_t;
+typedef vector int		v4si_t;
+typedef vector long long	v2di_t;
+
+void v16qi_0a  (v16qi_t *p) { *p = (v16qi_t) { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; }
+void v8hi_0a   (v8hi_t  *p) { *p = (v8hi_t)  { 0, 0, 0, 0, 0, 0, 0, 0 }; }
+void v4si_0a   (v4si_t  *p) { *p = (v4si_t)  { 0, 0, 0, 0 }; }
+void v2di_0a   (v2di_t  *p) { *p = (v2di_t)  { 0, 0 }; }
+
+void v16qi_0b  (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)0); }
+void v8hi_0b   (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)0); }
+void v4si_0b   (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)0); }
+void v2di_0b   (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)0); }
+
+void v16qi_m1a (v16qi_t *p) { *p = (v16qi_t) { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }; }
+void v8hi_m1a  (v8hi_t  *p) { *p = (v8hi_t)  { -1, -1, -1, -1, -1, -1, -1, -1 }; }
+void v4si_m1a  (v4si_t  *p) { *p = (v4si_t)  { -1, -1, -1, -1 }; }
+void v2di_m1a  (v2di_t  *p) { *p = (v2di_t)  { -1, -1 }; }
+
+void v16qi_m1b (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)-1); }
+void v8hi_m1b  (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)-1); }
+void v4si_m1b  (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)-1); }
+void v2di_m1b  (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)-1); }
+
+void v16qi_5a  (v16qi_t *p) { *p = (v16qi_t) { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; }
+void v8hi_5a   (v8hi_t  *p) { *p = (v8hi_t)  { 5, 5, 5, 5, 5, 5, 5, 5 }; }
+void v4si_5a   (v4si_t  *p) { *p = (v4si_t)  { 5, 5, 5, 5 }; }
+void v2di_5a   (v2di_t  *p) { *p = (v2di_t)  { 5, 5 }; }
+
+void v16qi_5b  (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)5); }
+void v8hi_5b   (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)5); }
+void v4si_5b   (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)5); }
+void v2di_5b   (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)5); }
+
+void v16qi_33a (v16qi_t *p) { *p = (v16qi_t) { 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33 }; }
+void v8hi_33a  (v8hi_t  *p) { *p = (v8hi_t)  { 33, 33, 33, 33, 33, 33, 33, 33 }; }
+void v4si_33a  (v4si_t  *p) { *p = (v4si_t)  { 33, 33, 33, 33 }; }
+void v2di_33a  (v2di_t  *p) { *p = (v2di_t)  { 33, 33 }; }
+
+void v16qi_33b (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)33); }
+void v8hi_33b  (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)33); }
+void v4si_33b  (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)33); }
+void v2di_33b  (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)33); }
+
+/* { dg-final { scan-assembler     "xxspltib"     } } */
+/* { dg-final { scan-assembler     "vextsb2d"     } } */
+/* { dg-final { scan-assembler     "vextsb2w"     } } */
+/* { dg-final { scan-assembler     "vupk\[hl\]sb" } } */
+/* { dg-final { scan-assembler-not "lxvd2x"       } } */
+/* { dg-final { scan-assembler-not "lxvw4x"       } } */
+/* { dg-final { scan-assembler-not "lxv "         } } */
+/* { dg-final { scan-assembler-not "lxvx"         } } */
+/* { dg-final { scan-assembler-not "lvx"          } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-4.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-4.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-splat-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-splat-4.c	2016-06-09 23:28:23.000000000 +0000
@@ -0,0 +1,10 @@
+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+
+#include <altivec.h>
+
+vector long long foo (long long a) { return (vector long long) { a, a }; }
+
+/* { dg-final { scan-assembler "mtvsrdd" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-vneg.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-vneg.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-vneg.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-vneg.c	2016-06-01 23:23:42.000000000 +0000
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { powerpc64*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+/* Verify P9 vector negate instructions.  */
+
+vector long long v2di_neg (vector long long a) { return -a; }
+vector int v4si_neg (vector int a) { return -a; }
+
+/* { dg-final { scan-assembler "vnegd" } } */
+/* { dg-final { scan-assembler "vnegw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-vparity.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-vparity.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-vparity.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-vparity.c	2016-06-01 23:23:42.000000000 +0000
@@ -0,0 +1,107 @@
+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2 -mlra -mvsx-timode" } */
+
+#include <altivec.h>
+
+vector int
+parity_v4si_1s (vector int a)
+{
+  return vec_vprtyb (a);
+}
+
+vector int
+parity_v4si_2s (vector int a)
+{
+  return vec_vprtybw (a);
+}
+
+vector unsigned int
+parity_v4si_1u (vector unsigned int a)
+{
+  return vec_vprtyb (a);
+}
+
+vector unsigned int
+parity_v4si_2u (vector unsigned int a)
+{
+  return vec_vprtybw (a);
+}
+
+vector long long
+parity_v2di_1s (vector long long a)
+{
+  return vec_vprtyb (a);
+}
+
+vector long long
+parity_v2di_2s (vector long long a)
+{
+  return vec_vprtybd (a);
+}
+
+vector unsigned long long
+parity_v2di_1u (vector unsigned long long a)
+{
+  return vec_vprtyb (a);
+}
+
+vector unsigned long long
+parity_v2di_2u (vector unsigned long long a)
+{
+  return vec_vprtybd (a);
+}
+
+vector __int128_t
+parity_v1ti_1s (vector __int128_t a)
+{
+  return vec_vprtyb (a);
+}
+
+vector __int128_t
+parity_v1ti_2s (vector __int128_t a)
+{
+  return vec_vprtybq (a);
+}
+
+__int128_t
+parity_ti_3s (__int128_t a)
+{
+  return vec_vprtyb (a);
+}
+
+__int128_t
+parity_ti_4s (__int128_t a)
+{
+  return vec_vprtybq (a);
+}
+
+vector __uint128_t
+parity_v1ti_1u (vector __uint128_t a)
+{
+  return vec_vprtyb (a);
+}
+
+vector __uint128_t
+parity_v1ti_2u (vector __uint128_t a)
+{
+  return vec_vprtybq (a);
+}
+
+__uint128_t
+parity_ti_3u (__uint128_t a)
+{
+  return vec_vprtyb (a);
+}
+
+__uint128_t
+parity_ti_4u (__uint128_t a)
+{
+  return vec_vprtybq (a);
+}
+
+/* { dg-final { scan-assembler "vprtybd" } } */
+/* { dg-final { scan-assembler "vprtybq" } } */
+/* { dg-final { scan-assembler "vprtybw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-vpermr.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-vpermr.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/p9-vpermr.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/p9-vpermr.c	2016-06-01 23:23:42.000000000 +0000
@@ -0,0 +1,21 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+/* Test generation of VPERMR/XXPERMR on ISA 3.0 in little endian.  */
+
+#include <altivec.h>
+
+vector long long
+permute (vector long long *p, vector long long *q, vector unsigned char mask)
+{
+  vector long long a = *p;
+  vector long long b = *q;
+
+  /* Force a, b to be in altivec registers to select vpermr insn.  */
+  __asm__ (" # a: %x0, b: %x1" : "+v" (a), "+v" (b));
+
+  return vec_perm (a, b, mask);
+}
+
+/* { dg-final { scan-assembler "vpermr\|xxpermr" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr47755.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr47755.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr47755.c	2014-11-04 12:09:50.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr47755.c	2016-06-09 23:28:23.000000000 +0000
@@ -3,7 +3,7 @@
 /* { dg-require-effective-target powerpc_vsx_ok } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-O3 -mcpu=power7" } */
-/* { dg-final { scan-assembler "xxlxor" } } */
+/* { dg-final { scan-assembler "xxlxor\|vspltis\[bhw\]" } } */
 /* { dg-final { scan-assembler-not "lxvd2x" } } */
 /* { dg-final { scan-assembler-not "lxvw4x" } } */
 /* { dg-final { scan-assembler-not "lvx" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr68805.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr68805.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr68805.c	2015-12-17 01:01:24.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr68805.c	2016-06-01 22:09:14.000000000 +0000
@@ -1,6 +1,6 @@
 /* { dg-do compile { target powerpc64le-*-* } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-O2 -mvsx-timode -mcpu=power8" } */
+/* { dg-options "-O2 -mvsx-timode -mcpu=power8 -mlra" } */
 
 typedef struct bar {
   void *a;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr70963.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr70963.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr70963.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr70963.c	2016-05-15 21:48:43.000000000 +0000
@@ -0,0 +1,44 @@
+/* { dg-do run { target powerpc64*-*-* } } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8" } */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <altivec.h>
+
+static int failed;
+static void test (void);
+
+static void check (int result, const char *name)
+{
+  if (!result)
+    {
+      failed++;
+      printf ("fail %s\n", name);
+    }
+}
+    
+int main (void)
+{
+  test ();
+  if (failed)
+    abort ();
+  return 0;
+}
+
+vector double x = { 81.0, 76.0 };
+vector long long y = { 81, 76 };
+
+static void test()
+{
+  vector long long a = vec_cts (x, 0);
+  vector double b = vec_ctf (a, 0);
+  vector long long c = __builtin_vsx_xvcvdpuxds_scale (x, 0);
+  vector double d = vec_ctf (c, 0);
+  check (vec_all_eq (a, y), "vec_cts");
+  check (vec_all_eq (b, x), "vec_ctf");
+  check (vec_all_eq (c, y), "xvcvdpuxds");
+  check (vec_all_eq (d, x), "vec_ctf unsigned");
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71186.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71186.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71186.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71186.c	2016-06-09 23:28:23.000000000 +0000
@@ -0,0 +1,32 @@
+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+
+static unsigned short x[(16384/sizeof(unsigned short))] __attribute__ ((aligned (16)));
+static unsigned short y[(16384/sizeof(unsigned short))] __attribute__ ((aligned (16)));
+static unsigned short a;
+
+void obfuscate(void *a, ...);
+
+static void __attribute__((noinline)) do_one(void)
+{
+ unsigned long i;
+
+ obfuscate(x, y, &a);
+
+ for (i = 0; i < (16384/sizeof(unsigned short)); i++)
+  y[i] = a * x[i];
+
+ obfuscate(x, y, &a);
+}
+
+int main(void)
+{
+ unsigned long i;
+
+ for (i = 0; i < 1000000; i++)
+  do_one();
+
+ return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71493-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71493-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71493-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71493-1.c	2016-07-19 03:39:34.000000000 +0000
@@ -0,0 +1,13 @@
+/* { dg-do compile { target { powerpc*-*-linux* && ilp32 } } } */
+/* { dg-options "-O2 -msvr4-struct-return" } */
+
+struct S1 { float f; };
+
+struct S1 foo1 (void)
+{
+  struct S1 s = { 1.0f };
+  return s;
+}
+
+/* { dg-final { scan-assembler     "lwz" } } */
+/* { dg-final { scan-assembler-not "lfs" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71493-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71493-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71493-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71493-2.c	2016-07-19 03:39:34.000000000 +0000
@@ -0,0 +1,13 @@
+/* { dg-do compile { target { powerpc*-*-linux* && ilp32 } } } */
+/* { dg-options "-O2 -msvr4-struct-return" } */
+
+struct S2 { double d; };
+
+struct S2 foo2 (void)
+{
+  struct S2 s = { 1.0 };
+  return s;
+}
+
+/* { dg-final { scan-assembler     "lwz" } } */
+/* { dg-final { scan-assembler-not "lfd" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71656-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71656-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71656-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71656-1.c	2016-07-01 17:56:54.000000000 +0000
@@ -0,0 +1,20 @@
+/* Test for reload ICE arising from POWER9 Vector Dform code generation.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-O1 -mcpu=power9 -mpower9-dform-vector -mno-lra" } */
+
+typedef __attribute__((altivec(vector__))) int type_t;
+type_t
+func (type_t *src)
+{
+  asm volatile ("# force the base reg on the load below to be spilled"
+                   : /* no outputs */
+                   : /* no inputs */
+                   : "r0", "r3", "r4", "r5", "r6", "r7",
+                     "r8", "r9", "r10", "r11", "r12", "r14", "r15",
+                     "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+                     "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31");
+  return src[1];
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71656-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71656-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71656-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71656-2.c	2016-07-01 17:56:54.000000000 +0000
@@ -0,0 +1,47 @@
+/* Test for reload ICE arising from POWER9 Vector Dform code generation.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-O3 -mcpu=power9 -mpower9-dform-vector -mno-lra -funroll-loops -fno-aggressive-loop-optimizations" } */
+
+typedef double vec[3];
+struct vec_t
+{
+  vec x;
+  vec y;
+};
+int a, j, k, l, m, n, o, p, q;
+double b, i;
+vec c;
+double h[6];
+void func1 (vec);
+
+void
+func2 (double *b)
+{
+  for (; k; k--)
+    for (; j <= k;)
+      for (; m <= q; m++)
+	for (; n <= k; n++)
+	  for (; o <= l; o++)
+	    {
+	      j = p + m + n + o;
+	      h[j] = i;
+	    }
+}
+
+void
+func3 (void)
+{
+  struct vec_t d;
+  func1 (d.y);
+  func2 (&b);
+  for (; a;)
+    {
+      double *e = d.y, *g;
+      double f;
+      c[0] = g[0] + f * e[0];
+      c[1] = g[1] + f * e[1];
+      func1 (c);
+    }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71670.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71670.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71670.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71670.c	2016-07-04 09:52:38.000000000 +0000
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O1" } */
+
+volatile int a;
+int b;
+void fn1(void) { b + (long)b || a; }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71698.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71698.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71698.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71698.c	2016-07-01 16:06:26.000000000 +0000
@@ -0,0 +1,13 @@
+/* Test for a reload ICE arising from trying to direct move a TDmode value.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-require-effective-target dfp } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-O1 -mcpu=power9 -mno-lra" } */
+
+extern void testvad128 (int n, ...);
+void
+testitd128 (_Decimal128 g01d128)
+{
+  testvad128 (1, g01d128);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71720.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71720.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71720.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71720.c	2016-07-07 22:44:15.000000000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+/* Verify that we generate xxspltw <reg>,<reg>,0 for V4SFmode splat.  */
+
+vector float
+splat_v4sf (float f)
+{
+  return (vector float) { f, f, f, f };
+}
+
+/* { dg-final { scan-assembler "xscvdpspn "      } } */
+/* { dg-final { scan-assembler "xxspltw .*,.*,0" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71763.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71763.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71763.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71763.c	2016-07-15 20:58:23.000000000 +0000
@@ -0,0 +1,25 @@
+// PR target/71763
+// { dg-do compile }
+// { dg-options "-O1 -mvsx" }
+
+int a, b;
+float c;
+
+void fn2(void);
+
+void fn1(void)
+{
+        long d;
+
+        for (d = 3; d; d--) {
+                for (a = 0; a <= 1; a++) {
+                        b &= 1;
+                        if (b) {
+                                for (;;) {
+                                        fn2();
+                                        c = d;
+                                }
+                        }
+                }
+        }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71805.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71805.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/pr71805.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/pr71805.c	2016-07-12 18:12:11.000000000 +0000
@@ -0,0 +1,113 @@
+/* { dg-require-effective-target p9vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O3 --param tree-reassoc-width=1" } */
+
+/* Originally from gcc.dg/vect/pr45752.c.  */
+#include <stdarg.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern void abort (void);
+extern void exit (int);
+#ifdef __cplusplus
+}
+#endif
+
+#define M00 100
+#define M10 216
+#define M20 23
+#define M30 237
+#define M40 437
+
+#define M01 1322
+#define M11 13
+#define M21 27271
+#define M31 2280
+#define M41 284
+
+#define M02 74
+#define M12 191
+#define M22 500
+#define M32 111
+#define M42 1114
+
+#define M03 134
+#define M13 117
+#define M23 11
+#define M33 771
+#define M43 71
+
+#define M04 334
+#define M14 147
+#define M24 115
+#define M34 7716
+#define M44 16
+
+#define N 20
+
+void foo (unsigned int *__restrict__ pInput,
+          unsigned int *__restrict__ pOutput,
+          unsigned int *__restrict__ pInput2,
+          unsigned int *__restrict__ pOutput2)
+{
+  unsigned int i, a, b, c, d, e;
+
+  for (i = 0; i < N / 5; i++)
+    {
+       a = *pInput++;
+       b = *pInput++;
+       c = *pInput++;
+       d = *pInput++;
+       e = *pInput++;
+
+       *pOutput++ = M00 * a + M01 * b + M02 * c + M03 * d + M04 * e;
+       *pOutput++ = M10 * a + M11 * b + M12 * c + M13 * d + M14 * e;
+       *pOutput++ = M20 * a + M21 * b + M22 * c + M23 * d + M24 * e;
+       *pOutput++ = M30 * a + M31 * b + M32 * c + M33 * d + M34 * e;
+       *pOutput++ = M40 * a + M41 * b + M42 * c + M43 * d + M44 * e;
+
+
+       a = *pInput2++;
+       b = *pInput2++;
+       c = *pInput2++;
+       d = *pInput2++;
+       e = *pInput2++;
+
+       *pOutput2++ = M00 * a + M01 * b + M02 * c + M03 * d + M04 * e;
+       *pOutput2++ = M10 * a + M11 * b + M12 * c + M13 * d + M14 * e;
+       *pOutput2++ = M20 * a + M21 * b + M22 * c + M23 * d + M24 * e;
+       *pOutput2++ = M30 * a + M31 * b + M32 * c + M33 * d + M34 * e;
+       *pOutput2++ = M40 * a + M41 * b + M42 * c + M43 * d + M44 * e;
+
+    }
+}
+
+int main (int argc, const char* argv[])
+{
+  unsigned int input[N], output[N], i, input2[N], output2[N];
+  unsigned int check_results[N]
+    = {3208, 1334, 28764, 35679, 2789, 13028, 4754, 168364, 91254, 12399, 
+    22848, 8174, 307964, 146829, 22009, 32668, 11594, 447564, 202404, 31619 };
+  unsigned int check_results2[N]
+    = {7136, 2702, 84604, 57909, 6633, 16956, 6122, 224204, 113484, 16243, 
+    26776, 9542, 363804, 169059, 25853, 36596, 12962, 503404, 224634, 35463 };
+
+  for (i = 0; i < N; i++)
+    {
+      input[i] = i%256;
+      input2[i] = i + 2;
+      output[i] = 0;
+      output2[i] = 0;
+      __asm__ volatile ("");
+    }
+
+  foo (input, output, input2, output2);
+
+  for (i = 0; i < N; i++)
+    if (output[i] != check_results[i]
+        || output2[i] != check_results2[i])
+      abort ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/signbit-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/signbit-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/signbit-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/signbit-1.c	2016-07-12 19:51:09.000000000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2 -mfloat128" } */
+
+int do_signbit_kf (__float128 a) { return __builtin_signbit (a); }
+int do_signbit_if (__ibm128 a) { return __builtin_signbit (a); }
+int do_signbit_tf (long double a) { return __builtin_signbit (a); }
+
+/* { dg-final { scan-assembler-not   "stxvd2x"  } } */
+/* { dg-final { scan-assembler-not   "stxvw4x"  } } */
+/* { dg-final { scan-assembler-not   "stxsd"    } } */
+/* { dg-final { scan-assembler-not   "stxsdx"   } } */
+/* { dg-final { scan-assembler-times "mfvsrd" 3 } } */
+/* { dg-final { scan-assembler-times "srdi"   3 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/signbit-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/signbit-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/signbit-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/signbit-2.c	2016-07-12 19:51:09.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2 -mfloat128" } */
+
+int do_signbit_kf (__float128 *a) { return __builtin_signbit (*a); }
+
+/* { dg-final { scan-assembler-not   "stxvd2x"  } } */
+/* { dg-final { scan-assembler-not   "stxvw4x"  } } */
+/* { dg-final { scan-assembler-not   "stxsd"    } } */
+/* { dg-final { scan-assembler-not   "stxsdx"   } } */
+/* { dg-final { scan-assembler-not   "lxvd2x"   } } */
+/* { dg-final { scan-assembler-not   "lxvw4x"   } } */
+/* { dg-final { scan-assembler-not   "lxsd"     } } */
+/* { dg-final { scan-assembler-not   "lxsdx"    } } */
+/* { dg-final { scan-assembler-times "ld"     1 } } */
+/* { dg-final { scan-assembler-times "srdi"   1 } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/signbit-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/signbit-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/signbit-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/signbit-3.c	2016-07-12 19:51:09.000000000 +0000
@@ -0,0 +1,172 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-options "-mcpu=power7 -O2 -mfloat128 -lm" } */
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+#include <stddef.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <stdlib.h>
+#include <math.h>
+
+#if defined(__BIG_ENDIAN__)
+struct ieee128 {
+  uint64_t upper;
+  uint64_t lower;
+};
+
+#elif defined(__LITTLE_ENDIAN__)
+struct ieee128 {
+  uint64_t lower;
+  uint64_t upper;
+};
+
+#else
+#error "Unknown system"
+#endif
+
+union ieee_union {
+  __float128 f128;
+  struct ieee128 st128;
+};
+
+#ifdef DEBUG
+static int num_errors = 0;
+
+__attribute__((__noinline__))
+static void
+failure (int expected, int got, __float128 x)
+{
+  unsigned sign;
+  unsigned exponent;
+  uint64_t mantissa1;
+  uint64_t mantissa2;
+  uint64_t upper;
+  uint64_t lower;
+
+  union ieee_union u;
+
+  u.f128 = x;
+  upper  = u.st128.upper;
+  lower  = u.st128.lower;
+
+  sign      = (unsigned)((upper >> 63) & 1);
+  exponent  = (unsigned)((upper >> 48) & ((((uint64_t)1) << 16) - 1));
+  mantissa1 = (upper & ((((uint64_t)1) << 48) - 1));
+  mantissa2 = lower;
+
+  printf ("Expected %d, got %d, %c 0x%.4x 0x%.12" PRIx64 " 0x%.16" PRIx64,
+	  expected, got,
+	  sign ? '-' : '+',
+	  exponent,
+	  mantissa1,
+	  mantissa2);
+
+  num_errors++;
+}
+
+#else
+
+#define failure(E, G, F) abort ()
+#endif
+
+__attribute__((__noinline__))
+static void
+test_signbit_arg (__float128 f128, int expected)
+{
+  int sign = __builtin_signbit (f128);
+
+  if ((expected != 0 && sign == 0)
+      || (expected == 0 && sign != 0))
+    failure (f128, expected, sign);
+}
+
+__attribute__((__noinline__))
+static void
+test_signbit_mem (__float128 *ptr, int expected)
+{
+  int sign = __builtin_signbit (*ptr);
+
+  if ((expected != 0 && sign == 0)
+      || (expected == 0 && sign != 0))
+    failure (*ptr, expected, sign);
+}
+
+__attribute__((__noinline__))
+static void
+test_signbit_gpr (__float128 *ptr, int expected)
+{
+  __float128 f128 = *ptr;
+  int sign;
+
+  __asm__ (" # %0" : "+r" (f128));
+
+  sign = __builtin_signbit (f128);
+  if ((expected != 0 && sign == 0)
+      || (expected == 0 && sign != 0))
+    failure (f128, expected, sign);
+}
+
+__attribute__((__noinline__))
+static void
+test_signbit (__float128 f128, int expected)
+{
+#ifdef DEBUG
+  union ieee_union u;
+  u.f128 = f128;
+  printf ("Expecting %d, trying %-5g "
+	  "(0x%.16" PRIx64 " 0x%.16" PRIx64 ")\n",
+	  expected, (double)f128,
+	  u.st128.upper, u.st128.lower);
+#endif
+
+  test_signbit_arg (f128,  expected);
+  test_signbit_mem (&f128, expected);
+  test_signbit_gpr (&f128, expected);
+}
+
+int
+main (void)
+{
+  union ieee_union u;
+
+  test_signbit (+0.0q, 0);
+  test_signbit (+1.0q, 0);
+
+  test_signbit (-0.0q, 1);
+  test_signbit (-1.0q, 1);
+
+  test_signbit (__builtin_copysign (__builtin_infq (), +1.0q), 0);
+  test_signbit (__builtin_copysign (__builtin_infq (), -1.0q), 1);
+
+  test_signbit (__builtin_copysign (__builtin_nanq (""), +1.0q), 0);
+  test_signbit (__builtin_copysign (__builtin_nanq (""), -1.0q), 1);
+
+  /* force the bottom double word to have specific bits in the 'sign' bit to
+     make sure we are picking the right word.  */
+  u.f128 = 1.0q;
+  u.st128.lower = 0ULL;
+  test_signbit (u.f128, 0);
+
+  u.st128.lower = ~0ULL;
+  test_signbit (u.f128, 0);
+
+  u.f128 = -1.0q;
+  u.st128.lower = 0ULL;
+  test_signbit (u.f128, 1);
+
+  u.st128.lower = ~0ULL;
+  test_signbit (u.f128, 1);
+
+#ifdef DEBUG
+  printf ("%d error(s) were found\n", num_errors);
+  if (num_errors)
+    return num_errors;
+#endif
+
+  return 0;
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-0.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-0.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-0.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-0.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned int
+doAbsoluteDifferenceUnsignedInt (__vector unsigned int *p,
+				 __vector unsigned int *q)
+{
+  __vector unsigned int source_1, source_2;
+  __vector unsigned int result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = __builtin_vec_vadu (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsduw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-1.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned int
+doAbsoluteDifferenceUnsignedIntMacro (__vector unsigned int *p,
+				      __vector unsigned int *q)
+{
+  __vector unsigned int result, source_1, source_2;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = vec_absd (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsduw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-2.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned short
+doAbsoluteDifferenceUnsignedShort (__vector unsigned short *p,
+				   __vector unsigned short *q)
+{
+  __vector unsigned short source_1, source_2;
+  __vector unsigned short result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = __builtin_vec_vadu (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsduh" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-3.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned short
+doAbsoluteDifferenceUnsignedShortMacro (__vector unsigned short *p,
+				      __vector unsigned short *q)
+{
+  __vector unsigned short result, source_1, source_2;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = vec_absd (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsduh" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-4.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-4.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-4.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned char
+doAbsoluteDifferenceUnsignedChar (__vector unsigned char *p,
+				  __vector unsigned char *q)
+{
+  __vector unsigned char source_1, source_2;
+  __vector unsigned char result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = __builtin_vec_vadu (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsdub" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-5.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-5.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdu-5.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdu-5.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned char
+doAbsoluteDifferenceUnsignedCharMacro (__vector unsigned char *p,
+				       __vector unsigned char *q)
+{
+  __vector unsigned char result, source_1, source_2;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = vec_absd (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsdub" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdub-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdub-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdub-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdub-1.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned char
+doAbsoluteDifferenceUnsigned (__vector unsigned char *p,
+			      __vector unsigned char *q)
+{
+  __vector unsigned char source_1, source_2;
+  __vector unsigned char uc_result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  uc_result = __builtin_vec_vadub (source_1, source_2);
+  return uc_result;
+}
+
+/* { dg-final { scan-assembler "vabsdub" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdub-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdub-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsdub-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsdub-2.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned char
+doAbsoluteDifferenceUnsigned (__vector unsigned char *p,
+			      __vector unsigned char *q)
+{
+  __vector unsigned char source_1, source_2;
+  __vector unsigned char uc_result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  uc_result = vec_absdb (source_1, source_2);
+  return uc_result;
+}
+
+/* { dg-final { scan-assembler "vabsdub" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduh-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduh-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduh-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduh-1.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned short
+doAbsoluteDifferenceUnsigned (__vector unsigned short *p,
+			      __vector unsigned short *q)
+{
+  __vector unsigned short source_1, source_2;
+  __vector unsigned short us_result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  us_result = __builtin_vec_vaduh (source_1, source_2);
+  return us_result;
+}
+
+/* { dg-final { scan-assembler "vabsduh" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduh-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduh-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduh-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduh-2.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned short
+doAbsoluteDifferenceUnsignedMacro (__vector unsigned short *p,
+				   __vector unsigned short *q)
+{
+  __vector unsigned short result, source_1, source_2;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = vec_absdh (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsduh" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduw-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduw-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduw-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduw-1.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned int
+doAbsoluteDifferenceUnsigned (__vector unsigned int *p,
+			      __vector unsigned int *q)
+{
+  __vector unsigned int source_1, source_2;
+  __vector unsigned int ui_result;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  ui_result = __builtin_vec_vaduw (source_1, source_2);
+  return ui_result;
+}
+
+/* { dg-final { scan-assembler "vabsduw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduw-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduw-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vadsduw-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vadsduw-2.c	2016-06-30 17:07:42.000000000 +0000
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+/* This test should succeed on both 32- and 64-bit configurations.  */
+#include <altivec.h>
+
+__vector unsigned int
+doAbsoluteDifferenceUnsignedMacro (__vector unsigned int *p,
+				   __vector unsigned int *q)
+{
+  __vector unsigned int result, source_1, source_2;
+
+  source_1 = *p;
+  source_2 = *q;
+
+  result = vec_absdw (source_1, source_2);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vabsduw" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vslv-0.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vslv-0.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vslv-0.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vslv-0.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+__vector unsigned char
+doCharShiftLeft (__vector unsigned char *p, __vector unsigned char *q)
+{
+  __vector unsigned char result, input, shift_distance;
+  result = __builtin_vec_vslv (input, shift_distance);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vslv" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vslv-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vslv-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vslv-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vslv-1.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+__vector unsigned char
+doCharShiftLeft (__vector unsigned char *p, __vector unsigned char *q)
+{
+  __vector unsigned char result, input, shift_distance;
+  result = vec_slv (input, shift_distance);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vslv" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsrv-0.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsrv-0.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsrv-0.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsrv-0.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+__vector unsigned char
+doCharShiftLeft (__vector unsigned char *p, __vector unsigned char *q)
+{
+  __vector unsigned char result, input, shift_distance;
+  result = __builtin_vec_vsrv (input, shift_distance);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vsrv" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsrv-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsrv-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsrv-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsrv-1.c	2016-07-01 20:09:06.000000000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-mcpu=power9" } */
+
+#include <altivec.h>
+
+__vector unsigned char
+doCharShiftLeft (__vector unsigned char *p, __vector unsigned char *q)
+{
+  __vector unsigned char result, input, shift_distance;
+  result = vec_srv (input, shift_distance);
+  return result;
+}
+
+/* { dg-final { scan-assembler "vsrv" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-1.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-1.c	2016-05-30 17:09:22.000000000 +0000
@@ -0,0 +1,143 @@
+/* { dg-do compile { target { powerpc64le*-*-* } } } */
+/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O0" } */
+/* { dg-final { scan-assembler-times "lxvd2x" 18 } } */
+/* { dg-final { scan-assembler-times "lxvw4x" 6 } } */
+/* { dg-final { scan-assembler-times "stxvd2x" 18 } } */
+/* { dg-final { scan-assembler-times "stxvw4x" 6 } } */
+/* { dg-final { scan-assembler-times "xxpermdi" 24 } } */
+
+#include <altivec.h>
+
+extern vector double vd, *vdp;
+extern vector signed long long vsll, *vsllp;
+extern vector unsigned long long vull, *vullp;
+extern vector float vf, *vfp;
+extern vector signed int vsi, *vsip;
+extern vector unsigned int vui, *vuip;
+extern double *dp;
+extern signed long long *sllp;
+extern unsigned long long *ullp;
+extern float *fp;
+extern signed int *sip;
+extern unsigned int *uip;
+
+void foo0 (void)
+{
+  vd = vec_xl (0, vdp);
+}
+
+void foo1 (void)
+{
+  vsll = vec_xl (0, vsllp);
+}
+
+void foo2 (void)
+{
+  vull = vec_xl (0, vullp);
+}
+
+void foo3 (void)
+{
+  vf = vec_xl (0, vfp);
+}
+
+void foo4 (void)
+{
+  vsi = vec_xl (0, vsip);
+}
+
+void foo5 (void)
+{
+  vui = vec_xl (0, vuip);
+}
+
+void foo6 (void)
+{
+  vec_xst (vd, 0, vdp);
+}
+
+void foo7 (void)
+{
+  vec_xst (vsll, 0, vsllp);
+}
+
+void foo8 (void)
+{
+  vec_xst (vull, 0, vullp);
+}
+
+void foo9 (void)
+{
+  vec_xst (vf, 0, vfp);
+}
+
+void foo10 (void)
+{
+  vec_xst (vsi, 0, vsip);
+}
+
+void foo11 (void)
+{
+  vec_xst (vui, 0, vuip);
+}
+
+void foo20 (void)
+{
+  vd = vec_xl (0, dp);
+}
+
+void foo21 (void)
+{
+  vsll = vec_xl (0, sllp);
+}
+
+void foo22 (void)
+{
+  vull = vec_xl (0, ullp);
+}
+
+void foo23 (void)
+{
+  vf = vec_xl (0, fp);
+}
+
+void foo24 (void)
+{
+  vsi = vec_xl (0, sip);
+}
+
+void foo25 (void)
+{
+  vui = vec_xl (0, uip);
+}
+
+void foo26 (void)
+{
+  vec_xst (vd, 0, dp);
+}
+
+void foo27 (void)
+{
+  vec_xst (vsll, 0, sllp);
+}
+
+void foo28 (void)
+{
+  vec_xst (vull, 0, ullp);
+}
+
+void foo29 (void)
+{
+  vec_xst (vf, 0, fp);
+}
+
+void foo30 (void)
+{
+  vec_xst (vsi, 0, sip);
+}
+
+void foo31 (void)
+{
+  vec_xst (vui, 0, uip);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-2.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-2.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-2.c	2016-06-16 16:27:24.000000000 +0000
@@ -0,0 +1,236 @@
+/* { dg-do compile { target { powerpc64le*-*-* } } } */
+/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O0" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } { "*" } { "" } } */
+/* { dg-final { scan-assembler-times "lxvd2x" 6 } } */
+/* { dg-final { scan-assembler-times "lxvw4x" 6 } } */
+/* { dg-final { scan-assembler-times "lxvh8x" 4 } } */
+/* { dg-final { scan-assembler-times "lxvb16x" 4 } } */
+/* { dg-final { scan-assembler-times "stxvd2x" 6 } } */
+/* { dg-final { scan-assembler-times "stxvw4x" 6 } } */
+/* { dg-final { scan-assembler-times "stxvh8x" 4 } } */
+/* { dg-final { scan-assembler-times "stxvb16x" 4 } } */
+
+#include <altivec.h>
+
+extern vector double vd, *vdp;
+extern vector signed long long vsll, *vsllp;
+extern vector unsigned long long vull, *vullp;
+extern vector float vf, *vfp;
+extern vector signed int vsi, *vsip;
+extern vector unsigned int vui, *vuip;
+extern vector signed short vss, *vssp;
+extern vector unsigned short vus, *vusp;
+extern vector signed char vsc, *vscp;
+extern vector unsigned char vuc, *vucp;
+extern double *dp;
+extern signed long long *sllp;
+extern unsigned long long *ullp;
+extern float *fp;
+extern signed int *sip;
+extern unsigned int *uip;
+extern signed short *ssp;
+extern unsigned short *usp;
+extern signed char *scp;
+extern unsigned char *ucp;
+
+void foo0 (void)
+{
+  vd = vec_xl (0, vdp);
+}
+
+void foo1 (void)
+{
+  vsll = vec_xl (0, vsllp);
+}
+
+void foo2 (void)
+{
+  vull = vec_xl (0, vullp);
+}
+
+void foo3 (void)
+{
+  vf = vec_xl (0, vfp);
+}
+
+void foo4 (void)
+{
+  vsi = vec_xl (0, vsip);
+}
+
+void foo5 (void)
+{
+  vui = vec_xl (0, vuip);
+}
+
+void foo6 (void)
+{
+  vss = vec_xl (0, vssp);
+}
+
+void foo7 (void)
+{
+  vus = vec_xl (0, vusp);
+}
+
+void foo8 (void)
+{
+  vsc = vec_xl (0, vscp);
+}
+
+void foo9 (void)
+{
+  vuc = vec_xl (0, vucp);
+}
+
+void foo10 (void)
+{
+  vec_xst (vd, 0, vdp);
+}
+
+void foo11 (void)
+{
+  vec_xst (vsll, 0, vsllp);
+}
+
+void foo12 (void)
+{
+  vec_xst (vull, 0, vullp);
+}
+
+void foo13 (void)
+{
+  vec_xst (vf, 0, vfp);
+}
+
+void foo14 (void)
+{
+  vec_xst (vsi, 0, vsip);
+}
+
+void foo15 (void)
+{
+  vec_xst (vui, 0, vuip);
+}
+
+void foo16 (void)
+{
+  vec_xst (vss, 0, vssp);
+}
+
+void foo17 (void)
+{
+  vec_xst (vus, 0, vusp);
+}
+
+void foo18 (void)
+{
+  vec_xst (vsc, 0, vscp);
+}
+
+void foo19 (void)
+{
+  vec_xst (vuc, 0, vucp);
+}
+
+void foo20 (void)
+{
+  vd = vec_xl (0, dp);
+}
+
+void foo21 (void)
+{
+  vsll = vec_xl (0, sllp);
+}
+
+void foo22 (void)
+{
+  vull = vec_xl (0, ullp);
+}
+
+void foo23 (void)
+{
+  vf = vec_xl (0, fp);
+}
+
+void foo24 (void)
+{
+  vsi = vec_xl (0, sip);
+}
+
+void foo25 (void)
+{
+  vui = vec_xl (0, uip);
+}
+
+void foo26 (void)
+{
+  vss = vec_xl (0, ssp);
+}
+
+void foo27 (void)
+{
+  vus = vec_xl (0, usp);
+}
+
+void foo28 (void)
+{
+  vsc = vec_xl (0, scp);
+}
+
+void foo29 (void)
+{
+  vuc = vec_xl (0, ucp);
+}
+
+void foo30 (void)
+{
+  vec_xst (vd, 0, dp);
+}
+
+void foo31 (void)
+{
+  vec_xst (vsll, 0, sllp);
+}
+
+void foo32 (void)
+{
+  vec_xst (vull, 0, ullp);
+}
+
+void foo33 (void)
+{
+  vec_xst (vf, 0, fp);
+}
+
+void foo34 (void)
+{
+  vec_xst (vsi, 0, sip);
+}
+
+void foo35 (void)
+{
+  vec_xst (vui, 0, uip);
+}
+
+void foo36 (void)
+{
+  vec_xst (vss, 0, ssp);
+}
+
+void foo37 (void)
+{
+  vec_xst (vus, 0, usp);
+}
+
+void foo38 (void)
+{
+  vec_xst (vsc, 0, scp);
+}
+
+void foo39 (void)
+{
+  vec_xst (vuc, 0, ucp);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-3.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-3.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-3.c	2016-05-30 17:09:22.000000000 +0000
@@ -0,0 +1,142 @@
+/* { dg-do compile { target { powerpc64-*-* } } } */
+/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O0" } */
+/* { dg-final { scan-assembler-times "lxvd2x" 16 } } */
+/* { dg-final { scan-assembler-times "lxvw4x" 8 } } */
+/* { dg-final { scan-assembler-times "stxvd2x" 16 } } */
+/* { dg-final { scan-assembler-times "stxvw4x" 8 } } */
+
+#include <altivec.h>
+
+extern vector double vd, *vdp;
+extern vector signed long long vsll, *vsllp;
+extern vector unsigned long long vull, *vullp;
+extern vector float vf, *vfp;
+extern vector signed int vsi, *vsip;
+extern vector unsigned int vui, *vuip;
+extern double *dp;
+extern signed long long *sllp;
+extern unsigned long long *ullp;
+extern float *fp;
+extern signed int *sip;
+extern unsigned int *uip;
+
+void foo0 (void)
+{
+  vd = vec_xl (0, vdp);
+}
+
+void foo1 (void)
+{
+  vsll = vec_xl (0, vsllp);
+}
+
+void foo2 (void)
+{
+  vull = vec_xl (0, vullp);
+}
+
+void foo3 (void)
+{
+  vf = vec_xl (0, vfp);
+}
+
+void foo4 (void)
+{
+  vsi = vec_xl (0, vsip);
+}
+
+void foo5 (void)
+{
+  vui = vec_xl (0, vuip);
+}
+
+void foo6 (void)
+{
+  vec_xst (vd, 0, vdp);
+}
+
+void foo7 (void)
+{
+  vec_xst (vsll, 0, vsllp);
+}
+
+void foo8 (void)
+{
+  vec_xst (vull, 0, vullp);
+}
+
+void foo9 (void)
+{
+  vec_xst (vf, 0, vfp);
+}
+
+void foo10 (void)
+{
+  vec_xst (vsi, 0, vsip);
+}
+
+void foo11 (void)
+{
+  vec_xst (vui, 0, vuip);
+}
+
+void foo20 (void)
+{
+  vd = vec_xl (0, dp);
+}
+
+void foo21 (void)
+{
+  vsll = vec_xl (0, sllp);
+}
+
+void foo22 (void)
+{
+  vull = vec_xl (0, ullp);
+}
+
+void foo23 (void)
+{
+  vf = vec_xl (0, fp);
+}
+
+void foo24 (void)
+{
+  vsi = vec_xl (0, sip);
+}
+
+void foo25 (void)
+{
+  vui = vec_xl (0, uip);
+}
+
+void foo26 (void)
+{
+  vec_xst (vd, 0, dp);
+}
+
+void foo27 (void)
+{
+  vec_xst (vsll, 0, sllp);
+}
+
+void foo28 (void)
+{
+  vec_xst (vull, 0, ullp);
+}
+
+void foo29 (void)
+{
+  vec_xst (vf, 0, fp);
+}
+
+void foo30 (void)
+{
+  vec_xst (vsi, 0, sip);
+}
+
+void foo31 (void)
+{
+  vec_xst (vui, 0, uip);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-4.c gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-4.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/powerpc/vsx-elemrev-4.c	2016-06-16 16:27:24.000000000 +0000
@@ -0,0 +1,230 @@
+/* { dg-do compile { target { powerpc64-*-* } } } */
+/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O0" } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "" { powerpc*-*-aix* } { "*" } { "" } } */
+/* { dg-final { scan-assembler-times "lxvx" 40 } } */
+/* { dg-final { scan-assembler-times "stxvx" 40 } } */
+
+#include <altivec.h>
+
+extern vector double vd, *vdp;
+extern vector signed long long vsll, *vsllp;
+extern vector unsigned long long vull, *vullp;
+extern vector float vf, *vfp;
+extern vector signed int vsi, *vsip;
+extern vector unsigned int vui, *vuip;
+extern vector signed short vss, *vssp;
+extern vector unsigned short vus, *vusp;
+extern vector signed char vsc, *vscp;
+extern vector unsigned char vuc, *vucp;
+extern double *dp;
+extern signed long long *sllp;
+extern unsigned long long *ullp;
+extern float *fp;
+extern signed int *sip;
+extern unsigned int *uip;
+extern signed short *ssp;
+extern unsigned short *usp;
+extern signed char *scp;
+extern unsigned char *ucp;
+
+void foo0 (void)
+{
+  vd = vec_xl (0, vdp);
+}
+
+void foo1 (void)
+{
+  vsll = vec_xl (0, vsllp);
+}
+
+void foo2 (void)
+{
+  vull = vec_xl (0, vullp);
+}
+
+void foo3 (void)
+{
+  vf = vec_xl (0, vfp);
+}
+
+void foo4 (void)
+{
+  vsi = vec_xl (0, vsip);
+}
+
+void foo5 (void)
+{
+  vui = vec_xl (0, vuip);
+}
+
+void foo6 (void)
+{
+  vss = vec_xl (0, vssp);
+}
+
+void foo7 (void)
+{
+  vus = vec_xl (0, vusp);
+}
+
+void foo8 (void)
+{
+  vsc = vec_xl (0, vscp);
+}
+
+void foo9 (void)
+{
+  vuc = vec_xl (0, vucp);
+}
+
+void foo10 (void)
+{
+  vec_xst (vd, 0, vdp);
+}
+
+void foo11 (void)
+{
+  vec_xst (vsll, 0, vsllp);
+}
+
+void foo12 (void)
+{
+  vec_xst (vull, 0, vullp);
+}
+
+void foo13 (void)
+{
+  vec_xst (vf, 0, vfp);
+}
+
+void foo14 (void)
+{
+  vec_xst (vsi, 0, vsip);
+}
+
+void foo15 (void)
+{
+  vec_xst (vui, 0, vuip);
+}
+
+void foo16 (void)
+{
+  vec_xst (vss, 0, vssp);
+}
+
+void foo17 (void)
+{
+  vec_xst (vus, 0, vusp);
+}
+
+void foo18 (void)
+{
+  vec_xst (vsc, 0, vscp);
+}
+
+void foo19 (void)
+{
+  vec_xst (vuc, 0, vucp);
+}
+
+void foo20 (void)
+{
+  vd = vec_xl (0, dp);
+}
+
+void foo21 (void)
+{
+  vsll = vec_xl (0, sllp);
+}
+
+void foo22 (void)
+{
+  vull = vec_xl (0, ullp);
+}
+
+void foo23 (void)
+{
+  vf = vec_xl (0, fp);
+}
+
+void foo24 (void)
+{
+  vsi = vec_xl (0, sip);
+}
+
+void foo25 (void)
+{
+  vui = vec_xl (0, uip);
+}
+
+void foo26 (void)
+{
+  vss = vec_xl (0, ssp);
+}
+
+void foo27 (void)
+{
+  vus = vec_xl (0, usp);
+}
+
+void foo28 (void)
+{
+  vsc = vec_xl (0, scp);
+}
+
+void foo29 (void)
+{
+  vuc = vec_xl (0, ucp);
+}
+
+void foo30 (void)
+{
+  vec_xst (vd, 0, dp);
+}
+
+void foo31 (void)
+{
+  vec_xst (vsll, 0, sllp);
+}
+
+void foo32 (void)
+{
+  vec_xst (vull, 0, ullp);
+}
+
+void foo33 (void)
+{
+  vec_xst (vf, 0, fp);
+}
+
+void foo34 (void)
+{
+  vec_xst (vsi, 0, sip);
+}
+
+void foo35 (void)
+{
+  vec_xst (vui, 0, uip);
+}
+
+void foo36 (void)
+{
+  vec_xst (vss, 0, ssp);
+}
+
+void foo37 (void)
+{
+  vec_xst (vus, 0, usp);
+}
+
+void foo38 (void)
+{
+  vec_xst (vsc, 0, scp);
+}
+
+void foo39 (void)
+{
+  vec_xst (vuc, 0, ucp);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/s390/nolrl-1.c gcc-6-20160721/gcc/testsuite/gcc.target/s390/nolrl-1.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/s390/nolrl-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/s390/nolrl-1.c	2016-07-18 10:52:23.000000000 +0000
@@ -0,0 +1,19 @@
+/* Make sure the compiler does not try to use a relative long
+   instruction to load the string since it might not meet the
+   alignment requirements of the instruction.  */
+
+/* { dg-do compile } */
+/* { dg-options "-march=z10 -O3 -mzarch" } */
+
+extern void foo (char*);
+
+void
+bar ()
+{
+    unsigned char z[32];
+
+    __builtin_memcpy (z, "\001\000\000\000", 4);
+    foo (z);
+}
+
+/* { dg-final { scan-assembler-not "lrl" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/sparc/fpcmp.c gcc-6-20160721/gcc/testsuite/gcc.target/sparc/fpcmp.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/sparc/fpcmp.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/sparc/fpcmp.c	2016-06-08 13:34:25.000000000 +0000
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-mvis4" } */
+
+typedef unsigned char vec8 __attribute__((vector_size(8)));
+
+long test_fpcmple8 (vec8 a, vec8 b)
+{
+  return __builtin_vis_fpcmple8 (a, b);
+}
+
+long test_fpcmpgt8 (vec8 a, vec8 b)
+{
+  return __builtin_vis_fpcmpgt8 (a, b);
+}
+
+/* { dg-final { scan-assembler "fpcmple8\t%" } } */
+/* { dg-final { scan-assembler "fpcmpgt8\t%" } } */
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/sparc/fpcmpu.c gcc-6-20160721/gcc/testsuite/gcc.target/sparc/fpcmpu.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/sparc/fpcmpu.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/sparc/fpcmpu.c	2016-06-08 13:34:25.000000000 +0000
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-mvis4" } */
+
+
+typedef short vec16 __attribute__((vector_size(8)));
+typedef int vec32 __attribute__((vector_size(8)));
+
+long test_fpcmpule16 (vec16 a, vec16 b)
+{
+  return __builtin_vis_fpcmpule16 (a, b);
+}
+
+long test_fpcmpugt16 (vec16 a, vec16 b)
+{
+  return __builtin_vis_fpcmpugt16 (a, b);
+}
+
+long test_fpcmpule32 (vec32 a, vec32 b)
+{
+  return __builtin_vis_fpcmpule32 (a, b);
+}
+
+long test_fpcmpugt32 (vec32 a, vec32 b)
+{
+  return __builtin_vis_fpcmpugt32 (a, b);
+}
+
+/* { dg-final { scan-assembler "fpcmpule16\t%" } } */
+/* { dg-final { scan-assembler "fpcmpugt16\t%" } } */
+/* { dg-final { scan-assembler "fpcmpule32\t%" } } */
+/* { dg-final { scan-assembler "fpcmpugt32\t%" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gcc.target/sparc/vis4misc.c gcc-6-20160721/gcc/testsuite/gcc.target/sparc/vis4misc.c
--- gcc-6.1.0/gcc/testsuite/gcc.target/sparc/vis4misc.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gcc.target/sparc/vis4misc.c	2016-06-08 13:34:25.000000000 +0000
@@ -0,0 +1,126 @@
+/* { dg-do compile } */
+/* { dg-options "-mvis4" } */
+typedef int __v2si __attribute__((vector_size(8)));
+typedef short __v4hi __attribute__((vector_size(8)));
+typedef unsigned char __v8qi __attribute__((vector_size(8)));
+
+__v8qi test_fpadd8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpadd8 (x, y);
+}
+
+__v8qi test_fpadds8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpadds8 (x, y);
+}
+
+__v8qi test_fpaddus8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpaddus8 (x, y);
+}
+
+__v4hi test_fpaddus16 (__v4hi x, __v4hi y)
+{
+  return __builtin_vis_fpaddus16 (x, y);
+}
+
+__v8qi test_fpsub8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpsub8 (x, y);
+}
+
+__v8qi test_fpsubs8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpsubs8 (x, y);
+}
+
+__v8qi test_fpsubus8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpsubus8 (x, y);
+}
+
+__v4hi test_fpsubus16 (__v4hi x, __v4hi y)
+{
+  return __builtin_vis_fpsubus16 (x, y);
+}
+
+__v8qi test_fpmax8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpmax8 (x, y);
+}
+
+__v4hi test_fpmax16 (__v4hi x, __v4hi y)
+{
+  return __builtin_vis_fpmax16 (x, y);
+}
+
+__v2si test_fpmax32 (__v2si x, __v2si y)
+{
+  return __builtin_vis_fpmax32 (x, y);
+}
+
+__v8qi test_fpmaxu8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpmaxu8 (x, y);
+}
+
+__v4hi test_fpmaxu16 (__v4hi x, __v4hi y)
+{
+  return __builtin_vis_fpmaxu16 (x, y);
+}
+
+__v2si test_fpmaxu32 (__v2si x, __v2si y)
+{
+  return __builtin_vis_fpmaxu32 (x, y);
+}
+
+__v8qi test_fpmin8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpmin8 (x, y);
+}
+
+__v4hi test_fpmin16 (__v4hi x, __v4hi y)
+{
+  return __builtin_vis_fpmin16 (x, y);
+}
+
+__v2si test_fpmin32 (__v2si x, __v2si y)
+{
+  return __builtin_vis_fpmin32 (x, y);
+}
+
+__v8qi test_fpminu8 (__v8qi x, __v8qi y)
+{
+  return __builtin_vis_fpminu8 (x, y);
+}
+
+__v4hi test_fpminu16 (__v4hi x, __v4hi y)
+{
+  return __builtin_vis_fpminu16 (x, y);
+}
+
+__v2si test_fpminu32 (__v2si x, __v2si y)
+{
+  return __builtin_vis_fpminu32 (x, y);
+}
+
+/* { dg-final { scan-assembler "fpadd8\t%" } } */
+/* { dg-final { scan-assembler "fpadds8\t%" } } */
+/* { dg-final { scan-assembler "fpaddus8\t%" } } */
+/* { dg-final { scan-assembler "fpaddus16\t%" } } */
+/* { dg-final { scan-assembler "fpsub8\t%" } } */
+/* { dg-final { scan-assembler "fpsubs8\t%" } } */
+/* { dg-final { scan-assembler "fpsubus8\t%" } } */
+/* { dg-final { scan-assembler "fpsubus16\t%" } } */
+/* { dg-final { scan-assembler "fpmax8\t%" } } */
+/* { dg-final { scan-assembler "fpmax16\t%" } } */
+/* { dg-final { scan-assembler "fpmax32\t%" } } */
+/* { dg-final { scan-assembler "fpmaxu8\t%" } } */
+/* { dg-final { scan-assembler "fpmaxu16\t%" } } */
+/* { dg-final { scan-assembler "fpmaxu32\t%" } } */
+/* { dg-final { scan-assembler "fpmin8\t%" } } */
+/* { dg-final { scan-assembler "fpmin16\t%" } } */
+/* { dg-final { scan-assembler "fpmin32\t%" } } */
+/* { dg-final { scan-assembler "fpminu8\t%" } } */
+/* { dg-final { scan-assembler "fpminu16\t%" } } */
+/* { dg-final { scan-assembler "fpminu32\t%" } } */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/array_constructor_49.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/array_constructor_49.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/array_constructor_49.f90	2015-05-29 08:20:29.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/array_constructor_49.f90	2016-06-12 14:04:08.000000000 +0000
@@ -6,7 +6,7 @@
 program t
   integer :: ndim=2, ndfp=4, i
   character (len=8) :: line
-  write (unit=line,fmt='(4I2)'), (/ ( i, i = 1, ndfp ) /) + ndim
+  write (unit=line,fmt='(4I2)') (/ ( i, i = 1, ndfp ) /) + ndim
   if (line /= ' 3 4 5 6') call abort
 end program t
 ! { dg-final { scan-tree-dump-times "__var" 3 "original" } }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/class_array_22.f03 gcc-6-20160721/gcc/testsuite/gfortran.dg/class_array_22.f03
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/class_array_22.f03	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/class_array_22.f03	2016-06-05 18:09:27.000000000 +0000
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-options "-frepack-arrays " }
+!
+! Original class_array_11.f03 but with -frepack-arrays a new
+! ICE was produced reported in
+! PR fortran/69659
+!
+! Original testcase by Ian Harvey <ian_harvey@bigpond.com>
+! Reduced by Janus Weil <Janus@gcc.gnu.org>
+
+  IMPLICIT NONE
+
+  TYPE :: ParentVector
+    INTEGER :: a
+  END TYPE ParentVector
+
+CONTAINS
+
+  SUBROUTINE vector_operation(pvec)
+    CLASS(ParentVector), INTENT(INOUT) :: pvec(:)
+    print *,pvec(1)%a
+  END SUBROUTINE
+
+END
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/comma_IO_extension_1.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/comma_IO_extension_1.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/comma_IO_extension_1.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/comma_IO_extension_1.f90	2016-06-12 14:04:08.000000000 +0000
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR 60751
+! Contributed by Walter Spector <w6ws@earthlink.net>
+program extracomma
+  implicit none
+
+  write (*,*), 1, 2, 3 ! { dg-warning "Legacy Extension: Comma before i/o item list" }
+end program
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/comma_IO_extension_2.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/comma_IO_extension_2.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/comma_IO_extension_2.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/comma_IO_extension_2.f90	2016-06-12 14:04:08.000000000 +0000
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR 60751
+! Contributed by Walter Spector <w6ws@earthlink.net>
+program extracomma
+  implicit none
+
+  write (*,*), 1, 2, 3
+end program
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_1.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_1.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_1.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_1.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,56 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Basic STRUCTURE test.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Basic structure
+structure /s1/                ! type s1
+  integer i1
+  logical l1
+  real r1
+  character c1
+end structure                 ! end type s1
+
+record /s1/ r1                ! type (s1) r1
+record /s1/ r1_a(3)           ! type (s1) r1_a(3)
+
+! Basic records
+r1.i1 = 13579                  ! r1%i1 = ...
+r1.l1 = .true.
+r1.r1 = 13.579
+r1.c1 = 'F'
+r1_a(2) = r1
+r1_a(3).r1 = 135.79
+
+if (r1.i1 .ne. 13579) then
+  call aborts("r1.i1")
+endif
+
+if (r1.l1 .neqv. .true.) then
+  call aborts("r1.l1")
+endif
+
+if (r1.r1 .ne. 13.579) then
+  call aborts("r1.r1")
+endif
+
+if (r1.c1 .ne. 'F') then
+  call aborts("r1.c1")
+endif
+
+if (r1_a(2).i1 .ne. 13579) then
+  call aborts("r1_a(2).i1")
+endif
+
+if (r1_a(3).r1 .ne. 135.79) then
+  call aborts("r1_a(3).r1")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_10.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_10.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_10.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_10.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,119 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Runtime tests for rules governing dot ('.') as a member accessor, including
+! voodoo with aliased user-defined vs. intrinsic operators and nested members.
+! See gcc/fortran/match.c (gfc_match_member_sep).
+!
+
+module dec_structure_10
+  ! Operator overload tests with .ne. and constant member
+  structure /s1/
+    integer i
+    integer ne
+    logical b
+  end structure
+
+  ! Operator overload tests with .eq., .test. and nested members
+  structure /s2/
+    record /s1/ eq
+    record /s1/ test
+    record /s1/ and
+    integer i
+  end structure
+
+  ! Deep nested access tests
+  structure /s3/
+    record /s2/ r2
+  end structure
+  structure /s4/
+    record /s3/ r3
+  end structure
+  structure /s5/
+    record /s4/ r4
+  end structure
+  structure /s6/
+    record /s5/ r5
+  end structure
+  structure /s7/
+    record /s6/ r6
+  end structure
+
+  ! Operator overloads to mess with nested member accesses
+  interface operator (.ne.)
+    module procedure ne_func
+  end interface operator (.ne.)
+  interface operator (.eq.)
+    module procedure eq_func
+  end interface operator (.eq.)
+  interface operator (.test.)
+    module procedure tstfunc
+  end interface operator (.test.)
+  contains
+  ! ne_func will be called on (x) .ne. (y)
+  function ne_func (r, i)
+    integer, intent(in) :: i
+    type(s1), intent(in) :: r
+    integer ne_func
+    ne_func = r%i + i
+  end function
+  ! eq_func will be called on (x) .eq. (y)
+  function eq_func (r, i)
+    integer, intent(in) :: i
+    type(s2), intent(in) :: r
+    integer eq_func
+    eq_func = r%eq%i + i
+  end function eq_func
+  ! tstfunc will be called on (x) .test. (y)
+  function tstfunc (r, i)
+    integer, intent(in) :: i
+    type(s2), intent(in) :: r
+    integer tstfunc
+    tstfunc = r%i + i
+  end function tstfunc
+end module
+
+use dec_structure_10
+
+record /s1/ r
+record /s2/ struct
+record /s7/ r7
+integer i, j
+logical l
+struct%eq%i = 5
+i = -5
+
+! Nested access: struct has a member and which has a member b
+l =  struct .and. b   ! struct%and%b
+l =  struct .and. b .or. .false. ! (struct%and%b) .or. (.false.)
+
+! Intrinsic op: r has no member 'ne'
+j =  r .ne. i         ! <intrinsic> ne(r, i)
+j = (r) .ne. i        ! <intrinsic> ne(r, i)
+
+! Intrinsic op; r has a member 'ne' but it is not a record
+j =  r .ne. i         ! <intrinsic> ne(r, i)
+j = (r) .ne. i        ! <intrinsic> ne(r, i)
+
+! Nested access: struct has a member eq which has a member i
+j =  struct .eq. i    ! struct%eq%i
+if ( j .ne. struct%eq%i ) call abort()
+
+! User op: struct is compared to i with eq_func
+j = (struct) .eq. i   ! eq_func(struct, i) -> struct%eq%i + i
+if ( j .ne. struct%eq%i + i ) call abort()
+
+! User op: struct has a member test which has a member i, but test is a uop
+j =  struct .test. i  ! tstfunc(struct, i) -> struct%i + i
+if ( j .ne. struct%i + i ) call abort()
+
+! User op: struct is compared to i with eq_func
+j = (struct) .test. i ! tstfunc(struct, i) -> struct%i + i
+if ( j .ne. struct%i + i ) call abort()
+
+! Deep nested access tests
+r7.r6.r5.r4.r3.r2.i = 1337
+j = r7.r6.r5.r4.r3.r2.i
+if ( j .ne. 1337 ) call abort()
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_11.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_11.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_11.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_11.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! Tests for what CAN'T be done with dot ('.') as a member accessor.
+!
+
+structure /s1/
+  integer eq
+end structure
+
+record /s1/ r
+integer i, j, k
+
+j = i.j          ! { dg-error "nonderived-type variable" }
+j = r .eq. i     ! { dg-error "Operands of comparison" }
+j = r.i          ! { dg-error "is not a member of" }
+j = r.           ! { dg-error "Expected structure component or operator name" }
+j = .i           ! { dg-error "Invalid character in name" }
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_2.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_2.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_2.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_2.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,41 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test STRUCTUREs containin other STRUCTUREs.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Basic structure
+structure /s1/
+  integer i1
+  logical l1
+  real r1
+  character c1
+end structure
+
+structure /s2/
+  integer i
+  record /s1/ r1
+endstructure
+
+record /s1/ r1
+record /s2/ r2, r2_a(10)
+
+! Nested and array records
+r2.r1.r1 = 135.79
+r2_a(3).r1.i1 = -13579
+
+if (r2.r1.r1 .ne. 135.79) then
+  call aborts("r1.r1.r1")
+endif
+
+if (r2_a(3).r1.i1 .ne. -13579) then
+  call aborts("r2_a(3).r1.i1")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_3.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_3.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_3.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_3.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,52 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test nested STRUCTURE definitions.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+structure /s3/
+  real p
+  structure /s4/ recrd, recrd_a(3)
+    integer i, j
+  end structure
+  real q
+end structure
+
+record /s3/ r3
+record /s4/ r4
+
+r3.p = 1.3579
+r4.i = 0
+r4.j = 1
+r3.recrd = r4
+r3.recrd_a(1) = r3.recrd
+r3.recrd_a(2).i = 1
+r3.recrd_a(2).j = 0
+
+if (r3.p .ne. 1.3579) then
+  call aborts("r3.p")
+endif
+
+if (r4.i .ne. 0) then
+  call aborts("r4.i")
+endif
+
+if (r4.j .ne. 1) then
+  call aborts("r4.j")
+endif
+
+if (r3.recrd.i .ne. 0 .or. r3.recrd.j .ne. 1) then
+  call aborts("r3.recrd")
+endif
+
+if (r3.recrd_a(2).i .ne. 1 .or. r3.recrd_a(2).j .ne. 0) then
+  call aborts("r3.recrd_a(2)")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_4.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_4.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_4.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_4.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test anonymous STRUCTURE definitions.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+structure /s5/
+  structure recrd, recrd_a(3)
+    real x, y
+  end structure
+end structure
+
+record /s5/ r5
+
+r5.recrd.x = 1.3
+r5.recrd.y = 5.7
+r5.recrd_a(1) = r5.recrd
+r5.recrd_a(2).x = 5.7
+r5.recrd_a(2).y = 1.3
+
+if (r5.recrd.x .ne. 1.3) then
+  call aborts("r5.recrd.x")
+endif
+
+if (r5.recrd.y .ne. 5.7) then
+  call aborts("r5.recrd.y")
+endif
+
+if (r5.recrd_a(1).x .ne. 1.3 .or. r5.recrd_a(1).y .ne. 5.7) then
+  call aborts("r5.recrd_a(1)")
+endif
+
+if (r5.recrd_a(2).x .ne. 5.7 .or. r5.recrd_a(2).y .ne. 1.3) then
+  call aborts("r5.recrd_a(2)")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_5.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_5.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_5.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_5.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,49 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test STRUCTUREs which share names with variables.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Special regression where shared names within a module caused an ICE
+! from gfc_get_module_backend_decl
+module dec_structure_5m
+  structure /s6/
+    integer i
+  end structure
+
+  record /s6/ s6
+end module
+
+program dec_structure_5
+  use dec_structure_5m
+
+  structure /s7/
+    real r
+  end structure
+
+  record /s7/ s7(3)
+
+  s6.i = 0
+  s7(1).r = 1.0
+  s7(2).r = 2.0
+  s7(3).r = 3.0
+
+  if (s6.i .ne. 0) then
+    call aborts("s6.i")
+  endif
+
+  if (s7(1).r .ne. 1.0) then
+    call aborts("s7(1).r")
+  endif
+
+  if (s7(2).r .ne. 2.0) then
+    call aborts("s7(2).r")
+  endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_6.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_6.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_6.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_6.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,46 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test old-style CLIST initializers in STRUCTURE.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+integer, parameter :: as = 3
+structure /s8/
+  character*20 c /"HELLO"/  ! ok
+  integer*2 j /300_4/       ! ok, converted
+  integer   k /65536_8/     ! ok, implicit
+  integer*4 l /200000/      ! ok, types match
+  integer   m(5) /5,4,3,2,1/! ok
+  integer   n(5) /1,3*2,1/  ! ok, with repeat spec (/1,2,2,2,1/)
+  integer   o(as) /as*9/    ! ok, parameter array spec
+  integer   p(2,2) /1,2,3,4/! ok
+  real      q(3) /1_2,3.5,2.4E-12_8/ ! ok, with some implicit conversions
+  integer :: canary = z'3D3D3D3D'
+end structure
+
+record /s8/ r8
+
+! Old-style (clist) initializers in structures
+if ( r8.c /= "HELLO" ) call aborts ("r8.c")
+if ( r8.j /= 300 ) call aborts ("r8.j")
+if ( r8.k /= 65536 ) call aborts ("r8.k")
+if ( r8.l /= 200000 ) call aborts ("r8.l")
+if (     r8.m(1) /= 5 .or. r8.m(2) /= 4 .or. r8.m(3) /= 3 &
+    .or. r8.m(4) /= 2 .or. r8.m(5) /= 1) &
+  call aborts ("r8.m")
+if (     r8.n(1) /= 1 .or. r8.n(2) /= 2 .or. r8.n(3) /= 2 .or. r8.n(4) /= 2 &
+    .or. r8.n(5) /= 1) &
+  call aborts ("r8.n")
+if ( r8.o(1) /= 9 .or. r8.o(2) /= 9 .or. r8.o(3) /= 9 ) call aborts ("r8.o")
+if (     r8.p(1,1) /= 1 .or. r8.p(2,1) /= 2 .or. r8.p(1,2) /= 3 &
+    .or. r8.p(2,2) /= 4) &
+  call aborts ("r8.p")
+if ( r8.canary /= z'3D3D3D3D' ) call aborts ("r8.canary")
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_7.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_7.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_7.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_7.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,75 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test passing STRUCTUREs through functions and subroutines.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+module dec_structure_7m
+  structure /s1/
+    integer i1
+    logical l1
+    real r1
+    character c1
+  end structure
+
+  structure /s2/
+    integer i
+    record /s1/ r1
+  endstructure
+
+contains
+  ! Pass structure through subroutine
+  subroutine sub (rec1, i)
+    implicit none
+    integer, intent(in) :: i
+    record /s1/ rec1
+    rec1.i1 = i
+  end subroutine
+
+  ! Pass structure through function
+  function func (rec2, r)
+    implicit none
+    real, intent(in) :: r
+    record /s2/ rec2
+    real func
+    rec2.r1.r1 = r
+    func = rec2.r1.r1
+    return
+  end function
+end module
+
+program dec_structure_7
+  use dec_structure_7m
+
+  implicit none
+  record /s1/ r1
+  record /s2/ r2
+  real junk
+
+  ! Passing through functions and subroutines
+  r1.i1 = 0
+  call sub (r1, 10)
+
+  r2.r1.r1 = 0.0
+  junk = func (r2, -20.14)
+
+  if (r1.i1 .ne. 10) then
+    call aborts("sub(r1, 10)")
+  endif
+
+  if (r2.r1.r1 .ne. -20.14) then
+    call aborts("func(r2, -20.14)")
+  endif
+
+  if (junk .ne. -20.14) then
+    print *, junk
+    call aborts("junk = func()")
+  endif
+
+end program
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_8.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_8.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_8.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_8.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,60 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure -fmax-errors=0" }
+!
+! Comprehensive compile tests for what structures CAN'T do.
+!
+
+! Old-style (clist) initialization
+integer,parameter :: as = 3
+structure /t1/
+  integer*1 a /300_2/       ! { dg-error "Arithmetic overflow" }
+  integer   b //            ! { dg-error "Empty old style initializer list" }
+  integer   c /2*3/         ! { dg-error "Repeat spec invalid in scalar" }
+  integer   d /1,2,3/       ! { dg-error "End of scalar initializer expected" }
+  integer   e /"HI"/        ! { dg-error "Can't convert" }
+  integer   f(as) /4*9/     ! { dg-error "Too many elements" }
+  integer   g(3) /1,3/      ! { dg-error "Not enough elements" }
+  integer   h(3) /1,3,5,7/  ! { dg-error "Too many elements" }
+  integer   i(3) /2*1/      ! { dg-error "Not enough elements" }
+  integer   j(3) /10*1/     ! { dg-error "Too many elements" }
+  integer   k(3) /2.5*3/    ! { dg-error "Repeat spec must be an integer" }
+  integer   l(2) /2*/       ! { dg-error "Expected data constant" }
+  integer   m(1) /          ! { dg-error "Syntax error in old style" }
+  integer   n(2) /1         ! { dg-error "Syntax error in old style" }
+  integer   o(2) /1,        ! { dg-error "Syntax error in old style" }
+  integer   p(1) /x/        ! { dg-error "must be a PARAMETER" }
+end structure
+
+structure              ! { dg-error "Structure name expected" }
+structure /            ! { dg-error "Structure name expected" }
+structure //           ! { dg-error "Structure name expected" }
+structure /.or./       ! { dg-error "Structure name expected" }
+structure /integer/    ! { dg-error "Structure name.*cannot be the same" }
+structure /foo/ bar    ! { dg-error "Junk after" }
+structure /t1/         ! { dg-error "Type definition.*T1" }
+
+record                 ! { dg-error "Structure name expected" }
+record bar             ! { dg-error "Structure name expected" }
+record / bar           ! { dg-error "Structure name expected" }
+record // bar          ! { dg-error "Structure name expected" }
+record foo/ bar        ! { dg-error "Structure name expected" }
+record /foo bar        ! { dg-error "Structure name expected" }
+record /foo/ bar       ! { dg-error "used before it is defined" }
+record /t1/            ! { dg-error "Invalid character in name" }
+
+structure /t2/
+  ENTRY here           ! { dg-error "ENTRY statement.*cannot appear" }
+  integer a
+  integer a            ! { dg-error "Component.*already declared" }
+  structure $z         ! { dg-error "Invalid character in name" }
+  structure //         ! { dg-error "Invalid character in name" }
+  structure // x       ! { dg-error "Invalid character in name" }
+  structure /t3/       ! { dg-error "Invalid character in name" }
+  structure /t3/ x,$y  ! { dg-error "Invalid character in name" }
+  structure /t4/ y
+    integer i, j, k
+  end structure
+  structure /t4/ z     ! { dg-error "Type definition.*T4" }
+end structure
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_9.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_9.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_structure_9.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_structure_9.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,42 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! Basic compile tests for what CAN be done with dot ('.') as a member accessor.
+!
+
+logical :: l, l2 = .true., l3 = .false., and
+integer i
+character(5) s
+real r
+
+structure /s1/
+  integer i
+  character(5) s
+  real r
+end structure
+
+record /s1/ r1
+
+! Basic 
+l = l .and. l2 .or. l3
+l = and .and. and .and. and
+l =  l2 .eqv. l3
+l = (l2) .eqv. l3
+
+! Integers
+l = .not. (i .eq. 0)
+l = .not. (0 .eq. i)
+l = .not. (r1.i .eq. 0)
+l = .not. (0 .eq. r1.i)
+! Characters
+l = .not. (s .eq. "hello")
+l = .not. ("hello" .eq. s)
+l = .not. (r1.s .eq. "hello")
+l = .not. ("hello" .eq. r1.s)
+! Reals
+l = .not. (r .eq. 3.14)
+l = .not. (3.14 .eq. r)
+l = .not. (r1.r .eq. 3.14)
+l = .not. (3.14 .eq. r1.r)
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_1.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_1.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_1.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_1.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,66 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test whether union backend declarations are corrently _not_ copied when they
+! are not in fact equal. The structure defined in sub() is seen later, but
+! where siz has a different value.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+subroutine sub ()
+  integer, parameter :: siz = 1024
+  structure /s6/
+    union ! U0
+      map ! M0
+        integer ibuf(siz)
+      end map
+      map ! M1
+        character(8) cbuf(siz)
+      end map
+      map ! M2
+        real rbuf(siz)
+      end map
+    end union
+  end structure
+  record /s6/ r6
+  r6.ibuf(1) = z'badbeef'
+  r6.ibuf(2) = z'badbeef'
+end subroutine
+
+! Repeat definition from subroutine sub with different size parameter.
+! If the structure definition is copied here the stack may get messed up.
+integer, parameter :: siz = 65536
+structure /s6/
+  union ! U12
+    map
+      integer ibuf(siz)
+    end map
+    map
+      character(8) cbuf(siz)
+    end map
+    map
+      real rbuf(siz)
+    end map
+  end union
+end structure
+
+record /s6/ r6
+integer :: r6_canary = 0
+
+! Copied type declaration - this should not cause problems
+i = 1
+do while (i < siz)
+  r6.ibuf(i) = z'badbeef'
+  i = i + 1
+end do
+
+if ( r6_canary .ne. 0 ) then
+  call aborts ('copied decls: overflow')
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_2.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_2.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_2.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_2.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,60 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test basic UNION implementation.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Empty union
+structure /s0/
+  union ! U0
+    map ! M0
+    end map
+    map ! M1
+    end map
+  end union
+end structure
+
+! Basic unions
+structure /s1/
+  union ! U1
+    map ! M2
+      integer(4) a
+    end map
+    map ! M3
+      real(4) b
+    end map
+  end union
+end structure
+structure /s2/
+  union ! U2
+    map ! M4
+      integer(2) w1, w2
+    end map
+    map ! M5
+      integer(4) long
+    end map
+  end union
+end structure
+
+record /s1/ r1
+record /s2/ r2
+
+! Basic unions
+r1.a = 0
+r1.b = 1.33e7
+if ( r1.a .eq. 0 ) call aborts ("basic union 1")
+
+! Endian-agnostic runtime check
+r2.long = z'12345678'
+if (.not. (     (r2.w1 .eq. z'1234' .and. r2.w2 .eq. z'5678') &
+           .or. (r2.w1 .eq. z'5678' .and. r2.w2 .eq. z'1234')) ) then
+    call aborts ("basic union 2")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_3.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_3.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_3.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_3.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,35 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test UNIONs with initializations.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Initialization expressions
+structure /s3/
+  integer(4) :: i = 8
+  union ! U7
+    map
+      integer(4) :: x = 1600
+      integer(4) :: y = 1800
+    end map
+    map
+      integer(2) a, b, c
+    end map
+  end union
+end structure
+
+record /s3/ r3
+
+! Initialized unions
+if ( r3.x .ne. 1600 .or. r3.y .ne. 1800) then
+  r3.x = r3.y ! If r3 isn't used the initializations are optimized out
+  call aborts ("union initialization")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_4.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_4.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_4.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_4.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,63 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test nested UNIONs.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Nested unions
+structure /s4/
+  union ! U0                ! rax
+    map
+      character(16) rx
+    end map
+    map
+      character(8) rh         ! rah
+      union ! U1
+        map
+          character(8) rl     ! ral
+        end map
+        map
+          character(8) ex     ! eax
+        end map
+        map
+          character(4) eh     ! eah
+          union ! U2
+            map
+              character(4) el ! eal
+            end map
+            map
+              character(4) x  ! ax
+            end map
+            map
+              character(2) h  ! ah
+              character(2) l  ! al
+            end map
+          end union
+        end map
+      end union
+    end map
+  end union
+end structure
+record /s4/ r4
+
+
+! Nested unions
+r4.rx     =     'AAAAAAAA.BBB.C.D'
+
+if ( r4.rx .ne. 'AAAAAAAA.BBB.C.D' ) call aborts ("rax")
+if ( r4.rh .ne. 'AAAAAAAA'         ) call aborts ("rah")
+if ( r4.rl .ne.         '.BBB.C.D' ) call aborts ("ral")
+if ( r4.ex .ne.         '.BBB.C.D' ) call aborts ("eax")
+if ( r4.eh .ne.         '.BBB'     ) call aborts ("eah")
+if ( r4.el .ne.             '.C.D' ) call aborts ("eal")
+if ( r4.x  .ne.             '.C.D' ) call aborts ("ax")
+if ( r4.h  .ne.             '.C'   ) call aborts ("ah")
+if ( r4.l  .ne.               '.D' ) call aborts ("al")
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_5.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_5.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_5.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_5.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,41 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! Test UNIONs with array components.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+! Unions with arrays
+structure /s5/
+  union
+    map
+      character :: s(5)
+    end map
+    map
+      integer(1) :: a(5)
+    end map
+  end union
+end structure
+
+record /s5/ r5
+
+! Unions with arrays
+r5.a(1) = z'41'
+r5.a(2) = z'42'
+r5.a(3) = z'43'
+r5.a(4) = z'44'
+r5.a(5) = z'45'
+if (     r5.s(1) .ne. 'A' &
+    .or. r5.s(2) .ne. 'B' &
+    .or. r5.s(3) .ne. 'C' &
+    .or. r5.s(4) .ne. 'D' &
+    .or. r5.s(5) .ne. 'E') then
+  call aborts ("arrays")
+endif
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_6.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_6.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_6.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_6.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,59 @@
+! { dg-do run }
+! { dg-options "-fdec-structure" }
+!
+! sub0 and sub1 test a regression where calling gfc_use_derived from
+! gfc_find_component on the structure type symbol being parsed caused the
+! symbol to be freed and swapped for the previously seen type symbol, leaving
+! dangling pointers and causing all sorts of mayhem.
+!
+
+subroutine sub0 (u)
+  structure /s/
+    union ! U0
+      map ! M0
+        integer i
+      end map
+    end union
+  end structure
+  record /s/ u
+  u.i = 0
+end subroutine sub0
+
+subroutine sub1 ()
+  structure /s/
+    union ! U1
+      map ! M1
+        integer i
+      end map
+    end union
+  end structure
+  record /s/ u
+  interface ! matches the declaration of sub0 above
+    subroutine sub0 (u)
+      structure /s/
+        union ! U2
+          map ! M2
+            integer i ! gfc_find_component should not call gfc_use_derived
+          end map     ! here, otherwise this structure's type symbol is freed
+        end union     ! out from under it
+      end structure
+      record /s/ u
+    end subroutine sub0
+  end interface
+  call sub0(u)
+end subroutine
+
+! If sub0 and sub1 aren't used they may be omitted
+structure /s/
+  union ! U1
+    map ! M3
+      integer i
+    end map
+  end union
+end structure
+record /s/ u
+
+call sub0(u)
+call sub1()
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_7.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_7.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dec_union_7.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dec_union_7.f90	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,38 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! Comprehensive compile tests for what unions CAN'T do.
+!
+
+! Syntax errors
+structure /s0/
+  union a b c      ! { dg-error "Junk after UNION" }
+  union
+    map a b c      ! { dg-error "Junk after MAP" }
+    integer x      ! { dg-error "Unexpected" }
+    structure /s2/ ! { dg-error "Unexpected" }
+    map
+      map          ! { dg-error "Unexpected" }
+    end map
+  end union
+end structure
+
+! Initialization expressions
+structure /s1/
+  union
+    map
+      integer(4) :: x = 1600 ! { dg-error "Conflicting initializers" }
+      integer(4) :: y = 1800
+    end map
+    map
+      integer(2) a, b, c, d
+      integer :: e = 0 ! { dg-error "Conflicting initializers" }
+    end map
+    map
+      real :: p = 1.3, q = 3.7 ! { dg-error "Conflicting initializers" }
+    end map
+  end union
+end structure
+record /s1/ r1
+
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/deferred_character_17.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/deferred_character_17.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/deferred_character_17.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/deferred_character_17.f90	2016-07-13 16:09:57.000000000 +0000
@@ -0,0 +1,13 @@
+!{ dg-do run }
+
+! Check fix for PR fortran/71623
+
+program allocatemvce
+  implicit none
+  character(len=:), allocatable :: string
+  integer, dimension(4), target :: array = [1,2,3,4]
+  integer, dimension(:), pointer :: array_ptr
+  array_ptr => array
+  ! The allocate used to segfault
+  allocate(character(len=size(array_ptr))::string)
+end program allocatemvce
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/dependency_46.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/dependency_46.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/dependency_46.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/dependency_46.f90	2016-07-10 21:26:28.000000000 +0000
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 71783 - this used to ICE due to a missing charlen for the temporary.
+! Test case by Toon Moene.
+
+SUBROUTINE prtdata(ilen)
+  INTEGER :: ilen
+  character(len=ilen), allocatable :: cline(:)
+  allocate(cline(2))
+  cline(1) = 'a'
+  cline(2) = cline(1)
+END SUBROUTINE prtdata
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95	2015-01-15 20:11:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95	2016-06-29 16:08:13.000000000 +0000
@@ -83,6 +83,18 @@
   end do
   !$acc end parallel ! { dg-error "Unexpected \\\!\\\$ACC END PARALLEL" }
 
+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) waitasync ! { dg-error "Unclassifiable OpenACC directive" }
+  do i = 1, N
+     b(i) = a(i)
+  end do
+  !$acc end parallel ! { dg-error "Unexpected \\\!\\\$ACC END PARALLEL" }
+
+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) asyncwait ! { dg-error "Unclassifiable OpenACC directive" }
+  do i = 1, N
+     b(i) = a(i)
+  end do
+  !$acc end parallel ! { dg-error "Unexpected \\\!\\\$ACC END PARALLEL" }
+
   !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait
   do i = 1, N
      b(i) = a(i)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95	2015-01-15 20:11:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95	2016-06-29 16:08:13.000000000 +0000
@@ -11,17 +11,17 @@
   a(:) = 3.0
   b(:) = 0.0
 
-  !$acc wait (1 2) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait (1 2) ! { dg-error "Syntax error in OpenACC expression list at" }
 
-  !$acc wait (1,) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait (1,) ! { dg-error "Syntax error in OpenACC expression list at" }
 
-  !$acc wait (,1) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait (,1) ! { dg-error "Syntax error in OpenACC expression list at" }
 
-  !$acc wait (1, 2, ) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait (1, 2, ) ! { dg-error "Syntax error in OpenACC expression list at" }
 
-  !$acc wait (1, 2, ,) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait (1, 2, ,) ! { dg-error "Syntax error in OpenACC expression list at" }
 
-  !$acc wait (1 ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait (1 ! { dg-error "Syntax error in OpenACC expression list at" }
 
   !$acc wait (1, *) ! { dg-error "Invalid argument to \\\$\\\!ACC WAIT" }
 
@@ -33,9 +33,9 @@
 
   !$acc wait (1.0) ! { dg-error "WAIT clause at \\\(1\\\) requires a scalar INTEGER expression" }
 
-  !$acc wait 1 ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait 1 ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait N ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait N ! { dg-error "Unclassifiable OpenACC directive" }
 
   !$acc wait (1)
 end program asyncwait
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95	2015-01-15 20:11:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95	2016-06-29 16:08:13.000000000 +0000
@@ -11,21 +11,21 @@
   a(:) = 3.0
   b(:) = 0.0
 
-  !$acc wait async (1 2) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1 2) ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait async (1,) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1,) ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait async (,1) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (,1) ! { dg-error "Invalid character in name" }
 
-  !$acc wait async (1, 2, ) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1, 2, ) ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait async (1, 2, ,) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1, 2, ,) ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait async (1 ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1 ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait async (1, *) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1, *) ! { dg-error "Unclassifiable OpenACC directive" }
 
-  !$acc wait async (1, a) ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async (1, a) ! { dg-error "Unclassifiable OpenACC directive" }
 
   !$acc wait async (a) ! { dg-error "ASYNC clause at \\\(1\\\) requires a scalar INTEGER expression" }
 
@@ -33,5 +33,9 @@
 
   !$acc wait async (1.0) ! { dg-error "ASYNC clause at \\\(1\\\) requires a scalar INTEGER expression" }
 
-  !$acc wait async 1 ! { dg-error "Unexpected junk in \\\!\\\$ACC WAIT at" }
+  !$acc wait async 1 ! { dg-error "Unclassifiable OpenACC directive" }
+
+  !$acc waitasync ! { dg-error "Unclassifiable OpenACC directive" }
+
+  !$acc wait,async ! { dg-error "Unclassifiable OpenACC directive" }
 end program asyncwait
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cache-1.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cache-1.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cache-1.f95	2015-10-27 16:54:52.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cache-1.f95	2016-06-10 09:46:04.000000000 +0000
@@ -1,4 +1,6 @@
-! { dg-do compile }
+! OpenACC cache directive: valid usage.
+! For execution testing, this file is "#include"d from
+! libgomp/testsuite/libgomp.oacc-fortran/cache-1.f95.
 ! { dg-additional-options "-std=f2008" }
 
 program test
@@ -6,11 +8,8 @@
   integer :: i, d(10), e(5,13)
 
   do concurrent (i=1:5)
-    !$acc cache (d)
     !$acc cache (d(1:3))
     !$acc cache (d(i:i+2))
-
-    !$acc cache (e)
     !$acc cache (e(1:3,2:4))
     !$acc cache (e(i:i+2,i+1:i+3))
   enddo
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cache-2.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cache-2.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cache-2.f95	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cache-2.f95	2016-06-10 09:46:04.000000000 +0000
@@ -0,0 +1,12 @@
+! OpenACC cache directive: invalid usage.
+! { dg-additional-options "-std=f2008" }
+
+program test
+  implicit none
+  integer :: i, d(10), e(5,13)
+
+  do concurrent (i=1:5)
+    !$acc cache (d) ! { dg-error "" "TODO" { xfail *-*-* } }
+    !$acc cache (e) ! { dg-error "" "TODO" { xfail *-*-* } }
+  enddo
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/coarray.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/coarray.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/coarray.f95	2015-12-02 19:59:27.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/coarray.f95	2016-06-10 09:46:04.000000000 +0000
@@ -24,7 +24,7 @@
     !$acc end parallel loop
     !$acc parallel loop
     do i = 1,5
-      !$acc cache (a)
+      !$acc cache (a) ! { dg-error "" "TODO" { xfail *-*-* } }
     enddo
     !$acc end parallel loop
     !$acc update device (a)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/combined-directives.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/combined-directives.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/combined-directives.f90	2016-03-30 15:08:47.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/combined-directives.f90	2016-06-10 09:46:18.000000000 +0000
@@ -143,7 +143,8 @@
 ! { dg-final { scan-tree-dump-times "acc loop private.i. private.j. vector" 2 "gimple" } }
 ! { dg-final { scan-tree-dump-times "acc loop private.i. private.j. seq" 2 "gimple" } }
 ! { dg-final { scan-tree-dump-times "acc loop private.i. private.j. auto" 2 "gimple" } }
-! { dg-final { scan-tree-dump-times "acc loop private.i. private.j. tile.2, 3" 2 "gimple" } }
+! XFAILed: OpenACC tile clauses are discarded during gimplification.
+! { dg-final { scan-tree-dump-times "acc loop private.i. private.j. tile.2, 3" 2 "gimple" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "acc loop private.i. independent" 2 "gimple" } }
 ! { dg-final { scan-tree-dump-times "private.z" 2 "gimple" } }
 ! { dg-final { scan-tree-dump-times "omp target oacc_\[^ \]+ map.force_tofrom:y" 2 "gimple" } }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cray-2.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cray-2.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cray-2.f95	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cray-2.f95	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,56 @@
+! { dg-additional-options "-fcray-pointer" }
+! See also cray.f95.
+
+program test
+  call oacc1
+contains
+  subroutine oacc1
+    implicit none
+    integer :: i
+    real :: pointee
+    pointer (ptr, pointee)
+    !$acc declare device_resident (pointee)
+    !$acc declare device_resident (ptr)
+    !$acc data copy (pointee) ! { dg-error "Cray pointee" }
+    !$acc end data
+    !$acc data deviceptr (pointee) ! { dg-error "Cray pointee" }
+    !$acc end data
+    !$acc parallel private (pointee) ! { dg-error "Cray pointee" }
+    !$acc end parallel
+    !$acc host_data use_device (pointee) ! { dg-error "Cray pointee" }
+    !$acc end host_data
+    !$acc parallel loop reduction(+:pointee) ! { dg-error "Cray pointee" }
+    do i = 1,5
+    enddo
+    !$acc end parallel loop
+    !$acc parallel loop
+    do i = 1,5
+      !$acc cache (pointee) ! { dg-error "Cray pointee" }
+    enddo
+    !$acc end parallel loop
+    !$acc update device (pointee) ! { dg-error "Cray pointee" }
+    !$acc update host (pointee) ! { dg-error "Cray pointee" }
+    !$acc update self (pointee) ! { dg-error "Cray pointee" }
+    !$acc data copy (ptr)
+    !$acc end data
+    !$acc data deviceptr (ptr) ! { dg-error "Cray pointer" }
+    !$acc end data
+    !$acc parallel private (ptr)
+    !$acc end parallel
+    !$acc host_data use_device (ptr) ! { dg-error "Cray pointer" }
+    !$acc end host_data
+    !$acc parallel loop reduction(+:ptr) ! { dg-error "Cray pointer" }
+    do i = 1,5
+    enddo
+    !$acc end parallel loop
+    !$acc parallel loop
+    do i = 1,5
+      !TODO: This must fail, as in openacc-1_0-branch.
+      !$acc cache (ptr) ! { dg-error "" "TODO" { xfail *-*-* } }
+    enddo
+    !$acc end parallel loop
+    !$acc update device (ptr)
+    !$acc update host (ptr)
+    !$acc update self (ptr)
+  end subroutine oacc1
+end program test
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cray.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cray.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/cray.f95	2015-10-27 16:54:52.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/cray.f95	2016-06-10 09:46:18.000000000 +0000
@@ -1,5 +1,5 @@
-! { dg-do compile } 
 ! { dg-additional-options "-fcray-pointer" }
+! See also cray-2.f95.
 
 module test
 contains
@@ -8,8 +8,8 @@
     integer :: i
     real :: pointee
     pointer (ptr, pointee)
-    !$acc declare device_resident (pointee) 
-    !$acc declare device_resident (ptr) 
+    !$acc declare device_resident (pointee)
+    !$acc declare device_resident (ptr)
     !$acc data copy (pointee) ! { dg-error "Cray pointee" }
     !$acc end data
     !$acc data deviceptr (pointee) ! { dg-error "Cray pointee" }
@@ -44,7 +44,8 @@
     !$acc end parallel loop
     !$acc parallel loop
     do i = 1,5
-      !$acc cache (ptr) ! TODO: This must fail, as in openacc-1_0-branch
+      !TODO: This must fail, as in openacc-1_0-branch.
+      !$acc cache (ptr) ! { dg-error "" "TODO" { xfail *-*-* } }
     enddo
     !$acc end parallel loop
     !$acc update device (ptr)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-1-2.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-1-2.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-1-2.f95	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-1-2.f95	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,176 @@
+! See also loop-1.f95.
+
+program test
+  call test1
+contains
+
+subroutine test1
+  integer :: i, j, k, b(10)
+  integer, dimension (30) :: a
+  double precision :: d
+  real :: r
+  i = 0
+  !$acc loop
+  do 100 ! { dg-error "cannot be a DO WHILE or DO without loop control" }
+    if (i .gt. 0) exit ! { dg-error "EXIT statement" }
+  100 i = i + 1
+  i = 0
+  !$acc loop
+  do ! { dg-error "cannot be a DO WHILE or DO without loop control" }
+      if (i .gt. 0) exit ! { dg-error "EXIT statement" }
+       i = i + 1
+  end do
+  i = 0
+  !$acc loop
+  do 200 while (i .lt. 4) ! { dg-error "cannot be a DO WHILE or DO without loop control" }
+  200 i = i + 1
+  !$acc loop
+  do while (i .lt. 8) ! { dg-error "cannot be a DO WHILE or DO without loop control" }
+       i = i + 1
+  end do
+  !$acc loop
+  do 300 d = 1, 30, 6
+      i = d
+  300 a(i) = 1
+  ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 32 }
+  ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 32 }
+  !$acc loop
+  do d = 1, 30, 5
+       i = d
+      a(i) = 2
+  end do
+  ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 38 }
+  ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 38 }
+  !$acc loop
+  do i = 1, 30
+      if (i .eq. 16) exit ! { dg-error "EXIT statement" }
+  end do
+  !$acc loop
+  outer: do i = 1, 30
+      do j = 5, 10
+          if (i .eq. 6 .and. j .eq. 7) exit outer ! { dg-error "EXIT statement" }
+      end do
+  end do outer
+  last: do i = 1, 30
+   end do last
+
+  ! different types of loop are allowed
+  !$acc loop
+  do i = 1,10
+  end do
+  !$acc loop
+  do 400, i = 1,10
+400   a(i) = i
+
+  ! after loop directive must be loop
+  !$acc loop
+  a(1) = 1 ! { dg-error "Expected DO loop" }
+  do i = 1,10
+  enddo
+
+  ! combined directives may be used with/without end
+  !$acc parallel loop
+  do i = 1,10
+  enddo
+  !$acc parallel loop
+  do i = 1,10
+  enddo
+  !$acc end parallel loop
+  !$acc kernels loop
+  do i = 1,10
+  enddo
+  !$acc kernels loop
+  do i = 1,10
+  enddo
+  !$acc end kernels loop
+
+  !$acc kernels loop reduction(max:i)
+  do i = 1,10
+  enddo
+  !$acc kernels
+  !$acc loop reduction(max:i)
+  do i = 1,10
+  enddo
+  !$acc end kernels
+
+  !$acc parallel loop collapse(0) ! { dg-error "constant positive integer" }
+  do i = 1,10
+  enddo
+
+  !$acc parallel loop collapse(-1) ! { dg-error "constant positive integer" }
+  do i = 1,10
+  enddo
+
+  !$acc parallel loop collapse(i) ! { dg-error "Constant expression required" }
+  do i = 1,10
+  enddo
+
+  !$acc parallel loop collapse(4) ! { dg-error "not enough DO loops for collapsed" }
+    do i = 1, 3
+        do j = 4, 6
+          do k = 5, 7
+              a(i+j-k) = i + j + k
+          end do
+        end do
+    end do
+    !$acc parallel loop collapse(2)
+    do i = 1, 5, 2
+        do j = i + 1, 7, i  ! { dg-error "collapsed loops don.t form rectangular iteration space" }
+        end do
+    end do
+    !$acc parallel loop collapse(2)
+    do i = 1, 3
+        do j = 4, 6
+        end do
+    end do
+    !$acc parallel loop collapse(2)
+    do i = 1, 3
+        do j = 4, 6
+        end do
+        k = 4
+    end do
+    !$acc parallel loop collapse(3-1)
+    do i = 1, 3
+        do j = 4, 6
+        end do
+        k = 4
+    end do
+    !$acc parallel loop collapse(1+1)
+    do i = 1, 3
+        do j = 4, 6
+        end do
+        k = 4
+    end do
+    !$acc parallel loop collapse(2)
+    do i = 1, 3
+        do      ! { dg-error "cannot be a DO WHILE or DO without loop control" }
+        end do
+    end do
+    !$acc parallel loop collapse(2)
+    do i = 1, 3
+        do r = 4, 6
+        end do
+        ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 151 }
+        ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 151 }
+    end do
+
+    ! Both seq and independent are not allowed
+  !$acc loop independent seq ! { dg-error "SEQ conflicts with INDEPENDENT" }
+  do i = 1,10
+  enddo
+
+
+  !$acc cache (a(1:10)) ! { dg-error "ACC CACHE directive must be inside of loop" }
+
+  do i = 1,10
+    !$acc cache(a(i:i+1))
+  enddo
+
+  do i = 1,10
+    !$acc cache(a(i:i+1))
+    a(i) = i
+    !$acc cache(a(i+2:i+2+1))
+  enddo
+
+end subroutine test1
+end program test
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-1.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-1.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-1.f95	2016-03-30 15:08:47.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-1.f95	2016-06-10 09:46:18.000000000 +0000
@@ -1,8 +1,10 @@
+! See also loop-1-2.f95.
+
 module test
   implicit none
 contains
 
-subroutine test1  
+subroutine test1
   integer :: i, j, k, b(10)
   integer, dimension (30) :: a
   double precision :: d
@@ -30,15 +32,15 @@
   do 300 d = 1, 30, 6
       i = d
   300 a(i) = 1
-  ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 30 }
-  ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 30 }
+  ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 32 }
+  ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 32 }
   !$acc loop
   do d = 1, 30, 5
        i = d
       a(i) = 2
   end do
-  ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 36 }
-  ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 36 }
+  ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 38 }
+  ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 38 }
   !$acc loop
   do i = 1, 30
       if (i .eq. 16) exit ! { dg-error "EXIT statement" }
@@ -53,7 +55,7 @@
    end do last
 
   ! different types of loop are allowed
-  !$acc loop 
+  !$acc loop
   do i = 1,10
   end do
   !$acc loop
@@ -65,8 +67,8 @@
   a(1) = 1 ! { dg-error "Expected DO loop" }
   do i = 1,10
   enddo
-  
-  ! combined directives may be used with/without end 
+
+  ! combined directives may be used with/without end
   !$acc parallel loop
   do i = 1,10
   enddo
@@ -82,11 +84,11 @@
   enddo
   !$acc end kernels loop
 
-  !$acc kernels loop reduction(max:i) 
+  !$acc kernels loop reduction(max:i)
   do i = 1,10
   enddo
-  !$acc kernels 
-  !$acc loop reduction(max:i) 
+  !$acc kernels
+  !$acc loop reduction(max:i)
   do i = 1,10
   enddo
   !$acc end kernels
@@ -118,7 +120,7 @@
     end do
     !$acc parallel loop collapse(2)
     do i = 1, 3
-        do j = 4, 6  
+        do j = 4, 6
         end do
     end do
     !$acc parallel loop collapse(2)
@@ -148,8 +150,8 @@
     do i = 1, 3
         do r = 4, 6
         end do
-        ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 149 }
-        ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 149 }
+        ! { dg-warning "Deleted feature: Loop variable at .1. must be integer" "" { target *-*-* } 151 }
+        ! { dg-error "ACC LOOP iteration variable must be of type integer" "" { target *-*-* } 151 }
     end do
 
     ! Both seq and independent are not allowed
@@ -158,15 +160,16 @@
   enddo
 
 
-  !$acc cache (a) ! { dg-error "inside of loop" }
+  !$acc cache (a(1:10)) ! { dg-error "ACC CACHE directive must be inside of loop" }
 
   do i = 1,10
-    !$acc cache(a)
+    !$acc cache(a(i:i+1))
   enddo
 
   do i = 1,10
+    !$acc cache(a(i:i+1))
     a(i) = i
-    !$acc cache(a) 
+    !$acc cache(a(i+2:i+2+1))
   enddo
 
 end subroutine test1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-3-2.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-3-2.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-3-2.f95	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-3-2.f95	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,58 @@
+! { dg-additional-options "-std=f2008" }
+! See also loop-3.f95.
+
+program test
+  call test1
+contains
+subroutine test1
+  implicit none
+  integer :: i, j
+
+  ! !$acc end loop not required by spec
+  !$acc loop
+  do i = 1,5
+  enddo
+  !$acc end loop ! { dg-warning "Redundant" }
+
+  !$acc loop
+  do i = 1,5
+  enddo
+  j = 1
+  !$acc end loop ! { dg-error "Unexpected" }
+
+  !$acc parallel
+  !$acc loop
+  do i = 1,5
+  enddo
+  !$acc end parallel
+  !$acc end loop ! { dg-error "Unexpected" }
+
+  ! OpenACC supports Fortran 2008 do concurrent statement
+  !$acc loop
+  do concurrent (i = 1:5)
+  end do
+
+  !$acc loop
+  outer_loop: do i = 1, 5
+    inner_loop: do j = 1,5
+      if (i .eq. j) cycle outer_loop
+      if (i .ne. j) exit outer_loop ! { dg-error "EXIT statement" }
+    end do inner_loop
+  end do outer_loop
+
+  outer_loop1: do i = 1, 5
+    !$acc loop
+    inner_loop1: do j = 1,5
+      if (i .eq. j) cycle outer_loop1 ! { dg-error "CYCLE statement" }
+    end do inner_loop1
+  end do outer_loop1
+
+  !$acc loop collapse(2)
+  outer_loop2: do i = 1, 5
+    inner_loop2: do j = 1,5
+      if (i .eq. j) cycle outer_loop2 ! { dg-error "CYCLE statement" }
+      if (i .ne. j) exit outer_loop2 ! { dg-error "EXIT statement" }
+    end do inner_loop2
+  end do outer_loop2
+end subroutine test1
+end program test
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-3.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-3.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/loop-3.f95	2015-01-15 20:11:12.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/loop-3.f95	2016-06-10 09:46:18.000000000 +0000
@@ -1,10 +1,10 @@
-! { dg-do compile }
 ! { dg-additional-options "-std=f2008" }
+! See also loop-3-2.f95.
 
 subroutine test1
   implicit none
   integer :: i, j
-  
+
   ! !$acc end loop not required by spec
   !$acc loop
   do i = 1,5
@@ -23,7 +23,7 @@
   enddo
   !$acc end parallel
   !$acc end loop ! { dg-error "Unexpected" }
-  
+
   ! OpenACC supports Fortran 2008 do concurrent statement
   !$acc loop
   do concurrent (i = 1:5)
@@ -35,7 +35,7 @@
       if (i .eq. j) cycle outer_loop
       if (i .ne. j) exit outer_loop ! { dg-error "EXIT statement" }
     end do inner_loop
-  end do outer_loop 
+  end do outer_loop
 
   outer_loop1: do i = 1, 5
     !$acc loop
@@ -50,6 +50,5 @@
       if (i .eq. j) cycle outer_loop2 ! { dg-error "CYCLE statement" }
       if (i .ne. j) exit outer_loop2 ! { dg-error "EXIT statement" }
     end do inner_loop2
-  end do outer_loop2 
+  end do outer_loop2
 end subroutine test1
-
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/nested-function-1.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/nested-function-1.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/nested-function-1.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/nested-function-1.f90	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,93 @@
+! Exercise nested function decomposition, gcc/tree-nested.c.
+! See gcc/testsuite/gcc.dg/goacc/nested-function-1.c for the C version.
+
+program main
+  integer, parameter :: N = 100
+  integer :: nonlocal_arg
+  integer :: nonlocal_a(N)
+  integer :: nonlocal_i
+  integer :: nonlocal_j
+
+  nonlocal_a (:) = 5
+  nonlocal_arg = 5
+
+  call local ()
+  call nonlocal ()
+
+contains
+
+  subroutine local ()
+    integer :: local_i
+    integer :: local_arg
+    integer :: local_a(N)
+    integer :: local_j
+
+    local_a (:) = 5
+    local_arg = 5
+
+    !$acc kernels loop &
+    !$acc gang(num:local_arg) worker(local_arg) vector(local_arg) &
+    !$acc wait async(local_arg)
+    do local_i = 1, N
+       !$acc cache (local_a(local_i:local_i + 5))
+       local_a(local_i) = 100
+       !$acc loop seq tile(*)
+       do local_j = 1, N
+       enddo
+       !$acc loop auto independent tile(1)
+       do local_j = 1, N
+       enddo
+    enddo
+    !$acc end kernels loop
+
+    !$acc kernels loop &
+    !$acc gang(static:local_arg) worker(local_arg) vector(local_arg) &
+    !$acc wait(local_arg, local_arg + 1, local_arg + 2) async
+    do local_i = 1, N
+       !$acc cache (local_a(local_i:local_i + 4))
+       local_a(local_i) = 100
+       !$acc loop seq tile(1)
+       do local_j = 1, N
+       enddo
+       !$acc loop auto independent tile(*)
+       do local_j = 1, N
+       enddo
+    enddo
+    !$acc end kernels loop
+  end subroutine local
+
+  subroutine nonlocal ()
+    nonlocal_a (:) = 5
+    nonlocal_arg = 5
+
+    !$acc kernels loop &
+    !$acc gang(num:nonlocal_arg) worker(nonlocal_arg) vector(nonlocal_arg) &
+    !$acc wait async(nonlocal_arg)
+    do nonlocal_i = 1, N
+       !$acc cache (nonlocal_a(nonlocal_i:nonlocal_i + 3))
+       nonlocal_a(nonlocal_i) = 100
+       !$acc loop seq tile(2)
+       do nonlocal_j = 1, N
+       enddo
+       !$acc loop auto independent tile(3)
+       do nonlocal_j = 1, N
+       enddo
+    enddo
+    !$acc end kernels loop
+
+    !$acc kernels loop &
+    !$acc gang(static:nonlocal_arg) worker(nonlocal_arg) vector(nonlocal_arg) &
+    !$acc wait(nonlocal_arg, nonlocal_arg + 1, nonlocal_arg + 2) async
+    do nonlocal_i = 1, N
+       !$acc cache (nonlocal_a(nonlocal_i:nonlocal_i + 2))
+       nonlocal_a(nonlocal_i) = 100
+       !$acc loop seq tile(*)
+       do nonlocal_j = 1, N
+       enddo
+       !$acc loop auto independent tile(*)
+       do nonlocal_j = 1, N
+       enddo
+    enddo
+    !$acc end kernels loop
+  end subroutine nonlocal
+end program main
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/pr71704.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/pr71704.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/pr71704.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/pr71704.f90	2016-07-08 21:27:22.000000000 +0000
@@ -0,0 +1,60 @@
+! PR fortran/71704
+! { dg-do compile }
+
+real function f1 ()
+!$acc routine (f1)
+  f1 = 1
+end
+
+real function f2 (a)
+  integer a
+  !$acc enter data copyin(a)
+  f2 = 1
+end
+
+real function f3 (a)
+  integer a
+!$acc enter data copyin(a)
+  f3 = 1
+end
+
+real function f4 ()
+!$acc wait
+  f4 = 1
+end
+
+real function f5 (a)
+  integer a
+!$acc update device(a)
+  f5 = 1
+end
+
+real function f6 ()
+!$acc parallel
+!$acc end parallel
+  f6 = 1
+end
+
+real function f7 ()
+!$acc kernels
+!$acc end kernels
+  f7 = 1
+end
+
+real function f8 ()
+!$acc data
+!$acc end data
+  f8 = 1
+end
+
+real function f9 ()
+!$acc host_data
+!$acc end host_data
+  f8 = 1
+end
+
+real function f10 (a)
+  integer a
+!$acc declare present (a)
+  f8 = 1
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/reduction-2.f95 gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/reduction-2.f95
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc/reduction-2.f95	2015-12-02 19:59:27.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/goacc/reduction-2.f95	2016-04-29 17:37:55.000000000 +0000
@@ -15,7 +15,7 @@
   !$acc end kernels loop
 end subroutine
 
-! { dg-final { scan-tree-dump-times "target oacc_parallel firstprivate.a." 1 "gimple" } }
+! { dg-final { scan-tree-dump-times "target oacc_parallel reduction..:a. map.tofrom.a." 1 "gimple" } }
 ! { dg-final { scan-tree-dump-times "acc loop private.p. reduction..:a." 1 "gimple" } }
 ! { dg-final { scan-tree-dump-times "target oacc_kernels map.force_tofrom:a .len: 4.." 1 "gimple" } }
 ! { dg-final { scan-tree-dump-times "acc loop private.k. reduction..:a." 1 "gimple" } }
Only in gcc-6.1.0/gcc/testsuite/gfortran.dg/goacc: subroutines.f90
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/order-1.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/order-1.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/order-1.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/order-1.f90	2016-06-01 12:22:54.000000000 +0000
@@ -0,0 +1,92 @@
+! { dg-do compile }
+
+module m
+  integer :: i
+end module m
+subroutine f1
+  type t
+    integer :: i
+  end type t
+  interface
+    integer function f3 (a, b)
+      !$omp declare simd (f3) uniform (a)
+      use m
+      import :: t
+      implicit none
+      type (t) :: a
+      integer :: b
+    end function f3
+  end interface
+  interface
+    integer function f4 (a, b)
+      use m
+      !$omp declare simd (f4) uniform (a)
+      import :: t
+      implicit none
+      type (t) :: a
+      integer :: b
+    end function f4
+  end interface
+  interface
+    integer function f5 (a, b)
+      use m
+      import :: t
+      !$omp declare simd (f5) uniform (a)
+      implicit none
+      type (t) :: a
+      integer :: b
+    end function f5
+  end interface
+  interface
+    integer function f6 (a, b)
+      use m
+      import :: t
+      implicit none
+      !$omp declare simd (f6) uniform (a)
+      type (t) :: a
+      integer :: b
+    end function f6
+  end interface
+  interface
+    integer function f7 (a, b)
+      use m
+      import :: t
+      implicit none
+      type (t) :: a
+      !$omp declare simd (f7) uniform (a)
+      integer :: b
+    end function f7
+  end interface
+  call f2
+contains
+  subroutine f2
+    !$omp threadprivate (t1)
+    use m
+    !$omp threadprivate (t2)
+    implicit none
+    !$omp threadprivate (t3)
+    integer, save :: t1, t2, t3, t4
+    !$omp threadprivate (t4)
+    t1 = 1; t2 = 2; t3 = 3; t4 = 4
+  end subroutine f2
+  subroutine f8
+    !$omp declare reduction (f8_1:real:omp_out = omp_out + omp_in)
+    use m
+    !$omp declare reduction (f8_2:real:omp_out = omp_out + omp_in)
+    implicit none
+    !$omp declare reduction (f8_3:real:omp_out = omp_out + omp_in)
+    integer :: j
+    !$omp declare reduction (f8_4:real:omp_out = omp_out + omp_in)
+  end subroutine f8
+  subroutine f9
+    !$omp declare target (f9_1)
+    use m
+    !$omp declare target (f9_2)
+    implicit none
+    !$omp declare target (f9_3)
+    !$omp declare target
+    integer, save :: f9_1, f9_2, f9_3, f9_4
+    !$omp declare target (f9_4)
+    f9_1 = 1; f9_2 = 2; f9_3 = 3; f9_4 = 4
+  end subroutine f9
+end subroutine f1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/order-2.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/order-2.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/order-2.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/order-2.f90	2016-06-01 12:22:54.000000000 +0000
@@ -0,0 +1,37 @@
+! { dg-do compile }
+
+module m
+  integer :: i
+end module m
+subroutine f1
+  call f2
+contains
+  subroutine f2
+    use m
+    implicit none
+    integer, save :: t
+    t = 1
+    !$omp threadprivate (t1)	! { dg-error "Unexpected" }
+  end subroutine f2
+  subroutine f3
+    use m
+    implicit none
+    integer :: j
+    j = 1
+    !$omp declare reduction (foo:real:omp_out = omp_out + omp_in)	! { dg-error "Unexpected" }
+  end subroutine f3
+  subroutine f4
+    use m
+    implicit none
+    !$omp declare target
+    integer, save :: f4_1
+    f4_1 = 1
+    !$omp declare target (f4_1)	! { dg-error "Unexpected" }
+    !$omp declare target	! { dg-error "Unexpected" }
+  end subroutine f4
+  integer function f5 (a, b)
+    integer :: a, b
+    a = 1; b = 2
+    !$omp declare simd (f5) notinbranch	! { dg-error "Unexpected" }
+  end function f5
+end subroutine f1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr70855.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr70855.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr70855.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr70855.f90	2016-05-11 13:18:05.000000000 +0000
@@ -0,0 +1,18 @@
+! PR fortran/70855
+! { dg-do compile }
+! { dg-additional-options "-O2" }
+
+program pr70855
+   integer, parameter :: m = 4
+   integer, parameter :: n = 2
+   real :: a(m,n)
+   real :: x(n)
+   real :: y(m)
+   a = 1.0
+   x = 1.0
+!$omp parallel
+!$omp workshare
+   y(1:m) = matmul ( a(1:m,1:n), x(1:n) )
+!$omp end workshare
+!$omp end parallel
+end program pr70855
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71687.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71687.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71687.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71687.f90	2016-07-02 10:25:52.000000000 +0000
@@ -0,0 +1,11 @@
+! PR fortran/71687
+! { dg-do compile }
+! { dg-additional-options "-fstack-arrays -O2" }
+
+subroutine s (n, x)
+   integer :: n
+   real :: x(n)
+!$omp parallel
+   x(1:n) = x(n:1:-1)
+!$omp end parallel
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71704.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71704.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71704.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71704.f90	2016-07-02 10:23:45.000000000 +0000
@@ -0,0 +1,58 @@
+! PR fortran/71704
+! { dg-do compile }
+
+real function f0 ()
+!$omp declare simd (f0)
+  f0 = 1
+end
+
+real function f1 ()
+!$omp declare target (f1)
+  f1 = 1
+end
+
+real function f2 ()
+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) &
+!$omp & initializer (omp_priv = 0)
+  f2 = 1
+end
+
+real function f3 ()
+  real, save :: t
+!$omp threadprivate (t)
+  f3 = 1
+end
+
+real function f4 ()
+!$omp taskwait
+  f4 = 1
+end
+
+real function f5 ()
+!$omp barrier
+  f5 = 1
+end
+
+real function f6 ()
+!$omp parallel
+!$omp end parallel
+  f6 = 1
+end
+
+real function f7 ()
+!$omp single
+!$omp end single
+  f7 = 1
+end
+
+real function f8 ()
+!$omp critical
+!$omp end critical
+  f8 = 1
+end
+
+real function f9 ()
+!$omp critical
+!$omp end critical
+  f9 = 1
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71705.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71705.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71705.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71705.f90	2016-07-02 10:22:48.000000000 +0000
@@ -0,0 +1,7 @@
+! PR fortran/71705
+! { dg-do compile }
+
+  real :: x
+  x = 0.0
+  !$omp target update to(x)
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71758.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71758.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/gomp/pr71758.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/gomp/pr71758.f90	2016-07-11 20:43:11.000000000 +0000
@@ -0,0 +1,10 @@
+! PR middle-end/71758
+
+subroutine pr71758 (p)
+  integer(8) :: i
+  integer :: p(20)
+  i = 0
+  !$omp target device(i)
+  !$omp end target
+  !$omp target update to(p(1:1)) device(i)
+end subroutine
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/graphite/pr38083.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/graphite/pr38083.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/graphite/pr38083.f90	2009-07-31 02:45:54.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/graphite/pr38083.f90	2016-06-12 14:04:08.000000000 +0000
@@ -8,7 +8,7 @@
 10 IF (IL .GE. IH) GO TO 80
 20 NSEGS = (IH + IL) / 2
   IF (NSEGS .GT. MAXSGS) THEN
-     WRITE (IOUNIT),MAXSGS
+     WRITE (IOUNIT) MAXSGS
   ENDIF
 80 NSEGS = NSEGS - 1
 90 IF (IH - IL .GE. 11) GO TO 20
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/guality/pr41558.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/guality/pr41558.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/guality/pr41558.f90	2012-02-07 22:28:18.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/guality/pr41558.f90	2016-06-12 14:04:08.000000000 +0000
@@ -5,7 +5,7 @@
 
 subroutine f (s)
   character(len=3) :: s
-  write (*,*), s ! { dg-final { gdb-test 7 "s" "'foo'" } }
+  write (*,*) s ! { dg-final { gdb-test 7 "s" "'foo'" } }
 end
   call f ('foo')
 end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90 gcc-6-20160721/gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90	2015-02-23 23:02:50.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90	2016-06-12 14:04:08.000000000 +0000
@@ -1,4 +1,4 @@
 ! { dg-options "-fno-range-check" }
 program test
-  write (*), (2_8 ** 64009999_8) / 2
+  write (*,*) (2_8 ** 64009999_8) / 2
 end program test
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr69603.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr69603.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr69603.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr69603.f90	2016-05-15 18:48:40.000000000 +0000
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-options "-fimplicit-none" }
+! PR fortran/69603 - segfault with -fimplicit-none and proc_ptr_comp_24.f90
+! Based on reduced testcase by Dominique d'Humieres
+PROGRAM prog
+  implicit none
+  TYPE object
+     PROCEDURE(), POINTER, NOPASS :: f
+  END TYPE object
+  TYPE (object) :: o1
+  CALL set_func(o1%f)
+CONTAINS
+  SUBROUTINE set_func(f)
+    PROCEDURE(), POINTER :: f
+  END SUBROUTINE set_func
+END PROGRAM prog
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr70673.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr70673.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr70673.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr70673.f90	2016-06-27 19:18:21.000000000 +0000
@@ -0,0 +1,25 @@
+! { dg-do run }
+!
+! Test the fix for PR70673
+!
+! Contributed by David Kinniburgh  <davidgkinniburgh@yahoo.co.uk>
+!
+module m
+contains
+  subroutine s(inp)
+    character(*), intent(in) :: inp
+    character(:), allocatable :: a
+    a = a           ! This used to ICE.
+    a = inp
+    a = a           ! This used to ICE too
+    if ((len (a) .ne. 5) .or. (a .ne. "hello")) call abort
+    a = a(2:3)      ! Make sure that temporary creation is not broken.
+    if ((len (a) .ne. 2) .or. (a .ne. "el")) call abort
+    deallocate (a)
+    a = a           ! This would ICE too.
+  end subroutine s
+end module m
+
+  use m
+  call s("hello")
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr70931.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr70931.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr70931.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr70931.f90	2016-05-13 13:22:42.000000000 +0000
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-g" }
+program p
+   type t
+      integer :: a
+      integer :: b(0)
+   end type
+   type(t), parameter :: z = t(1, [2])
+   print *, z
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71047.f08 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71047.f08
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71047.f08	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71047.f08	2016-05-14 19:52:46.000000000 +0000
@@ -0,0 +1,48 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! Fortran/PR71047
+!
+
+module m
+ implicit none
+
+ type, abstract :: c_abstr
+  integer :: i = 0
+ end type c_abstr
+
+ type, extends(c_abstr) :: t_a
+  class(c_abstr), allocatable :: f
+ end type t_a
+ 
+ type, extends(c_abstr) :: t_b
+ end type t_b
+
+contains
+
+ subroutine set(y,x)
+  class(c_abstr), intent(in)  :: x
+  type(t_a),      intent(out) :: y
+   allocate( y%f , source=x )
+ end subroutine set
+
+end module m
+
+
+program p
+ use m
+ implicit none
+
+ type(t_a) :: res
+ type(t_b) :: var
+
+  call set( res , var )
+  write(*,*) res%i
+
+end program p
+
+!
+! Check to ensure the vtable is actually initialized.
+!
+! { dg-final { scan-tree-dump "t_a\\.\\d+\\.f\\._vptr =" "original" } }
+!
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71204.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71204.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71204.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71204.f90	2016-05-20 18:52:38.000000000 +0000
@@ -0,0 +1,17 @@
+! PR fortran/71204
+! { dg-do compile }
+! { dg-options "-O0" }
+
+module pr71204
+  character(10), allocatable :: z(:)
+end module
+
+subroutine s1
+  use pr71204
+  z(2) = z(1)
+end
+
+subroutine s2
+  use pr71204
+  z(2) = z(1)
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71688.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71688.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71688.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71688.f90	2016-07-20 13:24:19.000000000 +0000
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+
+program p
+   call s
+contains
+   subroutine s
+      real :: x[*] = 1
+      block
+      end block
+      x = 2
+   end
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71764.f90 gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71764.f90
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/pr71764.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/pr71764.f90	2016-07-16 03:54:12.000000000 +0000
@@ -0,0 +1,34 @@
+! { dg-do run }
+! PR71764 
+program p
+   use iso_c_binding, only: c_ptr, c_null_ptr, c_ptr, c_associated, c_loc
+   logical, target :: rls
+   real, target :: t = 3.14
+   type(c_ptr) :: nullptr,c
+   real, pointer :: k
+   nullptr = c_null_ptr
+   c = nullptr
+   rls = c_associated(c)
+   if (rls) call abort
+   if (c_associated(c)) call abort
+   c = c_loc(rls)
+   if (.not. c_associated(c)) call abort
+   c = nullptr
+   if (c_associated(c)) call abort
+   c = c_loc(t)
+   k => t
+   call association_test(k, c)
+contains
+  subroutine association_test(a,b)
+    use iso_c_binding, only: c_associated, c_loc, c_ptr
+    implicit none
+    real, pointer :: a
+    type(c_ptr) :: b
+    if(c_associated(b, c_loc(a))) then
+       return
+    else
+       call abort
+    end if
+  end subroutine association_test
+end
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/submodule_14.f08 gcc-6-20160721/gcc/testsuite/gfortran.dg/submodule_14.f08
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/submodule_14.f08	2016-03-12 13:59:10.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/submodule_14.f08	2016-06-01 18:46:11.000000000 +0000
@@ -27,7 +27,7 @@
         Call sub1 (x)
     End If
   End Procedure sub1
-  module function fcn1 (x) result(res)
+  recursive module function fcn1 (x) result(res)
     integer, intent (inout) :: x
     integer :: res
     res = x - 1
@@ -46,4 +46,4 @@
   x = 10
   if (fcn1 (x) .ne. 0) call abort
 end
-
+! { dg-final { cleanup-submodules "test@testson" } }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/submodule_15.f08 gcc-6-20160721/gcc/testsuite/gfortran.dg/submodule_15.f08
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/submodule_15.f08	2016-03-12 13:59:10.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/submodule_15.f08	2016-04-27 16:58:19.000000000 +0000
@@ -56,3 +56,4 @@
   incr = 1
   if (a3(i) .ne. 11) call abort
 end
+! { dg-final { cleanup-submodules "a@a_son" } }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/submodule_16.f08 gcc-6-20160721/gcc/testsuite/gfortran.dg/submodule_16.f08
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/submodule_16.f08	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/submodule_16.f08	2016-06-01 18:46:11.000000000 +0000
@@ -0,0 +1,53 @@
+! { dg-do compile }
+!
+! Tests the fix for PR71156 in which the valid code (f7, f8 and f9 below)
+! triggered an error, while the invalid code (f1 to f6) compiled.
+!
+! Contributed by Damian Rousn  <damian@sourceryinstitute.org>
+!
+module my_interface
+  implicit none
+  interface
+    module subroutine f1
+    end subroutine
+    module subroutine f2
+    end subroutine
+    module subroutine f3
+    end subroutine
+    elemental module subroutine f4
+    end subroutine
+    pure module subroutine f5
+    end subroutine
+    recursive module subroutine f6
+    end subroutine
+    elemental module subroutine f7
+    end subroutine
+    pure module subroutine f8
+    end subroutine
+    recursive module subroutine f9
+    end subroutine
+  end interface
+end module
+
+submodule(my_interface) my_implementation
+  implicit none
+contains
+    elemental module subroutine f1 ! { dg-error "Mismatch in ELEMENTAL attribute" }
+    end subroutine
+    pure module subroutine f2 ! { dg-error "Mismatch in PURE attribute" }
+    end subroutine
+    recursive module subroutine f3 ! { dg-error "Mismatch in RECURSIVE attribute" }
+    end subroutine
+    module subroutine f4 ! { dg-error "ELEMENTAL prefix" }
+    end subroutine
+    module subroutine f5 ! { dg-error "PURE prefix" }
+    end subroutine
+    module subroutine f6 ! { dg-error "RECURSIVE prefix" }
+    end subroutine
+    elemental module subroutine f7
+    end subroutine
+    pure module subroutine f8
+    end subroutine
+    recursive module subroutine f9
+    end subroutine
+end submodule
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gfortran.dg/unexpected_eof.f gcc-6-20160721/gcc/testsuite/gfortran.dg/unexpected_eof.f
--- gcc-6.1.0/gcc/testsuite/gfortran.dg/unexpected_eof.f	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gfortran.dg/unexpected_eof.f	2016-05-27 01:05:21.000000000 +0000
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR66461  ICE on missing end program in fixed source
+      program p
+         integer x(2)
+         x = -1
+         if ( x(1) < 0 .or.
+     &        x(2) < 0 ) print *, x
+! { dg-error "Unexpected end of file" "" { target *-*-* } 0 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gnat.dg/case_character.adb gcc-6-20160721/gcc/testsuite/gnat.dg/case_character.adb
--- gcc-6.1.0/gcc/testsuite/gnat.dg/case_character.adb	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gnat.dg/case_character.adb	2016-06-11 11:55:51.000000000 +0000
@@ -0,0 +1,19 @@
+-- { dg-do run }
+
+procedure Case_Character is
+
+  function Test (C : Character) return Integer is
+  begin
+    case C is
+      when ASCII.HT | ' ' .. Character'Last => return 1;
+      when others => return 0;
+    end case;
+  end;
+
+begin
+
+  if Test ('A') /= 1 then
+    raise Program_Error;
+  end if;
+
+end;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gnat.dg/debug5.adb gcc-6-20160721/gcc/testsuite/gnat.dg/debug5.adb
--- gcc-6.1.0/gcc/testsuite/gnat.dg/debug5.adb	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gnat.dg/debug5.adb	2016-05-03 16:20:47.000000000 +0000
@@ -0,0 +1,22 @@
+-- { dg-do compile }
+-- { dg-options "-g" }
+
+procedure Debug5 is
+
+   type Record_Type (L1, L2 : Natural) is record
+      S1 : String (1 .. L1);
+      case L2 is
+         when 0      => null;
+         when others => S2 : String (L1 .. L2);
+      end case;
+   end record;
+
+   procedure Discard (R : Record_Type) is
+   begin
+      null;
+   end Discard;
+
+   R : constant Record_Type := (0, 0, others => <>);
+begin
+   Discard (R);
+end Debug5;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gnat.dg/opt56.adb gcc-6-20160721/gcc/testsuite/gnat.dg/opt56.adb
--- gcc-6.1.0/gcc/testsuite/gnat.dg/opt56.adb	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gnat.dg/opt56.adb	2016-06-01 10:38:35.000000000 +0000
@@ -0,0 +1,15 @@
+-- { dg-do compile }
+-- { dg-options "-O3" }
+
+package body Opt56 is
+
+   function F (Values : Vector) return Boolean is
+      Result : Boolean := True;
+   begin
+      for I in Values'Range loop
+         Result := Result and Values (I) >= 0.0;
+     end loop;
+     return Result;
+   end;
+
+end Opt56;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gnat.dg/opt56.ads gcc-6-20160721/gcc/testsuite/gnat.dg/opt56.ads
--- gcc-6.1.0/gcc/testsuite/gnat.dg/opt56.ads	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gnat.dg/opt56.ads	2016-06-01 10:38:35.000000000 +0000
@@ -0,0 +1,7 @@
+package Opt56 is
+
+   type Vector is array (Positive range <>) of Float;
+
+   function F (Values : Vector) return Boolean;
+
+end Opt56;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gnat.dg/renaming10.adb gcc-6-20160721/gcc/testsuite/gnat.dg/renaming10.adb
--- gcc-6.1.0/gcc/testsuite/gnat.dg/renaming10.adb	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gnat.dg/renaming10.adb	2016-06-13 08:02:10.000000000 +0000
@@ -0,0 +1,12 @@
+-- { dg-do compile }
+
+package body Renaming10 is
+
+   function F (Input : Rec) return Natural is
+      Position : Natural renames Input.Position;
+      Index : Natural renames Natural'Succ(Position);
+   begin
+      return Index;
+   end;
+
+end Renaming10;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/gnat.dg/renaming10.ads gcc-6-20160721/gcc/testsuite/gnat.dg/renaming10.ads
--- gcc-6.1.0/gcc/testsuite/gnat.dg/renaming10.ads	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/gnat.dg/renaming10.ads	2016-06-13 08:02:10.000000000 +0000
@@ -0,0 +1,9 @@
+package Renaming10 is
+
+   type Rec is record
+      Position : Natural;
+   end record;
+
+   function F (Input : Rec) return Natural;
+
+end Renaming10;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/lib/target-supports.exp gcc-6-20160721/gcc/testsuite/lib/target-supports.exp
--- gcc-6.1.0/gcc/testsuite/lib/target-supports.exp	2016-04-11 19:45:35.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/lib/target-supports.exp	2016-07-05 17:54:02.000000000 +0000
@@ -2300,6 +2300,40 @@
 	float dummy = 1.0q;
     } "$opts"]
 }
+
+# Return 1 if the target supports __float128,
+# 0 otherwise.
+
+proc check_effective_target___float128 { } {
+    if { [istarget powerpc*-*-*] } {
+	return [check_ppc_float128_sw_available]
+    }
+    if { [istarget ia64-*-*]
+	 || [istarget i?86-*-*]
+	 || [istarget x86_64-*-*] } {
+	return 1
+    }
+    return 0
+}
+
+proc add_options_for___float128 { flags } {
+    if { [istarget powerpc*-*-*] } {
+	return "$flags -mfloat128 -mvsx"
+    }
+    return "$flags"
+}
+
+# Return 1 if the target supports any special run-time requirements
+# for __float128 or _Float128,
+# 0 otherwise.
+
+proc check_effective_target_base_quadfloat_support { } {
+    if { [istarget powerpc*-*-*] } {
+	return [check_vsx_hw_available]
+    }
+    return 1
+}
+
 # Return 1 if the target supports compiling fixed-point,
 # 0 otherwise.
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/opt55.adb gcc-6-20160721/gcc/testsuite/opt55.adb
--- gcc-6.1.0/gcc/testsuite/opt55.adb	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/opt55.adb	2016-05-25 20:44:21.000000000 +0000
@@ -0,0 +1,20 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt55 is
+
+   function Cond (B : Boolean; If_True, If_False : Date) return Date is
+   begin
+      if B then
+         return If_True;
+      else
+         return If_False;
+      end if;
+   end;
+
+   function F (C : Rec2; B : Boolean) return Date is
+   begin
+      return Cond (B, C.D1, C.D2);
+   end;
+
+end Opt55;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/testsuite/opt55.ads gcc-6-20160721/gcc/testsuite/opt55.ads
--- gcc-6.1.0/gcc/testsuite/opt55.ads	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/gcc/testsuite/opt55.ads	2016-05-25 20:44:21.000000000 +0000
@@ -0,0 +1,22 @@
+package Opt55 is
+
+   type Date is record
+      D : Float;
+   end record;
+
+   type Rec1 (Kind : Boolean := False) is record
+      case Kind is
+         when True => N : Natural;
+         when False => null;
+      end case;
+   end record;
+
+   type Rec2 (D : Positive) is record
+      R  : Rec1;
+      D1 : Date;
+      D2 : Date;
+   end record;
+
+   function F (C : Rec2; B : Boolean) return Date;
+
+end Opt55;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/timevar.def gcc-6-20160721/gcc/timevar.def
--- gcc-6.1.0/gcc/timevar.def	2016-02-10 11:22:29.000000000 +0000
+++ gcc-6-20160721/gcc/timevar.def	2016-07-21 06:18:06.000000000 +0000
@@ -137,6 +137,8 @@
 DEFTIMEVAR (TV_PARSE_INLINE          , "parser inl. func. body")
 DEFTIMEVAR (TV_PARSE_INMETH          , "parser inl. meth. body")
 DEFTIMEVAR (TV_TEMPLATE_INST         , "template instantiation")
+DEFTIMEVAR (TV_CONSTRAINT_SAT        , "constraint satisfaction")
+DEFTIMEVAR (TV_CONSTRAINT_SUB        , "constraint subsumption")
 DEFTIMEVAR (TV_FLATTEN_INLINING      , "flatten inlining")
 DEFTIMEVAR (TV_EARLY_INLINING        , "early inlining heuristics")
 DEFTIMEVAR (TV_INLINE_PARAMETERS     , "inline parameters")
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/timevar.h gcc-6-20160721/gcc/timevar.h
--- gcc-6.1.0/gcc/timevar.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/timevar.h	2016-07-21 06:18:06.000000000 +0000
@@ -229,6 +229,14 @@
       m_timer->push (m_tv);
   }
 
+  explicit auto_timevar (timevar_id_t tv)
+    : m_timer (g_timer)
+    , m_tv (tv)
+  {
+    if (m_timer)
+      m_timer->push (m_tv);
+  }
+
   ~auto_timevar ()
   {
     if (m_timer)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-chkp.c gcc-6-20160721/gcc/tree-chkp.c
--- gcc-6.1.0/gcc/tree-chkp.c	2016-02-21 11:25:31.000000000 +0000
+++ gcc-6-20160721/gcc/tree-chkp.c	2016-05-11 09:55:55.000000000 +0000
@@ -1853,7 +1853,9 @@
 
   /* If function decl is available then use it for
      formal arguments list.  Otherwise use function type.  */
-  if (fndecl && DECL_ARGUMENTS (fndecl))
+  if (fndecl
+      && DECL_ARGUMENTS (fndecl)
+      && gimple_call_fntype (call) == TREE_TYPE (fndecl))
     first_formal_arg = DECL_ARGUMENTS (fndecl);
   else
     {
@@ -1929,7 +1931,16 @@
     {
       tree new_decl = chkp_maybe_create_clone (fndecl)->decl;
       gimple_call_set_fndecl (new_call, new_decl);
-      gimple_call_set_fntype (new_call, TREE_TYPE (new_decl));
+      /* In case of a type cast we should modify used function
+	 type instead of using type of new fndecl.  */
+      if (gimple_call_fntype (call) != TREE_TYPE (fndecl))
+	{
+	  tree type = gimple_call_fntype (call);
+	  type = chkp_copy_function_type_adding_bounds (type);
+	  gimple_call_set_fntype (new_call, type);
+	}
+      else
+	gimple_call_set_fntype (new_call, TREE_TYPE (new_decl));
     }
   /* For indirect call we should fix function pointer type if
      pass some bounds.  */
@@ -3646,6 +3657,7 @@
       break;
 
     case ADDR_EXPR:
+    case WITH_SIZE_EXPR:
       bounds = chkp_make_addressed_object_bounds (TREE_OPERAND (ptr_src, 0), iter);
       break;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-inline.c gcc-6-20160721/gcc/tree-inline.c
--- gcc-6.1.0/gcc/tree-inline.c	2016-04-04 15:42:19.000000000 +0000
+++ gcc-6-20160721/gcc/tree-inline.c	2016-05-12 14:34:18.000000000 +0000
@@ -840,7 +840,7 @@
 static unsigned short
 remap_dependence_clique (copy_body_data *id, unsigned short clique)
 {
-  if (clique == 0)
+  if (clique == 0 || processing_debug_stmt)
     return 0;
   if (!id->dependence_map)
     id->dependence_map = new hash_map<dependence_hash, unsigned short>;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-nested.c gcc-6-20160721/gcc/tree-nested.c
--- gcc-6.1.0/gcc/tree-nested.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/tree-nested.c	2016-06-14 14:45:23.000000000 +0000
@@ -1114,6 +1114,8 @@
 	case OMP_CLAUSE_GANG:
 	case OMP_CLAUSE_WORKER:
 	case OMP_CLAUSE_VECTOR:
+	case OMP_CLAUSE_ASYNC:
+	case OMP_CLAUSE_WAIT:
 	  /* Several OpenACC clauses have optional arguments.  Check if they
 	     are present.  */
 	  if (OMP_CLAUSE_OPERAND (clause, 0))
@@ -1197,8 +1199,22 @@
 	case OMP_CLAUSE_SIMD:
 	case OMP_CLAUSE_DEFAULTMAP:
 	case OMP_CLAUSE_SEQ:
+	case OMP_CLAUSE_INDEPENDENT:
+	case OMP_CLAUSE_AUTO:
 	  break;
 
+	case OMP_CLAUSE_TILE:
+	  /* OpenACC tile clauses are discarded during gimplification, so we
+	     don't expect to see anything here.  */
+	  gcc_unreachable ();
+
+	case OMP_CLAUSE__CACHE_:
+	  /* These clauses belong to the OpenACC cache directive, which is
+	     discarded during gimplification, so we don't expect to see
+	     anything here.  */
+	  gcc_unreachable ();
+
+	case OMP_CLAUSE_DEVICE_RESIDENT:
 	default:
 	  gcc_unreachable ();
 	}
@@ -1332,7 +1348,7 @@
 	{
 	  wi->val_only = true;
 	  wi->is_lhs = false;
-	  *handled_ops_p = true;
+	  *handled_ops_p = false;
 	  return NULL_TREE;
 	}
       break;
@@ -1790,6 +1806,8 @@
 	case OMP_CLAUSE_GANG:
 	case OMP_CLAUSE_WORKER:
 	case OMP_CLAUSE_VECTOR:
+	case OMP_CLAUSE_ASYNC:
+	case OMP_CLAUSE_WAIT:
 	  /* Several OpenACC clauses have optional arguments.  Check if they
 	     are present.  */
 	  if (OMP_CLAUSE_OPERAND (clause, 0))
@@ -1878,8 +1896,22 @@
 	case OMP_CLAUSE_SIMD:
 	case OMP_CLAUSE_DEFAULTMAP:
 	case OMP_CLAUSE_SEQ:
+	case OMP_CLAUSE_INDEPENDENT:
+	case OMP_CLAUSE_AUTO:
 	  break;
 
+	case OMP_CLAUSE_TILE:
+	  /* OpenACC tile clauses are discarded during gimplification, so we
+	     don't expect to see anything here.  */
+	  gcc_unreachable ();
+
+	case OMP_CLAUSE__CACHE_:
+	  /* These clauses belong to the OpenACC cache directive, which is
+	     discarded during gimplification, so we don't expect to see
+	     anything here.  */
+	  gcc_unreachable ();
+
+	case OMP_CLAUSE_DEVICE_RESIDENT:
 	default:
 	  gcc_unreachable ();
 	}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-object-size.c gcc-6-20160721/gcc/tree-object-size.c
--- gcc-6.1.0/gcc/tree-object-size.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/tree-object-size.c	2016-07-21 07:49:15.000000000 +0000
@@ -43,7 +43,12 @@
   unsigned int *stack, *tos;
 };
 
-static const unsigned HOST_WIDE_INT unknown[4] = { -1, -1, 0, 0 };
+static const unsigned HOST_WIDE_INT unknown[4] = {
+  HOST_WIDE_INT_M1U,
+  HOST_WIDE_INT_M1U,
+  0,
+  0
+};
 
 static tree compute_object_offset (const_tree, const_tree);
 static unsigned HOST_WIDE_INT addr_object_size (struct object_size_info *,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-sra.c gcc-6-20160721/gcc/tree-sra.c
--- gcc-6.1.0/gcc/tree-sra.c	2016-04-13 20:35:59.000000000 +0000
+++ gcc-6-20160721/gcc/tree-sra.c	2016-05-23 11:27:14.000000000 +0000
@@ -2074,7 +2074,8 @@
       access->grp_scalar_write = grp_scalar_write;
       access->grp_assignment_read = grp_assignment_read;
       access->grp_assignment_write = grp_assignment_write;
-      access->grp_hint = multiple_scalar_reads || total_scalarization;
+      access->grp_hint = total_scalarization
+	|| (multiple_scalar_reads && !constant_decl_p (var));
       access->grp_total_scalarization = total_scalarization;
       access->grp_partial_lhs = grp_partial_lhs;
       access->grp_unscalarizable_region = unscalarizable_region;
@@ -3559,32 +3560,31 @@
   unsigned i;
 
   EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)
-    if (bitmap_bit_p (should_scalarize_away_bitmap, i)
-	&& !bitmap_bit_p (cannot_scalarize_away_bitmap, i))
-      {
-	tree var = candidate (i);
-	if (!constant_decl_p (var))
-	  continue;
-	vec<access_p> *access_vec = get_base_access_vector (var);
-	if (!access_vec)
-	  continue;
-	for (unsigned i = 0; i < access_vec->length (); i++)
-	  {
-	    struct access *access = (*access_vec)[i];
-	    if (!access->replacement_decl)
-	      continue;
-	    gassign *stmt = gimple_build_assign (
-	      get_access_replacement (access), unshare_expr (access->expr));
-	    if (dump_file && (dump_flags & TDF_DETAILS))
-	      {
-		fprintf (dump_file, "Generating constant initializer: ");
-		print_gimple_stmt (dump_file, stmt, 0, 1);
-		fprintf (dump_file, "\n");
-	      }
-	    gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);
-	    update_stmt (stmt);
-	  }
-      }
+    {
+      tree var = candidate (i);
+      if (!constant_decl_p (var))
+	continue;
+      vec<access_p> *access_vec = get_base_access_vector (var);
+      if (!access_vec)
+	continue;
+      for (unsigned i = 0; i < access_vec->length (); i++)
+	{
+	  struct access *access = (*access_vec)[i];
+	  if (!access->replacement_decl)
+	    continue;
+	  gassign *stmt
+	    = gimple_build_assign (get_access_replacement (access),
+				   unshare_expr (access->expr));
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "Generating constant initializer: ");
+	      print_gimple_stmt (dump_file, stmt, 0, 1);
+	      fprintf (dump_file, "\n");
+	    }
+	  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);
+	  update_stmt (stmt);
+	}
+    }
 
   seq = gsi_seq (gsi);
   if (seq)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-coalesce.c gcc-6-20160721/gcc/tree-ssa-coalesce.c
--- gcc-6.1.0/gcc/tree-ssa-coalesce.c	2016-04-08 17:28:20.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-coalesce.c	2016-05-04 20:25:10.000000000 +0000
@@ -1505,7 +1505,8 @@
 /* Given SSA_NAMEs NAME1 and NAME2, return true if they are candidates for
    coalescing together, false otherwise.
 
-   This must stay consistent with var_map_base_init in tree-ssa-live.c.  */
+   This must stay consistent with compute_samebase_partition_bases and 
+   compute_optimized_partition_bases.  */
 
 bool
 gimple_can_coalesce_p (tree name1, tree name2)
@@ -1759,7 +1760,7 @@
       else
 	/* This restricts what anonymous SSA names we can coalesce
 	   as it restricts the sets we compute conflicts for.
-	   Using TREE_TYPE to generate sets is the easies as
+	   Using TREE_TYPE to generate sets is the easiest as
 	   type equivalency also holds for SSA names with the same
 	   underlying decl.
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-loop-unswitch.c gcc-6-20160721/gcc/tree-ssa-loop-unswitch.c
--- gcc-6.1.0/gcc/tree-ssa-loop-unswitch.c	2016-04-12 13:38:46.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-loop-unswitch.c	2016-05-10 14:26:37.000000000 +0000
@@ -532,6 +532,12 @@
 		 guard_edge->src->index, guard_edge->dest->index);
       return NULL;
     }
+  if (guard_edge->dest == loop->latch)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Guard edge destination is loop latch.\n");
+      return NULL;
+    }
 
   if (dump_file && (dump_flags & TDF_DETAILS))
     fprintf (dump_file,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-phiopt.c gcc-6-20160721/gcc/tree-ssa-phiopt.c
--- gcc-6.1.0/gcc/tree-ssa-phiopt.c	2016-03-14 14:50:40.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-phiopt.c	2016-05-25 20:44:21.000000000 +0000
@@ -438,15 +438,18 @@
   /* Check if arg0 is an SSA_NAME and the stmt which defines arg0 is
      a conversion.  */
   arg0_def_stmt = SSA_NAME_DEF_STMT (arg0);
-  if (!is_gimple_assign (arg0_def_stmt)
-      || !gimple_assign_cast_p (arg0_def_stmt))
+  if (!gimple_assign_cast_p (arg0_def_stmt))
     return NULL;
 
   /* Use the RHS as new_arg0.  */
   convert_code = gimple_assign_rhs_code (arg0_def_stmt);
   new_arg0 = gimple_assign_rhs1 (arg0_def_stmt);
   if (convert_code == VIEW_CONVERT_EXPR)
-    new_arg0 = TREE_OPERAND (new_arg0, 0);
+    {
+      new_arg0 = TREE_OPERAND (new_arg0, 0);
+      if (!is_gimple_reg_type (TREE_TYPE (new_arg0)))
+	return NULL;
+    }
 
   if (TREE_CODE (arg1) == SSA_NAME)
     {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-sccvn.c gcc-6-20160721/gcc/tree-ssa-sccvn.c
--- gcc-6.1.0/gcc/tree-ssa-sccvn.c	2016-04-19 13:17:46.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-sccvn.c	2016-06-13 17:44:29.000000000 +0000
@@ -1976,11 +1976,7 @@
       /* We need to pre-pend vr->operands[0..i] to rhs.  */
       vec<vn_reference_op_s> old = vr->operands;
       if (i + 1 + rhs.length () > vr->operands.length ())
-	{
-	  vr->operands.safe_grow (i + 1 + rhs.length ());
-	  if (old == shared_lookup_references)
-	    shared_lookup_references = vr->operands;
-	}
+	vr->operands.safe_grow (i + 1 + rhs.length ());
       else
 	vr->operands.truncate (i + 1 + rhs.length ());
       FOR_EACH_VEC_ELT (rhs, j, vro)
@@ -2131,8 +2127,7 @@
 	{
 	  vec<vn_reference_op_s> old = vr->operands;
 	  vr->operands.safe_grow_cleared (2);
-	  if (old == shared_lookup_references
-	      && vr->operands != old)
+	  if (old == shared_lookup_references)
 	    shared_lookup_references = vr->operands;
 	}
       else
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-strlen.c gcc-6-20160721/gcc/tree-ssa-strlen.c
--- gcc-6.1.0/gcc/tree-ssa-strlen.c	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-strlen.c	2016-06-21 07:15:36.000000000 +0000
@@ -859,6 +859,65 @@
     }
 }
 
+/* Return true if STMT is a call to a builtin function with the right
+   arguments and attributes that should be considered for optimization
+   by this pass.  */
+
+static bool
+valid_builtin_call (gimple *stmt)
+{
+  if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
+    return false;
+
+  tree callee = gimple_call_fndecl (stmt);
+  switch (DECL_FUNCTION_CODE (callee))
+    {
+    case BUILT_IN_MEMCMP:
+    case BUILT_IN_STRCHR:
+    case BUILT_IN_STRCHR_CHKP:
+    case BUILT_IN_STRLEN:
+    case BUILT_IN_STRLEN_CHKP:
+      /* The above functions should be pure.  Punt if they aren't.  */
+      if (gimple_vdef (stmt) || gimple_vuse (stmt) == NULL_TREE)
+	return false;
+      break;
+
+    case BUILT_IN_CALLOC:
+    case BUILT_IN_MALLOC:
+    case BUILT_IN_MEMCPY:
+    case BUILT_IN_MEMCPY_CHK:
+    case BUILT_IN_MEMCPY_CHKP:
+    case BUILT_IN_MEMCPY_CHK_CHKP:
+    case BUILT_IN_MEMPCPY:
+    case BUILT_IN_MEMPCPY_CHK:
+    case BUILT_IN_MEMPCPY_CHKP:
+    case BUILT_IN_MEMPCPY_CHK_CHKP:
+    case BUILT_IN_MEMSET:
+    case BUILT_IN_STPCPY:
+    case BUILT_IN_STPCPY_CHK:
+    case BUILT_IN_STPCPY_CHKP:
+    case BUILT_IN_STPCPY_CHK_CHKP:
+    case BUILT_IN_STRCAT:
+    case BUILT_IN_STRCAT_CHK:
+    case BUILT_IN_STRCAT_CHKP:
+    case BUILT_IN_STRCAT_CHK_CHKP:
+    case BUILT_IN_STRCPY:
+    case BUILT_IN_STRCPY_CHK:
+    case BUILT_IN_STRCPY_CHKP:
+    case BUILT_IN_STRCPY_CHK_CHKP:
+      /* The above functions should be neither const nor pure.  Punt if they
+	 aren't.  */
+      if (gimple_vdef (stmt) == NULL_TREE || gimple_vuse (stmt) == NULL_TREE)
+	return false;
+      break;
+
+    default:
+      break;
+    }
+
+  return true;
+}
+
 /* If the last .MEM setter statement before STMT is
    memcpy (x, y, strlen (y) + 1), the only .MEM use of it is STMT
    and STMT is known to overwrite x[strlen (x)], adjust the last memcpy to
@@ -934,7 +993,7 @@
       return;
     }
 
-  if (!gimple_call_builtin_p (last.stmt, BUILT_IN_NORMAL))
+  if (!valid_builtin_call (last.stmt))
     return;
 
   callee = gimple_call_fndecl (last.stmt);
@@ -1810,7 +1869,7 @@
   if (!stmt1 || !is_gimple_call (stmt1))
     return true;
   tree callee1 = gimple_call_fndecl (stmt1);
-  if (!gimple_call_builtin_p (stmt1, BUILT_IN_NORMAL))
+  if (!valid_builtin_call (stmt1))
     return true;
   enum built_in_function code1 = DECL_FUNCTION_CODE (callee1);
   tree size = gimple_call_arg (stmt2, 2);
@@ -2055,7 +2114,7 @@
   if (is_gimple_call (stmt))
     {
       tree callee = gimple_call_fndecl (stmt);
-      if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
+      if (valid_builtin_call (stmt))
 	switch (DECL_FUNCTION_CODE (callee))
 	  {
 	  case BUILT_IN_STRLEN:
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-structalias.c gcc-6-20160721/gcc/tree-ssa-structalias.c
--- gcc-6.1.0/gcc/tree-ssa-structalias.c	2016-03-10 08:06:03.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-structalias.c	2016-05-13 13:22:42.000000000 +0000
@@ -4639,12 +4639,11 @@
 	  auto_vec<ce_s, 2> lhsc;
 	  struct constraint_expr rhs;
 	  struct constraint_expr *lhsp;
+	  bool aggr_p = aggregate_value_p (lhsop, gimple_call_fntype (t));
 
 	  get_constraint_for (lhsop, &lhsc);
 	  rhs = get_function_part_constraint (fi, fi_result);
-	  if (fndecl
-	      && DECL_RESULT (fndecl)
-	      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))
+	  if (aggr_p)
 	    {
 	      auto_vec<ce_s, 2> tem;
 	      tem.quick_push (rhs);
@@ -4654,22 +4653,19 @@
 	    }
 	  FOR_EACH_VEC_ELT (lhsc, j, lhsp)
 	    process_constraint (new_constraint (*lhsp, rhs));
-	}
 
-      /* If we pass the result decl by reference, honor that.  */
-      if (lhsop
-	  && fndecl
-	  && DECL_RESULT (fndecl)
-	  && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))
-	{
-	  struct constraint_expr lhs;
-	  struct constraint_expr *rhsp;
+	  /* If we pass the result decl by reference, honor that.  */
+	  if (aggr_p)
+	    {
+	      struct constraint_expr lhs;
+	      struct constraint_expr *rhsp;
 
-	  get_constraint_for_address_of (lhsop, &rhsc);
-	  lhs = get_function_part_constraint (fi, fi_result);
-	  FOR_EACH_VEC_ELT (rhsc, j, rhsp)
-	    process_constraint (new_constraint (lhs, *rhsp));
-	  rhsc.truncate (0);
+	      get_constraint_for_address_of (lhsop, &rhsc);
+	      lhs = get_function_part_constraint (fi, fi_result);
+	      FOR_EACH_VEC_ELT (rhsc, j, rhsp)
+		  process_constraint (new_constraint (lhs, *rhsp));
+	      rhsc.truncate (0);
+	    }
 	}
 
       /* If we use a static chain, pass it along.  */
@@ -7486,7 +7482,7 @@
   = { true, false, false, false, false, false, false, false, NULL };
 
 /* Associate node with varinfo DATA. Worker for
-   cgraph_for_node_and_aliases.  */
+   cgraph_for_symbol_thunks_and_aliases.  */
 static bool
 associate_varinfo_to_alias (struct cgraph_node *node, void *data)
 {
@@ -7496,6 +7492,29 @@
   return false;
 }
 
+/* Compute whether node is refered to non-locally.  Worker for
+   cgraph_for_symbol_thunks_and_aliases.  */
+static bool
+refered_from_nonlocal_fn (struct cgraph_node *node, void *data)
+{
+  bool *nonlocal_p = (bool *)data;
+  *nonlocal_p |= (node->used_from_other_partition
+		  || node->externally_visible
+		  || node->force_output);
+  return false;
+}
+
+/* Same for varpool nodes.  */
+static bool
+refered_from_nonlocal_var (struct varpool_node *node, void *data)
+{
+  bool *nonlocal_p = (bool *)data;
+  *nonlocal_p |= (node->used_from_other_partition
+		  || node->externally_visible
+		  || node->force_output);
+  return false;
+}
+
 /* Execute the driver for IPA PTA.  */
 static unsigned int
 ipa_pta_execute (void)
@@ -7559,6 +7578,8 @@
 			 || node->externally_visible
 			 || node->force_output
 			 || node_address_taken);
+      node->call_for_symbol_thunks_and_aliases (refered_from_nonlocal_fn,
+						&nonlocal_p, true);
 
       vi = create_function_info_for (node->decl,
 				     alias_get_name (node->decl), false,
@@ -7596,6 +7617,8 @@
       bool nonlocal_p = (var->used_from_other_partition
 			 || var->externally_visible
 			 || var->force_output);
+      var->call_for_symbol_and_aliases (refered_from_nonlocal_var,
+					&nonlocal_p, true);
       if (nonlocal_p)
 	vi->is_ipa_escape_point = true;
     }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-tail-merge.c gcc-6-20160721/gcc/tree-ssa-tail-merge.c
--- gcc-6.1.0/gcc/tree-ssa-tail-merge.c	2016-03-07 14:50:13.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-tail-merge.c	2016-06-10 09:45:51.000000000 +0000
@@ -538,6 +538,9 @@
   gimple *s1, *s2;
   basic_block bb1, bb2;
 
+  if (e1 == e2)
+    return 1;
+
   if (e1->hashval != e2->hashval)
     return 0;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa-uninit.c gcc-6-20160721/gcc/tree-ssa-uninit.c
--- gcc-6.1.0/gcc/tree-ssa-uninit.c	2016-01-13 12:15:01.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa-uninit.c	2016-06-21 07:13:52.000000000 +0000
@@ -133,6 +133,29 @@
   if (!has_undefined_value_p (t))
     return;
 
+  /* Anonymous SSA_NAMEs shouldn't be uninitialized, but ssa_undefined_value_p
+     can return true if the def stmt of anonymous SSA_NAME is COMPLEX_EXPR
+     created for conversion from scalar to complex.  Use the underlying var of
+     the COMPLEX_EXPRs real part in that case.  See PR71581.  */
+  if (expr == NULL_TREE
+      && var == NULL_TREE
+      && SSA_NAME_VAR (t) == NULL_TREE
+      && is_gimple_assign (SSA_NAME_DEF_STMT (t))
+      && gimple_assign_rhs_code (SSA_NAME_DEF_STMT (t)) == COMPLEX_EXPR)
+    {
+      tree v = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (t));
+      if (TREE_CODE (v) == SSA_NAME
+	  && has_undefined_value_p (v)
+	  && zerop (gimple_assign_rhs2 (SSA_NAME_DEF_STMT (t))))
+	{
+	  expr = SSA_NAME_VAR (v);
+	  var = expr;
+	}
+    }
+
+  if (expr == NULL_TREE)
+    return;
+
   /* TREE_NO_WARNING either means we already warned, or the front end
      wishes to suppress the warning.  */
   if ((context
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-ssa.c gcc-6-20160721/gcc/tree-ssa.c
--- gcc-6.1.0/gcc/tree-ssa.c	2016-02-09 08:35:22.000000000 +0000
+++ gcc-6-20160721/gcc/tree-ssa.c	2016-07-07 07:30:04.000000000 +0000
@@ -1342,6 +1342,18 @@
       tree decl = TREE_OPERAND (TREE_OPERAND (lhs, 0), 0);
       if (DECL_P (decl)
 	  && DECL_SIZE (decl) == TYPE_SIZE (TREE_TYPE (lhs))
+	  /* If the dynamic type of the decl has larger precision than
+	     the decl itself we can't use the decls type for SSA rewriting.  */
+	  && ((! INTEGRAL_TYPE_P (TREE_TYPE (decl))
+	       || compare_tree_int (DECL_SIZE (decl),
+				    TYPE_PRECISION (TREE_TYPE (decl))) == 0)
+	      || (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
+		  && (TYPE_PRECISION (TREE_TYPE (decl))
+		      >= TYPE_PRECISION (TREE_TYPE (lhs)))))
+	  /* Make sure we are not re-writing non-float copying into float
+	     copying as that can incur normalization.  */
+	  && (! FLOAT_TYPE_P (TREE_TYPE (decl))
+	      || types_compatible_p (TREE_TYPE (lhs), TREE_TYPE (decl)))
 	  && (TREE_THIS_VOLATILE (decl) == TREE_THIS_VOLATILE (lhs)))
 	return false;
     }
@@ -1590,9 +1602,16 @@
 		if (gimple_assign_lhs (stmt) != lhs
 		    && !useless_type_conversion_p (TREE_TYPE (lhs),
 						   TREE_TYPE (rhs)))
-		  rhs = fold_build1 (VIEW_CONVERT_EXPR,
-				     TREE_TYPE (lhs), rhs);
-
+		  {
+		    if (gimple_clobber_p (stmt))
+		      {
+			rhs = build_constructor (TREE_TYPE (lhs), NULL);
+			TREE_THIS_VOLATILE (rhs) = 1;
+		      }
+		    else
+		      rhs = fold_build1 (VIEW_CONVERT_EXPR,
+					 TREE_TYPE (lhs), rhs);
+		  }
 		if (gimple_assign_lhs (stmt) != lhs)
 		  gimple_assign_set_lhs (stmt, lhs);
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-vect-data-refs.c gcc-6-20160721/gcc/tree-vect-data-refs.c
--- gcc-6.1.0/gcc/tree-vect-data-refs.c	2016-04-15 07:28:44.000000000 +0000
+++ gcc-6-20160721/gcc/tree-vect-data-refs.c	2016-07-11 15:21:20.000000000 +0000
@@ -692,6 +692,7 @@
   tree base, base_addr;
   tree misalign = NULL_TREE;
   tree aligned_to;
+  tree step;
   unsigned HOST_WIDE_INT alignment;
 
   if (dump_enabled_p ())
@@ -822,16 +823,20 @@
       DR_VECT_AUX (dr)->base_element_aligned = true;
     }
 
+  if (loop && nested_in_vect_loop_p (loop, stmt))
+    step = STMT_VINFO_DR_STEP (stmt_info);
+  else
+    step = DR_STEP (dr);
   /* If this is a backward running DR then first access in the larger
      vectype actually is N-1 elements before the address in the DR.
      Adjust misalign accordingly.  */
-  if (tree_int_cst_sgn (DR_STEP (dr)) < 0)
+  if (tree_int_cst_sgn (step) < 0)
     {
       tree offset = ssize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);
       /* DR_STEP(dr) is the same as -TYPE_SIZE of the scalar type,
 	 otherwise we wouldn't be here.  */
-      offset = fold_build2 (MULT_EXPR, ssizetype, offset, DR_STEP (dr));
-      /* PLUS because DR_STEP was negative.  */
+      offset = fold_build2 (MULT_EXPR, ssizetype, offset, step);
+      /* PLUS because STEP was negative.  */
       misalign = size_binop (PLUS_EXPR, misalign, offset);
     }
 
@@ -2751,7 +2756,7 @@
 	  /* Sorting has ensured that DR_INIT (dra) <= DR_INIT (drb).  */
 	  HOST_WIDE_INT init_a = TREE_INT_CST_LOW (DR_INIT (dra));
 	  HOST_WIDE_INT init_b = TREE_INT_CST_LOW (DR_INIT (drb));
-	  gcc_assert (init_a < init_b);
+	  gcc_assert (init_a <= init_b);
 
 	  /* If init_b == init_a + the size of the type * k, we have an
 	     interleaving, and DRA is accessed before DRB.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-vect-loop.c gcc-6-20160721/gcc/tree-vect-loop.c
--- gcc-6.1.0/gcc/tree-vect-loop.c	2016-04-12 13:38:46.000000000 +0000
+++ gcc-6-20160721/gcc/tree-vect-loop.c	2016-06-01 16:06:29.000000000 +0000
@@ -216,7 +216,8 @@
 
 	  gcc_assert (stmt_info);
 
-	  if (STMT_VINFO_RELEVANT_P (stmt_info))
+	  if (STMT_VINFO_RELEVANT_P (stmt_info)
+	      || STMT_VINFO_LIVE_P (stmt_info))
             {
 	      gcc_assert (!STMT_VINFO_VECTYPE (stmt_info));
               scalar_type = TREE_TYPE (PHI_RESULT (phi));
@@ -437,9 +438,12 @@
 	      /* Bool ops don't participate in vectorization factor
 		 computation.  For comparison use compared types to
 		 compute a factor.  */
-	      if (TREE_CODE (scalar_type) == BOOLEAN_TYPE)
+	      if (TREE_CODE (scalar_type) == BOOLEAN_TYPE
+		  && is_gimple_assign (stmt)
+		  && gimple_assign_rhs_code (stmt) != COND_EXPR)
 		{
-		  if (STMT_VINFO_RELEVANT_P (stmt_info))
+		  if (STMT_VINFO_RELEVANT_P (stmt_info)
+		      || STMT_VINFO_LIVE_P (stmt_info))
 		    mask_producers.safe_push (stmt_info);
 		  bool_result = true;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-vect-patterns.c gcc-6-20160721/gcc/tree-vect-patterns.c
--- gcc-6.1.0/gcc/tree-vect-patterns.c	2016-03-23 09:52:00.000000000 +0000
+++ gcc-6-20160721/gcc/tree-vect-patterns.c	2016-05-10 16:59:04.000000000 +0000
@@ -3673,8 +3673,10 @@
 	  if (!rhs1_type)
 	    return NULL;
 	}
-      else
+      else if (COMPARISON_CLASS_P (rhs1))
 	rhs1_type = TREE_TYPE (TREE_OPERAND (rhs1, 0));
+      else
+	return NULL;
 
       vectype2 = get_mask_type_for_scalar_type (rhs1_type);
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-vect-slp.c gcc-6-20160721/gcc/tree-vect-slp.c
--- gcc-6.1.0/gcc/tree-vect-slp.c	2016-02-29 13:24:24.000000000 +0000
+++ gcc-6-20160721/gcc/tree-vect-slp.c	2016-06-06 18:47:33.000000000 +0000
@@ -3050,7 +3050,7 @@
 		      if (integer_zerop (op))
 			op = build_int_cst (TREE_TYPE (vector_type), 0);
 		      else if (integer_onep (op))
-			op = build_int_cst (TREE_TYPE (vector_type), 1);
+			op = build_all_ones_cst (TREE_TYPE (vector_type));
 		      else
 			gcc_unreachable ();
 		    }
@@ -3065,8 +3065,14 @@
 		  gimple *init_stmt;
 		  if (VECTOR_BOOLEAN_TYPE_P (vector_type))
 		    {
+		      tree true_val
+			= build_all_ones_cst (TREE_TYPE (vector_type));
+		      tree false_val
+			= build_zero_cst (TREE_TYPE (vector_type));
 		      gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (op)));
-		      init_stmt = gimple_build_assign (new_temp, NOP_EXPR, op);
+		      init_stmt = gimple_build_assign (new_temp, COND_EXPR,
+						       op, true_val,
+						       false_val);
 		    }
 		  else
 		    {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-vect-stmts.c gcc-6-20160721/gcc/tree-vect-stmts.c
--- gcc-6.1.0/gcc/tree-vect-stmts.c	2016-04-20 07:21:42.000000000 +0000
+++ gcc-6-20160721/gcc/tree-vect-stmts.c	2016-07-11 20:39:44.000000000 +0000
@@ -1256,10 +1256,11 @@
   gimple *init_stmt;
   tree new_temp;
 
-  if (TREE_CODE (type) == VECTOR_TYPE
-      && TREE_CODE (TREE_TYPE (val)) != VECTOR_TYPE)
+  /* We abuse this function to push sth to a SSA name with initial 'val'.  */
+  if (! useless_type_conversion_p (type, TREE_TYPE (val)))
     {
-      if (!types_compatible_p (TREE_TYPE (type), TREE_TYPE (val)))
+      gcc_assert (TREE_CODE (type) == VECTOR_TYPE);
+      if (! types_compatible_p (TREE_TYPE (type), TREE_TYPE (val)))
 	{
 	  /* Scalar boolean value should be transformed into
 	     all zeros or all ones value before building a vector.  */
@@ -1284,7 +1285,13 @@
 	  else
 	    {
 	      new_temp = make_ssa_name (TREE_TYPE (type));
-	      init_stmt = gimple_build_assign (new_temp, NOP_EXPR, val);
+	      if (! INTEGRAL_TYPE_P (TREE_TYPE (val)))
+		init_stmt = gimple_build_assign (new_temp,
+						 fold_build1 (VIEW_CONVERT_EXPR,
+							      TREE_TYPE (type),
+							      val));
+	      else
+		init_stmt = gimple_build_assign (new_temp, NOP_EXPR, val);
 	      vect_init_vector_1 (stmt, init_stmt, gsi);
 	      val = new_temp;
 	    }
@@ -3022,8 +3029,10 @@
     {
       STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_push (bestn->decl);
       for (i = 0; i < nargs; i++)
-	if (bestn->simdclone->args[i].arg_type
-	    == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)
+	if ((bestn->simdclone->args[i].arg_type
+	     == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)
+	    || (bestn->simdclone->args[i].arg_type
+		== SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP))
 	  {
 	    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_grow_cleared (i * 3
 									+ 1);
@@ -3159,6 +3168,7 @@
 	      vargs.safe_push (op);
 	      break;
 	    case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:
+	    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:
 	      if (j == 0)
 		{
 		  gimple_seq stmts;
@@ -3222,6 +3232,8 @@
 		  vargs.safe_push (new_temp);
 		}
 	      break;
+	    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:
+	    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:
 	    case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:
 	    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:
 	    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:
@@ -5074,11 +5086,8 @@
 	    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,
 			       slp_node, -1);
 	  if (op_type == ternary_op)
-	    {
-	      vec_oprnds2.create (1);
-	      vec_oprnds2.quick_push (vect_get_vec_def_for_operand (op2,
-		                                                    stmt));
-	    }
+	    vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
+			       slp_node, -1);
 	}
       else
 	{
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree-vrp.c gcc-6-20160721/gcc/tree-vrp.c
--- gcc-6.1.0/gcc/tree-vrp.c	2016-03-30 00:55:00.000000000 +0000
+++ gcc-6-20160721/gcc/tree-vrp.c	2016-07-07 07:30:04.000000000 +0000
@@ -2519,20 +2519,13 @@
 		  min = wide_int_to_tree (expr_type, tmin);
 		  max = wide_int_to_tree (expr_type, tmax);
 		}
-	      else if (min_ovf == -1 && max_ovf == 1)
-		{
-		  /* Underflow and overflow, drop to VR_VARYING.  */
-		  set_value_range_to_varying (vr);
-		  return;
-		}
-	      else
+	      else if ((min_ovf == -1 && max_ovf == 0)
+		       || (max_ovf == 1 && min_ovf == 0))
 		{
 		  /* Min underflow or max overflow.  The range kind
 		     changes to VR_ANTI_RANGE.  */
 		  bool covers = false;
 		  wide_int tem = tmin;
-		  gcc_assert ((min_ovf == -1 && max_ovf == 0)
-			      || (max_ovf == 1 && min_ovf == 0));
 		  type = VR_ANTI_RANGE;
 		  tmin = tmax + 1;
 		  if (wi::cmp (tmin, tmax, sgn) < 0)
@@ -2551,6 +2544,12 @@
 		  min = wide_int_to_tree (expr_type, tmin);
 		  max = wide_int_to_tree (expr_type, tmax);
 		}
+	      else
+		{
+		  /* Other underflow and/or overflow, drop to VR_VARYING.  */
+		  set_value_range_to_varying (vr);
+		  return;
+		}
 	    }
 	  else
 	    {
@@ -2991,7 +2990,8 @@
 		     and divisor are available.  */
 		  if (vr1.type == VR_RANGE
 		      && !symbolic_range_p (&vr0)
-		      && !symbolic_range_p (&vr1))
+		      && !symbolic_range_p (&vr1)
+		      && compare_values (vr1.max, zero) != 0)
 		    min = int_const_binop (code, vr0.min, vr1.max);
 		  else
 		    min = zero;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree.c gcc-6-20160721/gcc/tree.c
--- gcc-6.1.0/gcc/tree.c	2016-04-14 16:51:16.000000000 +0000
+++ gcc-6-20160721/gcc/tree.c	2016-07-04 17:33:50.000000000 +0000
@@ -5015,7 +5015,7 @@
       && TREE_CODE (TREE_VALUE (attr2)) == TREE_LIST)
     {
       /* Handle attribute format.  */
-      if (is_attribute_p ("format", TREE_PURPOSE (attr1)))
+      if (is_attribute_p ("format", get_attribute_name (attr1)))
 	{
 	  attr1 = TREE_VALUE (attr1);
 	  attr2 = TREE_VALUE (attr2);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/tree.h gcc-6-20160721/gcc/tree.h
--- gcc-6.1.0/gcc/tree.h	2016-04-08 21:09:47.000000000 +0000
+++ gcc-6-20160721/gcc/tree.h	2016-05-25 16:01:24.000000000 +0000
@@ -4730,6 +4730,17 @@
 	  && TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));
 }
 
+/* Return true if the argument is a complete type or an array
+   of unknown bound (whose type is incomplete but) whose elements
+   have complete type.  */
+static inline bool
+complete_or_array_type_p (const_tree type)
+{
+  return COMPLETE_TYPE_P (type)
+	 || (TREE_CODE (type) == ARRAY_TYPE
+	     && COMPLETE_TYPE_P (TREE_TYPE (type)));
+}
+
 extern tree strip_float_extensions (tree);
 extern int really_constant_p (const_tree);
 extern bool decl_address_invariant_p (const_tree);
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/gcc/ubsan.c gcc-6-20160721/gcc/ubsan.c
--- gcc-6.1.0/gcc/ubsan.c	2016-01-06 10:24:15.000000000 +0000
+++ gcc-6-20160721/gcc/ubsan.c	2016-05-06 10:54:12.000000000 +0000
@@ -302,7 +302,6 @@
 static unsigned short
 get_ubsan_type_info_for_type (tree type)
 {
-  gcc_assert (TYPE_SIZE (type) && tree_fits_uhwi_p (TYPE_SIZE (type)));
   if (TREE_CODE (type) == REAL_TYPE)
     return tree_to_uhwi (TYPE_SIZE (type));
   else if (INTEGRAL_TYPE_P (type))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libatomic/ChangeLog gcc-6-20160721/libatomic/ChangeLog
--- gcc-6.1.0/libatomic/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libatomic/ChangeLog	2016-05-10 07:03:07.000000000 +0000
@@ -1,3 +1,13 @@
+2016-05-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline:
+	2016-04-27  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* configure.tgt (configure_tgt_pre_target_cpu_XCFLAGS): New variable.
+	(*-*-rtems*): New supported target.
+	* config/rtems/host-config.h: New file.
+	* config/rtems/lock.c: Likewise.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libatomic/config/rtems/host-config.h gcc-6-20160721/libatomic/config/rtems/host-config.h
--- gcc-6.1.0/libatomic/config/rtems/host-config.h	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libatomic/config/rtems/host-config.h	2016-05-10 07:03:07.000000000 +0000
@@ -0,0 +1,41 @@
+/* Copyright (C) 2016 Free Software Foundation, Inc.
+   Contributed by Sebastian Huber <sebastian.huber@embedded-brains.de>.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Included after all more target-specific host-config.h.  */
+
+#include <machine/_libatomic.h>
+
+static inline UWORD
+protect_start (void *ptr)
+{
+  return _Libatomic_Protect_start (ptr);
+}
+
+static inline void
+protect_end (void *ptr, UWORD isr_level)
+{
+  _Libatomic_Protect_end (ptr, isr_level);
+}
+
+#include_next <host-config.h>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libatomic/config/rtems/lock.c gcc-6-20160721/libatomic/config/rtems/lock.c
--- gcc-6.1.0/libatomic/config/rtems/lock.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libatomic/config/rtems/lock.c	2016-05-10 07:03:07.000000000 +0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2016 Free Software Foundation, Inc.
+   Contributed by Sebastian Huber <sebastian.huber@embedded-brains.de>.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "libatomic_i.h"
+
+void
+libat_lock_n (void *ptr, size_t n)
+{
+  _Libatomic_Lock_n (ptr, n);
+}
+
+void
+libat_unlock_n (void *ptr, size_t n)
+{
+  _Libatomic_Unlock_n (ptr, n);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libatomic/configure.tgt gcc-6-20160721/libatomic/configure.tgt
--- gcc-6.1.0/libatomic/configure.tgt	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libatomic/configure.tgt	2016-05-10 07:03:07.000000000 +0000
@@ -26,6 +26,10 @@
 # Map the target cpu to an ARCH sub-directory.  At the same time,
 # work out any special compilation flags as necessary.
 
+# Give operating systems the opportunity to discard XCFLAGS modifications based
+# on ${target_cpu}.  For example to allow proper use of multilibs.
+configure_tgt_pre_target_cpu_XCFLAGS="${XCFLAGS}"
+
 case "${target_cpu}" in
   alpha*)
 	# fenv.c needs this option to generate inexact exceptions.
@@ -128,6 +132,12 @@
             ;;
         esac
 	;;
+
+  *-*-rtems*)
+	XCFLAGS="${configure_tgt_pre_target_cpu_XCFLAGS}"
+	config_path="rtems"
+	;;
+
   *-*-elf*)
 	# ??? No target OS.  We could be targeting bare-metal kernel-mode,
 	# or user-mode for some custom OS.  If the target supports TAS,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libbacktrace/ChangeLog gcc-6-20160721/libbacktrace/ChangeLog
--- gcc-6.1.0/libbacktrace/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libbacktrace/ChangeLog	2016-05-18 14:48:40.000000000 +0000
@@ -1,3 +1,9 @@
+2016-05-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/71161
+	* elf.c (phdr_callback) [__i386__]: Add
+	__attribute__((__force_align_arg_pointer__)).
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
@@ -19,12 +25,13 @@
 
 2015-12-18  Andris Pavenis  <andris.pavenis@iki.fi>
 
-	* configure.ac: Specify that DJGPP do not have mmap even when sys/mman.h exists
+	* configure.ac: Specify that DJGPP do not have mmap
+	even when sys/mman.h exists.
 	* configure: Regenerate
 
 2015-12-09  John David Anglin  <danglin@gcc.gnu.org>
 
-	PR 68115/libfortran
+	PR libgfortran/68115
 	* configure.ac: Set libbacktrace_cv_sys_sync to no on hppa*-*-hpux*.
 	* configure: Regenerate.
 	* elf.c (backtrace_initialize): Cast __sync_bool_compare_and_swap call
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libbacktrace/elf.c gcc-6-20160721/libbacktrace/elf.c
--- gcc-6.1.0/libbacktrace/elf.c	2016-03-02 16:32:55.000000000 +0000
+++ gcc-6-20160721/libbacktrace/elf.c	2016-05-18 14:48:40.000000000 +0000
@@ -866,6 +866,9 @@
    libraries.  */
 
 static int
+#ifdef __i386__
+__attribute__ ((__force_align_arg_pointer__))
+#endif
 phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,
 	       void *pdata)
 {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libcilkrts/ChangeLog gcc-6-20160721/libcilkrts/ChangeLog
--- gcc-6.1.0/libcilkrts/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libcilkrts/ChangeLog	2016-05-08 11:42:49.000000000 +0000
@@ -1,3 +1,12 @@
+2016-05-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2016-04-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/60290
+	* Makefile.am (GENERAL_FLAGS): Add -funwind-tables.
+	* Makefile.in: Regenerate.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libcilkrts/Makefile.am gcc-6-20160721/libcilkrts/Makefile.am
--- gcc-6.1.0/libcilkrts/Makefile.am	2014-08-12 11:06:44.000000000 +0000
+++ gcc-6-20160721/libcilkrts/Makefile.am	2016-05-08 11:42:49.000000000 +0000
@@ -43,6 +43,9 @@
 # Enable Intel Cilk Plus extension
 GENERAL_FLAGS += -fcilkplus
 
+# Always generate unwind tables
+GENERAL_FLAGS += -funwind-tables
+
 AM_CFLAGS = $(XCFLAGS) $(GENERAL_FLAGS) -std=c99
 AM_CPPFLAGS = $(GENERAL_FLAGS)
 AM_LDFLAGS = $(XLDFLAGS)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libcilkrts/Makefile.in gcc-6-20160721/libcilkrts/Makefile.in
--- gcc-6.1.0/libcilkrts/Makefile.in	2015-05-13 11:01:24.000000000 +0000
+++ gcc-6-20160721/libcilkrts/Makefile.in	2016-05-08 11:42:49.000000000 +0000
@@ -371,9 +371,11 @@
 # GENERAL_FLAGS += -D_Cilk_spawn="" -D_Cilk_sync="" -D_Cilk_for=for
 
 # Enable Intel Cilk Plus extension
+
+# Always generate unwind tables
 GENERAL_FLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/runtime \
 	-I$(top_srcdir)/runtime/config/$(config_dir) \
-	-DIN_CILK_RUNTIME=1 -fcilkplus
+	-DIN_CILK_RUNTIME=1 -fcilkplus -funwind-tables
 AM_CFLAGS = $(XCFLAGS) $(GENERAL_FLAGS) -std=c99
 AM_CPPFLAGS = $(GENERAL_FLAGS)
 AM_LDFLAGS = $(XLDFLAGS)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libffi/ChangeLog gcc-6-20160721/libffi/ChangeLog
--- gcc-6.1.0/libffi/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libffi/ChangeLog	2016-05-23 15:00:41.000000000 +0000
@@ -1,3 +1,10 @@
+2016-05-23  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport trunk r236594:
+
+	PR libffi/65567
+	* testsuite/lib/libffi.exp (libffi_feature_test): Fix, and simply.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
Only in gcc-6.1.0/libffi/doc: libffi.info
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libffi/testsuite/lib/libffi.exp gcc-6-20160721/libffi/testsuite/lib/libffi.exp
--- gcc-6.1.0/libffi/testsuite/lib/libffi.exp	2015-10-27 00:39:32.000000000 +0000
+++ gcc-6-20160721/libffi/testsuite/lib/libffi.exp	2016-05-23 15:00:41.000000000 +0000
@@ -227,20 +227,21 @@
 
 # TEST should be a preprocessor condition.  Returns true if it holds.
 proc libffi_feature_test { test } {
-    set src "ffitest.c"
+    set src "ffitest[pid].c"
 
     set f [open $src "w"]
     puts $f "#include <ffi.h>"
     puts $f $test
-    puts $f "xyzzy"
+    puts $f "/* OK */"
+    puts $f "#else"
+    puts $f "# error Failed $test"
     puts $f "#endif"
     close $f
 
-    set lines [libffi_target_compile $src "" "preprocess" ""]
+    set lines [libffi_target_compile $src /dev/null assembly ""]
     file delete $src
 
-    set last [lindex [split $lines] end]
-    return [regexp -- "xyzzy" $last]
+    return [string match "" $lines]
 }
 
 # Utility routines.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgcc/ChangeLog gcc-6-20160721/libgcc/ChangeLog
--- gcc-6.1.0/libgcc/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libgcc/ChangeLog	2016-07-14 14:03:20.000000000 +0000
@@ -1,3 +1,25 @@
+2016-07-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/_divkc3.c: New.
+	* config/rs6000/_mulkc3.c: New.
+	* config/rs6000/quad-float128.h: Define TFtype; declare _mulkc3
+	and _divkc3.
+	* config/rs6000/t-float128: Add _mulkc3 and _divkc3 to
+	fp128_ppc_funcs.
+
+2016-05-17  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2016-05-10  Joel Sherrill <joel@rtems.org>
+
+	PR libgcc/70720
+	* config.host (moxie-*-rtems*): Merge this stanza with other moxie
+	targets so the same extra_parts are built.  Also have tmake_file add
+	on to its value rather than override.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgcc/config/rs6000/_divkc3.c gcc-6-20160721/libgcc/config/rs6000/_divkc3.c
--- gcc-6.1.0/libgcc/config/rs6000/_divkc3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgcc/config/rs6000/_divkc3.c	2016-07-14 14:03:20.000000000 +0000
@@ -0,0 +1,64 @@
+typedef float KFtype __attribute__ ((mode (KF)));
+typedef __complex float KCtype __attribute__ ((mode (KC)));
+
+#define COPYSIGN(x,y) __builtin_copysignq (x, y)
+#define INFINITY __builtin_infq ()
+#define FABS __builtin_fabsq
+#define isnan __builtin_isnan
+#define isinf __builtin_isinf
+#define isfinite __builtin_isfinite
+
+KCtype
+__divkc3 (KFtype a, KFtype b, KFtype c, KFtype d)
+{
+  KFtype denom, ratio, x, y;
+  KCtype res;
+
+  /* ??? We can get better behavior from logarithmic scaling instead of
+     the division.  But that would mean starting to link libgcc against
+     libm.  We could implement something akin to ldexp/frexp as gcc builtins
+     fairly easily...  */
+  if (FABS (c) < FABS (d))
+    {
+      ratio = c / d;
+      denom = (c * ratio) + d;
+      x = ((a * ratio) + b) / denom;
+      y = ((b * ratio) - a) / denom;
+    }
+  else
+    {
+      ratio = d / c;
+      denom = (d * ratio) + c;
+      x = ((b * ratio) + a) / denom;
+      y = (b - (a * ratio)) / denom;
+    }
+
+  /* Recover infinities and zeros that computed as NaN+iNaN; the only cases
+     are nonzero/zero, infinite/finite, and finite/infinite.  */
+  if (isnan (x) && isnan (y))
+    {
+      if (c == 0.0 && d == 0.0 && (!isnan (a) || !isnan (b)))
+	{
+	  x = COPYSIGN (INFINITY, c) * a;
+	  y = COPYSIGN (INFINITY, c) * b;
+	}
+      else if ((isinf (a) || isinf (b)) && isfinite (c) && isfinite (d))
+	{
+	  a = COPYSIGN (isinf (a) ? 1 : 0, a);
+	  b = COPYSIGN (isinf (b) ? 1 : 0, b);
+	  x = INFINITY * (a * c + b * d);
+	  y = INFINITY * (b * c - a * d);
+	}
+      else if ((isinf (c) || isinf (d)) && isfinite (a) && isfinite (b))
+	{
+	  c = COPYSIGN (isinf (c) ? 1 : 0, c);
+	  d = COPYSIGN (isinf (d) ? 1 : 0, d);
+	  x = 0.0 * (a * c + b * d);
+	  y = 0.0 * (b * c - a * d);
+	}
+    }
+
+  __real__ res = x;
+  __imag__ res = y;
+  return res;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgcc/config/rs6000/_mulkc3.c gcc-6-20160721/libgcc/config/rs6000/_mulkc3.c
--- gcc-6.1.0/libgcc/config/rs6000/_mulkc3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgcc/config/rs6000/_mulkc3.c	2016-07-14 14:03:20.000000000 +0000
@@ -0,0 +1,69 @@
+typedef float KFtype __attribute__ ((mode (KF)));
+typedef __complex float KCtype __attribute__ ((mode (KC)));
+
+#define COPYSIGN(x,y) __builtin_copysignq (x, y)
+#define INFINITY __builtin_infq ()
+#define isnan __builtin_isnan
+#define isinf __builtin_isinf
+
+KCtype
+__mulkc3 (KFtype a, KFtype b, KFtype c, KFtype d)
+{
+  KFtype ac, bd, ad, bc, x, y;
+  KCtype res;
+
+  ac = a * c;
+  bd = b * d;
+  ad = a * d;
+  bc = b * c;
+
+  x = ac - bd;
+  y = ad + bc;
+
+  if (isnan (x) && isnan (y))
+    {
+      /* Recover infinities that computed as NaN + iNaN.  */
+      _Bool recalc = 0;
+      if (isinf (a) || isinf (b))
+	{
+	  /* z is infinite.  "Box" the infinity and change NaNs in
+	     the other factor to 0.  */
+	  a = COPYSIGN (isinf (a) ? 1 : 0, a);
+	  b = COPYSIGN (isinf (b) ? 1 : 0, b);
+	  if (isnan (c)) c = COPYSIGN (0, c);
+	  if (isnan (d)) d = COPYSIGN (0, d);
+          recalc = 1;
+	}
+     if (isinf (c) || isinf (d))
+	{
+	  /* w is infinite.  "Box" the infinity and change NaNs in
+	     the other factor to 0.  */
+	  c = COPYSIGN (isinf (c) ? 1 : 0, c);
+	  d = COPYSIGN (isinf (d) ? 1 : 0, d);
+	  if (isnan (a)) a = COPYSIGN (0, a);
+	  if (isnan (b)) b = COPYSIGN (0, b);
+	  recalc = 1;
+	}
+     if (!recalc
+	  && (isinf (ac) || isinf (bd)
+	      || isinf (ad) || isinf (bc)))
+	{
+	  /* Recover infinities from overflow by changing NaNs to 0.  */
+	  if (isnan (a)) a = COPYSIGN (0, a);
+	  if (isnan (b)) b = COPYSIGN (0, b);
+	  if (isnan (c)) c = COPYSIGN (0, c);
+	  if (isnan (d)) d = COPYSIGN (0, d);
+	  recalc = 1;
+	}
+      if (recalc)
+	{
+	  x = INFINITY * (a * c - b * d);
+	  y = INFINITY * (a * d + b * c);
+	}
+    }
+
+  __real__ res = x;
+  __imag__ res = y;
+  return res;
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgcc/config/rs6000/quad-float128.h gcc-6-20160721/libgcc/config/rs6000/quad-float128.h
--- gcc-6.1.0/libgcc/config/rs6000/quad-float128.h	2016-01-21 17:52:33.000000000 +0000
+++ gcc-6-20160721/libgcc/config/rs6000/quad-float128.h	2016-07-14 14:03:20.000000000 +0000
@@ -33,6 +33,10 @@
    This define forces it to use KFmode (aka, ieee 128-bit floating point).  */
 #define TF KF
 
+/* We also need TCtype to represent complex ieee 128-bit float for
+   __mulkc3 and __divkc3.  */
+typedef __complex float TCtype __attribute__ ((mode (KC)));
+
 /* Force the use of the VSX instruction set.  */
 #if defined(_ARCH_PPC) && (!defined(__VSX__) || !defined(__FLOAT128__))
 #pragma GCC target ("vsx,float128")
@@ -154,6 +158,10 @@
 extern IBM128_TYPE __extendkftf2 (TFtype);
 extern TFtype __trunctfkf2 (IBM128_TYPE);
 
+/* Complex __float128 built on __float128 interfaces.  */
+extern TCtype __mulkc3 (TFtype, TFtype, TFtype, TFtype);
+extern TCtype __divkc3 (TFtype, TFtype, TFtype, TFtype);
+
 /* Implementation of conversions between __ibm128 and __float128, to allow the
    same code to be used on systems with IEEE 128-bit emulation and with IEEE
    128-bit hardware support.  */
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgcc/config/rs6000/t-float128 gcc-6-20160721/libgcc/config/rs6000/t-float128
--- gcc-6.1.0/libgcc/config/rs6000/t-float128	2016-01-21 17:52:33.000000000 +0000
+++ gcc-6-20160721/libgcc/config/rs6000/t-float128	2016-07-14 14:03:20.000000000 +0000
@@ -25,7 +25,7 @@
 # New functions for software emulation
 fp128_ppc_funcs		= floattikf floatuntikf fixkfti fixunskfti \
 			  extendkftf2-sw trunctfkf2-sw \
-			  sfp-exceptions
+			  sfp-exceptions _mulkc3 _divkc3
 
 fp128_ppc_src		= $(addprefix $(srcdir)/config/rs6000/,$(addsuffix \
 				.c,$(fp128_ppc_funcs)))
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgcc/config.host gcc-6-20160721/libgcc/config.host
--- gcc-6.1.0/libgcc/config.host	2016-02-26 20:02:28.000000000 +0000
+++ gcc-6-20160721/libgcc/config.host	2016-05-17 06:15:52.000000000 +0000
@@ -931,14 +931,9 @@
 mn10300-*-*)
 	tmake_file=t-fdpbit
 	;;
-moxie-*-elf | moxie-*-moxiebox* | moxie-*-uclinux*)
-	tmake_file="moxie/t-moxie t-softfp-sfdf t-softfp-excl t-softfp"
-	extra_parts="$extra_parts crti.o crtn.o crtbegin.o crtend.o"
-	;;
-moxie-*-rtems*)
+moxie-*-elf | moxie-*-moxiebox* | moxie-*-uclinux* | moxie-*-rtems*)
 	tmake_file="$tmake_file moxie/t-moxie t-softfp-sfdf t-softfp-excl t-softfp"
-	# Don't use default.
-	extra_parts=
+	extra_parts="$extra_parts crti.o crtn.o crtbegin.o crtend.o"
 	;;
 msp430*-*-elf)
 	tmake_file="$tm_file t-crtstuff t-fdpbit msp430/t-msp430"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/ChangeLog gcc-6-20160721/libgomp/ChangeLog
--- gcc-6.1.0/libgomp/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libgomp/ChangeLog	2016-07-02 10:24:41.000000000 +0000
@@ -1,3 +1,65 @@
+2016-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/71717
+	* testsuite/libgomp.fortran/associate3.f90: New test.
+
+2016-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-06-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c++/target-21.C: New test.
+
+	2016-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c++/target-20.C: New test.
+
+2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/71373
+	Backport from trunk r237291:
+	2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>
+		    Cesar Philippidis  <cesar@codesourcery.com>
+
+	* libgomp.oacc-c/nested-function-1.c: New file.
+	* libgomp.oacc-c/nested-function-2.c: Likewise.
+	* libgomp.oacc-fortran/nested-function-1.f90: Likewise.
+	* libgomp.oacc-fortran/nested-function-2.f90: Likewise.
+	* libgomp.oacc-fortran/nested-function-3.f90: Likewise.
+
+	PR c/71381
+	Backport from trunk r237290:
+	* testsuite/libgomp.oacc-c-c++-common/cache-1.c: #include
+	"../../../gcc/testsuite/c-c++-common/goacc/cache-1.c".
+	* testsuite/libgomp.oacc-fortran/cache-1.f95: New file.
+
+2016-05-23  Martin Jambor  <mjambor@suse.cz>
+
+	* testsuite/libgomp.hsa.c/switch-sbr-2.c: New test.
+
+2016-05-16  Martin Jambor  <mjambor@suse.cz>
+
+        * testsuite/libgomp.hsa.c/complex-align-2.c: New test.
+
+2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR middle-end/70626
+	* testsuite/libgomp.oacc-c++/template-reduction.C: Adjust test.
+	* testsuite/libgomp.oacc-c-c++-common/combined-reduction.c: New test.
+	* testsuite/libgomp.oacc-fortran/combined-reduction.f90: New test.
+
+2016-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/70680
+	* testsuite/libgomp.c/pr70680-1.c: New test.
+	* testsuite/libgomp.c/pr70680-2.c: New test.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
Only in gcc-6.1.0/libgomp: libgomp.info
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.c/pr70680-1.c gcc-6-20160721/libgomp/testsuite/libgomp.c/pr70680-1.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.c/pr70680-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.c/pr70680-1.c	2016-04-27 12:22:47.000000000 +0000
@@ -0,0 +1,75 @@
+/* PR middle-end/70680 */
+
+int v;
+
+void
+f1 (void)
+{
+  int i = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd
+    for (i = 0; i < 100; i++)
+      ;
+    v = i;
+  }
+  if (i != 100)
+    __builtin_abort ();
+}
+
+void
+f2 (void)
+{
+  int i = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd
+    for (i = 0; i < 100; i++)
+      ;
+  }
+  if (i != 100)
+    __builtin_abort ();
+}
+
+void
+f3 (void)
+{
+  int i = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd linear(i: 1)
+    for (i = 0; i < 100; i++)
+      ;
+    v = i;
+  }
+  if (i != 100)
+    __builtin_abort ();
+}
+
+void
+f4 (void)
+{
+  int i = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd linear(i: 1)
+    for (i = 0; i < 100; i++)
+      ;
+  }
+  if (i != 100)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  f1 ();
+  if (v++ != 100)
+    __builtin_abort ();
+  f2 ();
+  f3 ();
+  if (v++ != 100)
+    __builtin_abort ();
+  f4 ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.c/pr70680-2.c gcc-6-20160721/libgomp/testsuite/libgomp.c/pr70680-2.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.c/pr70680-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.c/pr70680-2.c	2016-04-27 12:22:47.000000000 +0000
@@ -0,0 +1,79 @@
+/* PR middle-end/70680 */
+
+int v;
+
+void
+f1 (void)
+{
+  int i = 0, j = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd collapse(2)
+    for (i = 0; i < 10; i++)
+      for (j = 0; j < 10; j++)
+	;
+    v = i + j;
+  }
+  if (i != 10 || j != 10)
+    __builtin_abort ();
+}
+
+void
+f2 (void)
+{
+  int i = 0, j = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd collapse(2)
+    for (i = 0; i < 10; i++)
+      for (j = 0; j < 10; j++)
+	;
+  }
+  if (i != 10 || j != 10)
+    __builtin_abort ();
+}
+
+void
+f3 (void)
+{
+  int i = 0, j = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd collapse(2) lastprivate (i, j)
+    for (i = 0; i < 10; i++)
+      for (j = 0; j < 10; j++)
+	;
+    v = i + j;
+  }
+  if (i != 10 || j != 10)
+    __builtin_abort ();
+}
+
+void
+f4 (void)
+{
+  int i = 0, j = 0;
+#pragma omp task default(shared) if(0)
+  {
+#pragma omp simd collapse(2) lastprivate (i, j)
+    for (i = 0; i < 10; i++)
+      for (j = 0; j < 10; j++)
+	;
+  }
+  if (i != 10 || j != 10)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  f1 ();
+  if (v++ != 20)
+    __builtin_abort ();
+  f2 ();
+  f3 ();
+  if (v++ != 20)
+    __builtin_abort ();
+  f4 ();
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.c++/target-20.C gcc-6-20160721/libgomp/testsuite/libgomp.c++/target-20.C
--- gcc-6.1.0/libgomp/testsuite/libgomp.c++/target-20.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.c++/target-20.C	2016-06-21 07:09:57.000000000 +0000
@@ -0,0 +1,80 @@
+extern "C" void abort ();
+struct S { int a, b, c, d; };
+
+void
+foo (S &s)
+{
+  int err;
+  #pragma omp target map (s.b, s.d) map (from: err)
+  {
+    err = s.b != 21 || s.d != 24;
+    s.b++; s.d++;
+  }
+  if (err || s.b != 22 || s.d != 25)
+    abort ();
+  #pragma omp target data map (s.b, s.d)
+  {
+    #pragma omp target map (alloc: s.b, s.d) map (from: err)
+    {
+      err = s.b != 22 || s.d != 25;
+      s.b++; s.d++;
+    }
+  }
+  if (err || s.b != 23 || s.d != 26)
+    abort ();
+  #pragma omp target data map (s)
+  {
+    #pragma omp target map (alloc: s.b, s.d) map (from: err)
+    {
+      err = s.b != 23 || s.d != 26;
+      s.b++; s.d++;
+    }
+  }
+  if (err || s.b != 24 || s.d != 27)
+    abort ();
+}
+
+template <typename T, typename U>
+void
+bar (S &s, T &t, U u)
+{
+  int err;
+  #pragma omp target map (s.b, s.d, t.b, t.d, u.b, u.d) map (from: err)
+  {
+    err = s.b != 21 || s.d != 24 || t.b != 73 || t.d != 82 || u.b != 31 || u.d != 37;
+    s.b++; s.d++; t.b++; t.d++; u.b++; u.d++;
+  }
+  if (err || s.b != 22 || s.d != 25 || t.b != 74 || t.d != 83 || u.b != 32 || u.d != 38)
+    abort ();
+  #pragma omp target data map (s.b, s.d, t.b, t.d, u.b, u.d)
+  {
+    #pragma omp target map (alloc: s.b, s.d, t.b, t.d, u.b, u.d) map (from: err)
+    {
+      err = s.b != 22 || s.d != 25 || t.b != 74 || t.d != 83 || u.b != 32 || u.d != 38;
+      s.b++; s.d++; t.b++; t.d++; u.b++; u.d++;
+    }
+  }
+  if (err || s.b != 23 || s.d != 26 || t.b != 75 || t.d != 84 || u.b != 33 || u.d != 39)
+    abort ();
+  #pragma omp target data map (s, t, u)
+  {
+    #pragma omp target map (alloc: s.b, s.d, t.b, t.d, u.b, u.d) map (from: err)
+    {
+      err = s.b != 23 || s.d != 26 || t.b != 75 || t.d != 84 || u.b != 33 || u.d != 39;
+      s.b++; s.d++; t.b++; t.d++; u.b++; u.d++;
+    }
+  }
+  if (err || s.b != 24 || s.d != 27 || t.b != 76 || t.d != 85 || u.b != 34 || u.d != 40)
+    abort ();
+}
+
+int
+main ()
+{
+  S s = { 1, 21, 2, 24 };
+  foo (s);
+  S s2 = { 3, 21, 4, 24 };
+  S t = { 5, 73, 6, 82 };
+  S u = { 7, 31, 8, 37 };
+  bar <S, S &> (s2, t, u);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.c++/target-21.C gcc-6-20160721/libgomp/testsuite/libgomp.c++/target-21.C
--- gcc-6.1.0/libgomp/testsuite/libgomp.c++/target-21.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.c++/target-21.C	2016-06-21 07:11:10.000000000 +0000
@@ -0,0 +1,173 @@
+extern "C" void abort ();
+struct T { char t[270]; };
+struct S { int (&x)[10]; int *&y; T t; int &z; S (); ~S (); };
+
+template <int N>
+void
+foo (S s)
+{
+  int err;
+  #pragma omp target map (s.x[0:N], s.y[0:N]) map (s.t.t[16:3]) map (from: err)
+  {
+    err = s.x[2] != 28 || s.y[2] != 37 || s.t.t[17] != 81;
+    s.x[2]++;
+    s.y[2]++;
+    s.t.t[17]++;
+  }
+  if (err || s.x[2] != 29 || s.y[2] != 38 || s.t.t[17] != 82)
+    abort ();
+}
+
+template <int N>
+void
+bar (S s)
+{
+  int err;
+  #pragma omp target map (s.x, s.z)map(from:err)
+  {
+    err = s.x[2] != 29 || s.z != 6;
+    s.x[2]++;
+    s.z++;
+  }
+  if (err || s.x[2] != 30 || s.z != 7)
+    abort ();
+}
+
+template <int N>
+void
+foo2 (S &s)
+{
+  int err;
+  #pragma omp target map (s.x[N:10], s.y[N:10]) map (from: err) map (s.t.t[N+16:N+3])
+  {
+    err = s.x[2] != 30 || s.y[2] != 38 || s.t.t[17] != 81;
+    s.x[2]++;
+    s.y[2]++;
+    s.t.t[17]++;
+  }
+  if (err || s.x[2] != 31 || s.y[2] != 39 || s.t.t[17] != 82)
+    abort ();
+}
+
+template <int N>
+void
+bar2 (S &s)
+{
+  int err;
+  #pragma omp target map (s.x, s.z)map(from:err)
+  {
+    err = s.x[2] != 31 || s.z != 7;
+    s.x[2]++;
+    s.z++;
+  }
+  if (err || s.x[2] != 32 || s.z != 8)
+    abort ();
+}
+
+template <typename U>
+void
+foo3 (U s)
+{
+  int err;
+  #pragma omp target map (s.x[0:10], s.y[0:10]) map (from: err) map (s.t.t[16:3])
+  {
+    err = s.x[2] != 32 || s.y[2] != 39 || s.t.t[17] != 82;
+    s.x[2]++;
+    s.y[2]++;
+    s.t.t[17]++;
+  }
+  if (err || s.x[2] != 33 || s.y[2] != 40 || s.t.t[17] != 83)
+    abort ();
+}
+
+template <typename U>
+void
+bar3 (U s)
+{
+  int err;
+  #pragma omp target map (s.x, s.z)map(from:err)
+  {
+    err = s.x[2] != 33 || s.z != 8;
+    s.x[2]++;
+    s.z++;
+  }
+  if (err || s.x[2] != 34 || s.z != 9)
+    abort ();
+}
+
+template <typename U>
+void
+foo4 (U &s)
+{
+  int err;
+  #pragma omp target map (s.x[0:10], s.y[0:10]) map (from: err) map (s.t.t[16:3])
+  {
+    err = s.x[2] != 34 || s.y[2] != 40 || s.t.t[17] != 82;
+    s.x[2]++;
+    s.y[2]++;
+    s.t.t[17]++;
+  }
+  if (err || s.x[2] != 35 || s.y[2] != 41 || s.t.t[17] != 83)
+    abort ();
+}
+
+template <typename U>
+void
+bar4 (U &s)
+{
+  int err;
+  #pragma omp target map (s.x, s.z)map(from:err)
+  {
+    err = s.x[2] != 35 || s.z != 9;
+    s.x[2]++;
+    s.z++;
+  }
+  if (err || s.x[2] != 36 || s.z != 10)
+    abort ();
+}
+
+int xt[10] = { 1, 2, 28, 3, 4, 5, 6, 7, 8, 9 };
+int yt[10] = { 1, 2, 37, 3, 4, 5, 6, 7, 8, 9 };
+int *yp = yt;
+int zt = 6;
+
+S::S () : x (xt), y (yp), z (zt)
+{
+}
+
+S::~S ()
+{
+}
+
+int
+main ()
+{
+  S s;
+  s.t.t[16] = 5;
+  s.t.t[17] = 81;
+  s.t.t[18] = 9;
+  foo <10> (s);
+  if (s.t.t[17] != 81)
+    abort ();
+  bar <7> (s);
+  foo2 <0> (s);
+  if (s.t.t[17] != 82)
+    abort ();
+  bar2 <21> (s);
+  foo3 <S> (s);
+  if (s.t.t[17] != 82)
+    abort ();
+  bar3 <S> (s);
+  foo4 <S> (s);
+  if (s.t.t[17] != 83)
+    abort ();
+  bar4 <S> (s);
+  s.x[2] -= 4;
+  s.y[2] -= 2;
+  s.z -= 2;
+  s.t.t[17]--;
+  foo3 <S &> (s);
+  if (s.t.t[17] != 83)
+    abort ();
+  bar3 <S &> (s);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.fortran/associate3.f90 gcc-6-20160721/libgomp/testsuite/libgomp.fortran/associate3.f90
--- gcc-6.1.0/libgomp/testsuite/libgomp.fortran/associate3.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.fortran/associate3.f90	2016-07-02 10:24:41.000000000 +0000
@@ -0,0 +1,20 @@
+! PR fortran/71717
+! { dg-do run }
+
+  type t
+    real, allocatable :: f(:)
+  end type
+  type (t) :: v
+  integer :: i, j
+  allocate (v%f(4))
+  v%f = 19.
+  i = 5
+  associate (u => v, k => i)
+  !$omp parallel do
+  do j = 1, 4
+    u%f(j) = 21.
+    if (j.eq.1) k = 7
+  end do
+  end associate
+  if (any (v%f(:).ne.21.) .or. i.ne.7) call abort
+end
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.hsa.c/complex-align-2.c gcc-6-20160721/libgomp/testsuite/libgomp.hsa.c/complex-align-2.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.hsa.c/complex-align-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.hsa.c/complex-align-2.c	2016-05-16 17:52:28.000000000 +0000
@@ -0,0 +1,27 @@
+#pragma omp declare target
+    _Complex int *g;
+#pragma omp end declare target
+
+
+
+_Complex float f(void);
+
+int
+main ()
+{
+  _Complex int y;
+#pragma omp target map(from:y)
+  {
+    _Complex int x;
+    g = &x;
+    __imag__ x = 1;
+    __real__ x = 2;
+    y = x;
+  }
+
+  if ((__imag__ y != 1)
+      || (__real__ y != 2))
+    __builtin_abort ();
+  return 0;
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.hsa.c/switch-sbr-2.c gcc-6-20160721/libgomp/testsuite/libgomp.hsa.c/switch-sbr-2.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.hsa.c/switch-sbr-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.hsa.c/switch-sbr-2.c	2016-05-23 11:54:52.000000000 +0000
@@ -0,0 +1,59 @@
+/* { dg-additional-options "-fno-tree-switch-conversion" } */
+
+#pragma omp declare target
+int
+foo (unsigned a)
+{
+  switch (a)
+    {
+    case 1 ... 5:
+      return 1;
+    case 9 ... 11:
+      return a + 3;
+    case 12 ... 13:
+      return a + 3;
+    default:
+      return 44;
+    }
+}
+#pragma omp end declare target
+
+#define s 100
+
+void __attribute__((noinline, noclone))
+verify(int *a)
+{
+  if (a[0] != 44)
+    __builtin_abort ();
+  
+  for (int i = 1; i <= 5; i++)
+    if (a[i] != 1)
+      __builtin_abort ();
+
+  for (int i = 6; i <= 8; i++)
+    if (a[i] != 44)
+      __builtin_abort ();
+
+  for (int i = 9; i <= 13; i++)
+    if (a[i] != i + 3)
+      __builtin_abort ();
+
+  for (int i = 14; i < s; i++)
+    if (a[i] != 44)
+      __builtin_abort ();
+}
+
+int main(int argc)
+{
+  int array[s];
+#pragma omp target
+  {
+    for (int i = 0; i < s; i++)
+      {
+	int v = foo (i);
+	array[i] = v;
+      }
+  }
+  verify (array);
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c/nested-function-1.c gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c/nested-function-1.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c/nested-function-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c/nested-function-1.c	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,52 @@
+/* Exercise nested function decomposition, gcc/tree-nested.c.  */
+
+int
+main (void)
+{
+  void test1 ()
+  {
+    int i, j, k;
+    int a[4][7][8];
+
+    __builtin_memset (a, 0, sizeof (a));
+
+#pragma acc parallel
+#pragma acc loop collapse(4 - 1)
+    for (i = 1; i <= 3; i++)
+      for (j = 4; j <= 6; j++)
+	for (k = 5; k <= 7; k++)
+	  a[i][j][k] = i + j + k;
+
+    for (i = 1; i <= 3; i++)
+      for (j = 4; j <= 6; j++)
+	for (k = 5; k <= 7; k++)
+	  if (a[i][j][k] != i + j + k)
+	    __builtin_abort();
+  }
+
+  void test2 ()
+  {
+    int i, j, k;
+    int a[4][4][4];
+
+    __builtin_memset (a, 0, sizeof (a));
+
+#pragma acc parallel
+#pragma acc loop collapse(3)
+    for (i = 1; i <= 3; i++)
+      for (j = 1; j <= 3; j++)
+	for (k = 1; k <= 3; k++)
+	  a[i][j][k] = 1;
+
+    for (i = 1; i <= 3; i++)
+      for (j = 1; j <= 3; j++)
+	for (k = 1; k <= 3; k++)
+	  if (a[i][j][k] != 1)
+	    __builtin_abort ();
+  }
+
+  test1 ();
+  test2 ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c/nested-function-2.c gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c/nested-function-2.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c/nested-function-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c/nested-function-2.c	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,155 @@
+/* Exercise nested function decomposition, gcc/tree-nested.c.  */
+
+int
+main (void)
+{
+  int p1 = 2, p2 = 6, p3 = 0, p4 = 4, p5 = 13, p6 = 18, p7 = 1, p8 = 1, p9 = 1;
+
+  void test1 ()
+  {
+    int i, j, k;
+    int a[4][4][4];
+
+    __builtin_memset (a, '\0', sizeof (a));
+
+#pragma acc parallel
+#pragma acc loop collapse(3)
+    for (i = 1; i <= 3; i++)
+      for (j = 1; j <= 3; j++)
+	for (k = 2; k <= 3; k++)
+	  a[i][j][k] = 1;
+
+    for (i = 1; i <= 3; i++)
+      for (j = 1; j <= 3; j++)
+	for (k = 2; k <= 3; k++)
+	  if (a[i][j][k] != 1)
+	    __builtin_abort();
+  }
+
+  void test2 (int v1, int v2, int v3, int v4, int v5, int v6)
+  {
+    int i, j, k, l = 0, r = 0;
+    int a[7][5][19];
+    int b[7][5][19];
+
+    __builtin_memset (a, '\0', sizeof (a));
+    __builtin_memset (b, '\0', sizeof (b));
+
+#pragma acc parallel reduction (||:l)
+#pragma acc loop reduction (||:l) collapse(3)
+    for (i = v1; i <= v2; i++)
+      for (j = v3; j <= v4; j++)
+	for (k = v5; k <= v6; k++)
+	  {
+	    l = l || i < 2 || i > 6 || j < 0 || j > 4 || k < 13 || k > 18;
+	    if (!l)
+	      a[i][j][k] += 1;
+	  }
+
+    for (i = v1; i <= v2; i++)
+      for (j = v3; j <= v4; j++)
+	for (k = v5; k <= v6; k++)
+	  {
+	    r = r || i < 2 || i > 6 || j < 0 || j > 4 || k < 13 || k > 18;
+	    if (!r)
+	      b[i][j][k] += 1;
+	  }
+
+    if (l != r)
+      __builtin_abort ();
+
+    for (i = v1; i <= v2; i++)
+      for (j = v3; j <= v4; j++)
+	for (k = v5; k <= v6; k++)
+	  if (b[i][j][k] != a[i][j][k])
+	    __builtin_abort ();
+  }
+
+  void test3 (int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8,
+      int v9)
+  {
+    int i, j, k, l = 0, r = 0;
+    int a[7][5][19];
+    int b[7][5][19];
+
+    __builtin_memset (a, '\0', sizeof (a));
+    __builtin_memset (b, '\0', sizeof (b));
+
+#pragma acc parallel reduction (||:l)
+#pragma acc loop reduction (||:l) collapse(3)
+    for (i = v1; i <= v2; i += v7)
+      for (j = v3; j <= v4; j += v8)
+	for (k = v5; k <= v6; k += v9)
+	  {
+	    l = l || i < 2 || i > 6 || j < 0 || j > 4 || k < 13 || k > 18;
+	    if (!l)
+	      a[i][j][k] += 1;
+	  }
+
+    for (i = v1; i <= v2; i += v7)
+      for (j = v3; j <= v4; j += v8)
+	for (k = v5; k <= v6; k += v9)
+	  {
+	    r = r || i < 2 || i > 6 || j < 0 || j > 4 || k < 13 || k > 18;
+	    if (!r)
+	      b[i][j][k] += 1;
+	  }
+
+    if (l != r)
+      __builtin_abort ();
+
+    for (i = v1; i <= v2; i++)
+      for (j = v3; j <= v4; j++)
+	for (k = v5; k <= v6; k++)
+	  if (b[i][j][k] != a[i][j][k])
+	    __builtin_abort ();
+  }
+
+  void test4 ()
+  {
+    int i, j, k, l = 0, r = 0;
+    int a[7][5][19];
+    int b[7][5][19];
+    int v1 = p1, v2 = p2, v3 = p3, v4 = p4, v5 = p5, v6 = p6, v7 = p7, v8 = p8,
+      v9 = p9;
+
+    __builtin_memset (a, '\0', sizeof (a));
+    __builtin_memset (b, '\0', sizeof (b));
+
+#pragma acc parallel reduction (||:l)
+#pragma acc loop reduction (||:l) collapse(3)
+    for (i = v1; i <= v2; i += v7)
+      for (j = v3; j <= v4; j += v8)
+	for (k = v5; k <= v6; k += v9)
+	  {
+	    l = l || i < 2 || i > 6 || j < 0 || j > 4 || k < 13 || k > 18;
+	    if (!l)
+	      a[i][j][k] += 1;
+	  }
+
+    for (i = v1; i <= v2; i += v7)
+      for (j = v3; j <= v4; j += v8)
+	for (k = v5; k <= v6; k += v9)
+	  {
+	    r = r || i < 2 || i > 6 || j < 0 || j > 4 || k < 13 || k > 18;
+	    if (!r)
+	      b[i][j][k] += 1;
+	  }
+
+    if (l != r)
+      __builtin_abort ();
+
+    for (i = v1; i <= v2; i++)
+      for (j = v3; j <= v4; j++)
+	for (k = v5; k <= v6; k++)
+	  if (b[i][j][k] != a[i][j][k])
+	    __builtin_abort ();
+  }
+
+  test1 ();
+  test2 (p1, p2, p3, p4, p5, p6);
+  test3 (p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  test4 ();
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c++/template-reduction.C gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c++/template-reduction.C
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c++/template-reduction.C	2016-03-30 15:08:47.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c++/template-reduction.C	2016-04-29 17:37:55.000000000 +0000
@@ -7,7 +7,7 @@
 {
    T s = 0;
 
-#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy (s, array[0:n])
+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy (array[0:n])
   for (int i = 0; i < n; i++)
     s += array[i];
 
@@ -25,7 +25,7 @@
   for (int i = 0; i < n; i++)
     array[i] = i+1;
 
-#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy (s)
+#pragma acc parallel loop num_gangs (10) gang reduction (+:s)
   for (int i = 0; i < n; i++)
     s += array[i];
 
@@ -43,7 +43,7 @@
    for (int i = 0; i < n; i++)
      array[i] = i+1;
 
-#pragma acc parallel loop num_gangs (10) gang reduction (+:s) present (array[0:n]) copy (s) async wait (1)
+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) present (array[0:n]) async wait (1)
   for (int i = 0; i < n; i++)
     s += array[i];
 
@@ -59,7 +59,7 @@
 {
    T s = 0;
 
-#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy(s) firstprivate (c) async wait (1)
+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) firstprivate (c) async wait (1)
   for (int i = 0; i < n; i++)
     s += i+c;
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c	2015-01-15 20:11:12.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c	2016-06-10 09:46:04.000000000 +0000
@@ -1,48 +1,3 @@
-int
-main (int argc, char **argv)
-{
-#define N   2
-    int a[N], b[N];
-    int i;
+/* OpenACC cache directive.  */
 
-    for (i = 0; i < N; i++)
-    {
-        a[i] = 3;
-        b[i] = 0;
-    }
-
-#pragma acc parallel copyin (a[0:N]) copyout (b[0:N])
-{
-    int ii;
-
-    for (ii = 0; ii < N; ii++)
-    {
-        const int idx = ii;
-        int n = 1;
-        const int len = n;
-
-#pragma acc cache (a[0:N])
-
-#pragma acc cache (a[0:N], b[0:N])
-
-#pragma acc cache (a[0])
-
-#pragma acc cache (a[0], a[1], b[0:N])
-
-#pragma acc cache (a[idx])
-
-#pragma acc cache (a[idx:len])
-
-        b[ii] = a[ii];
-    }
-}
-
-
-    for (i = 0; i < N; i++)
-    {
-        if (a[i] != b[i])
-            __builtin_abort ();
-    }
-
-    return 0;
-}
+#include "../../../gcc/testsuite/c-c++-common/goacc/cache-1.c"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c-c++-common/combined-reduction.c gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c-c++-common/combined-reduction.c
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-c-c++-common/combined-reduction.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-c-c++-common/combined-reduction.c	2016-04-29 17:37:55.000000000 +0000
@@ -0,0 +1,23 @@
+/* Test a combined acc parallel loop reduction.  */
+
+/* { dg-do run } */
+
+#include <assert.h>
+
+int
+main ()
+{
+  int i, v1 = 0, v2 = 0, n = 100;
+
+#pragma acc parallel loop reduction(+:v1, v2)
+  for (i = 0; i < n; i++)
+    {
+      v1++;
+      v2++;
+    }
+
+  assert (v1 == n);
+  assert (v2 == n);
+
+  return 0;
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/cache-1.f95 gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/cache-1.f95
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/cache-1.f95	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/cache-1.f95	2016-06-10 09:46:04.000000000 +0000
@@ -0,0 +1,6 @@
+! OpenACC cache directive.
+! { dg-do run }
+! { dg-additional-options "-std=f2008" }
+! { dg-additional-options "-cpp" }
+
+#include "../../../gcc/testsuite/gfortran.dg/goacc/cache-1.f95"
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/combined-reduction.f90 gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/combined-reduction.f90
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/combined-reduction.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/combined-reduction.f90	2016-04-29 17:37:55.000000000 +0000
@@ -0,0 +1,19 @@
+! Test a combined acc parallel loop reduction.
+
+! { dg-do run }
+
+program test
+  implicit none
+  integer i, n, var
+
+  n = 100
+  var = 0
+
+  !$acc parallel loop reduction(+:var)
+  do i = 1, 100
+     var = var + 1
+  end do
+  !$acc end parallel loop
+
+  if (var .ne. n) call abort
+end program test
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/nested-function-1.f90 gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/nested-function-1.f90
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/nested-function-1.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/nested-function-1.f90	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,70 @@
+! Exercise nested function decomposition, gcc/tree-nested.c.
+
+! { dg-do run }
+
+program collapse2
+  call test1
+  call test2
+contains
+  subroutine test1
+    integer :: i, j, k, a(1:3, 4:6, 5:7)
+    logical :: l
+    l = .false.
+    a(:, :, :) = 0
+    !$acc parallel reduction (.or.:l)
+    !$acc loop worker vector collapse(4 - 1)
+      do 164 i = 1, 3
+        do 164 j = 4, 6
+          do 164 k = 5, 7
+            a(i, j, k) = i + j + k
+164      end do
+    !$acc loop worker vector reduction(.or.:l) collapse(2)
+firstdo: do i = 1, 3
+        do j = 4, 6
+          do k = 5, 7
+            if (a(i, j, k) .ne. (i + j + k)) l = .true.
+          end do
+        end do
+      end do firstdo
+    !$acc end parallel
+    if (l) call abort
+  end subroutine test1
+
+  subroutine test2
+    integer :: a(3,3,3), k, kk, kkk, l, ll, lll
+    a = 0
+    !$acc parallel
+    ! Use "gang(static:1)" here and below to effectively turn gang-redundant
+    ! execution mode into something like gang-single.
+    !$acc loop gang(static:1) collapse(1)
+      do 115 k=1,3
+         !$acc loop collapse(2)
+  dokk: do kk=1,3
+          do kkk=1,3
+            a(k,kk,kkk) = 1
+          enddo
+        enddo dokk
+115   continue
+    !$acc loop gang(static:1) collapse(1)
+      do k=1,3
+         if (any(a(k,1:3,1:3).ne.1)) call abort
+      enddo
+    ! Use "gang(static:1)" here and below to effectively turn gang-redundant
+    ! execution mode into something like gang-single.
+    !$acc loop gang(static:1) collapse(1)
+ dol: do 120 l=1,3
+    !$acc loop collapse(2)
+  doll: do ll=1,3
+          do lll=1,3
+            a(l,ll,lll) = 2
+          enddo
+        enddo doll
+120   end do dol
+    !$acc loop gang(static:1) collapse(1)
+     do l=1,3
+        if (any(a(l,1:3,1:3).ne.2)) call abort
+     enddo
+    !$acc end parallel
+  end subroutine test2
+
+end program collapse2
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/nested-function-2.f90 gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/nested-function-2.f90
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/nested-function-2.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/nested-function-2.f90	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,173 @@
+! Exercise nested function decomposition, gcc/tree-nested.c.
+
+! { dg-do run }
+
+program collapse3
+  integer :: p1, p2, p3, p4, p5, p6, p7, p8, p9
+  p1 = 2
+  p2 = 6
+  p3 = -2
+  p4 = 4
+  p5 = 13
+  p6 = 18
+  p7 = 1
+  p8 = 1
+  p9 = 1
+  call test1
+  call test2 (p1, p2, p3, p4, p5, p6)
+  call test3 (p1, p2, p3, p4, p5, p6, p7, p8, p9)
+  call test4
+contains
+  subroutine test1
+    integer :: a(3,3,3), k, kk, kkk, l, ll, lll
+    !$acc parallel
+    !$acc loop collapse(3)
+      do 115 k=1,3
+dokk:   do kk=1,3
+          do kkk=1,3
+            a(k,kk,kkk) = 1
+          enddo
+        enddo dokk
+115   continue
+    !$acc end parallel
+    if (any(a(1:3,1:3,1:3).ne.1)) call abort
+    !$acc parallel
+    !$acc loop collapse(3)
+dol:  do 120 l=1,3
+doll:   do ll=1,3
+          do lll=1,3
+            a(l,ll,lll) = 2
+          enddo
+        enddo doll
+120   end do dol
+    !$acc end parallel
+    if (any(a(1:3,1:3,1:3).ne.2)) call abort
+    end subroutine test1
+
+  subroutine test2(v1, v2, v3, v4, v5, v6)
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    !$acc parallel reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2
+        do j = v3, v4
+          do k = v5, v6
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2
+      do j = v3, v4
+        do k = v5, v6
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.l) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2
+      do j = v3, v4
+        do k = v5, v6
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+        end do
+      end do
+    end do
+  end subroutine test2
+
+  subroutine test3(v1, v2, v3, v4, v5, v6, v7, v8, v9)
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6, v7, v8, v9
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    !$acc parallel reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2, v7
+        do j = v3, v4, v8
+          do k = v5, v6, v9
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.l) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+        end do
+      end do
+    end do
+  end subroutine test3
+
+  subroutine test4
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6, v7, v8, v9
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    v1 = p1
+    v2 = p2
+    v3 = p3
+    v4 = p4
+    v5 = p5
+    v6 = p6
+    v7 = p7
+    v8 = p8
+    v9 = p9
+    !$acc parallel reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2, v7
+        do j = v3, v4, v8
+          do k = v5, v6, v9
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.r) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+         do k = v5, v6, v9
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+         end do
+      end do
+    end do
+  end subroutine test4
+
+end program collapse3
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/nested-function-3.f90 gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/nested-function-3.f90
--- gcc-6.1.0/libgomp/testsuite/libgomp.oacc-fortran/nested-function-3.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libgomp/testsuite/libgomp.oacc-fortran/nested-function-3.f90	2016-06-10 09:46:18.000000000 +0000
@@ -0,0 +1,244 @@
+! Exercise nested function decomposition, gcc/tree-nested.c.
+
+! { dg-do run }
+
+program sub_collapse_3
+  call test1
+  call test2 (2, 6, -2, 4, 13, 18)
+  call test3 (2, 6, -2, 4, 13, 18, 1, 1, 1)
+  call test4
+  call test5 (2, 6, -2, 4, 13, 18)
+  call test6 (2, 6, -2, 4, 13, 18, 1, 1, 1)
+contains
+  subroutine test1
+    integer :: a(3,3,3), k, kk, kkk, l, ll, lll
+    !$acc parallel
+    !$acc loop collapse(3)
+      do 115 k=1,3
+dokk:   do kk=1,3
+          do kkk=1,3
+            a(k,kk,kkk) = 1
+          enddo
+        enddo dokk
+115   continue
+    !$acc end parallel
+    if (any(a(1:3,1:3,1:3).ne.1)) call abort
+    !$acc parallel
+    !$acc loop collapse(3)
+dol:  do 120 l=1,3
+doll:   do ll=1,3
+          do lll=1,3
+            a(l,ll,lll) = 2
+          enddo
+        enddo doll
+120   end do dol
+    !$acc end parallel
+    if (any(a(1:3,1:3,1:3).ne.2)) call abort
+  end subroutine test1
+
+  subroutine test2(v1, v2, v3, v4, v5, v6)
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    !$acc parallel pcopyin (v1, v2, v3, v4, v5, v6) reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2
+        do j = v3, v4
+          do k = v5, v6
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2
+      do j = v3, v4
+        do k = v5, v6
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.l) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2
+      do j = v3, v4
+        do k = v5, v6
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+        end do
+      end do
+    end do
+  end subroutine test2
+
+  subroutine test3(v1, v2, v3, v4, v5, v6, v7, v8, v9)
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6, v7, v8, v9
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    !$acc parallel pcopyin (v1, v2, v3, v4, v5, v6, v7, v8, v9) reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2, v7
+        do j = v3, v4, v8
+          do k = v5, v6, v9
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.l) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+        end do
+      end do
+    end do
+  end subroutine test3
+
+  subroutine test4
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6, v7, v8, v9
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    v1 = 2
+    v2 = 6
+    v3 = -2
+    v4 = 4
+    v5 = 13
+    v6 = 18
+    v7 = 1
+    v8 = 1
+    v9 = 1
+    !$acc parallel pcopyin (v1, v2, v3, v4, v5, v6, v7, v8, v9) reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2, v7
+        do j = v3, v4, v8
+          do k = v5, v6, v9
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.r) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+         do k = v5, v6, v9
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+         end do
+      end do
+    end do
+  end subroutine test4
+
+  subroutine test5(v1, v2, v3, v4, v5, v6)
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    !$acc parallel pcopyin (v1, v2, v3, v4, v5, v6) reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2
+        do j = v3, v4
+          do k = v5, v6
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2
+      do j = v3, v4
+        do k = v5, v6
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.r) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2
+      do j = v3, v4
+        do k = v5, v6
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+        end do
+      end do
+    end do
+  end subroutine test5
+
+  subroutine test6(v1, v2, v3, v4, v5, v6, v7, v8, v9)
+    integer :: i, j, k, a(1:7, -3:5, 12:19), b(1:7, -3:5, 12:19)
+    integer :: v1, v2, v3, v4, v5, v6, v7, v8, v9
+    logical :: l, r
+    l = .false.
+    r = .false.
+    a(:, :, :) = 0
+    b(:, :, :) = 0
+    !$acc parallel pcopyin (v1, v2, v3, v4, v5, v6, v7, v8, v9) reduction (.or.:l)
+    !$acc loop reduction (.or.:l) collapse (3)
+      do i = v1, v2, v7
+        do j = v3, v4, v8
+          do k = v5, v6, v9
+            l = l.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+            l = l.or.k.lt.13.or.k.gt.18
+            if (.not.l) a(i, j, k) = a(i, j, k) + 1
+            m = i * 100 + j * 10 + k
+          end do
+        end do
+      end do
+    !$acc end parallel
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+          r = r.or.i.lt.2.or.i.gt.6.or.j.lt.-2.or.j.gt.4
+          r = r.or.k.lt.13.or.k.gt.18
+          if (.not.r) b(i, j, k) = b(i, j, k) + 1
+        end do
+      end do
+    end do
+    if (l .neqv. r) call abort
+    do i = v1, v2, v7
+      do j = v3, v4, v8
+        do k = v5, v6, v9
+           if (a(i, j, k) .ne. b(i, j, k)) call abort
+        end do
+      end do
+    end do
+  end subroutine test6
+
+end program sub_collapse_3
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libiberty/ChangeLog gcc-6-20160721/libiberty/ChangeLog
--- gcc-6.1.0/libiberty/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libiberty/ChangeLog	2016-07-21 06:15:23.000000000 +0000
@@ -1,3 +1,43 @@
+2016-07-21  Jason Merrill  <jason@redhat.com>
+
+	* cp-demangle.c (cplus_demangle_operators): Add f[lrLR].
+	(d_expression_1): Handle them.
+	(d_maybe_print_fold_expression): New.
+	(d_print_comp_inner): Use it.
+	(d_index_template_argument): Handle negative index.
+
+	* cp-demangle.c (cplus_demangle_operators): Add sP and sZ.
+	(d_print_comp_inner): Handle them.
+	(d_template_args_1): Split out from d_template_args.
+	(d_args_length): New.
+
+2016-05-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-05-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/70498
+	* cp-demangle.c (d_expression_1): Formatting fix.
+
+	2016-05-02  Marcel Bhme  <boehme.marcel@gmail.com>
+
+	PR c++/70498
+	* cp-demangle.c: Parse numbers as integer instead of long to avoid
+	overflow after sanity checks. Include <limits.h> if available.
+	(INT_MAX): Define if necessary.
+	(d_make_template_param): Takes integer argument instead of long.
+	(d_make_function_param): Likewise.
+	(d_append_num): Likewise.
+	(d_identifier): Likewise.
+	(d_number): Parse as and return integer.
+	(d_compact_number): Handle overflow.
+	(d_source_name): Change variable type to integer for parsed number.
+	(d_java_resource): Likewise.
+	(d_special_name): Likewise.
+	(d_discriminator): Likewise.
+	(d_unnamed_type): Likewise.
+	* testsuite/demangle-expected: Add regression test cases.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
@@ -16,7 +56,7 @@
 	-1.
 
 2016-03-31  Mikhail Maltsev  <maltsevm@gmail.com>
-	    Marcel Bohme  boehme.marcel@gmail.com
+	    Marcel Bohme  <boehme.marcel@gmail.com>
 
 	PR c++/67394
 	PR c++/70481
@@ -2037,7 +2077,7 @@
 	that are locale-independent.
 	* Makefile.in (filename_cmp.o): Add dependency on safe-ctype.h.
 
-2007-04-11  Thomas Neumann  tneumann@users.sourceforge.net
+2007-04-11  Thomas Neumann  <tneumann@users.sourceforge.net>
 
 	* argv.c: Use ANSI C declarations.
 	* make-relative-prefix.c: Likewise.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libiberty/cp-demangle.c gcc-6-20160721/libiberty/cp-demangle.c
--- gcc-6.1.0/libiberty/cp-demangle.c	2015-11-27 14:48:21.000000000 +0000
+++ gcc-6-20160721/libiberty/cp-demangle.c	2016-07-21 06:15:23.000000000 +0000
@@ -128,6 +128,13 @@
 # endif /* alloca */
 #endif /* HAVE_ALLOCA_H */
 
+#ifdef HAVE_LIMITS_H
+#include <limits.h>
+#endif
+#ifndef INT_MAX
+# define INT_MAX       (int)(((unsigned int) ~0) >> 1)          /* 0x7FFFFFFF */ 
+#endif
+
 #include "ansidecl.h"
 #include "libiberty.h"
 #include "demangle.h"
@@ -337,7 +344,7 @@
   /* Set to 1 if we saw a demangling error.  */
   int demangle_failure;
   /* The current index into any template argument packs we are using
-     for printing.  */
+     for printing, or -1 to print the whole pack.  */
   int pack_index;
   /* Number of d_print_flush calls so far.  */
   unsigned long int flush_count;
@@ -398,7 +405,7 @@
              struct demangle_component *);
 
 static struct demangle_component *
-d_make_template_param (struct d_info *, long);
+d_make_template_param (struct d_info *, int);
 
 static struct demangle_component *
 d_make_sub (struct d_info *, const char *, int);
@@ -421,9 +428,9 @@
 
 static struct demangle_component *d_source_name (struct d_info *);
 
-static long d_number (struct d_info *);
+static int d_number (struct d_info *);
 
-static struct demangle_component *d_identifier (struct d_info *, long);
+static struct demangle_component *d_identifier (struct d_info *, int);
 
 static struct demangle_component *d_operator_name (struct d_info *);
 
@@ -459,6 +466,7 @@
 d_template_param (struct d_info *);
 
 static struct demangle_component *d_template_args (struct d_info *);
+static struct demangle_component *d_template_args_1 (struct d_info *);
 
 static struct demangle_component *
 d_template_arg (struct d_info *);
@@ -1119,7 +1127,7 @@
 /* Add a new template parameter.  */
 
 static struct demangle_component *
-d_make_template_param (struct d_info *di, long i)
+d_make_template_param (struct d_info *di, int i)
 {
   struct demangle_component *p;
 
@@ -1135,7 +1143,7 @@
 /* Add a new function parameter.  */
 
 static struct demangle_component *
-d_make_function_param (struct d_info *di, long i)
+d_make_function_param (struct d_info *di, int i)
 {
   struct demangle_component *p;
 
@@ -1620,7 +1628,7 @@
 static struct demangle_component *
 d_source_name (struct d_info *di)
 {
-  long len;
+  int len;
   struct demangle_component *ret;
 
   len = d_number (di);
@@ -1633,12 +1641,12 @@
 
 /* number ::= [n] <(non-negative decimal integer)>  */
 
-static long
+static int
 d_number (struct d_info *di)
 {
   int negative;
   char peek;
-  long ret;
+  int ret;
 
   negative = 0;
   peek = d_peek_char (di);
@@ -1681,7 +1689,7 @@
 /* identifier ::= <(unqualified source code identifier)>  */
 
 static struct demangle_component *
-d_identifier (struct d_info *di, long len)
+d_identifier (struct d_info *di, int len)
 {
   const char *name;
 
@@ -1702,7 +1710,7 @@
   /* Look for something which looks like a gcc encoding of an
      anonymous namespace, and replace it with a more user friendly
      name.  */
-  if (len >= (long) ANONYMOUS_NAMESPACE_PREFIX_LEN + 2
+  if (len >= (int) ANONYMOUS_NAMESPACE_PREFIX_LEN + 2
       && memcmp (name, ANONYMOUS_NAMESPACE_PREFIX,
 		 ANONYMOUS_NAMESPACE_PREFIX_LEN) == 0)
     {
@@ -1754,6 +1762,10 @@
   { "eO", NL ("^="),        2 },
   { "eo", NL ("^"),         2 },
   { "eq", NL ("=="),        2 },
+  { "fL", NL ("..."),       3 },
+  { "fR", NL ("..."),       3 },
+  { "fl", NL ("..."),       2 },
+  { "fr", NL ("..."),       2 },
   { "ge", NL (">="),        2 },
   { "gs", NL ("::"),	    1 },
   { "gt", NL (">"),         2 },
@@ -1788,6 +1800,8 @@
   { "rc", NL ("reinterpret_cast"), 2 },
   { "rm", NL ("%"),         2 },
   { "rs", NL (">>"),        2 },
+  { "sP", NL ("sizeof..."), 1 },
+  { "sZ", NL ("sizeof..."), 1 },
   { "sc", NL ("static_cast"), 2 },
   { "st", NL ("sizeof "),   1 },
   { "sz", NL ("sizeof "),   1 },
@@ -1870,7 +1884,7 @@
 {
   struct demangle_component *p = NULL;
   struct demangle_component *next = NULL;
-  long len, i;
+  int len, i;
   char c;
   const char *str;
 
@@ -2012,7 +2026,7 @@
 	case 'C':
 	  {
 	    struct demangle_component *derived_type;
-	    long offset;
+	    int offset;
 	    struct demangle_component *base_type;
 
 	    derived_type = cplus_demangle_type (di);
@@ -2946,10 +2960,10 @@
 
 /* <non-negative number> _ */
 
-static long
+static int
 d_compact_number (struct d_info *di)
 {
-  long num;
+  int num;
   if (d_peek_char (di) == '_')
     num = 0;
   else if (d_peek_char (di) == 'n')
@@ -2957,7 +2971,7 @@
   else
     num = d_number (di) + 1;
 
-  if (! d_check_char (di, '_'))
+  if (num < 0 || ! d_check_char (di, '_'))
     return -1;
   return num;
 }
@@ -2969,7 +2983,7 @@
 static struct demangle_component *
 d_template_param (struct d_info *di)
 {
-  long param;
+  int param;
 
   if (! d_check_char (di, 'T'))
     return NULL;
@@ -2988,6 +3002,19 @@
 static struct demangle_component *
 d_template_args (struct d_info *di)
 {
+  if (d_peek_char (di) != 'I'
+      && d_peek_char (di) != 'J')
+    return NULL;
+  d_advance (di, 1);
+
+  return d_template_args_1 (di);
+}
+
+/* <template-arg>* E  */
+
+static struct demangle_component *
+d_template_args_1 (struct d_info *di)
+{
   struct demangle_component *hold_last_name;
   struct demangle_component *al;
   struct demangle_component **pal;
@@ -2997,11 +3024,6 @@
      constructor or destructor.  */
   hold_last_name = di->last_name;
 
-  if (d_peek_char (di) != 'I'
-      && d_peek_char (di) != 'J')
-    return NULL;
-  d_advance (di, 1);
-
   if (d_peek_char (di) == 'E')
     {
       /* An argument pack can be empty.  */
@@ -3171,9 +3193,10 @@
 	}
       else
 	{
-	  index = d_compact_number (di) + 1;
-	  if (index == 0)
+	  index = d_compact_number (di);
+	  if (index == INT_MAX || index == -1)
 	    return NULL;
+	  index++;
 	}
       return d_make_function_param (di, index);
     }
@@ -3262,6 +3285,8 @@
 	    if (op->type == DEMANGLE_COMPONENT_CAST
 		&& d_check_char (di, '_'))
 	      operand = d_exprlist (di, 'E');
+	    else if (code && !strcmp (code, "sP"))
+	      operand = d_template_args_1 (di);
 	    else
 	      operand = d_expression_1 (di);
 
@@ -3284,6 +3309,9 @@
 	      return NULL;
 	    if (op_is_new_cast (op))
 	      left = cplus_demangle_type (di);
+	    else if (code[0] == 'f')
+	      /* fold-expression.  */
+	      left = d_operator_name (di);
 	    else
 	      left = d_expression_1 (di);
 	    if (!strcmp (code, "cl"))
@@ -3318,6 +3346,13 @@
 		second = d_expression_1 (di);
 		third = d_expression_1 (di);
 	      }
+	    else if (code[0] == 'f')
+	      {
+		/* fold-expression.  */
+		first = d_operator_name (di);
+		second = d_expression_1 (di);
+		third = d_expression_1 (di);
+	      }
 	    else if (code[0] == 'n')
 	      {
 		/* new-expression.  */
@@ -3502,7 +3537,7 @@
 static int
 d_discriminator (struct d_info *di)
 {
-  long discrim;
+  int discrim;
 
   if (d_peek_char (di) != '_')
     return 1;
@@ -3558,7 +3593,7 @@
 d_unnamed_type (struct d_info *di)
 {
   struct demangle_component *ret;
-  long num;
+  int num;
 
   if (! d_check_char (di, 'U'))
     return NULL;
@@ -4086,10 +4121,10 @@
 }
 
 static inline void
-d_append_num (struct d_print_info *dpi, long l)
+d_append_num (struct d_print_info *dpi, int l)
 {
   char buf[25];
-  sprintf (buf,"%ld", l);
+  sprintf (buf,"%d", l);
   d_append_string (dpi, buf);
 }
 
@@ -4171,13 +4206,17 @@
 }
 
 /* Returns the I'th element of the template arglist ARGS, or NULL on
-   failure.  */
+   failure.  If I is negative, return the entire arglist.  */
 
 static struct demangle_component *
 d_index_template_argument (struct demangle_component *args, int i)
 {
   struct demangle_component *a;
 
+  if (i < 0)
+    /* Print the whole argument pack.  */
+    return args;
+
   for (a = args;
        a != NULL;
        a = d_right (a))
@@ -4277,6 +4316,30 @@
   return count;
 }
 
+/* Returns the number of template args in DC, expanding any pack expansions
+   found there.  */
+
+static int
+d_args_length (struct d_print_info *dpi, const struct demangle_component *dc)
+{
+  int count = 0;
+  for (; dc && dc->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST;
+       dc = d_right (dc))
+    {
+      struct demangle_component *elt = d_left (dc);
+      if (elt == NULL)
+	break;
+      if (elt->type == DEMANGLE_COMPONENT_PACK_EXPANSION)
+	{
+	  struct demangle_component *a = d_find_pack (dpi, d_left (elt));
+	  count += d_pack_length (a);
+	}
+      else
+	++count;
+    }
+  return count;
+}
+
 /* DC is a component of a mangled expression.  Print it, wrapped in parens
    if needed.  */
 
@@ -4353,6 +4416,70 @@
   return NULL;
 }
 
+/* If DC is a C++17 fold-expression, print it and return true; otherwise
+   return false.  */
+
+static int
+d_maybe_print_fold_expression (struct d_print_info *dpi, int options,
+			       const struct demangle_component *dc)
+{
+  const struct demangle_component *ops, *operator_, *op1, *op2;
+  int save_idx;
+
+  const char *fold_code = d_left (dc)->u.s_operator.op->code;
+  if (fold_code[0] != 'f')
+    return 0;
+
+  ops = d_right (dc);
+  operator_ = d_left (ops);
+  op1 = d_right (ops);
+  op2 = 0;
+  if (op1->type == DEMANGLE_COMPONENT_TRINARY_ARG2)
+    {
+      op2 = d_right (op1);
+      op1 = d_left (op1);
+    }
+
+  /* Print the whole pack.  */
+  save_idx = dpi->pack_index;
+  dpi->pack_index = -1;
+
+  switch (fold_code[1])
+    {
+      /* Unary left fold, (... + X).  */
+    case 'l':
+      d_append_string (dpi, "(...");
+      d_print_expr_op (dpi, options, operator_);
+      d_print_subexpr (dpi, options, op1);
+      d_append_char (dpi, ')');
+      break;
+
+      /* Unary right fold, (X + ...).  */
+    case 'r':
+      d_append_char (dpi, '(');
+      d_print_subexpr (dpi, options, op1);
+      d_print_expr_op (dpi, options, operator_);
+      d_append_string (dpi, "...)");
+      break;
+
+      /* Binary left fold, (42 + ... + X).  */
+    case 'L':
+      /* Binary right fold, (X + ... + 42).  */
+    case 'R':
+      d_append_char (dpi, '(');
+      d_print_subexpr (dpi, options, op1);
+      d_print_expr_op (dpi, options, operator_);
+      d_append_string (dpi, "...");
+      d_print_expr_op (dpi, options, operator_);
+      d_print_subexpr (dpi, options, op2);
+      d_append_char (dpi, ')');
+      break;
+    }
+
+  dpi->pack_index = save_idx;
+  return 1;
+}
+
 /* Subroutine to handle components.  */
 
 static void
@@ -5113,6 +5240,21 @@
 	      }
 	  }
 
+	/* For sizeof..., just print the pack length.  */
+	if (code && !strcmp (code, "sZ"))
+	  {
+	    struct demangle_component *a = d_find_pack (dpi, operand);
+	    int len = d_pack_length (a);
+	    d_append_num (dpi, len);
+	    return;
+	  }
+	else if (code && !strcmp (code, "sP"))
+	  {
+	    int len = d_args_length (dpi, operand);
+	    d_append_num (dpi, len);
+	    return;
+	  }
+
 	if (op->type != DEMANGLE_COMPONENT_CAST)
 	  d_print_expr_op (dpi, options, op);
 	else
@@ -5154,6 +5296,9 @@
 	  return;
 	}
 
+      if (d_maybe_print_fold_expression (dpi, options, dc))
+	return;
+
       /* We wrap an expression which uses the greater-than operator in
 	 an extra layer of parens so that it does not get confused
 	 with the '>' which ends the template parameters.  */
@@ -5209,6 +5354,8 @@
 	  d_print_error (dpi);
 	  return;
 	}
+      if (d_maybe_print_fold_expression (dpi, options, dc))
+	return;
       {
 	struct demangle_component *op = d_left (dc);
 	struct demangle_component *first = d_left (d_right (dc));
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libiberty/testsuite/demangle-expected gcc-6-20160721/libiberty/testsuite/demangle-expected
--- gcc-6.1.0/libiberty/testsuite/demangle-expected	2016-03-31 17:20:53.000000000 +0000
+++ gcc-6-20160721/libiberty/testsuite/demangle-expected	2016-07-21 06:15:23.000000000 +0000
@@ -4421,13 +4421,41 @@
 --format=gnu-v3
 _Z3fooI1FEN1XIXszdtcl1PclcvT__EEE5arrayEE4TypeEv
 X<sizeof ((P(((F)())())).array)>::Type foo<F>()
+
+_Z1fIJidEEv1AIXsZT_EE
+void f<int, double>(A<2>)
+
+_ZN1A1fIJiiEiJiiiEEEvRAsPDpT_T0_DpT1_E_iS3_S5_
+void A::f<int, int, int, int, int, int>(int (&) [6], int, int, int, int)
+
+_Z10unary_leftIJLi1ELi2ELi3EEEv1AIXflplT_EE
+void unary_left<1, 2, 3>(A<(...+(1, 2, 3))>)
+
+_Z11unary_rightIJLi1ELi2ELi3EEEv1AIXfrplT_EE
+void unary_right<1, 2, 3>(A<((1, 2, 3)+...)>)
+
+_Z11binary_leftIJLi1ELi2ELi3EEEv1AIXfLplLi42ET_EE
+void binary_left<1, 2, 3>(A<((42)+...+(1, 2, 3))>)
+
+_Z12binary_rightIJLi1ELi2ELi3EEEv1AIXfRplT_Li42EEE
+void binary_right<1, 2, 3>(A<((1, 2, 3)+...+(42))>)
 #
-# Tests a use-after-free problem
+# Tests a use-after-free problem PR70481
 
 _Q.__0
 ::Q.(void)
 #
-# Tests a use-after-free problem
+# Tests a use-after-free problem PR70481
 
 _Q10-__9cafebabe.
 cafebabe.::-(void)
+#
+# Tests integer overflow problem PR70492
+
+__vt_90000000000cafebabe
+__vt_90000000000cafebabe
+#
+# Tests write access violation PR70498
+
+_Z80800000000000000000000
+_Z80800000000000000000000
Only in gcc-6.1.0/libitm: libitm.info
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libjava/ChangeLog gcc-6-20160721/libjava/ChangeLog
--- gcc-6.1.0/libjava/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libjava/ChangeLog	2016-04-29 11:50:42.000000000 +0000
@@ -1,3 +1,11 @@
+2016-04-29  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	backport from trunk:
+	2016-04-20  Ben Elliston  <bje@gnu.org>
+
+	* testsuite/lib/libjava.exp (libjava_arguments): Use 'file
+	normalize' rather than the defunct DejaGnu 'absolute' proc.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
Only in gcc-6.1.0/libjava/classpath/doc: cp-tools.info
Only in gcc-6.1.0/libjava/classpath/doc: gappletviewer.1
Only in gcc-6.1.0/libjava/classpath/doc: gjar.1
Only in gcc-6.1.0/libjava/classpath/doc: gjarsigner.1
Only in gcc-6.1.0/libjava/classpath/doc: gjavah.1
Only in gcc-6.1.0/libjava/classpath/doc: gjdoc.1
Only in gcc-6.1.0/libjava/classpath/doc: gkeytool.1
Only in gcc-6.1.0/libjava/classpath/doc: gnative2ascii.1
Only in gcc-6.1.0/libjava/classpath/doc: gorbd.1
Only in gcc-6.1.0/libjava/classpath/doc: grmid.1
Only in gcc-6.1.0/libjava/classpath/doc: grmiregistry.1
Only in gcc-6.1.0/libjava/classpath/doc: gserialver.1
Only in gcc-6.1.0/libjava/classpath/doc: gtnameserv.1
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libjava/testsuite/lib/libjava.exp gcc-6-20160721/libjava/testsuite/lib/libjava.exp
--- gcc-6.1.0/libjava/testsuite/lib/libjava.exp	2014-05-20 08:20:06.000000000 +0000
+++ gcc-6-20160721/libjava/testsuite/lib/libjava.exp	2016-04-29 11:50:42.000000000 +0000
@@ -416,7 +416,7 @@
 
     # Search for libtool.  We need it to link.
     set found_compiler 0
-    set d [absolute $objdir]
+    set d [file normalize $objdir]
     foreach x {. .. ../.. ../../..} {
 	if {[file exists $d/$x/libtool]} then {
 	    # We have to run silently to avoid DejaGNU lossage.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libmpx/ChangeLog gcc-6-20160721/libmpx/ChangeLog
--- gcc-6.1.0/libmpx/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libmpx/ChangeLog	2016-06-10 09:31:37.000000000 +0000
@@ -1,3 +1,10 @@
+2016-06-10  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	Backport from mainline r237292.
+	2016-06-10  Ilya Enkovich  <ilya.enkovich@intel.com>
+
+	* mpxwrap/mpx_wrappers.c (move_bounds): Fix overflow bug.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libmpx/mpxwrap/mpx_wrappers.c gcc-6-20160721/libmpx/mpxwrap/mpx_wrappers.c
--- gcc-6.1.0/libmpx/mpxwrap/mpx_wrappers.c	2016-01-18 19:36:02.000000000 +0000
+++ gcc-6-20160721/libmpx/mpxwrap/mpx_wrappers.c	2016-06-10 09:31:37.000000000 +0000
@@ -27,6 +27,7 @@
 #include "string.h"
 #include <sys/mman.h>
 #include <stdint.h>
+#include <assert.h>
 #include "mpxrt/mpxrt.h"
 
 void *
@@ -418,7 +419,16 @@
           else
             elems_to_copy -= src_bt_index_end + 1;
         }
-      src_bd_index_end--;
+      /* Go to previous table but beware of overflow.
+	 We should have copied all required element
+	 in case src_bd_index_end is 0.  */
+      if (src_bd_index_end)
+	src_bd_index_end--;
+      else
+	{
+	  assert (!elems_to_copy);
+	  return;
+	}
       /* For each bounds table we check if there are valid pointers inside.
          If there are some, we copy table in pre-counted portions.  */
       for (; src_bd_index_end > src_bd_index; src_bd_index_end--)
Only in gcc-6.1.0/libquadmath: libquadmath.info
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libsanitizer/ChangeLog gcc-6-20160721/libsanitizer/ChangeLog
--- gcc-6.1.0/libsanitizer/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libsanitizer/ChangeLog	2016-05-18 21:26:54.000000000 +0000
@@ -1,3 +1,12 @@
+2016-05-18  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-05-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/71160
+	* asan/asan_malloc_linux.cc: Cherry pick upstream r254395
+	and r269633.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libsanitizer/asan/asan_malloc_linux.cc gcc-6-20160721/libsanitizer/asan/asan_malloc_linux.cc
--- gcc-6.1.0/libsanitizer/asan/asan_malloc_linux.cc	2014-09-23 17:59:53.000000000 +0000
+++ gcc-6-20160721/libsanitizer/asan/asan_malloc_linux.cc	2016-05-18 21:26:54.000000000 +0000
@@ -24,39 +24,62 @@
 // ---------------------- Replacement functions ---------------- {{{1
 using namespace __asan;  // NOLINT
 
+static uptr allocated_for_dlsym;
+static const uptr kDlsymAllocPoolSize = 1024;
+static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];
+
+static bool IsInDlsymAllocPool(const void *ptr) {
+  uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;
+  return off < sizeof(alloc_memory_for_dlsym);
+}
+
+static void *AllocateFromLocalPool(uptr size_in_bytes) {
+  uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;
+  void *mem = (void*)&alloc_memory_for_dlsym[allocated_for_dlsym];
+  allocated_for_dlsym += size_in_words;
+  CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);
+  return mem;
+}
+
 INTERCEPTOR(void, free, void *ptr) {
   GET_STACK_TRACE_FREE;
+  if (UNLIKELY(IsInDlsymAllocPool(ptr)))
+    return;
   asan_free(ptr, &stack, FROM_MALLOC);
 }
 
 INTERCEPTOR(void, cfree, void *ptr) {
   GET_STACK_TRACE_FREE;
+  if (UNLIKELY(IsInDlsymAllocPool(ptr)))
+    return;
   asan_free(ptr, &stack, FROM_MALLOC);
 }
 
 INTERCEPTOR(void*, malloc, uptr size) {
+  if (UNLIKELY(!asan_inited))
+    // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.
+    return AllocateFromLocalPool(size);
   GET_STACK_TRACE_MALLOC;
   return asan_malloc(size, &stack);
 }
 
 INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {
-  if (UNLIKELY(!asan_inited)) {
+  if (UNLIKELY(!asan_inited))
     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.
-    const uptr kCallocPoolSize = 1024;
-    static uptr calloc_memory_for_dlsym[kCallocPoolSize];
-    static uptr allocated;
-    uptr size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;
-    void *mem = (void*)&calloc_memory_for_dlsym[allocated];
-    allocated += size_in_words;
-    CHECK(allocated < kCallocPoolSize);
-    return mem;
-  }
+    return AllocateFromLocalPool(nmemb * size);
   GET_STACK_TRACE_MALLOC;
   return asan_calloc(nmemb, size, &stack);
 }
 
 INTERCEPTOR(void*, realloc, void *ptr, uptr size) {
   GET_STACK_TRACE_MALLOC;
+  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {
+    uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;
+    uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);
+    void *new_ptr = asan_malloc(size, &stack);
+    internal_memcpy(new_ptr, ptr, copy_size);
+    return new_ptr;
+  }
   return asan_realloc(ptr, size, &stack);
 }
 
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/ChangeLog gcc-6-20160721/libstdc++-v3/ChangeLog
--- gcc-6.1.0/libstdc++-v3/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/ChangeLog	2016-07-19 22:16:35.000000000 +0000
@@ -1,3 +1,209 @@
+2016-07-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2016-07-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/functional: Include <parallel/algorithm> in
+	Parallel Mode.
+
+	Backport from mainline
+	2016-07-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/experimental/functional/searchers.cc: Include <algorithm>
+	for std::search.
+
+	PR libstdc++/71856
+	* include/bits/c++config (_GLIBCXX_ASSERTIONS): Define to 1 not empty.
+	* include/parallel/balanced_quicksort.h: Include <unistd.h> for sleep.
+	* include/parallel/compiletime_settings.h (_GLIBCXX_ASSERTIONS):
+	Do not define here.
+
+	Backport from mainline
+	2016-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71320
+	* src/filesystem/ops.cc (permissions(const path&, perms, error_code&)):
+	Add or remove permissions according to perms argument.
+	* testsuite/experimental/filesystem/operations/permissions.cc: New
+	test.
+
+2016-07-06  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement LWG 2451, optional<T> should 'forward' T's
+	implicit conversions.
+	* include/experimental/optional (__is_optional_impl, __is_optional):
+	New.
+	(optional()): Make constexpr and default.
+	(optional(_Up&&), optional(const optional<_Up>&),
+	optional(optional<_Up>&& __t): New.
+	(operator=(_Up&&)): Constrain.
+	(operator=(const optional<_Up>&), operator=(optional<_Up>&&)): New.
+	* testsuite/experimental/optional/cons/value.cc:
+	Add tests for the functionality added by LWG 2451.
+	* testsuite/experimental/optional/cons/value_neg.cc: New.
+
+2016-07-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement LWG 2509,
+	any_cast doesn't work with rvalue reference targets and cannot
+	move with a value target.
+	* include/experimental/any (any(_ValueType&&)): Constrain and
+	add an overload that doesn't forward.
+	(any_cast(any&&)): Constrain and add an overload that moves.
+	* testsuite/experimental/any/misc/any_cast.cc: Add tests for
+	the functionality added by LWG 2509.
+
+2016-07-04  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR libstdc++/71313
+	* src/filesystem/ops.cc (remove_all(const path&, error_code&)):
+	Call remove_all for children of a directory.
+	* testsuite/experimental/filesystem/operations/create_directories.cc:
+	Adjust.
+
+2016-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71545
+	* include/bits/stl_algobase.h (lower_bound, lexicographical_compare):
+	Remove irreflexive checks.
+	* include/bits/stl_algo.h (lower_bound, upper_bound, equal_range,
+	binary_search): Likewise.
+	* testsuite/25_algorithms/equal_range/partitioned.cc: New test.
+	* testsuite/25_algorithms/lexicographical_compare/71545.cc: New test.
+	* testsuite/25_algorithms/lower_bound/partitioned.cc: New test.
+	* testsuite/25_algorithms/upper_bound/partitioned.cc: New test.
+	* testsuite/util/testsuite_iterators.h (__gnu_test::test_container):
+	Add constructor from array.
+
+2016-05-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2016-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/70762
+	* testsuite/util/testsuite_fs.h (__gnu_test::nonexistent_path): Use
+	static counter to return a different path on every call.
+
+	* testsuite/experimental/filesystem/path/native/string.cc: Add
+	dg-require-filesystem-ts directive.
+
+2016-05-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2016-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69703
+	* src/c++11/codecvt.cc (__codecvt_utf8_base<char16_t>::do_in,
+	__codecvt_utf8_utf16_base<char16_t>::do_in): Fix mask operations.
+
+	Backport from mainline
+	2016-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69703
+	* src/c++11/codecvt.cc (__codecvt_utf8_base<char16_t>::do_in)):
+	Override endianness bit in mode.
+	* testsuite/22_locale/codecvt/codecvt_utf8/69703.cc: New test.
+	* testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc: Test
+	that little_endian mode is ignored.
+	* testsuite/experimental/filesystem/path/native/string.cc: New test.
+
+	Backport from mainline
+	2016-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_dir.h (begin, end): Add noexcept.
+	* testsuite/experimental/filesystem/iterators/directory_iterator.cc:
+	Test begin and end functions.
+	* testsuite/experimental/filesystem/iterators/
+	recursive_directory_iterator.cc: Likewise.
+
+	Backport from mainline
+	2016-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71038
+	* src/filesystem/ops.cc (do_copy_file): Fix backwards conditions.
+	* testsuite/experimental/filesystem/operations/copy_file.cc: New test.
+
+	Backport from mainline
+	2016-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_dir.h (__directory_iterator_proxy):
+	Overload operator* to move from rvalues.
+
+	Backport from mainline
+	2016-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71036
+	* src/filesystem/ops.cc (create_dir): Handle EEXIST from mkdir.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	New test.
+
+	Backport from mainline
+	2016-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71037
+	* src/filesystem/ops.cc (canonical(const path&, const path&)): Add
+	base path to exception.
+	* testsuite/experimental/filesystem/operations/canonical.cc: Test
+	paths contained in exception.
+
+	Backport from mainline
+	2016-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71005
+	* include/experimental/bits/fs_dir.h (__directory_iterator_proxy):
+	New type.
+	(directory_iterator::operator++(int)): Return proxy.
+	(recursive_directory_iterator::operator++(int)): Likewise.
+	* testsuite/experimental/filesystem/iterators/directory_iterator.cc:
+	Test post-increment.
+	* testsuite/experimental/filesystem/iterators/
+	recursive_directory_iterator.cc: Likewise.
+
+	Backport from mainline
+	2016-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71004
+	* include/experimental/bits/fs_dir.h (recursive_directory_iterator):
+	Initialize scalar member variables in default constructor.
+	* testsuite/experimental/filesystem/iterators/
+	recursive_directory_iterator.cc: Test default construction.
+
+	Backport from mainline
+	2016-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/70609
+	* src/filesystem/ops.cc (close_fd): New function.
+	(do_copy_file): Set permissions before copying file contents. Check
+	result of closing file descriptors. Don't copy streambuf when file
+	is empty.
+	(copy(const path&, const path&, copy_options, error_code&)): Use
+	lstat for source file when copy_symlinks is set.
+	* testsuite/experimental/filesystem/operations/copy.cc: Test copy().
+
+	Backport from mainline
+	2016-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_fwd.h (operator&, operator|, operator^,
+	operator~ operator&=, operator|=, operator^=): Add noexcept to
+	overloaded operators for copy_options, perms and directory_options.
+	* src/filesystem/ops.cc (make_file_type, make_file_status,
+	is_not_found_errno, file_time): Add noexcept.
+
+2016-05-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71049
+	* src/c++11/cow-stdexcept.cc [!_GLIBCXX_USE_DUAL_ABI]: Don't define
+	exception constructors with __sso_string parameters.
+
+2016-05-09  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Avoid endless run-time recursion for copying single-element
+	tuples where the element type is by-value constructible
+	from any type.
+	* include/std/tuple (_NotSameTuple): New.
+	* include/std/tuple (tuple(_UElements&&...): Use it.
+	* testsuite/20_util/tuple/cons/element_accepts_anything_byval.cc: New.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/bits/c++config gcc-6-20160721/libstdc++-v3/include/bits/c++config
--- gcc-6.1.0/libstdc++-v3/include/bits/c++config	2016-04-14 16:23:06.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/bits/c++config	2016-07-19 22:16:23.000000000 +0000
@@ -414,7 +414,7 @@
 
 // Debug Mode implies checking assertions.
 #ifdef _GLIBCXX_DEBUG
-# define _GLIBCXX_ASSERTIONS
+# define _GLIBCXX_ASSERTIONS 1
 #endif
 
 // Disable std::string explicit instantiation declarations in order to assert.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/bits/stl_algo.h gcc-6-20160721/libstdc++-v3/include/bits/stl_algo.h
--- gcc-6.1.0/libstdc++-v3/include/bits/stl_algo.h	2016-04-14 16:23:06.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/bits/stl_algo.h	2016-06-17 18:53:46.000000000 +0000
@@ -2026,7 +2026,6 @@
 	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
       __glibcxx_requires_partitioned_lower_pred(__first, __last,
 						__val, __comp);
-      __glibcxx_requires_irreflexive_pred2(__first, __last, __comp);
 
       return std::__lower_bound(__first, __last, __val,
 				__gnu_cxx::__ops::__iter_comp_val(__comp));
@@ -2080,7 +2079,6 @@
       __glibcxx_function_requires(_LessThanOpConcept<
 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
       __glibcxx_requires_partitioned_upper(__first, __last, __val);
-      __glibcxx_requires_irreflexive2(__first, __last);
 
       return std::__upper_bound(__first, __last, __val,
 				__gnu_cxx::__ops::__val_less_iter());
@@ -2112,7 +2110,6 @@
 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
       __glibcxx_requires_partitioned_upper_pred(__first, __last,
 						__val, __comp);
-      __glibcxx_requires_irreflexive_pred2(__first, __last, __comp);
 
       return std::__upper_bound(__first, __last, __val,
 				__gnu_cxx::__ops::__val_comp_iter(__comp));
@@ -2186,7 +2183,6 @@
 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
       __glibcxx_requires_partitioned_lower(__first, __last, __val);
       __glibcxx_requires_partitioned_upper(__first, __last, __val);
-      __glibcxx_requires_irreflexive2(__first, __last);
 
       return std::__equal_range(__first, __last, __val,
 				__gnu_cxx::__ops::__iter_less_val(),
@@ -2225,7 +2221,6 @@
 						__val, __comp);
       __glibcxx_requires_partitioned_upper_pred(__first, __last,
 						__val, __comp);
-      __glibcxx_requires_irreflexive_pred2(__first, __last, __comp);
 
       return std::__equal_range(__first, __last, __val,
 				__gnu_cxx::__ops::__iter_comp_val(__comp),
@@ -2255,7 +2250,6 @@
 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
       __glibcxx_requires_partitioned_lower(__first, __last, __val);
       __glibcxx_requires_partitioned_upper(__first, __last, __val);
-      __glibcxx_requires_irreflexive2(__first, __last);
 
       _ForwardIterator __i
 	= std::__lower_bound(__first, __last, __val,
@@ -2291,7 +2285,6 @@
 						__val, __comp);
       __glibcxx_requires_partitioned_upper_pred(__first, __last,
 						__val, __comp);
-      __glibcxx_requires_irreflexive_pred2(__first, __last, __comp);
 
       _ForwardIterator __i
 	= std::__lower_bound(__first, __last, __val,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/bits/stl_algobase.h gcc-6-20160721/libstdc++-v3/include/bits/stl_algobase.h
--- gcc-6.1.0/libstdc++-v3/include/bits/stl_algobase.h	2016-01-26 19:38:20.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/bits/stl_algobase.h	2016-06-17 18:53:46.000000000 +0000
@@ -989,7 +989,6 @@
       __glibcxx_function_requires(_LessThanOpConcept<
 	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
       __glibcxx_requires_partitioned_lower(__first, __last, __val);
-      __glibcxx_requires_irreflexive2(__first, __last);
 
       return std::__lower_bound(__first, __last, __val,
 				__gnu_cxx::__ops::__iter_less_val());
@@ -1214,9 +1213,7 @@
       __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
       __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
       __glibcxx_requires_valid_range(__first1, __last1);
-      __glibcxx_requires_irreflexive2(__first1, __last1);
       __glibcxx_requires_valid_range(__first2, __last2);
-      __glibcxx_requires_irreflexive2(__first2, __last2);
 
       return std::__lexicographical_compare_aux(std::__niter_base(__first1),
 						std::__niter_base(__last1),
@@ -1246,9 +1243,7 @@
       __glibcxx_function_requires(_InputIteratorConcept<_II1>)
       __glibcxx_function_requires(_InputIteratorConcept<_II2>)
       __glibcxx_requires_valid_range(__first1, __last1);
-      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
       __glibcxx_requires_valid_range(__first2, __last2);
-      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
 
       return std::__lexicographical_compare_impl
 	(__first1, __last1, __first2, __last2,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/experimental/any gcc-6-20160721/libstdc++-v3/include/experimental/any
--- gcc-6.1.0/libstdc++-v3/include/experimental/any	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/experimental/any	2016-07-05 20:06:31.000000000 +0000
@@ -158,7 +158,9 @@
 
     /// Construct with a copy of @p __value as the contained object.
     template <typename _ValueType, typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>>
+	      typename _Mgr = _Manager<_Tp>,
+              typename enable_if<is_constructible<_Tp, _ValueType&&>::value,
+                                 bool>::type = true>
       any(_ValueType&& __value)
       : _M_manager(&_Mgr::_S_manage)
       {
@@ -167,6 +169,19 @@
 		      "The contained object must be CopyConstructible");
       }
 
+    /// Construct with a copy of @p __value as the contained object.
+    template <typename _ValueType, typename _Tp = _Decay<_ValueType>,
+	      typename _Mgr = _Manager<_Tp>,
+              typename enable_if<!is_constructible<_Tp, _ValueType&&>::value,
+                                 bool>::type = false>
+      any(_ValueType&& __value)
+      : _M_manager(&_Mgr::_S_manage)
+      {
+        _Mgr::_S_create(_M_storage, __value);
+	static_assert(is_copy_constructible<_Tp>::value,
+		      "The contained object must be CopyConstructible");
+      }
+
     /// Destructor, calls @c clear()
     ~any() { clear(); }
 
@@ -377,7 +392,10 @@
       __throw_bad_any_cast();
     }
 
-  template<typename _ValueType>
+  template<typename _ValueType,
+           typename enable_if<!is_move_constructible<_ValueType>::value
+                              || is_lvalue_reference<_ValueType>::value,
+                              bool>::type = true>
     inline _ValueType any_cast(any&& __any)
     {
       static_assert(any::__is_valid_cast<_ValueType>(),
@@ -387,6 +405,20 @@
 	return *__p;
       __throw_bad_any_cast();
     }
+
+  template<typename _ValueType,
+           typename enable_if<is_move_constructible<_ValueType>::value
+                              && !is_lvalue_reference<_ValueType>::value,
+                              bool>::type = false>
+    inline _ValueType any_cast(any&& __any)
+    {
+      static_assert(any::__is_valid_cast<_ValueType>(),
+	  "Template argument must be a reference or CopyConstructible type");
+      auto __p = any_cast<remove_reference_t<_ValueType>>(&__any);
+      if (__p)
+	return std::move(*__p);
+      __throw_bad_any_cast();
+    }
   // @}
 
   template<typename _Tp>
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/experimental/bits/fs_dir.h gcc-6-20160721/libstdc++-v3/include/experimental/bits/fs_dir.h
--- gcc-6.1.0/libstdc++-v3/include/experimental/bits/fs_dir.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/experimental/bits/fs_dir.h	2016-05-25 15:45:30.000000000 +0000
@@ -153,8 +153,25 @@
   };
 
   struct _Dir;
+  class directory_iterator;
   class recursive_directory_iterator;
 
+  struct __directory_iterator_proxy
+  {
+    const directory_entry& operator*() const& noexcept { return _M_entry; }
+
+    directory_entry operator*() && noexcept { return std::move(_M_entry); }
+
+  private:
+    friend class directory_iterator;
+    friend class recursive_directory_iterator;
+
+    explicit
+    __directory_iterator_proxy(const directory_entry& __e) : _M_entry(__e) { }
+
+    directory_entry _M_entry;
+  };
+
   class directory_iterator
   {
   public:
@@ -177,7 +194,8 @@
     : directory_iterator(__p, directory_options::none, __ec) { }
 
     directory_iterator(const path& __p,
-      directory_options __options, error_code& __ec) noexcept
+		       directory_options __options,
+		       error_code& __ec) noexcept
     : directory_iterator(__p, __options, &__ec) { }
 
     directory_iterator(const directory_iterator& __rhs) = default;
@@ -186,19 +204,22 @@
 
     ~directory_iterator() = default;
 
-    directory_iterator& operator=(const directory_iterator& __rhs) = default;
-    directory_iterator& operator=(directory_iterator&& __rhs) noexcept = default;
+    directory_iterator&
+    operator=(const directory_iterator& __rhs) = default;
+
+    directory_iterator&
+    operator=(directory_iterator&& __rhs) noexcept = default;
 
     const directory_entry& operator*() const;
     const directory_entry* operator->() const { return &**this; }
     directory_iterator&    operator++();
     directory_iterator&    increment(error_code& __ec) noexcept;
 
-    directory_iterator operator++(int)
+    __directory_iterator_proxy operator++(int)
     {
-      auto __tmp = *this;
+      __directory_iterator_proxy __pr{**this};
       ++*this;
-      return __tmp;
+      return __pr;
     }
 
   private:
@@ -214,10 +235,12 @@
   };
 
   inline directory_iterator
-  begin(directory_iterator __iter) { return __iter; }
+  begin(directory_iterator __iter) noexcept
+  { return __iter; }
 
   inline directory_iterator
-  end(directory_iterator) { return directory_iterator(); }
+  end(directory_iterator) noexcept
+  { return directory_iterator(); }
 
   inline bool
   operator==(const directory_iterator& __lhs, const directory_iterator& __rhs)
@@ -274,18 +297,18 @@
 
     // modifiers
     recursive_directory_iterator&
-      operator=(const recursive_directory_iterator& __rhs) noexcept;
+    operator=(const recursive_directory_iterator& __rhs) noexcept;
     recursive_directory_iterator&
-      operator=(recursive_directory_iterator&& __rhs) noexcept;
+    operator=(recursive_directory_iterator&& __rhs) noexcept;
 
     recursive_directory_iterator& operator++();
     recursive_directory_iterator& increment(error_code& __ec) noexcept;
 
-    recursive_directory_iterator operator++(int)
+    __directory_iterator_proxy operator++(int)
     {
-      auto __tmp = *this;
+      __directory_iterator_proxy __pr{**this};
       ++*this;
-      return __tmp;
+      return __pr;
     }
 
     void pop();
@@ -301,15 +324,17 @@
 
     struct _Dir_stack;
     std::shared_ptr<_Dir_stack> _M_dirs;
-    directory_options _M_options;
-    bool _M_pending;
+    directory_options _M_options = {};
+    bool _M_pending = false;
   };
 
   inline recursive_directory_iterator
-  begin(recursive_directory_iterator __iter) { return __iter; }
+  begin(recursive_directory_iterator __iter) noexcept
+  { return __iter; }
 
   inline recursive_directory_iterator
-  end(recursive_directory_iterator) { return recursive_directory_iterator(); }
+  end(recursive_directory_iterator) noexcept
+  { return recursive_directory_iterator(); }
 
   inline bool
   operator==(const recursive_directory_iterator& __lhs,
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/experimental/bits/fs_fwd.h gcc-6-20160721/libstdc++-v3/include/experimental/bits/fs_fwd.h
--- gcc-6.1.0/libstdc++-v3/include/experimental/bits/fs_fwd.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/experimental/bits/fs_fwd.h	2016-05-25 15:44:02.000000000 +0000
@@ -93,7 +93,7 @@
   };
 
   constexpr copy_options
-  operator&(copy_options __x, copy_options __y)
+  operator&(copy_options __x, copy_options __y) noexcept
   {
     using __utype = typename std::underlying_type<copy_options>::type;
     return static_cast<copy_options>(
@@ -101,7 +101,7 @@
   }
 
   constexpr copy_options
-  operator|(copy_options __x, copy_options __y)
+  operator|(copy_options __x, copy_options __y) noexcept
   {
     using __utype = typename std::underlying_type<copy_options>::type;
     return static_cast<copy_options>(
@@ -109,7 +109,7 @@
   }
 
   constexpr copy_options
-  operator^(copy_options __x, copy_options __y)
+  operator^(copy_options __x, copy_options __y) noexcept
   {
     using __utype = typename std::underlying_type<copy_options>::type;
     return static_cast<copy_options>(
@@ -117,22 +117,22 @@
   }
 
   constexpr copy_options
-  operator~(copy_options __x)
+  operator~(copy_options __x) noexcept
   {
     using __utype = typename std::underlying_type<copy_options>::type;
     return static_cast<copy_options>(~static_cast<__utype>(__x));
   }
 
   inline copy_options&
-  operator&=(copy_options& __x, copy_options __y)
+  operator&=(copy_options& __x, copy_options __y) noexcept
   { return __x = __x & __y; }
 
   inline copy_options&
-  operator|=(copy_options& __x, copy_options __y)
+  operator|=(copy_options& __x, copy_options __y) noexcept
   { return __x = __x | __y; }
 
   inline copy_options&
-  operator^=(copy_options& __x, copy_options __y)
+  operator^=(copy_options& __x, copy_options __y) noexcept
   { return __x = __x ^ __y; }
 
 
@@ -163,7 +163,7 @@
   };
 
   constexpr perms
-  operator&(perms __x, perms __y)
+  operator&(perms __x, perms __y) noexcept
   {
     using __utype = typename std::underlying_type<perms>::type;
     return static_cast<perms>(
@@ -171,7 +171,7 @@
   }
 
   constexpr perms
-  operator|(perms __x, perms __y)
+  operator|(perms __x, perms __y) noexcept
   {
     using __utype = typename std::underlying_type<perms>::type;
     return static_cast<perms>(
@@ -179,7 +179,7 @@
   }
 
   constexpr perms
-  operator^(perms __x, perms __y)
+  operator^(perms __x, perms __y) noexcept
   {
     using __utype = typename std::underlying_type<perms>::type;
     return static_cast<perms>(
@@ -187,22 +187,22 @@
   }
 
   constexpr perms
-  operator~(perms __x)
+  operator~(perms __x) noexcept
   {
     using __utype = typename std::underlying_type<perms>::type;
     return static_cast<perms>(~static_cast<__utype>(__x));
   }
 
   inline perms&
-  operator&=(perms& __x, perms __y)
+  operator&=(perms& __x, perms __y) noexcept
   { return __x = __x & __y; }
 
   inline perms&
-  operator|=(perms& __x, perms __y)
+  operator|=(perms& __x, perms __y) noexcept
   { return __x = __x | __y; }
 
   inline perms&
-  operator^=(perms& __x, perms __y)
+  operator^=(perms& __x, perms __y) noexcept
   { return __x = __x ^ __y; }
 
   // Bitmask type
@@ -211,7 +211,7 @@
   };
 
   constexpr directory_options
-  operator&(directory_options __x, directory_options __y)
+  operator&(directory_options __x, directory_options __y) noexcept
   {
     using __utype = typename std::underlying_type<directory_options>::type;
     return static_cast<directory_options>(
@@ -219,7 +219,7 @@
   }
 
   constexpr directory_options
-  operator|(directory_options __x, directory_options __y)
+  operator|(directory_options __x, directory_options __y) noexcept
   {
     using __utype = typename std::underlying_type<directory_options>::type;
     return static_cast<directory_options>(
@@ -227,7 +227,7 @@
   }
 
   constexpr directory_options
-  operator^(directory_options __x, directory_options __y)
+  operator^(directory_options __x, directory_options __y) noexcept
   {
     using __utype = typename std::underlying_type<directory_options>::type;
     return static_cast<directory_options>(
@@ -235,22 +235,22 @@
   }
 
   constexpr directory_options
-  operator~(directory_options __x)
+  operator~(directory_options __x) noexcept
   {
     using __utype = typename std::underlying_type<directory_options>::type;
     return static_cast<directory_options>(~static_cast<__utype>(__x));
   }
 
   inline directory_options&
-  operator&=(directory_options& __x, directory_options __y)
+  operator&=(directory_options& __x, directory_options __y) noexcept
   { return __x = __x & __y; }
 
   inline directory_options&
-  operator|=(directory_options& __x, directory_options __y)
+  operator|=(directory_options& __x, directory_options __y) noexcept
   { return __x = __x | __y; }
 
   inline directory_options&
-  operator^=(directory_options& __x, directory_options __y)
+  operator^=(directory_options& __x, directory_options __y) noexcept
   { return __x = __x ^ __y; }
 
   typedef chrono::time_point<chrono::system_clock> file_time_type;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/experimental/functional gcc-6-20160721/libstdc++-v3/include/experimental/functional
--- gcc-6.1.0/libstdc++-v3/include/experimental/functional	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/experimental/functional	2016-07-19 22:16:35.000000000 +0000
@@ -42,6 +42,9 @@
 #include <vector>
 #include <array>
 #include <bits/stl_algo.h>
+#ifdef _GLIBCXX_PARALLEL
+# include <parallel/algorithm> // For std::__parallel::search
+#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/experimental/optional gcc-6-20160721/libstdc++-v3/include/experimental/optional
--- gcc-6.1.0/libstdc++-v3/include/experimental/optional	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/experimental/optional	2016-07-06 13:58:32.000000000 +0000
@@ -470,6 +470,23 @@
       bool _M_engaged = false;
     };
 
+  template<typename _Tp>
+  class optional;
+
+  template<typename>
+    struct __is_optional_impl : false_type
+    { };
+
+  template<typename _Tp>
+  struct __is_optional_impl<optional<_Tp>> : true_type
+    { };
+
+  template<typename _Tp>
+    struct __is_optional
+    : public __is_optional_impl<std::remove_cv_t<std::remove_reference_t<_Tp>>>
+    { };
+
+
   /**
     * @brief Class template for optional values.
     */
@@ -502,6 +519,78 @@
       // _Optional_base has the responsibility for construction.
       using _Base::_Base;
 
+      constexpr optional() = default;
+      // Converting constructors for engaged optionals.
+      template <typename _Up,
+                enable_if_t<__and_<
+			      __not_<is_same<_Tp, _Up>>,
+			      is_constructible<_Tp, _Up&&>,
+			      is_convertible<_Up&&, _Tp>
+			      >::value, bool> = true>
+      constexpr optional(_Up&& __t)
+        : _Base(_Tp(std::forward<_Up>(__t))) { }
+
+      template <typename _Up,
+                enable_if_t<__and_<
+			    __not_<is_same<_Tp, _Up>>,
+			    is_constructible<_Tp, _Up&&>,
+			    __not_<is_convertible<_Up&&, _Tp>>
+			    >::value, bool> = false>
+      explicit constexpr optional(_Up&& __t)
+        : _Base(_Tp(std::forward<_Up>(__t))) { }
+
+      template <typename _Up,
+                enable_if_t<__and_<
+			    __not_<is_same<_Tp, _Up>>,
+			    __not_<is_constructible<
+			      _Tp, const optional<_Up>&>>,
+			    __not_<is_convertible<
+			      const optional<_Up>&, _Tp>>,
+			    is_constructible<_Tp, const _Up&>,
+			    is_convertible<const _Up&, _Tp>
+			    >::value, bool> = true>
+      constexpr optional(const optional<_Up>& __t)
+        : _Base(__t ? optional<_Tp>(*__t) : optional<_Tp>()) { }
+
+      template <typename _Up,
+                 enable_if_t<__and_<
+			       __not_<is_same<_Tp, _Up>>,
+			       __not_<is_constructible<
+					_Tp, const optional<_Up>&>>,
+			       __not_<is_convertible<
+				 const optional<_Up>&, _Tp>>,
+			       is_constructible<_Tp, const _Up&>,
+			       __not_<is_convertible<const _Up&, _Tp>>
+			       >::value, bool> = false>
+      explicit constexpr optional(const optional<_Up>& __t)
+        : _Base(__t ? optional<_Tp>(*__t) : optional<_Tp>()) { }
+
+      template <typename _Up,
+                enable_if_t<__and_<
+			      __not_<is_same<_Tp, _Up>>,
+			      __not_<is_constructible<
+				       _Tp, optional<_Up>&&>>,
+			      __not_<is_convertible<
+				       optional<_Up>&&, _Tp>>,
+			      is_constructible<_Tp, _Up&&>,
+			      is_convertible<_Up&&, _Tp>
+			      >::value, bool> = true>
+      constexpr optional(optional<_Up>&& __t)
+        : _Base(__t ? optional<_Tp>(std::move(*__t)) : optional<_Tp>()) { }
+
+      template <typename _Up,
+                enable_if_t<__and_<
+			    __not_<is_same<_Tp, _Up>>,
+			    __not_<is_constructible<
+				     _Tp, optional<_Up>&&>>,
+			    __not_<is_convertible<
+				     optional<_Up>&&, _Tp>>,
+			    is_constructible<_Tp, _Up&&>,
+			    __not_<is_convertible<_Up&&, _Tp>>
+			    >::value, bool> = false>
+      explicit constexpr optional(optional<_Up>&& __t)
+        : _Base(__t ? optional<_Tp>(std::move(*__t)) : optional<_Tp>()) { }
+
       // [X.Y.4.3] (partly) Assignment.
       optional&
       operator=(nullopt_t) noexcept
@@ -510,8 +599,12 @@
         return *this;
       }
 
-      template<typename _Up>
-        enable_if_t<is_same<_Tp, decay_t<_Up>>::value, optional&>
+      template<typename _Up,
+               enable_if_t<__and_<
+			   __not_<is_same<_Up, nullopt_t>>,
+			   __not_<__is_optional<_Up>>>::value,
+			 bool> = true>
+        optional&
         operator=(_Up&& __u)
         {
           static_assert(__and_<is_constructible<_Tp, _Up>,
@@ -525,6 +618,57 @@
 
           return *this;
         }
+
+      template<typename _Up,
+               enable_if_t<__and_<
+		 __not_<is_same<_Tp, _Up>>>::value,
+			   bool> = true>
+        optional&
+        operator=(const optional<_Up>& __u)
+        {
+          static_assert(__and_<is_constructible<_Tp, _Up>,
+			       is_assignable<_Tp&, _Up>>(),
+                        "Cannot assign to value type from argument");
+
+          if (__u)
+            {
+              if (this->_M_is_engaged())
+                this->_M_get() = *__u;
+              else
+                this->_M_construct(*__u);
+            }
+          else
+            {
+              this->_M_reset();
+            }
+          return *this;
+        }
+
+      template<typename _Up,
+               enable_if_t<__and_<
+		 __not_<is_same<_Tp, _Up>>>::value,
+			   bool> = true>
+        optional&
+        operator=(optional<_Up>&& __u)
+        {
+          static_assert(__and_<is_constructible<_Tp, _Up>,
+			       is_assignable<_Tp&, _Up>>(),
+                        "Cannot assign to value type from argument");
+
+          if (__u)
+            {
+              if (this->_M_is_engaged())
+                this->_M_get() = std::move(*__u);
+              else
+                this->_M_construct(std::move(*__u));
+            }
+          else
+            {
+              this->_M_reset();
+            }
+
+          return *this;
+        }
 
       template<typename... _Args>
 	void
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/parallel/balanced_quicksort.h gcc-6-20160721/libstdc++-v3/include/parallel/balanced_quicksort.h
--- gcc-6.1.0/libstdc++-v3/include/parallel/balanced_quicksort.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/parallel/balanced_quicksort.h	2016-07-19 22:16:23.000000000 +0000
@@ -53,6 +53,9 @@
 
 #if _GLIBCXX_ASSERTIONS
 #include <parallel/checkers.h>
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+#include <unistd.h>
+#endif
 #endif
 
 namespace __gnu_parallel
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/parallel/compiletime_settings.h gcc-6-20160721/libstdc++-v3/include/parallel/compiletime_settings.h
--- gcc-6.1.0/libstdc++-v3/include/parallel/compiletime_settings.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/parallel/compiletime_settings.h	2016-07-19 22:16:23.000000000 +0000
@@ -55,12 +55,6 @@
 #define _GLIBCXX_SCALE_DOWN_FPU 0
 #endif
 
-#ifndef _GLIBCXX_ASSERTIONS
-/** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.
- *  Should be switched on only locally. */
-#define _GLIBCXX_ASSERTIONS 0
-#endif
-
 #ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1
 /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.
  *  Consider the size of the L1 cache for
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/include/std/tuple gcc-6-20160721/libstdc++-v3/include/std/tuple
--- gcc-6.1.0/libstdc++-v3/include/std/tuple	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/include/std/tuple	2016-05-09 14:44:32.000000000 +0000
@@ -500,6 +500,14 @@
                      __not_<is_constructible<_Elements..., _SrcTuple>>
               >::value;
     }
+    template<typename... _UElements>
+    static constexpr bool _NotSameTuple()
+    {
+      return  __not_<is_same<tuple<_Elements...>,
+			     typename remove_const<
+			       typename remove_reference<_UElements...>::type
+			       >::type>>::value;
+    }
   };
 
   template<typename... _Elements>
@@ -534,6 +542,11 @@
     {
       return true;
     }
+    template<typename... _UElements>
+    static constexpr bool _NotSameTuple()
+    {
+      return  true;
+    }
   };
 
   /// Primary class template, tuple
@@ -611,7 +624,10 @@
                       _Elements...>;
 
       template<typename... _UElements, typename
-        enable_if<_TMC<_UElements...>::template
+	       enable_if<
+		  _TC<sizeof...(_UElements) == 1, _Elements...>::template
+		    _NotSameTuple<_UElements...>()
+		  && _TMC<_UElements...>::template
                     _MoveConstructibleTuple<_UElements...>()
                   && _TMC<_UElements...>::template
                     _ImplicitlyMoveConvertibleTuple<_UElements...>()
@@ -621,7 +637,10 @@
         : _Inherited(std::forward<_UElements>(__elements)...) { }
 
       template<typename... _UElements, typename
-        enable_if<_TMC<_UElements...>::template
+        enable_if<
+		  _TC<sizeof...(_UElements) == 1, _Elements...>::template
+		    _NotSameTuple<_UElements...>()
+		  && _TMC<_UElements...>::template
                     _MoveConstructibleTuple<_UElements...>()
                   && !_TMC<_UElements...>::template
                     _ImplicitlyMoveConvertibleTuple<_UElements...>()
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/src/c++11/codecvt.cc gcc-6-20160721/libstdc++-v3/src/c++11/codecvt.cc
--- gcc-6.1.0/libstdc++-v3/src/c++11/codecvt.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/src/c++11/codecvt.cc	2016-05-25 16:33:03.000000000 +0000
@@ -789,7 +789,11 @@
 {
   range<const char> from{ __from, __from_end };
   range<char16_t> to{ __to, __to_end };
-  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);
+  codecvt_mode mode = codecvt_mode(_M_mode & (consume_header|generate_header));
+#if __BYTE_ORDER__ != __ORDER_BIG_ENDIAN__
+  mode = codecvt_mode(mode | little_endian);
+#endif
+  auto res = ucs2_in(from, to, _M_maxcode, mode);
   __from_next = from.next;
   __to_next = to.next;
   return res;
@@ -1264,7 +1268,7 @@
 {
   range<const char> from{ __from, __from_end };
   range<char16_t> to{ __to, __to_end };
-  codecvt_mode mode = codecvt_mode(_M_mode | (consume_header|generate_header));
+  codecvt_mode mode = codecvt_mode(_M_mode & (consume_header|generate_header));
 #if __BYTE_ORDER__ != __ORDER_BIG_ENDIAN__
   mode = codecvt_mode(mode | little_endian);
 #endif
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/src/c++11/cow-stdexcept.cc gcc-6-20160721/libstdc++-v3/src/c++11/cow-stdexcept.cc
--- gcc-6.1.0/libstdc++-v3/src/c++11/cow-stdexcept.cc	2016-01-18 20:09:55.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/src/c++11/cow-stdexcept.cc	2016-05-11 19:06:45.000000000 +0000
@@ -292,6 +292,7 @@
   return (const char*) txnal_read_ptr((void**)&bs->_M_dataplus._M_p);
 }
 
+#if _GLIBCXX_USE_DUAL_ABI
 const char*
 _txnal_sso_string_c_str(const void* that)
 {
@@ -299,6 +300,7 @@
       (void* const*)const_cast<char* const*>(
 	  &((const std::__sso_string*) that)->_M_s._M_p));
 }
+#endif
 
 void
 _txnal_cow_string_D1_commit(void* data)
@@ -344,9 +346,24 @@
 // result in undefined behavior, which is in this case not initializing this
 // string.
 #if _GLIBCXX_USE_DUAL_ABI
-#define CTORDTORSTRINGCSTR(s) _txnal_sso_string_c_str((s))
+#define CTORS_FROM_SSOSTRING(NAME, CLASS, BASE)			\
+void									\
+_ZGTtNSt##NAME##C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE( \
+    CLASS* that, const std::__sso_string& s)				\
+{									\
+  CLASS e("");								\
+  _ITM_memcpyRnWt(that, &e, sizeof(CLASS));				\
+  /* Get the C string from the SSO string.  */				\
+  _txnal_cow_string_C1_for_exceptions(_txnal_##BASE##_get_msg(that),	\
+				      _txnal_sso_string_c_str(&s), that); \
+}									\
+void									\
+_ZGTtNSt##NAME##C2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE( \
+    CLASS*, const std::__sso_string&) __attribute__((alias		\
+("_ZGTtNSt" #NAME							\
+  "C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE")));
 #else
-#define CTORDTORSTRINGCSTR(s) ""
+#define CTORS_FROM_SSOSTRING(NAME, CLASS, BASE)
 #endif
 
 // This macro defines transaction constructors and destructors for a specific
@@ -373,21 +390,7 @@
 void									\
 _ZGTtNSt##NAME##C2EPKc (CLASS*, const char*)				\
   __attribute__((alias ("_ZGTtNSt" #NAME "C1EPKc")));			\
-void									\
-_ZGTtNSt##NAME##C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE( \
-    CLASS* that, const std::__sso_string& s)				\
-{									\
-  CLASS e("");								\
-  _ITM_memcpyRnWt(that, &e, sizeof(CLASS));				\
-  /* Get the C string from the SSO string.  */				\
-  _txnal_cow_string_C1_for_exceptions(_txnal_##BASE##_get_msg(that),	\
-				      CTORDTORSTRINGCSTR(&s), that);	\
-}									\
-void									\
-_ZGTtNSt##NAME##C2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE( \
-    CLASS*, const std::__sso_string&) __attribute__((alias		\
-("_ZGTtNSt" #NAME							\
-  "C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE")));	\
+CTORS_FROM_SSOSTRING(NAME, CLASS, BASE)					\
 void									\
 _ZGTtNSt##NAME##D1Ev(CLASS* that)					\
 { _txnal_cow_string_D1(_txnal_##BASE##_get_msg(that)); }		\
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/src/filesystem/ops.cc gcc-6-20160721/libstdc++-v3/src/filesystem/ops.cc
--- gcc-6.1.0/libstdc++-v3/src/filesystem/ops.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/src/filesystem/ops.cc	2016-07-19 16:34:23.000000000 +0000
@@ -220,8 +220,9 @@
 {
   error_code ec;
   path can = canonical(p, base, ec);
-  if (ec.value())
-    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot canonicalize", p, ec));
+  if (ec)
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot canonicalize", p, base,
+					     ec));
   return can;
 }
 
@@ -249,7 +250,7 @@
   typedef struct ::stat stat_type;
 
   inline fs::file_type
-  make_file_type(const stat_type& st)
+  make_file_type(const stat_type& st) noexcept
   {
     using fs::file_type;
 #ifdef _GLIBCXX_HAVE_S_ISREG
@@ -273,7 +274,7 @@
   }
 
   inline fs::file_status
-  make_file_status(const stat_type& st)
+  make_file_status(const stat_type& st) noexcept
   {
     return fs::file_status{
 	make_file_type(st),
@@ -282,13 +283,13 @@
   }
 
   inline bool
-  is_not_found_errno(int err)
+  is_not_found_errno(int err) noexcept
   {
     return err == ENOENT || err == ENOTDIR;
   }
 
   inline fs::file_time_type
-  file_time(const stat_type& st)
+  file_time(const stat_type& st) noexcept
   {
     using namespace std::chrono;
     return fs::file_time_type{
@@ -300,6 +301,17 @@
     };
   }
 
+  // Returns true if the file descriptor was successfully closed,
+  // otherwise returns false and the reason will be in errno.
+  inline bool
+  close_fd(int fd)
+  {
+    while (::close(fd))
+      if (errno != EINTR)
+	return false;
+    return true;
+  }
+
   bool
   do_copy_file(const fs::path& from, const fs::path& to,
 	       fs::copy_options option,
@@ -376,7 +388,8 @@
       }
 
     struct CloseFD {
-      ~CloseFD() { if (fd != -1) ::close(fd); }
+      ~CloseFD() { if (fd != -1) close_fd(fd); }
+      bool close() { return close_fd(std::exchange(fd, -1)); }
       int fd;
     };
 
@@ -401,34 +414,49 @@
 	return false;
       }
 
+#ifdef _GLIBCXX_USE_FCHMOD
+    if (::fchmod(out.fd, from_st->st_mode))
+#elif _GLIBCXX_USE_FCHMODAT
+    if (::fchmodat(AT_FDCWD, to.c_str(), from_st->st_mode, 0))
+#else
+    if (::chmod(to.c_str(), from_st->st_mode))
+#endif
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
+
 #ifdef _GLIBCXX_USE_SENDFILE
-    auto n = ::sendfile(out.fd, in.fd, nullptr, from_st->st_size);
+    const auto n = ::sendfile(out.fd, in.fd, nullptr, from_st->st_size);
     if (n != from_st->st_size)
       {
 	ec.assign(errno, std::generic_category());
 	return false;
       }
+    if (!out.close() || !in.close())
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
 #else
     __gnu_cxx::stdio_filebuf<char> sbin(in.fd, std::ios::in);
     __gnu_cxx::stdio_filebuf<char> sbout(out.fd, std::ios::out);
-    if ( !(std::ostream(&sbout) << &sbin) )
+    if (sbin.is_open())
+      in.fd = -1;
+    if (sbout.is_open())
+      out.fd = -1;
+    if (from_st->st_size && !(std::ostream(&sbout) << &sbin))
       {
 	ec = std::make_error_code(std::errc::io_error);
 	return false;
       }
-#endif
-
-#ifdef _GLIBCXX_USE_FCHMOD
-    if (::fchmod(out.fd, from_st->st_mode))
-#elif _GLIBCXX_USE_FCHMODAT
-    if (::fchmodat(AT_FDCWD, to.c_str(), from_st->st_mode, 0))
-#else
-    if (::chmod(to.c_str(), from_st->st_mode))
-#endif
+    if (!sbout.close() || !sbin.close())
       {
 	ec.assign(errno, std::generic_category());
 	return false;
       }
+#endif
+
     ec.clear();
     return true;
   }
@@ -439,13 +467,15 @@
 fs::copy(const path& from, const path& to, copy_options options,
 	 error_code& ec) noexcept
 {
-  bool skip_symlinks = is_set(options, copy_options::skip_symlinks);
-  bool create_symlinks = is_set(options, copy_options::create_symlinks);
-  bool use_lstat = create_symlinks || skip_symlinks;
+  const bool skip_symlinks = is_set(options, copy_options::skip_symlinks);
+  const bool create_symlinks = is_set(options, copy_options::create_symlinks);
+  const bool copy_symlinks = is_set(options, copy_options::copy_symlinks);
+  const bool use_lstat = create_symlinks || skip_symlinks;
 
   file_status f, t;
   stat_type from_st, to_st;
-  if (use_lstat
+  // N4099 doesn't check copy_symlinks here, but I think that's a defect.
+  if (use_lstat || copy_symlinks
       ? ::lstat(from.c_str(), &from_st)
       : ::stat(from.c_str(), &from_st))
     {
@@ -488,7 +518,7 @@
     {
       if (skip_symlinks)
 	ec.clear();
-      else if (!exists(t) && is_set(options, copy_options::copy_symlinks))
+      else if (!exists(t) && copy_symlinks)
 	copy_symlink(from, to, ec);
       else
 	// Not clear what should be done here.
@@ -630,22 +660,26 @@
   bool
   create_dir(const fs::path& p, fs::perms perm, std::error_code& ec)
   {
+    bool created = false;
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
     ::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);
     if (::mkdir(p.c_str(), mode))
       {
-	ec.assign(errno, std::generic_category());
-	return false;
+	const int err = errno;
+	if (err != EEXIST || !is_directory(p))
+	  ec.assign(err, std::generic_category());
+	else
+	  ec.clear();
       }
     else
       {
 	ec.clear();
-	return true;
+	created = true;
       }
 #else
     ec = std::make_error_code(std::errc::not_supported);
-    return false;
 #endif
+    return created;
   }
 } // namespace
 
@@ -1050,6 +1084,28 @@
 
 void fs::permissions(const path& p, perms prms, error_code& ec) noexcept
 {
+  const bool add = is_set(prms, perms::add_perms);
+  const bool remove = is_set(prms, perms::remove_perms);
+  if (add && remove)
+    {
+      ec = std::make_error_code(std::errc::invalid_argument);
+      return;
+    }
+
+  prms &= perms::mask;
+
+  if (add || remove)
+    {
+      auto st = status(p, ec);
+      if (ec)
+	return;
+      auto curr = st.permissions();
+      if (add)
+	prms |= curr;
+      else
+	prms = curr & ~prms;
+    }
+
 #if _GLIBCXX_USE_FCHMODAT
   if (::fchmodat(AT_FDCWD, p.c_str(), static_cast<mode_t>(prms), 0))
 #else
@@ -1138,7 +1194,7 @@
   uintmax_t count = 0;
   if (ec.value() == 0 && fs.type() == file_type::directory)
     for (directory_iterator d(p, ec), end; ec.value() == 0 && d != end; ++d)
-      count += fs::remove(d->path(), ec);
+      count += fs::remove_all(d->path(), ec);
   if (ec.value())
     return -1;
   return fs::remove(p, ec) ? ++count : -1;  // fs:remove() calls ec.clear()
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/20_util/tuple/cons/element_accepts_anything_byval.cc gcc-6-20160721/libstdc++-v3/testsuite/20_util/tuple/cons/element_accepts_anything_byval.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/20_util/tuple/cons/element_accepts_anything_byval.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/20_util/tuple/cons/element_accepts_anything_byval.cc	2016-05-09 14:44:32.000000000 +0000
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tuple>
+using namespace std;
+
+struct Something {
+    Something() { }
+    template <typename T> Something(T) { }
+};
+
+int main() {
+    tuple<Something> t1;
+    tuple<Something> t2 = t1;
+}
+
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc gcc-6-20160721/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc	2016-05-25 16:33:03.000000000 +0000
@@ -0,0 +1,103 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <codecvt>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  const char out[] = "abc";
+  char16_t in[4];
+  std::codecvt_utf8<char16_t> cvt;
+  std::mbstate_t st;
+  const char* no;
+  char16_t* ni;
+  auto res = cvt.in(st, out, out+3, no, in, in+3, ni);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( in[0] == u'a' );
+  VERIFY( in[1] == u'b' );
+  VERIFY( in[2] == u'c' );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  const char out[] = "abc";
+  char16_t in[4];
+  std::codecvt_utf8<char16_t, 0x10ffff, std::little_endian> cvt;
+  std::mbstate_t st;
+  const char* no;
+  char16_t* ni;
+  auto res = cvt.in(st, out, out+3, no, in, in+3, ni);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( in[0] == u'a' );
+  VERIFY( in[1] == u'b' );
+  VERIFY( in[2] == u'c' );
+}
+
+void
+test03()
+{
+  bool test __attribute__((unused)) = true;
+
+  const char out[] = "abc";
+  char32_t in[4];
+  std::codecvt_utf8<char32_t> cvt;
+  std::mbstate_t st;
+  const char* no;
+  char32_t* ni;
+  auto res = cvt.in(st, out, out+3, no, in, in+3, ni);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( in[0] == U'a' );
+  VERIFY( in[1] == U'b' );
+  VERIFY( in[2] == U'c' );
+}
+
+
+void
+test04()
+{
+  bool test __attribute__((unused)) = true;
+
+  const char out[] = "abc";
+  char32_t in[4];
+  std::codecvt_utf8<char32_t, 0x10ffff, std::little_endian> cvt;
+  std::mbstate_t st;
+  const char* no;
+  char32_t* ni;
+  auto res = cvt.in(st, out, out+3, no, in, in+3, ni);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( in[0] == U'a' );
+  VERIFY( in[1] == U'b' );
+  VERIFY( in[2] == U'c' );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test01();
+  test02();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc gcc-6-20160721/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc	2016-05-25 16:33:03.000000000 +0000
@@ -45,8 +45,35 @@
   VERIFY( buf[3] == utf16[3] );
 }
 
+void
+test02()
+{
+  // Endianness flag should make no difference.
+  std::codecvt_utf8_utf16<char16_t, 0x10ffff, std::little_endian> cvt;
+  char16_t utf16[] = u"\ub098\ub294\ud0dc\uc624";
+  const char16_t* nf16;
+  char utf8[16];
+  char* nt8;
+  std::mbstate_t st{};
+  auto res = cvt.out(st, utf16, utf16+4, nf16, utf8, utf8+16, nt8);
+  VERIFY( res == std::codecvt_base::ok );
+
+  st = {};
+  char16_t buf[4] = {};
+  const char* nf8 = nt8;
+  char16_t* nt16;
+  res = cvt.in(st, utf8, nf8, nf8, buf, buf+4, nt16);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( nt16 == buf+4 );
+  VERIFY( buf[0] == utf16[0] );
+  VERIFY( buf[1] == utf16[1] );
+  VERIFY( buf[2] == utf16[2] );
+  VERIFY( buf[3] == utf16[3] );
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/binary_search/partitioned.cc gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/binary_search/partitioned.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/binary_search/partitioned.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/binary_search/partitioned.cc	2016-06-17 18:53:46.000000000 +0000
@@ -0,0 +1,67 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -D_GLIBCXX_DEBUG" }
+
+#include <algorithm>
+#include <functional>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+using __gnu_test::test_container;
+using __gnu_test::forward_iterator_wrapper;
+
+struct X
+{
+  int val;
+
+  bool odd() const { return val % 2; }
+
+  // Partitioned so that all odd values come before even values:
+  bool operator<(const X& x) const { return this->odd() && !x.odd(); }
+};
+
+void
+test01()
+{
+  bool test __attribute((unused)) = true;
+
+  // Test with range that is partitioned, but not sorted.
+  X seq[] = { 1, 3, 5, 7, 1, 6, 4 };
+  test_container<X, forward_iterator_wrapper> c(seq);
+
+  auto b1 = std::binary_search(c.begin(), c.end(), X{2});
+  VERIFY( b1 );
+  auto b2 = std::binary_search(c.begin(), c.end(), X{2}, std::less<X>{});
+  VERIFY( b2 );
+
+  auto b3 = std::binary_search(c.begin(), c.end(), X{9});
+  VERIFY( b3 );
+  auto b4 = std::binary_search(c.begin(), c.end(), X{9}, std::less<X>{});
+  VERIFY( b4 );
+
+  auto b5 = std::binary_search(seq, seq+5, X{2});
+  VERIFY( !b5 );
+  auto b6 = std::binary_search(seq, seq+5, X{2}, std::less<X>{});
+  VERIFY( !b6 );
+}
+
+int
+main()
+{
+  test01();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/equal_range/partitioned.cc gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/equal_range/partitioned.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/equal_range/partitioned.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/equal_range/partitioned.cc	2016-06-17 18:53:46.000000000 +0000
@@ -0,0 +1,66 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -D_GLIBCXX_DEBUG" }
+
+#include <algorithm>
+#include <functional>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+using __gnu_test::test_container;
+using __gnu_test::forward_iterator_wrapper;
+
+struct X
+{
+  int val;
+
+  bool odd() const { return val % 2; }
+
+  // Partitioned so that all odd values come before even values:
+  bool operator<(const X& x) const { return this->odd() && !x.odd(); }
+};
+
+void
+test01()
+{
+  bool test __attribute((unused)) = true;
+
+  // Test with range that is partitioned, but not sorted.
+  X seq[] = { 1, 3, 5, 7, 1, 6, 4, 2 };
+  test_container<X, forward_iterator_wrapper> c(seq);
+
+  auto part1 = std::equal_range(c.begin(), c.end(), X{2});
+  VERIFY( part1.first != c.end() && part1.second == c.end() );
+  VERIFY( part1.first->val == 6 );
+  auto part2 = std::equal_range(c.begin(), c.end(), X{2}, std::less<X>{});
+  VERIFY( part2.first != c.end() && part1.second == c.end() );
+  VERIFY( part2.first->val == 6 );
+
+  auto part3 = std::equal_range(c.begin(), c.end(), X{9});
+  VERIFY( part3.first == c.begin() && part3.second != c.end() );
+  VERIFY( part3.second->val == 6 );
+  auto part4 = std::equal_range(c.begin(), c.end(), X{9}, std::less<X>{});
+  VERIFY( part4.first == c.begin() && part4.second != c.end() );
+  VERIFY( part4.second->val == 6 );
+}
+
+int
+main()
+{
+  test01();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/71545.cc gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/71545.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/71545.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/71545.cc	2016-06-17 18:53:46.000000000 +0000
@@ -0,0 +1,35 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -D_GLIBCXX_DEBUG" }
+// { dg-do link }
+
+#include <algorithm>
+
+struct X { };
+
+bool operator<(X, int) { return true; }
+bool operator<(int, X) { return false; }
+
+bool operator<(X, X); // undefined (PR libstdc++/71545)
+
+int main()
+{
+  X x[1];
+  int i[1];
+  std::lexicographical_compare(x, x+1, i, i+1);
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/lower_bound/partitioned.cc gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/lower_bound/partitioned.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/lower_bound/partitioned.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/lower_bound/partitioned.cc	2016-06-17 18:53:46.000000000 +0000
@@ -0,0 +1,100 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -D_GLIBCXX_DEBUG" }
+
+#include <algorithm>
+#include <functional>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+using __gnu_test::test_container;
+using __gnu_test::forward_iterator_wrapper;
+
+struct X
+{
+  int val;
+
+  bool odd() const { return val % 2; }
+
+  // Partitioned so that all odd values come before even values:
+  bool operator<(const X& x) const { return this->odd() && !x.odd(); }
+};
+
+void
+test01()
+{
+  bool test __attribute((unused)) = true;
+
+  // Test with range that is partitioned, but not sorted.
+  X seq[] = { 1, 3, 5, 7, 1, 6, 4, 2 };
+  test_container<X, forward_iterator_wrapper> c(seq);
+
+  auto part1 = std::lower_bound(c.begin(), c.end(), X{2});
+  VERIFY( part1 != c.end() );
+  VERIFY( part1->val == 6 );
+  auto part2 = std::lower_bound(c.begin(), c.end(), X{2}, std::less<X>{});
+  VERIFY( part2 != c.end() );
+  VERIFY( part2->val == 6 );
+
+  auto part3 = std::lower_bound(c.begin(), c.end(), X{9});
+  VERIFY( part3 != c.end() );
+  VERIFY( part3->val == 1 );
+  auto part4 = std::lower_bound(c.begin(), c.end(), X{9}, std::less<X>{});
+  VERIFY( part4 != c.end() );
+  VERIFY( part4->val == 1 );
+}
+
+struct Y
+{
+  double val;
+
+  // Not irreflexive, so not a strict weak order.
+  bool operator<(const Y& y) const { return val < int(y.val); }
+};
+
+void
+test02()
+{
+  bool test __attribute((unused)) = true;
+
+  // Test that Debug Mode checks don't fire (libstdc++/71545)
+
+  Y seq[] = { -0.1, 1.2, 5.0, 5.2, 5.1, 5.9, 5.5, 6.0 };
+  test_container<Y, forward_iterator_wrapper> c(seq);
+
+  auto part1 = std::lower_bound(c.begin(), c.end(), Y{5.5});
+  VERIFY( part1 != c.end() );
+  VERIFY( part1->val == 5.0 );
+  auto part2 = std::lower_bound(c.begin(), c.end(), Y{5.5}, std::less<Y>{});
+  VERIFY( part2 != c.end() );
+  VERIFY( part2->val == 5.0 );
+
+  auto part3 = std::lower_bound(c.begin(), c.end(), Y{1.0});
+  VERIFY( part3 != c.end() );
+  VERIFY( part3->val == 1.2 );
+  auto part4 = std::lower_bound(c.begin(), c.end(), Y{1.0}, std::less<Y>{});
+  VERIFY( part4 != c.end() );
+  VERIFY( part4->val == 1.2 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/upper_bound/partitioned.cc gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/upper_bound/partitioned.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/25_algorithms/upper_bound/partitioned.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/25_algorithms/upper_bound/partitioned.cc	2016-06-17 18:53:46.000000000 +0000
@@ -0,0 +1,98 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -D_GLIBCXX_DEBUG" }
+
+#include <algorithm>
+#include <functional>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+using __gnu_test::test_container;
+using __gnu_test::forward_iterator_wrapper;
+
+struct X
+{
+  int val;
+
+  bool odd() const { return val % 2; }
+
+  // Partitioned so that all odd values come before even values:
+  bool operator<(const X& x) const { return this->odd() && !x.odd(); }
+};
+
+void
+test01()
+{
+  bool test __attribute((unused)) = true;
+
+  // Test with range that is partitioned, but not sorted.
+  X seq[] = { 1, 3, 5, 7, 1, 6, 4, 2 };
+  test_container<X, forward_iterator_wrapper> c(seq);
+
+  auto part1 = std::upper_bound(c.begin(), c.end(), X{2});
+  VERIFY( part1 == c.end() );
+  auto part2 = std::upper_bound(c.begin(), c.end(), X{2}, std::less<X>{});
+  VERIFY( part2 == c.end() );
+
+  auto part3 = std::upper_bound(c.begin(), c.end(), X{9});
+  VERIFY( part3 != c.end() );
+  VERIFY( part3->val == 6 );
+  auto part4 = std::upper_bound(c.begin(), c.end(), X{9}, std::less<X>{});
+  VERIFY( part3 != c.end() );
+  VERIFY( part4->val == 6 );
+}
+
+struct Y
+{
+  double val;
+
+  // Not irreflexive, so not a strict weak order.
+  bool operator<(const Y& y) const { return val < (int)y.val; }
+};
+
+void
+test02()
+{
+  bool test __attribute((unused)) = true;
+
+  // Test that Debug Mode checks don't fire (libstdc++/71545)
+
+  Y seq[] = { -0.1, 1.2, 5.0, 5.2, 5.1, 5.9, 5.5, 6.0 };
+  test_container<Y, forward_iterator_wrapper> c(seq);
+
+  auto part1 = std::upper_bound(c.begin(), c.end(), Y{5.5});
+  VERIFY( part1 != c.end() );
+  VERIFY( part1->val == 6.0 );
+  auto part2 = std::upper_bound(c.begin(), c.end(), Y{5.5}, std::less<Y>{});
+  VERIFY( part2 != c.end() );
+  VERIFY( part2->val == 6.0 );
+
+  auto part3 = std::upper_bound(c.begin(), c.end(), Y{1.0});
+  VERIFY( part3 != c.end() );
+  VERIFY( part3->val == 5.0 );
+  auto part4 = std::upper_bound(c.begin(), c.end(), Y{1.0}, std::less<Y>{});
+  VERIFY( part4 != c.end() );
+  VERIFY( part4->val == 5.0 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	2016-07-05 20:06:31.000000000 +0000
@@ -77,8 +77,38 @@
   }
 }
 
+static int move_count = 0;
+
+void test03()
+{
+  struct MoveEnabled
+  {
+    MoveEnabled(MoveEnabled&&)
+    {
+      ++move_count;
+    }
+    MoveEnabled() = default;
+    MoveEnabled(const MoveEnabled&) = default;
+  };
+  MoveEnabled m;
+  MoveEnabled m2 = any_cast<MoveEnabled>(any(m));
+  VERIFY(move_count == 1);
+  MoveEnabled&& m3 = any_cast<MoveEnabled&&>(any(m));
+  VERIFY(move_count == 1);
+  struct MoveDeleted
+  {
+    MoveDeleted(MoveDeleted&&) = delete;
+    MoveDeleted() = default;
+    MoveDeleted(const MoveDeleted&) = default;
+  };
+  MoveDeleted md;
+  MoveDeleted&& md2 = any_cast<MoveDeleted>(any(std::move(md)));
+  MoveDeleted&& md3 = any_cast<MoveDeleted&&>(any(std::move(md)));
+}
+
 int main()
 {
   test01();
   test02();
+  test03();
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	2016-07-05 20:06:31.000000000 +0000
@@ -26,5 +26,5 @@
   using std::experimental::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 353 }
+  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 368 }
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc	2016-05-25 15:45:30.000000000 +0000
@@ -70,8 +70,79 @@
   remove_all(p, ec);
 }
 
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  const auto p = __gnu_test::nonexistent_path();
+  create_directory(p, fs::current_path(), ec);
+  create_directory_symlink(p, p / "l", ec);
+  VERIFY( !ec );
+
+  // Test post-increment (libstdc++/71005)
+  auto iter = fs::directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter != fs::directory_iterator() );
+  const auto entry1 = *iter;
+  const auto entry2 = *iter++;
+  VERIFY( entry1 == entry2 );
+  VERIFY( entry1.path() == p/"l" );
+  VERIFY( iter == fs::directory_iterator() );
+
+  remove_all(p, ec);
+}
+
+void
+test03()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  const auto p = __gnu_test::nonexistent_path();
+  create_directories(p / "longer_than_small_string_buffer", ec);
+  VERIFY( !ec );
+
+  // Test for no reallocation on each dereference (this is a GNU extension)
+  auto iter = fs::directory_iterator(p, ec);
+  const auto* s1 = iter->path().c_str();
+  const auto* s2 = iter->path().c_str();
+  VERIFY( s1 == s2 );
+
+  remove_all(p, ec);
+}
+
+void
+test04()
+{
+  bool test __attribute__((unused)) = false;
+
+  const fs::directory_iterator it;
+  VERIFY( it == fs::directory_iterator() );
+}
+
+void
+test05()
+{
+  bool test __attribute__((unused)) = false;
+
+  auto p = __gnu_test::nonexistent_path();
+  create_directory(p);
+  create_directory_symlink(p, p / "l");
+  fs::directory_iterator it(p), endit;
+  VERIFY( begin(it) == it );
+  static_assert( noexcept(begin(it)), "begin is noexcept" );
+  VERIFY( end(it) == endit );
+  static_assert( noexcept(end(it)), "end is noexcept" );
+}
+
 int
 main()
 {
   test01();
+  test02();
+  test03();
+  test04();
+  test05();
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc	2016-05-25 15:45:30.000000000 +0000
@@ -97,8 +97,83 @@
   remove_all(p, ec);
 }
 
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  const auto p = __gnu_test::nonexistent_path();
+  create_directories(p / "d1/d2", ec);
+  VERIFY( !ec );
+
+  // Test post-increment (libstdc++/71005)
+  auto iter = fs::recursive_directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter != fs::recursive_directory_iterator() );
+  const auto entry1 = *iter;
+  const auto entry2 = *iter++;
+  VERIFY( entry1 == entry2 );
+  VERIFY( entry1.path() == p/"d1" );
+  const auto entry3 = *iter;
+  const auto entry4 = *iter++;
+  VERIFY( entry3 == entry4 );
+  VERIFY( entry3.path() == p/"d1/d2" );
+  VERIFY( iter == fs::recursive_directory_iterator() );
+
+  remove_all(p, ec);
+}
+
+void
+test03()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  const auto p = __gnu_test::nonexistent_path();
+  create_directories(p / "longer_than_small_string_buffer", ec);
+  VERIFY( !ec );
+
+  // Test for no reallocation on each dereference (this is a GNU extension)
+  auto iter = fs::recursive_directory_iterator(p, ec);
+  const auto* s1 = iter->path().c_str();
+  const auto* s2 = iter->path().c_str();
+  VERIFY( s1 == s2 );
+
+  remove_all(p, ec);
+}
+
+void
+test04()
+{
+  bool test __attribute__((unused)) = false;
+
+  // libstdc++/71004
+  const fs::recursive_directory_iterator it;
+  VERIFY( it == fs::recursive_directory_iterator() );
+}
+
+void
+test05()
+{
+  bool test __attribute__((unused)) = false;
+
+  auto p = __gnu_test::nonexistent_path();
+  create_directory(p);
+  create_directory_symlink(p, p / "l");
+  fs::recursive_directory_iterator it(p), endit;
+  VERIFY( begin(it) == it );
+  static_assert( noexcept(begin(it)), "begin is noexcept" );
+  VERIFY( end(it) == endit );
+  static_assert( noexcept(end(it)), "end is noexcept" );
+}
+
 int
 main()
 {
   test01();
+  test02();
+  test03();
+  test04();
+  test05();
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc	2016-05-25 15:44:39.000000000 +0000
@@ -59,8 +59,28 @@
   VERIFY( !ec );
 }
 
+void
+test02()
+{
+#if __cpp_exceptions
+  bool test __attribute__((unused)) = false;
+
+  fs::path p = "rel", base = __gnu_test::nonexistent_path();
+  fs::path e1, e2;
+  try {
+    canonical(p, base);
+  } catch (const fs::filesystem_error& e) {
+    e1 = e.path1();
+    e2 = e.path2();
+  }
+  VERIFY( e1 == p );
+  VERIFY( e2 == base );
+#endif
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc	2016-05-25 15:44:15.000000000 +0000
@@ -21,34 +21,127 @@
 // 15.3 Copy [fs.op.copy]
 
 #include <experimental/filesystem>
+#include <fstream>
 #include <testsuite_fs.h>
 #include <testsuite_hooks.h>
 
-using std::experimental::filesystem::path;
+namespace fs = std::experimental::filesystem;
 
+// Test error conditions.
 void
 test01()
 {
   bool test __attribute__((unused)) = false;
 
-  for (const path& p : __gnu_test::test_paths)
-    VERIFY( absolute(p).is_absolute() );
+  auto p = __gnu_test::nonexistent_path();
+  std::error_code ec;
+
+  VERIFY( !fs::exists(p) );
+  fs::copy(p, ".", fs::copy_options::none, ec);
+  VERIFY( ec );
+
+  ec.clear();
+  fs::copy(".", ".", fs::copy_options::none, ec);
+  VERIFY( ec );
+
+  std::ofstream{p.native()};
+  VERIFY( fs::is_directory(".") );
+  VERIFY( fs::is_regular_file(p) );
+  ec.clear();
+  fs::copy(".", p, fs::copy_options::none, ec);
+  VERIFY( ec );
+
+  remove(p, ec);
 }
 
+// Test is_symlink(f) case.
 void
 test02()
 {
   bool test __attribute__((unused)) = false;
 
-  path p1("/");
-  VERIFY( absolute(p1) == p1 );
-  VERIFY( absolute(p1, "/bar") == p1 );
-  path p2("/foo");
-  VERIFY( absolute(p2) == p2 );
-  VERIFY( absolute(p2, "/bar") == p2 );
-  path p3("foo");
-  VERIFY( absolute(p3) != p3 );
-  VERIFY( absolute(p3, "/bar") == "/bar/foo" );
+  auto from = __gnu_test::nonexistent_path();
+  auto to = __gnu_test::nonexistent_path();
+  std::error_code ec;
+
+  fs::create_symlink(".", from, ec);
+  VERIFY( !ec );
+  VERIFY( fs::exists(from) );
+
+  fs::copy(from, to, fs::copy_options::skip_symlinks, ec);
+  VERIFY( !ec );
+  VERIFY( !fs::exists(to) );
+
+  fs::copy(from, to, fs::copy_options::skip_symlinks, ec);
+  VERIFY( !ec );
+  VERIFY( !fs::exists(to) );
+
+  fs::copy(from, to,
+           fs::copy_options::skip_symlinks|fs::copy_options::copy_symlinks,
+           ec);
+  VERIFY( !ec );
+  VERIFY( !fs::exists(to) );
+
+  fs::copy(from, to, fs::copy_options::copy_symlinks, ec);
+  VERIFY( !ec );
+  VERIFY( fs::exists(to) );
+
+  fs::copy(from, to, fs::copy_options::copy_symlinks, ec);
+  VERIFY( ec );
+
+  remove(from, ec);
+  remove(to, ec);
+}
+
+// Test is_regular_file(f) case.
+void
+test03()
+{
+  bool test __attribute__((unused)) = false;
+
+  auto from = __gnu_test::nonexistent_path();
+  auto to = __gnu_test::nonexistent_path();
+
+  // test empty file
+  std::ofstream{from.native()};
+  VERIFY( fs::exists(from) );
+  VERIFY( fs::file_size(from) == 0 );
+  fs::copy(from, to);
+  VERIFY( fs::exists(to) );
+  VERIFY( fs::file_size(to) == 0 );
+
+  remove(to);
+  VERIFY( !fs::exists(to) );
+  std::ofstream{from.native()} << "Hello, filesystem!";
+  VERIFY( fs::file_size(from) != 0 );
+  fs::copy(from, to);
+  VERIFY( fs::exists(to) );
+  VERIFY( fs::file_size(to) == fs::file_size(from) );
+}
+
+// Test is_directory(f) case.
+void
+test04()
+{
+  bool test __attribute__((unused)) = false;
+
+  auto from = __gnu_test::nonexistent_path();
+  auto to = __gnu_test::nonexistent_path();
+  std::error_code ec;
+
+}
+
+// Test no-op cases.
+void
+test05()
+{
+  bool test __attribute__((unused)) = false;
+
+  auto to = __gnu_test::nonexistent_path();
+  std::error_code ec;
+
+  fs::copy("/", to, fs::copy_options::create_symlinks, ec);
+  VERIFY( !ec );
 }
 
 int
@@ -56,4 +149,7 @@
 {
   test01();
   test02();
+  test03();
+  test04();
+  test05();
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/copy_file.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/copy_file.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/copy_file.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/copy_file.cc	2016-05-25 15:45:03.000000000 +0000
@@ -0,0 +1,82 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// 15.4 Copy [fs.op.copy_file]
+
+#include <experimental/filesystem>
+#include <fstream>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+  using std::experimental::filesystem::copy_options;
+  std::error_code ec;
+
+  auto from = __gnu_test::nonexistent_path();
+  auto to = __gnu_test::nonexistent_path();
+
+  // test non-existent file
+  bool b = copy_file(from, to, ec);
+  VERIFY( !b );
+  VERIFY( ec );
+  VERIFY( !exists(to) );
+
+  // test empty file
+  std::ofstream{from.native()};
+  VERIFY( exists(from) );
+  VERIFY( file_size(from) == 0 );
+
+  b = copy_file(from, to);
+  VERIFY( b );
+  VERIFY( exists(to) );
+  VERIFY( file_size(to) == 0 );
+  remove(to);
+  VERIFY( !exists(to) );
+  b = copy_file(from, to, copy_options::none, ec);
+  VERIFY( b );
+  VERIFY( !ec );
+  VERIFY( exists(to) );
+  VERIFY( file_size(to) == 0 );
+
+  std::ofstream{from.native()} << "Hello, filesystem!";
+  VERIFY( file_size(from) != 0 );
+  remove(to);
+  VERIFY( !exists(to) );
+  b = copy_file(from, to);
+  VERIFY( b );
+  VERIFY( exists(to) );
+  VERIFY( file_size(to) == file_size(from) );
+  remove(to);
+  VERIFY( !exists(to) );
+  b = copy_file(from, to);
+  VERIFY( b );
+  VERIFY( !ec );
+  VERIFY( exists(to) );
+  VERIFY( file_size(to) == file_size(from) );
+}
+
+int
+main()
+{
+  test01();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc	2016-07-04 13:15:10.000000000 +0000
@@ -65,7 +65,8 @@
   VERIFY( b );
   VERIFY( is_directory(p/"./d4/../d5") );
 
-  remove_all(p, ec);
+  std::uintmax_t count = remove_all(p, ec);
+  VERIFY( count == 6 );
 }
 
 int
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc	2016-05-25 15:44:44.000000000 +0000
@@ -0,0 +1,63 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+  std::error_code ec;
+
+  // Test empty path.
+  fs::path p;
+  bool b = create_directory( p, ec );
+  VERIFY( ec );
+  VERIFY( !b );
+
+  // Test non-existent path
+  p = __gnu_test::nonexistent_path();
+  VERIFY( !exists(p) );
+
+  b = create_directory(p, ec); // create the directory once
+  VERIFY( !ec );
+  VERIFY( b );
+  VERIFY( exists(p) );
+
+  // Test existing path (libstdc++/71036).
+  b = create_directory(p, ec);
+  VERIFY( !ec );
+  VERIFY( !b );
+  b = create_directory(p);
+  VERIFY( !ec );
+  VERIFY( !b );
+
+  remove_all(p, ec);
+}
+
+int
+main()
+{
+  test01();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/permissions.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/permissions.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/operations/permissions.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/operations/permissions.cc	2016-07-19 16:34:23.000000000 +0000
@@ -0,0 +1,51 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// 15.26 Permissions [fs.op.permissions]
+
+#include <experimental/filesystem>
+#include <fstream>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+  using perms = std::experimental::filesystem::perms;
+
+  auto p = __gnu_test::nonexistent_path();
+  std::ofstream{p.native()};
+  VERIFY( exists(p) );
+  permissions(p, perms::owner_all);
+  VERIFY( status(p).permissions() == perms::owner_all );
+  permissions(p, perms::group_read | perms::add_perms);
+  VERIFY( status(p).permissions() == (perms::owner_all | perms::group_read) );
+  permissions(p, perms::group_read | perms::remove_perms);
+  VERIFY( status(p).permissions() == perms::owner_all );
+
+  remove(p);
+}
+
+int
+main()
+{
+  test01();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/path/native/string.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/path/native/string.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/filesystem/path/native/string.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/filesystem/path/native/string.cc	2016-05-26 15:25:04.000000000 +0000
@@ -0,0 +1,73 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <string>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  using namespace std::experimental::filesystem;
+  const std::string s = "abc";
+  path p(s);
+
+  VERIFY( p.native() == s );
+  VERIFY( p.c_str() == s );
+  VERIFY( static_cast<std::string>(p) == s );
+
+  std::string s2 = p; // implicit conversion
+  VERIFY( s2 == p.native() );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  using namespace std::experimental::filesystem;
+  const char* s = "abc";
+  path p(s);
+
+  auto str = p.string<char>();
+  VERIFY( str == u"abc" );
+  VERIFY( str == p.string() );
+
+  auto strw = p.string<wchar_t>();
+  VERIFY( strw == L"abc" );
+  VERIFY( strw == p.wstring() );
+
+  auto str16 = p.string<char16_t>();
+  VERIFY( str16 == u"abc" );
+  VERIFY( str16 == p.u16string() );
+
+  auto str32 = p.string<char32_t>();
+  VERIFY( str32 == U"abc" );
+  VERIFY( str32 == p.u32string() );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/functional/searchers.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/functional/searchers.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/functional/searchers.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/functional/searchers.cc	2016-07-19 22:16:31.000000000 +0000
@@ -22,6 +22,7 @@
 #ifdef _GLIBCXX_USE_WCHAR_T
 # include <cwchar>
 #endif
+#include <algorithm>
 #include <testsuite_hooks.h>
 
 using std::experimental::make_default_searcher;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/optional/cons/value.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/optional/cons/value.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/optional/cons/value.cc	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/optional/cons/value.cc	2016-07-06 13:58:32.000000000 +0000
@@ -22,6 +22,7 @@
 #include <testsuite_hooks.h>
 
 #include <vector>
+#include <string>
 
 struct tracker
 {
@@ -236,4 +237,22 @@
 
     VERIFY( result == caught );
   }
+
+  {
+    std::experimental::optional<std::string> os = "foo";
+    struct X
+    {
+      explicit X(int) {}
+      X& operator=(int) {return *this;}
+    };
+    std::experimental::optional<X> ox{42};
+    std::experimental::optional<int> oi{42};
+    std::experimental::optional<X> ox2{oi};
+    std::experimental::optional<std::string> os2;
+    os2 = "foo";
+    std::experimental::optional<X> ox3;
+    ox3 = 42;
+    std::experimental::optional<X> ox4;
+    ox4 = oi;
+  }
 }
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/experimental/optional/cons/value_neg.cc gcc-6-20160721/libstdc++-v3/testsuite/experimental/optional/cons/value_neg.cc
--- gcc-6.1.0/libstdc++-v3/testsuite/experimental/optional/cons/value_neg.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/experimental/optional/cons/value_neg.cc	2016-07-06 13:58:32.000000000 +0000
@@ -0,0 +1,39 @@
+// { dg-options "-std=gnu++14" }
+// { dg-do compile }
+
+// Copyright (C) 2013-2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a moved_to of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <experimental/optional>
+#include <testsuite_hooks.h>
+
+#include <string>
+#include <memory>
+
+int main()
+{
+  {
+    struct X
+    {
+      explicit X(int) {}
+    };
+    std::experimental::optional<X> ox{42};
+    std::experimental::optional<X> ox2 = 42; // { dg-error "conversion" }
+    std::experimental::optional<std::unique_ptr<int>> oup{new int};
+    std::experimental::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error "conversion" }
+  }
+}
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/util/testsuite_fs.h gcc-6-20160721/libstdc++-v3/testsuite/util/testsuite_fs.h
--- gcc-6.1.0/libstdc++-v3/testsuite/util/testsuite_fs.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/util/testsuite_fs.h	2016-05-26 17:18:13.000000000 +0000
@@ -83,11 +83,13 @@
     p = tmp;
 #else
     char buf[64];
+    static int counter;
 #if _GLIBCXX_USE_C99_STDIO
-    std::snprintf(buf, 64, "filesystem-ts-test.%lu", (unsigned long)::getpid());
+    std::snprintf(buf, 64,
 #else
-    std::sprintf(buf, "filesystem-ts-test.%lu", (unsigned long)::getpid());
+    std::sprintf(buf,
 #endif
+      "filesystem-ts-test.%d.%lu", counter++, (unsigned long) ::getpid());
     p = buf;
 #endif
     return p;
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libstdc++-v3/testsuite/util/testsuite_iterators.h gcc-6-20160721/libstdc++-v3/testsuite/util/testsuite_iterators.h
--- gcc-6.1.0/libstdc++-v3/testsuite/util/testsuite_iterators.h	2016-01-04 14:30:50.000000000 +0000
+++ gcc-6-20160721/libstdc++-v3/testsuite/util/testsuite_iterators.h	2016-06-17 18:53:46.000000000 +0000
@@ -542,6 +542,13 @@
     test_container(T* _first, T* _last):bounds(_first, _last)
     { }
 
+#if __cplusplus >= 201103L
+      template<std::size_t N>
+	explicit
+	test_container(T (&arr)[N]) : test_container(arr, arr+N)
+	{ }
+#endif
+
     ItType<T>
     it(int pos)
     {
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libvtv/ChangeLog gcc-6-20160721/libvtv/ChangeLog
--- gcc-6.1.0/libvtv/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/libvtv/ChangeLog	2016-05-02 18:12:21.000000000 +0000
@@ -1,3 +1,10 @@
+2016-05-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* Makefile.am (toolexeclib_LTLIBRARIES): Only set if
+	ENABLE_VTABLE_VERIFY.
+	Simplify.
+	* Makefile.in: Regenerate.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libvtv/Makefile.am gcc-6-20160721/libvtv/Makefile.am
--- gcc-6.1.0/libvtv/Makefile.am	2015-11-25 10:30:25.000000000 +0000
+++ gcc-6-20160721/libvtv/Makefile.am	2016-05-02 18:12:21.000000000 +0000
@@ -38,10 +38,11 @@
 AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)
 AM_CXXFLAGS += -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end
 
-if VTV_CYGMIN
-  toolexeclib_LTLIBRARIES = libvtv.la libvtv_stubs.la
-else
+if ENABLE_VTABLE_VERIFY
   toolexeclib_LTLIBRARIES = libvtv.la
+if VTV_CYGMIN
+  toolexeclib_LTLIBRARIES += libvtv_stubs.la
+endif
 endif
 
 vtv_headers = \
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/libvtv/Makefile.in gcc-6-20160721/libvtv/Makefile.in
--- gcc-6.1.0/libvtv/Makefile.in	2016-04-27 08:22:11.000000000 +0000
+++ gcc-6-20160721/libvtv/Makefile.in	2016-07-21 22:33:06.000000000 +0000
@@ -53,7 +53,8 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-@ENABLE_VTABLE_VERIFY_TRUE@@VTV_NO_OBSTACK_TRUE@am__append_1 = obstack.c
+@ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_TRUE@am__append_1 = libvtv_stubs.la
+@ENABLE_VTABLE_VERIFY_TRUE@@VTV_NO_OBSTACK_TRUE@am__append_2 = obstack.c
 subdir = .
 DIST_COMMON = ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/configure $(am__configure_deps) \
@@ -119,8 +120,8 @@
 libvtv_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(libvtv_la_LDFLAGS) $(LDFLAGS) -o $@
-@VTV_CYGMIN_FALSE@am_libvtv_la_rpath = -rpath $(toolexeclibdir)
-@VTV_CYGMIN_TRUE@am_libvtv_la_rpath = -rpath $(toolexeclibdir)
+@ENABLE_VTABLE_VERIFY_TRUE@am_libvtv_la_rpath = -rpath \
+@ENABLE_VTABLE_VERIFY_TRUE@	$(toolexeclibdir)
 libvtv_stubs_la_LIBADD =
 am__objects_3 = vtv_start.lo vtv_stubs.lo vtv_end.lo
 @ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_TRUE@am_libvtv_stubs_la_OBJECTS =  \
@@ -129,7 +130,9 @@
 libvtv_stubs_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(libvtv_stubs_la_LDFLAGS) $(LDFLAGS) -o $@
-@VTV_CYGMIN_TRUE@am_libvtv_stubs_la_rpath = -rpath $(toolexeclibdir)
+@ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_TRUE@am_libvtv_stubs_la_rpath =  \
+@ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_TRUE@	-rpath \
+@ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_TRUE@	$(toolexeclibdir)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/../depcomp
 am__depfiles_maybe = depfiles
@@ -323,8 +326,8 @@
 AM_CCASFLAGS = $(XCFLAGS)
 AM_CXXFLAGS = $(XCFLAGS) $(LIBSTDCXX_RAW_CXX_CXXFLAGS) \
 	-Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end
-@VTV_CYGMIN_FALSE@toolexeclib_LTLIBRARIES = libvtv.la
-@VTV_CYGMIN_TRUE@toolexeclib_LTLIBRARIES = libvtv.la libvtv_stubs.la
+@ENABLE_VTABLE_VERIFY_TRUE@toolexeclib_LTLIBRARIES = libvtv.la \
+@ENABLE_VTABLE_VERIFY_TRUE@	$(am__append_1)
 vtv_headers = \
 	vtv_map.h \
 	vtv_malloc.h \
@@ -354,7 +357,7 @@
 @VTV_CYGMIN_TRUE@libvtv_stubs_la_LDFLAGS = $(lt_host_flags)
 @ENABLE_VTABLE_VERIFY_FALSE@libvtv_la_SOURCES = 
 @ENABLE_VTABLE_VERIFY_TRUE@libvtv_la_SOURCES = $(vtv_sources) \
-@ENABLE_VTABLE_VERIFY_TRUE@	$(am__append_1)
+@ENABLE_VTABLE_VERIFY_TRUE@	$(am__append_2)
 @ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_TRUE@libvtv_stubs_la_SOURCES = $(vtv_stubs_sources)
 @ENABLE_VTABLE_VERIFY_FALSE@libvtv_include_HEADERS = 
 @ENABLE_VTABLE_VERIFY_TRUE@libvtv_include_HEADERS = $(vtv_headers)
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/maintainer-scripts/ChangeLog gcc-6-20160721/maintainer-scripts/ChangeLog
--- gcc-6.1.0/maintainer-scripts/ChangeLog	2016-04-27 08:20:21.000000000 +0000
+++ gcc-6-20160721/maintainer-scripts/ChangeLog	2016-06-13 07:57:52.000000000 +0000
@@ -1,3 +1,8 @@
+2016-06-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* generate_libstdcxx_web_docs: Use realpath to get absolute path.
+	Add comment about LaTeX errors.
+
 2016-04-27  Release Manager
 
 	* GCC 6.1.0 released.
diff -ru --unidirectional-new-file --exclude po gcc-6.1.0/maintainer-scripts/generate_libstdcxx_web_docs gcc-6-20160721/maintainer-scripts/generate_libstdcxx_web_docs
--- gcc-6.1.0/maintainer-scripts/generate_libstdcxx_web_docs	2014-10-30 10:11:38.000000000 +0000
+++ gcc-6-20160721/maintainer-scripts/generate_libstdcxx_web_docs	2016-06-13 07:57:52.000000000 +0000
@@ -3,7 +3,7 @@
 # i.e. http://gcc.gnu.org/onlinedocs/gcc-x.y.z/libstdc++*
 
 SRCDIR=${1}
-DOCSDIR=${2}
+DOCSDIR=$(realpath ${2})
 
 if ! [ $# -eq 2 -a -x "${SRCDIR}/configure" -a -d "${DOCSDIR}" ]
 then
@@ -34,6 +34,9 @@
 ${SRCDIR}/configure --enable-languages=c,c++ --disable-gcc $disabled_libs --docdir=/docs
 eval `grep '^target=' config.log`
 make configure-target
+# If the following step fails with an error like
+# ! LaTeX Error: File `xtab.sty' not found.
+# then you need to install the relevant TeX package e.g. texlive-xtab
 make -C $target/libstdc++-v3 doc-install-html doc-install-xml doc-install-pdf DESTDIR=$DESTDIR
 cd $DESTDIR/docs
 mkdir libstdc++
