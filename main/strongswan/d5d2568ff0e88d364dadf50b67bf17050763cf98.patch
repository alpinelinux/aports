From d5d2568ff0e88d364dadf50b67bf17050763cf98 Mon Sep 17 00:00:00 2001
From: Tobias Brunner <tobias@strongswan.org>
Date: Fri, 21 Feb 2025 16:45:57 +0100
Subject: [PATCH] callback-job: Replace return_false() in constructors with
 dedicated function

Besides being clearer, this fixes issues with GCC 15.  The latter uses
C23 by default, which changes the meaning of function declarations
without parameters such as

	bool return false();

Instead of "this function takes an unknown number of arguments", this
now equals (void), that is, "this function takes no arguments".  So we
run into incompatible pointer type warnings all over when using such
functions.  They could be cast to (void*) but this seems the cleaner
solution for this use case.
---
 src/charon-cmd/cmd/cmd_connection.c                   |  2 +-
 .../jni/libandroidbridge/backend/android_dns_proxy.c  |  2 +-
 .../jni/libandroidbridge/backend/android_service.c    |  6 +++---
 src/libcharon/network/receiver.c                      |  2 +-
 src/libcharon/network/sender.c                        |  2 +-
 .../plugins/bypass_lan/bypass_lan_listener.c          |  4 ++--
 .../plugins/eap_radius/eap_radius_accounting.c        |  2 +-
 src/libcharon/plugins/eap_radius/eap_radius_plugin.c  |  2 +-
 src/libcharon/plugins/ha/ha_ctl.c                     |  2 +-
 src/libcharon/plugins/ha/ha_dispatcher.c              |  2 +-
 src/libcharon/plugins/ha/ha_segments.c                |  6 +++---
 .../kernel_libipsec/kernel_libipsec_esp_handler.c     |  2 +-
 .../plugins/kernel_libipsec/kernel_libipsec_router.c  |  2 +-
 src/libcharon/plugins/smp/smp.c                       |  4 ++--
 src/libcharon/plugins/tnc_pdp/tnc_pdp_connections.c   |  2 +-
 src/libcharon/plugins/uci/uci_control.c               |  2 +-
 src/libipsec/ipsec_event_relay.c                      |  2 +-
 src/libipsec/ipsec_processor.c                        |  4 ++--
 src/libpttls/pt_tls_dispatcher.c                      |  2 +-
 src/libstrongswan/networking/streams/stream_service.c |  2 +-
 src/libstrongswan/processing/jobs/callback_job.c      | 10 +++++++++-
 src/libstrongswan/processing/jobs/callback_job.h      | 11 ++++++++++-
 src/libstrongswan/processing/scheduler.c              |  3 ++-
 src/libstrongswan/processing/watcher.c                |  4 ++--
 src/libtls/tests/suites/test_socket.c                 |  2 +-
 25 files changed, 51 insertions(+), 33 deletions(-)

diff --git a/src/charon-cmd/cmd/cmd_connection.c b/src/charon-cmd/cmd/cmd_connection.c
index 8e8d8236e52..e220e33a62a 100644
--- a/src/charon-cmd/cmd/cmd_connection.c
+++ b/src/charon-cmd/cmd/cmd_connection.c
@@ -585,7 +585,7 @@ cmd_connection_t *cmd_connection_create()
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio(
 			(callback_job_cb_t)initiate, this, NULL,
-			(callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+			callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 
 	return &this->public;
 }
diff --git a/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_dns_proxy.c b/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_dns_proxy.c
index caaa2ff058b..cc15bd40f0a 100644
--- a/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_dns_proxy.c
+++ b/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_dns_proxy.c
@@ -340,7 +340,7 @@ METHOD(android_dns_proxy_t, handle, bool,
 						  skt);
 		lib->scheduler->schedule_job(lib->scheduler,
 			(job_t*)callback_job_create(handle_timeout, skt,
-					NULL, (callback_job_cancel_t)return_false), SOCKET_TIMEOUT);
+					NULL, callback_job_cancel_thread), SOCKET_TIMEOUT);
 	}
 	skt->last_use = time_monotonic(NULL);
 	if (sendto(skt->fd, data.ptr, data.len, 0, dst->get_sockaddr(dst),
diff --git a/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_service.c b/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_service.c
index f7e6ec34bee..12d2e681bec 100644
--- a/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_service.c
+++ b/src/frontends/android/app/src/main/jni/libandroidbridge/backend/android_service.c
@@ -359,7 +359,7 @@ static bool setup_tun_device(private_android_service_t *this,
 
 		lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create((callback_job_cb_t)handle_plain, this,
-									NULL, (callback_job_cancel_t)return_false));
+									NULL, callback_job_cancel_thread));
 	}
 	return TRUE;
 }
@@ -600,7 +600,7 @@ METHOD(listener_t, alert, bool,
 				lib->processor->queue_job(lib->processor,
 					(job_t*)callback_job_create_with_prio(
 						(callback_job_cb_t)reestablish, id, free,
-						(callback_job_cancel_t)return_false, JOB_PRIO_HIGH));
+						callback_job_cancel_thread, JOB_PRIO_HIGH));
 				break;
 			}
 			case ALERT_PEER_INIT_UNREACHABLE:
@@ -619,7 +619,7 @@ METHOD(listener_t, alert, bool,
 					lib->processor->queue_job(lib->processor,
 						(job_t*)callback_job_create_with_prio(
 							(callback_job_cb_t)terminate, id, free,
-							(callback_job_cancel_t)return_false, JOB_PRIO_HIGH));
+							callback_job_cancel_thread, JOB_PRIO_HIGH));
 					stay_registered = FALSE;
 				}
 				else
diff --git a/src/libcharon/network/receiver.c b/src/libcharon/network/receiver.c
index e79d5974409..480d1d622d5 100644
--- a/src/libcharon/network/receiver.c
+++ b/src/libcharon/network/receiver.c
@@ -737,7 +737,7 @@ receiver_t *receiver_create()
 
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)receive_packets,
-			this, NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+			this, NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 
 	return &this->public;
 }
diff --git a/src/libcharon/network/sender.c b/src/libcharon/network/sender.c
index 4543766d62e..3fcd17f1b63 100644
--- a/src/libcharon/network/sender.c
+++ b/src/libcharon/network/sender.c
@@ -216,7 +216,7 @@ sender_t * sender_create()
 
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)send_packets,
-			this, NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+			this, NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 
 	return &this->public;
 }
diff --git a/src/libcharon/plugins/bypass_lan/bypass_lan_listener.c b/src/libcharon/plugins/bypass_lan/bypass_lan_listener.c
index db7abd8146b..c9aed3666fc 100644
--- a/src/libcharon/plugins/bypass_lan/bypass_lan_listener.c
+++ b/src/libcharon/plugins/bypass_lan/bypass_lan_listener.c
@@ -227,7 +227,7 @@ METHOD(kernel_listener_t, roam, bool,
 {
 	lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create((callback_job_cb_t)update_bypass, this,
-									NULL, (callback_job_cancel_t)return_false));
+									NULL, callback_job_cancel_thread));
 	return TRUE;
 }
 
@@ -269,7 +269,7 @@ METHOD(bypass_lan_listener_t, reload_interfaces, void,
 	this->mutex->unlock(this->mutex);
 	lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create((callback_job_cb_t)update_bypass, this,
-									NULL, (callback_job_cancel_t)return_false));
+									NULL, callback_job_cancel_thread));
 }
 
 METHOD(bypass_lan_listener_t, destroy, void,
diff --git a/src/libcharon/plugins/eap_radius/eap_radius_accounting.c b/src/libcharon/plugins/eap_radius/eap_radius_accounting.c
index f833dc3c0b4..2f29d080764 100644
--- a/src/libcharon/plugins/eap_radius/eap_radius_accounting.c
+++ b/src/libcharon/plugins/eap_radius/eap_radius_accounting.c
@@ -706,7 +706,7 @@ static void schedule_interim(private_eap_radius_accounting_t *this,
 			(job_t*)callback_job_create_with_prio(
 				(callback_job_cb_t)send_interim,
 				data, (void*)destroy_interim_data,
-				(callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL), tv);
+				callback_job_cancel_thread, JOB_PRIO_CRITICAL), tv);
 	}
 }
 
diff --git a/src/libcharon/plugins/eap_radius/eap_radius_plugin.c b/src/libcharon/plugins/eap_radius/eap_radius_plugin.c
index 5051542615a..55d5e032cea 100644
--- a/src/libcharon/plugins/eap_radius/eap_radius_plugin.c
+++ b/src/libcharon/plugins/eap_radius/eap_radius_plugin.c
@@ -445,7 +445,7 @@ void eap_radius_handle_timeout(ike_sa_id_t *id)
 		lib->processor->queue_job(lib->processor,
 				(job_t*)callback_job_create_with_prio(
 						(callback_job_cb_t)delete_all_async, NULL, NULL,
-						(callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+						callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 	}
 	else if (id)
 	{
diff --git a/src/libcharon/plugins/ha/ha_ctl.c b/src/libcharon/plugins/ha/ha_ctl.c
index 8859bae166b..3d2ac7de84d 100644
--- a/src/libcharon/plugins/ha/ha_ctl.c
+++ b/src/libcharon/plugins/ha/ha_ctl.c
@@ -199,6 +199,6 @@ ha_ctl_t *ha_ctl_create(ha_segments_t *segments, ha_cache_t *cache)
 
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)dispatch_fifo,
-			this, NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+			this, NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 	return &this->public;
 }
diff --git a/src/libcharon/plugins/ha/ha_dispatcher.c b/src/libcharon/plugins/ha/ha_dispatcher.c
index 5de26a65a27..83be91ab159 100644
--- a/src/libcharon/plugins/ha/ha_dispatcher.c
+++ b/src/libcharon/plugins/ha/ha_dispatcher.c
@@ -1184,7 +1184,7 @@ ha_dispatcher_t *ha_dispatcher_create(ha_socket_t *socket,
 	);
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)dispatch, this,
-				NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+				NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 
 	return &this->public;
 }
diff --git a/src/libcharon/plugins/ha/ha_segments.c b/src/libcharon/plugins/ha/ha_segments.c
index afb76b39ea2..32d9ee40717 100644
--- a/src/libcharon/plugins/ha/ha_segments.c
+++ b/src/libcharon/plugins/ha/ha_segments.c
@@ -316,7 +316,7 @@ static void start_watchdog(private_ha_segments_t *this)
 	this->heartbeat_active = TRUE;
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)watchdog, this,
-				NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+				NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 }
 
 METHOD(ha_segments_t, handle_status, void,
@@ -404,7 +404,7 @@ static void start_heartbeat(private_ha_segments_t *this)
 {
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)send_status,
-			this, NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+			this, NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 }
 
 /**
@@ -451,7 +451,7 @@ static void start_autobalance(private_ha_segments_t *this)
 	DBG1(DBG_CFG, "scheduling HA autobalance every %ds", this->autobalance);
 	lib->scheduler->schedule_job(lib->scheduler,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)autobalance,
-			this, NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL),
+			this, NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL),
 		this->autobalance);
 }
 
diff --git a/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_esp_handler.c b/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_esp_handler.c
index 095ad67b4b0..c18e266e4d1 100644
--- a/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_esp_handler.c
+++ b/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_esp_handler.c
@@ -337,7 +337,7 @@ kernel_libipsec_esp_handler_t *kernel_libipsec_esp_handler_create()
 	}
 	lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create(send_esp, this, NULL,
-										(callback_job_cancel_t)return_false));
+										callback_job_cancel_thread));
 	return &this->public;
 }
 
diff --git a/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_router.c b/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_router.c
index 74746e251de..07adc70be3e 100644
--- a/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_router.c
+++ b/src/libcharon/plugins/kernel_libipsec/kernel_libipsec_router.c
@@ -364,7 +364,7 @@ kernel_libipsec_router_t *kernel_libipsec_router_create()
 	charon->receiver->add_esp_cb(charon->receiver, receiver_esp_cb, NULL);
 	lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create((callback_job_cb_t)handle_plain, this,
-									NULL, (callback_job_cancel_t)return_false));
+										NULL, callback_job_cancel_thread));
 
 	router = &this->public;
 	return &this->public;
diff --git a/src/libcharon/plugins/smp/smp.c b/src/libcharon/plugins/smp/smp.c
index 6ca9f13997e..85ff5830bc5 100644
--- a/src/libcharon/plugins/smp/smp.c
+++ b/src/libcharon/plugins/smp/smp.c
@@ -710,7 +710,7 @@ static job_requeue_t dispatch(private_smp_t *this)
 	fdp = malloc_thing(int);
 	*fdp = fd;
 	job = callback_job_create((callback_job_cb_t)process, fdp, free,
-							  (callback_job_cancel_t)return_false);
+							  callback_job_cancel_thread);
 	lib->processor->queue_job(lib->processor, (job_t*)job);
 
 	return JOB_REQUEUE_DIRECT;
@@ -800,7 +800,7 @@ plugin_t *smp_plugin_create()
 
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create_with_prio((callback_job_cb_t)dispatch, this,
-				NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+				NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 
 	return &this->public.plugin;
 }
diff --git a/src/libcharon/plugins/tnc_pdp/tnc_pdp_connections.c b/src/libcharon/plugins/tnc_pdp/tnc_pdp_connections.c
index 30aeb116dec..da317a894d9 100644
--- a/src/libcharon/plugins/tnc_pdp/tnc_pdp_connections.c
+++ b/src/libcharon/plugins/tnc_pdp/tnc_pdp_connections.c
@@ -210,7 +210,7 @@ METHOD(tnc_pdp_connections_t, add, void,
 	/* schedule timeout checking */
 	lib->scheduler->schedule_job_ms(lib->scheduler,
 				(job_t*)callback_job_create((callback_job_cb_t)check_timeouts,
-					this, NULL, (callback_job_cancel_t)return_false),
+					this, NULL, callback_job_cancel_thread),
 				this->timeout * 1000);
 
 	dbg_nas_user(nas_id, user_name, FALSE, "created");
diff --git a/src/libcharon/plugins/uci/uci_control.c b/src/libcharon/plugins/uci/uci_control.c
index b033c832c8c..8074005ee57 100644
--- a/src/libcharon/plugins/uci/uci_control.c
+++ b/src/libcharon/plugins/uci/uci_control.c
@@ -296,7 +296,7 @@ uci_control_t *uci_control_create()
 	{
 		lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create_with_prio((callback_job_cb_t)receive,
-							this, NULL, (callback_job_cancel_t)return_false,
+							this, NULL, callback_job_cancel_thread,
 							JOB_PRIO_CRITICAL));
 	}
 	return &this->public;
diff --git a/src/libipsec/ipsec_event_relay.c b/src/libipsec/ipsec_event_relay.c
index 0f10795d168..802146eef21 100644
--- a/src/libipsec/ipsec_event_relay.c
+++ b/src/libipsec/ipsec_event_relay.c
@@ -230,7 +230,7 @@ ipsec_event_relay_t *ipsec_event_relay_create()
 
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create((callback_job_cb_t)handle_events, this,
-			NULL, (callback_job_cancel_t)return_false));
+			NULL, callback_job_cancel_thread));
 
 	return &this->public;
 }
diff --git a/src/libipsec/ipsec_processor.c b/src/libipsec/ipsec_processor.c
index 2572b088089..8549fefe261 100644
--- a/src/libipsec/ipsec_processor.c
+++ b/src/libipsec/ipsec_processor.c
@@ -336,9 +336,9 @@ ipsec_processor_t *ipsec_processor_create()
 
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create((callback_job_cb_t)process_inbound, this,
-									NULL, (callback_job_cancel_t)return_false));
+									NULL, callback_job_cancel_thread));
 	lib->processor->queue_job(lib->processor,
 		(job_t*)callback_job_create((callback_job_cb_t)process_outbound, this,
-									NULL, (callback_job_cancel_t)return_false));
+									NULL, callback_job_cancel_thread));
 	return &this->public;
 }
diff --git a/src/libpttls/pt_tls_dispatcher.c b/src/libpttls/pt_tls_dispatcher.c
index a134bee238f..c7e42b277e1 100644
--- a/src/libpttls/pt_tls_dispatcher.c
+++ b/src/libpttls/pt_tls_dispatcher.c
@@ -156,7 +156,7 @@ METHOD(pt_tls_dispatcher_t, dispatch, void,
 		lib->processor->queue_job(lib->processor,
 				(job_t*)callback_job_create_with_prio((callback_job_cb_t)handle,
 										connection, (void*)cleanup,
-										(callback_job_cancel_t)return_false,
+										callback_job_cancel_thread,
 										JOB_PRIO_CRITICAL));
 	}
 }
diff --git a/src/libstrongswan/networking/streams/stream_service.c b/src/libstrongswan/networking/streams/stream_service.c
index 5b709a2247d..c85a0664351 100644
--- a/src/libstrongswan/networking/streams/stream_service.c
+++ b/src/libstrongswan/networking/streams/stream_service.c
@@ -221,7 +221,7 @@ static bool watch(private_stream_service_t *this, int fd, watcher_event_t event)
 
 		lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create_with_prio((void*)accept_async, data,
-				(void*)destroy_async_data, (callback_job_cancel_t)return_false,
+				(void*)destroy_async_data, callback_job_cancel_thread,
 				this->prio));
 	}
 	else
diff --git a/src/libstrongswan/processing/jobs/callback_job.c b/src/libstrongswan/processing/jobs/callback_job.c
index cb2a0aba5b9..3ab40b947c9 100644
--- a/src/libstrongswan/processing/jobs/callback_job.c
+++ b/src/libstrongswan/processing/jobs/callback_job.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2012 Tobias Brunner
+ * Copyright (C) 2009-2025 Tobias Brunner
  * Copyright (C) 2007-2011 Martin Willi
  *
  * Copyright (C) secunet Security Networks AG
@@ -131,3 +131,11 @@ callback_job_t *callback_job_create(callback_job_cb_t cb, void *data,
 	return callback_job_create_with_prio(cb, data, cleanup, cancel,
 										 JOB_PRIO_MEDIUM);
 }
+
+/*
+ * Described in header
+ */
+bool callback_job_cancel_thread(void *data)
+{
+	return FALSE;
+}
diff --git a/src/libstrongswan/processing/jobs/callback_job.h b/src/libstrongswan/processing/jobs/callback_job.h
index 0f1ae212d87..fda86887944 100644
--- a/src/libstrongswan/processing/jobs/callback_job.h
+++ b/src/libstrongswan/processing/jobs/callback_job.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Tobias Brunner
+ * Copyright (C) 2012-2025 Tobias Brunner
  * Copyright (C) 2007-2011 Martin Willi
  *
  * Copyright (C) secunet Security Networks AG
@@ -62,6 +62,15 @@ typedef void (*callback_job_cleanup_t)(void *data);
  */
 typedef bool (*callback_job_cancel_t)(void *data);
 
+/**
+ * Default implementation of callback_job_cancel_t that simply returns FALSE
+ * to force cancellation of the thread by the processor.
+ *
+ * @param data			ignored argument
+ * @return				always returns FALSE
+ */
+bool callback_job_cancel_thread(void *data);
+
 /**
  * Class representing an callback Job.
  *
diff --git a/src/libstrongswan/processing/scheduler.c b/src/libstrongswan/processing/scheduler.c
index c5e5dd83e70..76d98ddff51 100644
--- a/src/libstrongswan/processing/scheduler.c
+++ b/src/libstrongswan/processing/scheduler.c
@@ -329,7 +329,8 @@ scheduler_t * scheduler_create()
 	this->heap = (event_t**)calloc(this->heap_size + 1, sizeof(event_t*));
 
 	job = callback_job_create_with_prio((callback_job_cb_t)schedule, this,
-										NULL, return_false, JOB_PRIO_CRITICAL);
+										NULL, callback_job_cancel_thread,
+										JOB_PRIO_CRITICAL);
 	lib->processor->queue_job(lib->processor, (job_t*)job);
 
 	return &this->public;
diff --git a/src/libstrongswan/processing/watcher.c b/src/libstrongswan/processing/watcher.c
index 1200d670959..a86ec0910d1 100644
--- a/src/libstrongswan/processing/watcher.c
+++ b/src/libstrongswan/processing/watcher.c
@@ -291,7 +291,7 @@ static void notify(private_watcher_t *this, entry_t *entry,
 
 	this->jobs->insert_last(this->jobs,
 					callback_job_create_with_prio((void*)notify_async, data,
-						(void*)notify_end, (callback_job_cancel_t)return_false,
+						(void*)notify_end, callback_job_cancel_thread,
 						JOB_PRIO_CRITICAL));
 }
 
@@ -559,7 +559,7 @@ METHOD(watcher_t, add, void,
 
 		lib->processor->queue_job(lib->processor,
 			(job_t*)callback_job_create_with_prio((void*)watch, this,
-				NULL, (callback_job_cancel_t)return_false, JOB_PRIO_CRITICAL));
+				NULL, callback_job_cancel_thread, JOB_PRIO_CRITICAL));
 	}
 	else
 	{
diff --git a/src/libtls/tests/suites/test_socket.c b/src/libtls/tests/suites/test_socket.c
index 91ee58b975f..c17d0a8873e 100644
--- a/src/libtls/tests/suites/test_socket.c
+++ b/src/libtls/tests/suites/test_socket.c
@@ -587,7 +587,7 @@ static void start_echo_server(echo_server_config_t *config)
 
 	lib->processor->queue_job(lib->processor, (job_t*)
 				callback_job_create((void*)serve_echo, config, NULL,
-									(callback_job_cancel_t)return_false));
+									callback_job_cancel_thread));
 }
 
 /**
