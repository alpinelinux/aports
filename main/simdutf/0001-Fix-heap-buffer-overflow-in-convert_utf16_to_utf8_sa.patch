From c2e7abec7588acfd6b64db3c6a7d2a44afb99fac Mon Sep 17 00:00:00 2001
From: Ze Sheng <108382772+OwenSanzas@users.noreply.github.com>
Date: Mon, 12 Jan 2026 14:37:13 -0600
Subject: [PATCH] Fix heap-buffer-overflow in convert_utf16_to_utf8_safe (#912)

Move bounds check BEFORE write for 1-byte ASCII cases to prevent
heap-buffer-overflow when output buffer is exactly full.

The bug was in two locations where the code writes to the output buffer
before checking if there is sufficient space (write-before-check pattern).
This is inconsistent with the 2-byte, 3-byte, and 4-byte cases which
correctly check before writing.

Fixes: https://github.com/simdutf/simdutf/issues/911

Rebased on top of v7.7.1
Co-authored-by: LN Liberda <lauren@selfisekai.rocks>
---
 src/scalar/utf16_to_utf8/utf16_to_utf8.h | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/scalar/utf16_to_utf8/utf16_to_utf8.h b/src/scalar/utf16_to_utf8/utf16_to_utf8.h
index 3132c097..0d3415e2 100644
--- a/src/scalar/utf16_to_utf8/utf16_to_utf8.h
+++ b/src/scalar/utf16_to_utf8/utf16_to_utf8.h
@@ -102,14 +102,14 @@ inline full_result convert_with_errors(const char16_t *buf, size_t len,
       if ((v & 0xFF80FF80FF80FF80) == 0) {
         size_t final_pos = pos + 4;
         while (pos < final_pos) {
+          if (check_output && size_t(end - utf8_output) < 1) {
+            return full_result(error_code::OUTPUT_BUFFER_TOO_SMALL, pos,
+                               utf8_output - start);
+          }
           *utf8_output++ = !match_system(big_endian)
                                ? char(u16_swap_bytes(buf[pos]))
                                : char(buf[pos]);
           pos++;
-          if (check_output && size_t(end - utf8_output) == 0) {
-            return full_result(error_code::OUTPUT_BUFFER_TOO_SMALL, pos,
-                               utf8_output - start);
-          }
         }
         continue;
       }
@@ -118,12 +118,12 @@ inline full_result convert_with_errors(const char16_t *buf, size_t len,
         !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
     if ((word & 0xFF80) == 0) {
       // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-      if (check_output && size_t(end - utf8_output) == 0) {
+      if (check_output && size_t(end - utf8_output) < 1) {
         return full_result(error_code::OUTPUT_BUFFER_TOO_SMALL, pos,
                            utf8_output - start);
       }
+      *utf8_output++ = char(word);
+      pos++;
     } else if ((word & 0xF800) == 0) {
       // will generate two UTF-8 bytes
       // we have 0b110XXXXX 0b10XXXXXX
