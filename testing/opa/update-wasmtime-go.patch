diff --git a/go.mod b/go.mod
index ff1513a1d..843bdc577 100644
--- a/go.mod
+++ b/go.mod
@@ -8,7 +8,7 @@ require (
 	github.com/OneOfOne/xxhash v1.2.8
 	github.com/agnivade/levenshtein v1.2.0
 	github.com/andreyvit/diff v0.0.0-20170406064948-c7f18ee00883
-	github.com/bytecodealliance/wasmtime-go/v3 v3.0.2
+	github.com/bytecodealliance/wasmtime-go/v28 v28.0.0
 	github.com/containerd/containerd v1.7.24
 	github.com/containerd/errdefs v1.0.0
 	github.com/dgraph-io/badger/v3 v3.2103.5
diff --git a/go.sum b/go.sum
index 859cba306..ece1113cd 100644
--- a/go.sum
+++ b/go.sum
@@ -18,8 +18,8 @@ github.com/arbovm/levenshtein v0.0.0-20160628152529-48b4e1c0c4d0/go.mod h1:t2tdK
 github.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=
 github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=
 github.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=
-github.com/bytecodealliance/wasmtime-go/v3 v3.0.2 h1:3uZCA/BLTIu+DqCfguByNMJa2HVHpXvjfy0Dy7g6fuA=
-github.com/bytecodealliance/wasmtime-go/v3 v3.0.2/go.mod h1:RnUjnIXxEJcL6BgCvNyzCCRzZcxCgsZCi+RNlvYor5Q=
+github.com/bytecodealliance/wasmtime-go/v28 v28.0.0 h1:aBU8cexP2rPZ0Qz488kvn2NXvWZHL2aG1/+n7Iv+xGc=
+github.com/bytecodealliance/wasmtime-go/v28 v28.0.0/go.mod h1:4OCU0xAW9ycwtX4nMF4zxwgJBJ5/0eMfJiHB0wAmkV4=
 github.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=
 github.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
 github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
diff --git a/internal/wasm/sdk/internal/wasm/bindings.go b/internal/wasm/sdk/internal/wasm/bindings.go
index 33ee7e451..867e4c173 100644
--- a/internal/wasm/sdk/internal/wasm/bindings.go
+++ b/internal/wasm/sdk/internal/wasm/bindings.go
@@ -16,7 +16,7 @@ import (
 	"strconv"
 	"time"
 
-	wasmtime "github.com/bytecodealliance/wasmtime-go/v3"
+	wasmtime "github.com/bytecodealliance/wasmtime-go/v28"
 
 	"github.com/open-policy-agent/opa/v1/ast"
 	"github.com/open-policy-agent/opa/v1/metrics"
diff --git a/internal/wasm/sdk/internal/wasm/pool.go b/internal/wasm/sdk/internal/wasm/pool.go
index 0bb38b423..f16df12e3 100644
--- a/internal/wasm/sdk/internal/wasm/pool.go
+++ b/internal/wasm/sdk/internal/wasm/pool.go
@@ -9,7 +9,7 @@ import (
 	"context"
 	"sync"
 
-	wasmtime "github.com/bytecodealliance/wasmtime-go/v3"
+	wasmtime "github.com/bytecodealliance/wasmtime-go/v28"
 
 	"github.com/open-policy-agent/opa/internal/wasm/sdk/opa/errors"
 	"github.com/open-policy-agent/opa/internal/wasm/util"
diff --git a/internal/wasm/sdk/internal/wasm/vm.go b/internal/wasm/sdk/internal/wasm/vm.go
index e5f589623..b097a3f9c 100644
--- a/internal/wasm/sdk/internal/wasm/vm.go
+++ b/internal/wasm/sdk/internal/wasm/vm.go
@@ -14,7 +14,7 @@ import (
 	"strings"
 	"time"
 
-	wasmtime "github.com/bytecodealliance/wasmtime-go/v3"
+	wasmtime "github.com/bytecodealliance/wasmtime-go/v28"
 
 	sdk_errors "github.com/open-policy-agent/opa/internal/wasm/sdk/opa/errors"
 	"github.com/open-policy-agent/opa/internal/wasm/util"
@@ -79,7 +79,7 @@ func newVM(opts vmOpts, engine *wasmtime.Engine) (*VM, error) {
 	v := &VM{engine: engine}
 	store := wasmtime.NewStore(engine)
 	store.SetEpochDeadline(1)
-	memorytype := wasmtime.NewMemoryType(opts.memoryMin, true, opts.memoryMax)
+	memorytype := wasmtime.NewMemoryType(opts.memoryMin, true, opts.memoryMax, false)
 	memory, err := wasmtime.NewMemory(store, memorytype)
 	if err != nil {
 		return nil, err
@@ -94,11 +94,11 @@ func newVM(opts vmOpts, engine *wasmtime.Engine) (*VM, error) {
 	v.dispatcher = newBuiltinDispatcher()
 	externs := opaFunctions(v.dispatcher, store)
 	for name, extern := range externs {
-		if err := linker.Define("env", name, extern); err != nil {
+		if err := linker.Define(store, "env", name, extern); err != nil {
 			return nil, fmt.Errorf("linker: env.%s: %w", name, err)
 		}
 	}
-	if err := linker.Define("env", "memory", memory); err != nil {
+	if err := linker.Define(store, "env", "memory", memory); err != nil {
 		return nil, fmt.Errorf("linker: env.memory: %w", err)
 	}
 
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/BUILD.bazel b/vendor/github.com/bytecodealliance/wasmtime-go/v28/BUILD.bazel
similarity index 92%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/BUILD.bazel
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/BUILD.bazel
index 58a2c5019..e8383628b 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/BUILD.bazel
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/BUILD.bazel
@@ -6,6 +6,7 @@ cc_library(
         "@io_bazel_rules_go//go/platform:darwin_amd64": ["build/macos-x86_64/libwasmtime.a"],
         "@io_bazel_rules_go//go/platform:linux_amd64": ["build/linux-x86_64/libwasmtime.a"],
         "@io_bazel_rules_go//go/platform:windows_amd64": ["build/windows-x86_64/libwasmtime.a"],
+        "@io_bazel_rules_go//go/platform:darwin_arm64": ["build/macos-aarch64/libwasmtime.a"],
     }),
     hdrs = glob(["build/include/**/*.h"]),
     includes = ["build/include"],
@@ -62,7 +63,7 @@ go_library(
         ],
         "//conditions:default": [],
     }),
-    importpath = "github.com/bytecodealliance/wasmtime-go/v3",
+    importpath = "github.com/bytecodealliance/wasmtime-go/v28",
     visibility = ["//visibility:public"],
 )
 
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/LICENSE b/vendor/github.com/bytecodealliance/wasmtime-go/v28/LICENSE
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/LICENSE
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/LICENSE
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/README.md b/vendor/github.com/bytecodealliance/wasmtime-go/v28/README.md
similarity index 84%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/README.md
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/README.md
index 38fe65713..3f3d994d6 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/README.md
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/README.md
@@ -12,8 +12,8 @@
     <a href="https://github.com/bytecodealliance/wasmtime-go/actions?query=workflow%3ACI">
       <img src="https://github.com/bytecodealliance/wasmtime-go/workflows/CI/badge.svg" alt="CI status"/>
     </a>
-    <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go/v3">
-      <img src="https://godoc.org/github.com/bytecodealliance/wasmtime-go/v3?status.svg" alt="Documentation"/>
+    <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go/v28">
+      <img src="https://godoc.org/github.com/bytecodealliance/wasmtime-go/v28?status.svg" alt="Documentation"/>
     </a>
     <a href="https://bytecodealliance.github.io/wasmtime-go/coverage.html">
       <img src="https://img.shields.io/badge/coverage-main-green" alt="Code Coverage"/>
@@ -25,7 +25,7 @@
 ## Installation
 
 ```sh
-go get -u github.com/bytecodealliance/wasmtime-go/v3@v3.0.2
+go get -u github.com/bytecodealliance/wasmtime-go/v28@v28.0.0
 ```
 
 Be sure to check out the [API documentation][api]!
@@ -39,7 +39,7 @@ need to arrange to build Wasmtime and use `CGO_*` env vars to compile correctly.
 
 This project has been tested with Go 1.13 or later.
 
-[api]: https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go/v3
+[api]: https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go/v28
 [wasmtime]: https://github.com/bytecodealliance/wasmtime
 
 If you are a bazel user, add following to your WORKSPACE file:
@@ -47,8 +47,8 @@ If you are a bazel user, add following to your WORKSPACE file:
 ```
 go_repository(
     name = "com_github_bytecodealliance_wasmtime_go",
-    importpath = "github.com/bytecodealliance/wasmtime-go/v3",
-    version = "v3.0.2",
+    importpath = "github.com/bytecodealliance/wasmtime-go/v28",
+    version = "v28.0.0",
 )
 ```
 
@@ -61,7 +61,7 @@ package main
 
 import (
     "fmt"
-    "github.com/bytecodealliance/wasmtime-go/v3"
+    "github.com/bytecodealliance/wasmtime-go/v28"
 )
 
 func main() {
@@ -151,3 +151,36 @@ $ go test
 ```
 
 And after that you should be good to go!
+
+### Release Checklist
+
+First run:
+
+```
+$ python3 ci/download-wasmtime.py
+$ go test
+```
+
+Make sure everything passes at the current version.
+
+Next run:
+
+```
+$ git ls-files | xargs sed -i 's/v16/v17/g'
+$ python3 ci/download-wasmtime.py
+$ go test
+```
+
+Fix all errors and such and then commit and make a PR.
+
+Once merged checkout `main` and do:
+
+```
+$ rm .gitignore
+$ python3 ci/download-wasmtime.py
+$ git add .
+$ git commit -m 'v28.0.0 release artifacts'
+$ git tag v28.0.0
+```
+
+and push up the tag
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/WORKSPACE b/vendor/github.com/bytecodealliance/wasmtime-go/v28/WORKSPACE
similarity index 90%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/WORKSPACE
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/WORKSPACE
index 361778a49..6aff04531 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/WORKSPACE
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/WORKSPACE
@@ -2,10 +2,10 @@ load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
 
 http_archive(
     name = "io_bazel_rules_go",
-    sha256 = "685052b498b6ddfe562ca7a97736741d87916fe536623afb7da2824c0211c369",
+    sha256 = "91585017debb61982f7054c9688857a2ad1fd823fc3f9cb05048b0025c47d023",
     urls = [
-        "https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.33.0/rules_go-v0.33.0.zip",
-        "https://github.com/bazelbuild/rules_go/releases/download/v0.33.0/rules_go-v0.33.0.zip",
+        "https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.42.0/rules_go-v0.42.0.zip",
+        "https://github.com/bazelbuild/rules_go/releases/download/v0.42.0/rules_go-v0.42.0.zip",
     ],
 )
 
@@ -63,6 +63,6 @@ go_repository(
 
 go_rules_dependencies()
 
-go_register_toolchains(version = "1.16")
+go_register_toolchains(version = "1.21.1")
 
 gazelle_dependencies()
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/doc-wasm.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/doc-wasm.h
similarity index 99%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/doc-wasm.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/doc-wasm.h
index 6bad15c74..45afbecf9 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/doc-wasm.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/doc-wasm.h
@@ -1,3 +1,5 @@
+/* clang-format off */
+
 /**
  * \file wasm.h
  *
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasi.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasi.h
new file mode 100644
index 000000000..b45ffd778
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasi.h
@@ -0,0 +1,246 @@
+/**
+ * \file wasi.h
+ *
+ * C API for WASI
+ */
+
+#ifndef WASI_H
+#define WASI_H
+
+#include "wasm.h"
+#include <stdint.h>
+#include <wasmtime/conf.h>
+
+#ifdef WASMTIME_FEATURE_WASI
+
+#ifndef WASI_API_EXTERN
+#ifdef _WIN32
+#define WASI_API_EXTERN __declspec(dllimport)
+#else
+#define WASI_API_EXTERN
+#endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define own
+
+#define WASI_DECLARE_OWN(name)                                                 \
+  typedef struct wasi_##name##_t wasi_##name##_t;                              \
+  WASI_API_EXTERN void wasi_##name##_delete(own wasi_##name##_t *);
+
+/**
+ * \typedef wasi_config_t
+ * \brief Convenience alias for #wasi_config_t
+ *
+ * \struct wasi_config_t
+ * \brief TODO
+ *
+ * \fn void wasi_config_delete(wasi_config_t *);
+ * \brief Deletes a configuration object.
+ */
+WASI_DECLARE_OWN(config)
+
+/**
+ * \brief Creates a new empty configuration object.
+ *
+ * The caller is expected to deallocate the returned configuration
+ */
+WASI_API_EXTERN own wasi_config_t *wasi_config_new();
+
+/**
+ * \brief Sets the argv list for this configuration object.
+ *
+ * By default WASI programs have an empty argv list, but this can be used to
+ * explicitly specify what the argv list for the program is.
+ *
+ * The arguments are copied into the `config` object as part of this function
+ * call, so the `argv` pointer only needs to stay alive for this function call.
+ *
+ * This function returns `true` if all arguments were registered successfully,
+ * or `false` if an argument was not valid UTF-8.
+ */
+WASI_API_EXTERN bool wasi_config_set_argv(wasi_config_t *config, size_t argc,
+                                          const char *argv[]);
+
+/**
+ * \brief Indicates that the argv list should be inherited from this process's
+ * argv list.
+ */
+WASI_API_EXTERN void wasi_config_inherit_argv(wasi_config_t *config);
+
+/**
+ * \brief Sets the list of environment variables available to the WASI instance.
+ *
+ * By default WASI programs have a blank environment, but this can be used to
+ * define some environment variables for them.
+ *
+ * It is required that the `names` and `values` lists both have `envc` entries.
+ *
+ * The env vars are copied into the `config` object as part of this function
+ * call, so the `names` and `values` pointers only need to stay alive for this
+ * function call.
+ *
+ * This function returns `true` if all environment variables were successfully
+ * registered. This returns `false` if environment variables are not valid
+ * UTF-8.
+ */
+WASI_API_EXTERN bool wasi_config_set_env(wasi_config_t *config, size_t envc,
+                                         const char *names[],
+                                         const char *values[]);
+
+/**
+ * \brief Indicates that the entire environment of the calling process should be
+ * inherited by this WASI configuration.
+ */
+WASI_API_EXTERN void wasi_config_inherit_env(wasi_config_t *config);
+
+/**
+ * \brief Configures standard input to be taken from the specified file.
+ *
+ * By default WASI programs have no stdin, but this configures the specified
+ * file to be used as stdin for this configuration.
+ *
+ * If the stdin location does not exist or it cannot be opened for reading then
+ * `false` is returned. Otherwise `true` is returned.
+ */
+WASI_API_EXTERN bool wasi_config_set_stdin_file(wasi_config_t *config,
+                                                const char *path);
+
+/**
+ * \brief Configures standard input to be taken from the specified
+ * #wasm_byte_vec_t.
+ *
+ * By default WASI programs have no stdin, but this configures the specified
+ * bytes to be used as stdin for this configuration.
+ *
+ * This function takes ownership of the `binary` argument.
+ */
+WASI_API_EXTERN void wasi_config_set_stdin_bytes(wasi_config_t *config,
+                                                 wasm_byte_vec_t *binary);
+
+/**
+ * \brief Configures this process's own stdin stream to be used as stdin for
+ * this WASI configuration.
+ */
+WASI_API_EXTERN void wasi_config_inherit_stdin(wasi_config_t *config);
+
+/**
+ * \brief Configures standard output to be written to the specified file.
+ *
+ * By default WASI programs have no stdout, but this configures the specified
+ * file to be used as stdout.
+ *
+ * If the stdout location could not be opened for writing then `false` is
+ * returned. Otherwise `true` is returned.
+ */
+WASI_API_EXTERN bool wasi_config_set_stdout_file(wasi_config_t *config,
+                                                 const char *path);
+
+/**
+ * \brief Configures this process's own stdout stream to be used as stdout for
+ * this WASI configuration.
+ */
+WASI_API_EXTERN void wasi_config_inherit_stdout(wasi_config_t *config);
+
+/**
+ * \brief Configures standard output to be written to the specified file.
+ *
+ * By default WASI programs have no stderr, but this configures the specified
+ * file to be used as stderr.
+ *
+ * If the stderr location could not be opened for writing then `false` is
+ * returned. Otherwise `true` is returned.
+ */
+WASI_API_EXTERN bool wasi_config_set_stderr_file(wasi_config_t *config,
+                                                 const char *path);
+
+/**
+ * \brief Configures this process's own stderr stream to be used as stderr for
+ * this WASI configuration.
+ */
+WASI_API_EXTERN void wasi_config_inherit_stderr(wasi_config_t *config);
+
+/**
+ * \brief The permissions granted for a directory when preopening it.
+ */
+enum wasi_dir_perms_flags {
+  /**
+   * \brief This directory can be read, for example its entries can be iterated
+   */
+  WASMTIME_WASI_DIR_PERMS_READ = 1,
+
+  /**
+   * \brief This directory can be written to, for example new files can be
+   * created within it.
+   */
+  WASMTIME_WASI_DIR_PERMS_WRITE = 2,
+};
+
+/**
+ * \brief The permissions granted for directories when preopening them,
+ * which is a bitmask with flag values from wasi_dir_perms_flags.
+ */
+typedef size_t wasi_dir_perms;
+
+/**
+ * \brief The permissions granted for files when preopening a directory.
+ */
+enum wasi_file_perms_flags {
+  /**
+   * \brief Files can be read.
+   */
+  WASMTIME_WASI_FILE_PERMS_READ = 1,
+
+  /**
+   * \brief Files can be written to.
+   */
+  WASMTIME_WASI_FILE_PERMS_WRITE = 2,
+};
+
+/**
+ * \brief The max permissions granted a file within a preopened directory,
+ * which is a bitmask with flag values from wasi_file_perms_flags.
+ */
+typedef size_t wasi_file_perms;
+
+/**
+ * \brief Configures a "preopened directory" to be available to WASI APIs.
+ *
+ * By default WASI programs do not have access to anything on the filesystem.
+ * This API can be used to grant WASI programs access to a directory on the
+ * filesystem, but only that directory (its whole contents but nothing above
+ * it).
+ *
+ * The `host_path` argument here is a path name on the host filesystem, and
+ * `guest_path` is the name by which it will be known in wasm.
+ *
+ * The `dir_perms` argument is the permissions that wasm will have to operate on
+ * `guest_path`. This can be used, for example, to provide readonly access to a
+ * directory. This argument is a bitmask with the following flag values:
+ * - WASMTIME_WASI_DIR_PERMS_READ
+ * - WASMTIME_WASI_DIR_PERMS_WRITE
+ *
+ * The `file_perms` argument is similar to `dir_perms` but corresponds to the
+ * maximum set of permissions that can be used for any file in this directory.
+ * This argument is a bitmask with the following flag values:
+ * - WASMTIME_WASI_FILE_PERMS_READ
+ * - WASMTIME_WASI_FILE_PERMS_WRITE
+ */
+WASI_API_EXTERN bool wasi_config_preopen_dir(wasi_config_t *config,
+                                             const char *host_path,
+                                             const char *guest_path,
+                                             wasi_dir_perms dir_perms,
+                                             wasi_file_perms file_perms);
+
+#undef own
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_FEATURE_WASI
+
+#endif // #ifdef WASI_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasm.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasm.h
similarity index 96%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasm.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasm.h
index 325e618b6..c8b3cb7d3 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasm.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasm.h
@@ -1,3 +1,9 @@
+// Wasmtime-vendored copy of this header file as present in upstream:
+// <https://github.com/WebAssembly/wasm-c-api/blob/2ce1367c9d1271c83fb63bef26d896a2f290cd23/include/wasm.h>
+//
+// Wasmtime maintainers can update this vendored copy in-tree with the
+// ./ci/vendor-c-api-headers.sh shell script.
+//
 // WebAssembly C API
 
 #ifndef WASM_H
@@ -10,7 +16,7 @@
 #include <assert.h>
 
 #ifndef WASM_API_EXTERN
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__) && !defined(LIBWASM_STATIC)
 #define WASM_API_EXTERN __declspec(dllimport)
 #else
 #define WASM_API_EXTERN
@@ -182,7 +188,7 @@ enum wasm_valkind_enum {
   WASM_I64,
   WASM_F32,
   WASM_F64,
-  WASM_ANYREF = 128,
+  WASM_EXTERNREF = 128,
   WASM_FUNCREF,
 };
 
@@ -191,10 +197,10 @@ WASM_API_EXTERN own wasm_valtype_t* wasm_valtype_new(wasm_valkind_t);
 WASM_API_EXTERN wasm_valkind_t wasm_valtype_kind(const wasm_valtype_t*);
 
 static inline bool wasm_valkind_is_num(wasm_valkind_t k) {
-  return k < WASM_ANYREF;
+  return k < WASM_EXTERNREF;
 }
 static inline bool wasm_valkind_is_ref(wasm_valkind_t k) {
-  return k >= WASM_ANYREF;
+  return k >= WASM_EXTERNREF;
 }
 
 static inline bool wasm_valtype_is_num(const wasm_valtype_t* t) {
@@ -547,8 +553,8 @@ static inline own wasm_valtype_t* wasm_valtype_new_f64(void) {
   return wasm_valtype_new(WASM_F64);
 }
 
-static inline own wasm_valtype_t* wasm_valtype_new_anyref(void) {
-  return wasm_valtype_new(WASM_ANYREF);
+static inline own wasm_valtype_t* wasm_valtype_new_externref(void) {
+  return wasm_valtype_new(WASM_EXTERNREF);
 }
 static inline own wasm_valtype_t* wasm_valtype_new_funcref(void) {
   return wasm_valtype_new(WASM_FUNCREF);
@@ -708,8 +714,8 @@ static inline void* wasm_val_ptr(const wasm_val_t* val) {
 #define WASM_I64_VAL(i) {.kind = WASM_I64, .of = {.i64 = i}}
 #define WASM_F32_VAL(z) {.kind = WASM_F32, .of = {.f32 = z}}
 #define WASM_F64_VAL(z) {.kind = WASM_F64, .of = {.f64 = z}}
-#define WASM_REF_VAL(r) {.kind = WASM_ANYREF, .of = {.ref = r}}
-#define WASM_INIT_VAL {.kind = WASM_ANYREF, .of = {.ref = NULL}}
+#define WASM_REF_VAL(r) {.kind = WASM_EXTERNREF, .of = {.ref = r}}
+#define WASM_INIT_VAL {.kind = WASM_EXTERNREF, .of = {.ref = NULL}}
 
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasm.hh b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasm.hh
new file mode 100644
index 000000000..e03408241
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasm.hh
@@ -0,0 +1,849 @@
+// Wasmtime-vendored copy of this header file as present in upstream:
+// <https://github.com/WebAssembly/wasm-c-api/blob/2ce1367c9d1271c83fb63bef26d896a2f290cd23/include/wasm.hh>
+//
+// Wasmtime maintainers can update this vendored copy in-tree with the
+// ./ci/vendor-c-api-headers.sh shell script.
+//
+// WebAssembly C++ API
+
+#ifndef WASM_HH
+#define WASM_HH
+
+#include <cassert>
+#include <cstddef>
+#include <cstdint>
+#include <cstring>
+#include <memory>
+#include <limits>
+#include <string>
+
+#ifndef WASM_API_EXTERN
+#if defined(_WIN32) && !defined(__MINGW32__) && !defined(LIBWASM_STATIC)
+#define WASM_API_EXTERN __declspec(dllimport)
+#else
+#define WASM_API_EXTERN
+#endif
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Auxiliaries
+
+// Machine types
+
+static_assert(sizeof(float) == sizeof(int32_t), "incompatible float type");
+static_assert(sizeof(double) == sizeof(int64_t), "incompatible double type");
+static_assert(sizeof(intptr_t) == sizeof(int32_t) ||
+              sizeof(intptr_t) == sizeof(int64_t), "incompatible pointer type");
+
+using byte_t = char;
+using float32_t = float;
+using float64_t = double;
+
+
+namespace wasm {
+
+// Vectors
+
+template<class T>
+class vec {
+  static const size_t invalid_size = SIZE_MAX;
+
+  size_t size_;
+  std::unique_ptr<T[]> data_;
+
+#ifdef WASM_API_DEBUG
+  WASM_API_EXTERN void make_data();
+  WASM_API_EXTERN void free_data();
+#else
+  void make_data() {}
+  void free_data() {}
+#endif
+
+  vec(size_t size) : vec(size, size ? new(std::nothrow) T[size] : nullptr) {
+    make_data();
+  }
+
+  vec(size_t size, T* data) : size_(size), data_(data) {
+    assert(!!size_ == !!data_ || size_ == invalid_size);
+  }
+
+public:
+  using elem_type = T;
+
+  vec(vec<T>&& that) : vec(that.size_, that.data_.release()) {
+    that.size_ = invalid_size;
+  }
+
+  ~vec() {
+    free_data();
+  }
+
+  operator bool() const {
+    return bool(size_ != invalid_size);
+  }
+
+  auto size() const -> size_t {
+    return size_;
+  }
+
+  auto get() const -> const T* {
+    return data_.get();
+  }
+
+  auto get() -> T* {
+    return data_.get();
+  }
+
+  auto release() -> T* {
+    size_ = invalid_size;
+    return data_.release();
+  }
+
+  void reset() {
+    free_data();
+    size_ = invalid_size;
+    data_.reset();
+  }
+
+  void reset(vec& that) {
+    free_data();
+    size_ = that.size_;
+    data_.reset(that.data_.release());
+    that.size_ = invalid_size;
+  }
+
+  auto operator=(vec&& that) -> vec& {
+    reset(that);
+    return *this;
+  }
+
+  auto operator[](size_t i) -> T& {
+    assert(i < size_);
+    return data_[i];
+  }
+
+  auto operator[](size_t i) const -> const T& {
+    assert(i < size_);
+    return data_[i];
+  }
+
+  auto copy() const -> vec {
+    auto v = vec(size_);
+    if (v) for (size_t i = 0; i < size_; ++i) v.data_[i] = data_[i];
+    return v;
+  }
+
+  // TODO: This can't be used for e.g. vec<Val>
+  auto deep_copy() const -> vec {
+    auto v = vec(size_);
+    if (v) for (size_t i = 0; i < size_; ++i) v.data_[i] = data_[i]->copy();
+    return v;
+  }
+
+  static auto make_uninitialized(size_t size = 0) -> vec {
+    return vec(size);
+  }
+
+  static auto make(size_t size, T init[]) -> vec {
+    auto v = vec(size);
+    if (v) for (size_t i = 0; i < size; ++i) v.data_[i] = std::move(init[i]);
+    return v;
+  }
+
+  static auto make(std::string s) -> vec<char> {
+    auto v = vec(s.length());
+    if (v) std::strncpy(v.get(), s.data(), s.length());
+    return v;
+  }
+
+  static auto make_nt(std::string s) -> vec<char> {
+    auto v = vec(s.length() + 1);
+    if (v) std::strcpy(v.get(), s.data());
+    return v;
+  }
+
+  // TODO(mvsc): MVSC requires this special case:
+  static auto make() -> vec {
+    return vec(0);
+  }
+
+  template<class... Ts>
+  static auto make(Ts&&... args) -> vec {
+    T data[] = { std::forward<Ts>(args)... };
+    return make(sizeof...(Ts), data);
+  }
+
+  static auto adopt(size_t size, T data[]) -> vec {
+    return vec(size, data);
+  }
+
+  static auto invalid() -> vec {
+    return vec(invalid_size, nullptr);
+  }
+};
+
+
+// Ownership
+
+class destroyer {
+public:
+  template <typename T>
+  void operator()(T* ptr) {
+    ptr->destroy();
+  }
+};
+
+template<class T> using own = std::unique_ptr<T, destroyer>;
+template<class T> using ownvec = vec<own<T>>;
+
+template<class T> own<T> make_own(T* ptr) {
+  return own<T>(ptr);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// Runtime Environment
+
+// Configuration
+
+class WASM_API_EXTERN Config {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Config() = default;
+  ~Config() = default;
+
+public:
+  static auto make() -> own<Config>;
+
+  // Implementations may provide custom methods for manipulating Configs.
+};
+
+
+// Engine
+
+class WASM_API_EXTERN Engine {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Engine() = default;
+  ~Engine() = default;
+
+public:
+  static auto make(own<Config>&& = Config::make()) -> own<Engine>;
+};
+
+
+// Store
+
+class WASM_API_EXTERN Store {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Store() = default;
+  ~Store() = default;
+
+public:
+  static auto make(Engine*) -> own<Store>;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Type Representations
+
+// Type attributes
+
+enum class Mutability : uint8_t { CONST, VAR };
+
+struct Limits {
+  uint32_t min;
+  uint32_t max;
+
+  Limits(uint32_t min, uint32_t max = std::numeric_limits<uint32_t>::max()) :
+    min(min), max(max) {}
+};
+
+
+// Value Types
+
+enum class ValKind : uint8_t {
+  I32, I64, F32, F64,
+  EXTERNREF = 128, FUNCREF,
+};
+
+inline bool is_num(ValKind k) { return k < ValKind::EXTERNREF; }
+inline bool is_ref(ValKind k) { return k >= ValKind::EXTERNREF; }
+
+
+class WASM_API_EXTERN ValType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  ValType() = default;
+  ~ValType() = default;
+
+public:
+  static auto make(ValKind) -> own<ValType>;
+  auto copy() const -> own<ValType>;
+
+  auto kind() const -> ValKind;
+  auto is_num() const -> bool { return wasm::is_num(kind()); }
+  auto is_ref() const -> bool { return wasm::is_ref(kind()); }
+};
+
+
+// External Types
+
+enum class ExternKind : uint8_t {
+  FUNC, GLOBAL, TABLE, MEMORY
+};
+
+class FuncType;
+class GlobalType;
+class TableType;
+class MemoryType;
+
+class WASM_API_EXTERN ExternType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  ExternType() = default;
+  ~ExternType() = default;
+
+public:
+  auto copy() const-> own<ExternType>;
+
+  auto kind() const -> ExternKind;
+
+  auto func() -> FuncType*;
+  auto global() -> GlobalType*;
+  auto table() -> TableType*;
+  auto memory() -> MemoryType*;
+
+  auto func() const -> const FuncType*;
+  auto global() const -> const GlobalType*;
+  auto table() const -> const TableType*;
+  auto memory() const -> const MemoryType*;
+};
+
+
+// Function Types
+
+class WASM_API_EXTERN FuncType : public ExternType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  FuncType() = default;
+  ~FuncType() = default;
+
+public:
+  static auto make(
+    ownvec<ValType>&& params = ownvec<ValType>::make(),
+    ownvec<ValType>&& results = ownvec<ValType>::make()
+  ) -> own<FuncType>;
+
+  auto copy() const -> own<FuncType>;
+
+  auto params() const -> const ownvec<ValType>&;
+  auto results() const -> const ownvec<ValType>&;
+};
+
+
+// Global Types
+
+class WASM_API_EXTERN GlobalType : public ExternType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  GlobalType() = default;
+  ~GlobalType() = default;
+
+public:
+  static auto make(own<ValType>&&, Mutability) -> own<GlobalType>;
+  auto copy() const -> own<GlobalType>;
+
+  auto content() const -> const ValType*;
+  auto mutability() const -> Mutability;
+};
+
+
+// Table Types
+
+class WASM_API_EXTERN TableType : public ExternType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  TableType() = default;
+  ~TableType() = default;
+
+public:
+  static auto make(own<ValType>&&, Limits) -> own<TableType>;
+  auto copy() const -> own<TableType>;
+
+  auto element() const -> const ValType*;
+  auto limits() const -> const Limits&;
+};
+
+
+// Memory Types
+
+class WASM_API_EXTERN MemoryType : public ExternType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  MemoryType() = default;
+  ~MemoryType() = default;
+
+public:
+  static auto make(Limits) -> own<MemoryType>;
+  auto copy() const -> own<MemoryType>;
+
+  auto limits() const -> const Limits&;
+};
+
+
+// Import Types
+
+using Name = vec<byte_t>;
+
+class WASM_API_EXTERN ImportType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  ImportType() = default;
+  ~ImportType() = default;
+
+public:
+  static auto make(Name&& module, Name&& name, own<ExternType>&&) ->
+    own<ImportType>;
+  auto copy() const -> own<ImportType>;
+
+  auto module() const -> const Name&;
+  auto name() const -> const Name&;
+  auto type() const -> const ExternType*;
+};
+
+
+// Export Types
+
+class WASM_API_EXTERN ExportType {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  ExportType() = default;
+  ~ExportType() = default;
+
+public:
+  static auto make(Name&&, own<ExternType>&&) -> own<ExportType>;
+  auto copy() const -> own<ExportType>;
+
+  auto name() const -> const Name&;
+  auto type() const -> const ExternType*;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Runtime Objects
+
+// References
+
+class WASM_API_EXTERN Ref {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Ref() = default;
+  ~Ref() = default;
+
+public:
+  auto copy() const -> own<Ref>;
+  auto same(const Ref*) const -> bool;
+
+  auto get_host_info() const -> void*;
+  void set_host_info(void* info, void (*finalizer)(void*) = nullptr);
+};
+
+
+// Values
+
+class Val {
+  ValKind kind_;
+  union impl {
+    int32_t i32;
+    int64_t i64;
+    float32_t f32;
+    float64_t f64;
+    Ref* ref;
+  } impl_;
+
+  Val(ValKind kind, impl impl) : kind_(kind), impl_(impl) {}
+
+public:
+  Val() : kind_(ValKind::EXTERNREF) { impl_.ref = nullptr; }
+  explicit Val(int32_t i) : kind_(ValKind::I32) { impl_.i32 = i; }
+  explicit Val(int64_t i) : kind_(ValKind::I64) { impl_.i64 = i; }
+  explicit Val(float32_t z) : kind_(ValKind::F32) { impl_.f32 = z; }
+  explicit Val(float64_t z) : kind_(ValKind::F64) { impl_.f64 = z; }
+  explicit Val(own<Ref>&& r) : kind_(ValKind::EXTERNREF) { impl_.ref = r.release(); }
+
+  Val(Val&& that) : kind_(that.kind_), impl_(that.impl_) {
+    if (is_ref()) that.impl_.ref = nullptr;
+  }
+
+  ~Val() {
+    reset();
+  }
+
+  auto is_num() const -> bool { return wasm::is_num(kind_); }
+  auto is_ref() const -> bool { return wasm::is_ref(kind_); }
+
+  static auto i32(int32_t x) -> Val { return Val(x); }
+  static auto i64(int64_t x) -> Val { return Val(x); }
+  static auto f32(float32_t x) -> Val { return Val(x); }
+  static auto f64(float64_t x) -> Val { return Val(x); }
+  static auto ref(own<Ref>&& x) -> Val { return Val(std::move(x)); }
+  template<class T> inline static auto make(T x) -> Val;
+  template<class T> inline static auto make(own<T>&& x) -> Val;
+
+  void reset() {
+    if (is_ref() && impl_.ref) {
+      destroyer()(impl_.ref);
+      impl_.ref = nullptr;
+    }
+  }
+
+  void reset(Val& that) {
+    reset();
+    kind_ = that.kind_;
+    impl_ = that.impl_;
+    if (is_ref()) that.impl_.ref = nullptr;
+  }
+
+  auto operator=(Val&& that) -> Val& {
+    reset(that);
+    return *this;
+  }
+
+  auto kind() const -> ValKind { return kind_; }
+  auto i32() const -> int32_t { assert(kind_ == ValKind::I32); return impl_.i32; }
+  auto i64() const -> int64_t { assert(kind_ == ValKind::I64); return impl_.i64; }
+  auto f32() const -> float32_t { assert(kind_ == ValKind::F32); return impl_.f32; }
+  auto f64() const -> float64_t { assert(kind_ == ValKind::F64); return impl_.f64; }
+  auto ref() const -> Ref* { assert(is_ref()); return impl_.ref; }
+  template<class T> inline auto get() const -> T;
+
+  auto release_ref() -> own<Ref> {
+    assert(is_ref());
+    auto ref = impl_.ref;
+    impl_.ref = nullptr;
+    return own<Ref>(ref);
+  }
+
+  auto copy() const -> Val {
+    if (is_ref() && impl_.ref != nullptr) {
+      // TODO(mvsc): MVSC cannot handle this:
+      // impl impl = {.ref = impl_.ref->copy().release()};
+      impl impl;
+      impl.ref = impl_.ref->copy().release();
+      return Val(kind_, impl);
+    } else {
+      return Val(kind_, impl_);
+    }
+  }
+};
+
+
+template<> inline auto Val::make<int32_t>(int32_t x) -> Val { return Val(x); }
+template<> inline auto Val::make<int64_t>(int64_t x) -> Val { return Val(x); }
+template<> inline auto Val::make<float32_t>(float32_t x) -> Val { return Val(x); }
+template<> inline auto Val::make<float64_t>(float64_t x) -> Val { return Val(x); }
+template<> inline auto Val::make<Ref>(own<Ref>&& x) -> Val {
+  return Val(std::move(x));
+}
+
+template<> inline auto Val::make<uint32_t>(uint32_t x) -> Val {
+  return Val(static_cast<int32_t>(x));
+}
+template<> inline auto Val::make<uint64_t>(uint64_t x) -> Val {
+  return Val(static_cast<int64_t>(x));
+}
+
+template<> inline auto Val::get<int32_t>() const -> int32_t { return i32(); }
+template<> inline auto Val::get<int64_t>() const -> int64_t { return i64(); }
+template<> inline auto Val::get<float32_t>() const -> float32_t { return f32(); }
+template<> inline auto Val::get<float64_t>() const -> float64_t { return f64(); }
+template<> inline auto Val::get<Ref*>() const -> Ref* { return ref(); }
+
+template<> inline auto Val::get<uint32_t>() const -> uint32_t {
+  return static_cast<uint32_t>(i32());
+}
+template<> inline auto Val::get<uint64_t>() const -> uint64_t {
+  return static_cast<uint64_t>(i64());
+}
+
+
+// Traps
+
+using Message = vec<byte_t>;  // null terminated
+
+class Instance;
+
+class WASM_API_EXTERN Frame {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Frame() = default;
+  ~Frame() = default;
+
+public:
+  auto copy() const -> own<Frame>;
+
+  auto instance() const -> Instance*;
+  auto func_index() const -> uint32_t;
+  auto func_offset() const -> size_t;
+  auto module_offset() const -> size_t;
+};
+
+class WASM_API_EXTERN Trap : public Ref {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Trap() = default;
+  ~Trap() = default;
+
+public:
+  static auto make(Store*, const Message& msg) -> own<Trap>;
+  auto copy() const -> own<Trap>;
+
+  auto message() const -> Message;
+  auto origin() const -> own<Frame>;  // may be null
+  auto trace() const -> ownvec<Frame>;  // may be empty, origin first
+};
+
+
+// Modules
+
+template<class T> class WASM_API_EXTERN Shared;
+
+class WASM_API_EXTERN Module : public Ref {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Module() = default;
+  ~Module() = default;
+
+public:
+  static auto validate(Store*, const vec<byte_t>& binary) -> bool;
+  static auto make(Store*, const vec<byte_t>& binary) -> own<Module>;
+  auto copy() const -> own<Module>;
+
+  auto imports() const -> ownvec<ImportType>;
+  auto exports() const -> ownvec<ExportType>;
+
+  auto share() const -> own<Shared<Module>>;
+  static auto obtain(Store*, const Shared<Module>*) -> own<Module>;
+
+  auto serialize() const -> vec<byte_t>;
+  static auto deserialize(Store*, const vec<byte_t>&) -> own<Module>;
+};
+
+
+// Shared objects
+
+template<>
+class WASM_API_EXTERN Shared<Module> {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Shared() = default;
+  ~Shared() = default;
+};
+
+
+// Foreign Objects
+
+class WASM_API_EXTERN Foreign : public Ref {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Foreign() = default;
+  ~Foreign() = default;
+
+public:
+  static auto make(Store*) -> own<Foreign>;
+  auto copy() const -> own<Foreign>;
+};
+
+
+// Externals
+
+class Func;
+class Global;
+class Table;
+class Memory;
+
+class WASM_API_EXTERN Extern : public Ref {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Extern() = default;
+  ~Extern() = default;
+
+public:
+  auto copy() const -> own<Extern>;
+
+  auto kind() const -> ExternKind;
+  auto type() const -> own<ExternType>;
+
+  auto func() -> Func*;
+  auto global() -> Global*;
+  auto table() -> Table*;
+  auto memory() -> Memory*;
+
+  auto func() const -> const Func*;
+  auto global() const -> const Global*;
+  auto table() const -> const Table*;
+  auto memory() const -> const Memory*;
+};
+
+
+// Function Instances
+
+class WASM_API_EXTERN Func : public Extern {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Func() = default;
+  ~Func() = default;
+
+public:
+  using callback = auto (*)(const vec<Val>&, vec<Val>&) -> own<Trap>;
+  using callback_with_env = auto (*)(void*, const vec<Val>&, vec<Val>&) -> own<Trap>;
+
+  static auto make(Store*, const FuncType*, callback) -> own<Func>;
+  static auto make(Store*, const FuncType*, callback_with_env,
+    void*, void (*finalizer)(void*) = nullptr) -> own<Func>;
+  auto copy() const -> own<Func>;
+
+  auto type() const -> own<FuncType>;
+  auto param_arity() const -> size_t;
+  auto result_arity() const -> size_t;
+
+  auto call(const vec<Val>&, vec<Val>&) const -> own<Trap>;
+};
+
+
+// Global Instances
+
+class WASM_API_EXTERN Global : public Extern {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Global() = default;
+  ~Global() = default;
+
+ public:
+  static auto make(Store*, const GlobalType*, const Val&) -> own<Global>;
+  auto copy() const -> own<Global>;
+
+  auto type() const -> own<GlobalType>;
+  auto get() const -> Val;
+  void set(const Val&);
+};
+
+
+// Table Instances
+
+class WASM_API_EXTERN Table : public Extern {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Table() = default;
+  ~Table() = default;
+
+public:
+  using size_t = uint32_t;
+
+  static auto make(
+    Store*, const TableType*, const Ref* init = nullptr) -> own<Table>;
+  auto copy() const -> own<Table>;
+
+  auto type() const -> own<TableType>;
+  auto get(size_t index) const -> own<Ref>;
+  auto set(size_t index, const Ref*) -> bool;
+  auto size() const -> size_t;
+  auto grow(size_t delta, const Ref* init = nullptr) -> bool;
+};
+
+
+// Memory Instances
+
+class WASM_API_EXTERN Memory : public Extern {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Memory() = default;
+  ~Memory() = default;
+
+public:
+  static auto make(Store*, const MemoryType*) -> own<Memory>;
+  auto copy() const -> own<Memory>;
+
+  using pages_t = uint32_t;
+
+  static const size_t page_size = 0x10000;
+
+  auto type() const -> own<MemoryType>;
+  auto data() const -> byte_t*;
+  auto data_size() const -> size_t;
+  auto size() const -> pages_t;
+  auto grow(pages_t delta) -> bool;
+};
+
+
+// Module Instances
+
+class WASM_API_EXTERN Instance : public Ref {
+  friend class destroyer;
+  void destroy();
+
+protected:
+  Instance() = default;
+  ~Instance() = default;
+
+public:
+  static auto make(
+    Store*, const Module*, const vec<Extern*>&, own<Trap>* = nullptr
+  ) -> own<Instance>;
+  auto copy() const -> own<Instance>;
+
+  auto exports() const -> ownvec<Extern>;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+
+}  // namespace wasm
+
+#endif  // #ifdef WASM_HH
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime.h
similarity index 89%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime.h
index c70fd8b71..25ca60024 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime.h
@@ -57,7 +57,8 @@
  *
  * * Linux - `-lpthread -ldl -lm`
  * * macOS - no extra flags needed
- * * Windows - `ws2_32.lib advapi32.lib userenv.lib ntdll.lib shell32.lib ole32.lib bcrypt.lib`
+ * * Windows - `ws2_32.lib advapi32.lib userenv.lib ntdll.lib shell32.lib
+ * ole32.lib bcrypt.lib`
  *
  * ## Building from Source
  *
@@ -89,7 +90,7 @@
  *   issue](https://github.com/bytecodealliance/wasmtime/issues/new).
  *
  * * [C embedding
- *   examples](https://bytecodealliance.github.io/wasmtime/examples-c-embed.html)
+ *   examples](https://bytecodealliance.github.io/wasmtime/lang-c.html)
  *   are available online and are tested from the Wasmtime repository itself.
  *
  * * [Contribution documentation for
@@ -151,9 +152,7 @@
  * provided access to it. For example in a host function created with
  * #wasmtime_func_new you can use #wasmtime_context_t in the host function
  * callback. This is because an argument, a #wasmtime_caller_t, provides access
- * to #wasmtime_context_t. On the other hand a destructor passed to
- * #wasmtime_externref_new, however, cannot use a #wasmtime_context_t because
- * it was not provided access to one. Doing so may lead to memory unsafety.
+ * to #wasmtime_context_t.
  *
  * ### Stores
  *
@@ -181,6 +180,9 @@
 #define WASMTIME_API_H
 
 #include <wasi.h>
+#include <wasmtime/conf.h>
+// clang-format off
+// IWYU pragma: begin_exports
 #include <wasmtime/config.h>
 #include <wasmtime/engine.h>
 #include <wasmtime/error.h>
@@ -191,23 +193,47 @@
 #include <wasmtime/linker.h>
 #include <wasmtime/memory.h>
 #include <wasmtime/module.h>
+#include <wasmtime/profiling.h>
+#include <wasmtime/sharedmemory.h>
 #include <wasmtime/store.h>
 #include <wasmtime/table.h>
 #include <wasmtime/trap.h>
 #include <wasmtime/val.h>
+#include <wasmtime/async.h>
+// IWYU pragma: end_exports
+// clang-format on
+
+/**
+ * \brief Wasmtime version string.
+ */
+#define WASMTIME_VERSION "28.0.0"
+/**
+ * \brief Wasmtime major version number.
+ */
+#define WASMTIME_VERSION_MAJOR 28
+/**
+ * \brief Wasmtime minor version number.
+ */
+#define WASMTIME_VERSION_MINOR 0
+/**
+ * \brief Wasmtime patch version number.
+ */
+#define WASMTIME_VERSION_PATCH 0
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#ifdef WASMTIME_FEATURE_WAT
+
 /**
- * \brief Converts from the text format of WebAssembly to to the binary format.
+ * \brief Converts from the text format of WebAssembly to the binary format.
  *
- * \param wat this it the input pointer with the WebAssembly Text Format inside of
- *   it. This will be parsed and converted to the binary format.
+ * \param wat this it the input pointer with the WebAssembly Text Format inside
+ *        of it. This will be parsed and converted to the binary format.
  * \param wat_len this it the length of `wat`, in bytes.
- * \param ret if the conversion is successful, this byte vector is filled in with
- *   the WebAssembly binary format.
+ * \param ret if the conversion is successful, this byte vector is filled in
+ *        with the WebAssembly binary format.
  *
  * \return a non-null error if parsing fails, or returns `NULL`. If parsing
  * fails then `ret` isn't touched.
@@ -215,14 +241,13 @@ extern "C" {
  * This function does not take ownership of `wat`, and the caller is expected to
  * deallocate the returned #wasmtime_error_t and #wasm_byte_vec_t.
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_wat2wasm(
-    const char *wat,
-    size_t wat_len,
-    wasm_byte_vec_t *ret
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_wat2wasm(const char *wat, size_t wat_len, wasm_byte_vec_t *ret);
+
+#endif
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_API_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/async.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/async.h
new file mode 100644
index 000000000..c0f6a14b4
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/async.h
@@ -0,0 +1,374 @@
+/**
+ * \file wasmtime/async.h
+ *
+ * \brief Wasmtime async functionality
+ *
+ * Async functionality in Wasmtime is well documented here:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support
+ *
+ * All WebAssembly executes synchronously, but an async support enables the Wasm
+ * code be executed on a separate stack, so it can be paused and resumed. There
+ * are three mechanisms for yielding control from wasm to the caller: fuel,
+ * epochs, and async host functions.
+ *
+ * When WebAssembly is executed, a `wasmtime_call_future_t` is returned. This
+ * struct represents the state of the execution and each call to
+ * `wasmtime_call_future_poll` will execute the WebAssembly code on a separate
+ * stack until the function returns or yields control back to the caller.
+ *
+ * It's expected these futures are pulled in a loop until completed, at which
+ * point the future should be deleted. Functions that return a
+ * `wasmtime_call_future_t` are special in that all parameters to that function
+ * should not be modified in any way and must be kept alive until the future is
+ * deleted. This includes concurrent calls for a single store - another function
+ * on a store should not be called while there is a `wasmtime_call_future_t`
+ * alive.
+ *
+ * As for asynchronous host calls - the reverse contract is upheld. Wasmtime
+ * will keep all parameters to the function alive and unmodified until the
+ * `wasmtime_func_async_continuation_callback_t` returns true.
+ *
+ */
+
+#ifndef WASMTIME_ASYNC_H
+#define WASMTIME_ASYNC_H
+
+#include <wasm.h>
+#include <wasmtime/conf.h>
+#include <wasmtime/config.h>
+#include <wasmtime/error.h>
+#include <wasmtime/func.h>
+#include <wasmtime/linker.h>
+#include <wasmtime/store.h>
+
+#ifdef WASMTIME_FEATURE_ASYNC
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief Whether or not to enable support for asynchronous functions in
+ * Wasmtime.
+ *
+ * When enabled, the config can optionally define host functions with async.
+ * Instances created and functions called with this Config must be called
+ * through their asynchronous APIs, however. For example using
+ * wasmtime_func_call will panic when used with this config.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support
+ */
+WASMTIME_CONFIG_PROP(void, async_support, bool)
+
+/**
+ * \brief Configures the size of the stacks used for asynchronous execution.
+ *
+ * This setting configures the size of the stacks that are allocated for
+ * asynchronous execution.
+ *
+ * The value cannot be less than max_wasm_stack.
+ *
+ * The amount of stack space guaranteed for host functions is async_stack_size -
+ * max_wasm_stack, so take care not to set these two values close to one
+ * another; doing so may cause host functions to overflow the stack and abort
+ * the process.
+ *
+ * By default this option is 2 MiB.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_stack_size
+ */
+WASMTIME_CONFIG_PROP(void, async_stack_size, uint64_t)
+
+/**
+ * \brief Configures a Store to yield execution of async WebAssembly code
+ * periodically.
+ *
+ * When a Store is configured to consume fuel with
+ * `wasmtime_config_consume_fuel` this method will configure what happens when
+ * fuel runs out. Specifically executing WebAssembly will be suspended and
+ * control will be yielded back to the caller.
+ *
+ * This is only suitable with use of a store associated with an async config
+ * because only then are futures used and yields are possible.
+ *
+ * \param context the context for the store to configure.
+ * \param interval the amount of fuel at which to yield. A value of 0 will
+ *        disable yielding.
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_context_fuel_async_yield_interval(wasmtime_context_t *context,
+                                           uint64_t interval);
+
+/**
+ * \brief Configures epoch-deadline expiration to yield to the async caller and
+ * the update the deadline.
+ *
+ * This is only suitable with use of a store associated with an async config
+ * because only then are futures used and yields are possible.
+ *
+ * See the Rust documentation for more:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Store.html#method.epoch_deadline_async_yield_and_update
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_context_epoch_deadline_async_yield_and_update(
+    wasmtime_context_t *context, uint64_t delta);
+
+/**
+ * The callback to determine a continuation's current state.
+ *
+ * Return true if the host call has completed, otherwise false will
+ * continue to yield WebAssembly execution.
+ */
+typedef bool (*wasmtime_func_async_continuation_callback_t)(void *env);
+
+/**
+ * A continuation for the current state of the host function's execution.
+ */
+typedef struct wasmtime_async_continuation_t {
+  /// Callback for if the async function has completed.
+  wasmtime_func_async_continuation_callback_t callback;
+  /// User-provided argument to pass to the callback.
+  void *env;
+  /// A finalizer for the user-provided *env
+  void (*finalizer)(void *);
+} wasmtime_async_continuation_t;
+
+/**
+ * \brief Callback signature for #wasmtime_linker_define_async_func.
+ *
+ * This is a host function that returns a continuation to be called later.
+ *
+ * All the arguments to this function will be kept alive until the continuation
+ * returns that it has errored or has completed.
+ *
+ * \param env user-provided argument passed to
+ *        #wasmtime_linker_define_async_func
+ * \param caller a temporary object that can only be used during this function
+ *        call. Used to acquire #wasmtime_context_t or caller's state
+ * \param args the arguments provided to this function invocation
+ * \param nargs how many arguments are provided
+ * \param results where to write the results of this function
+ * \param nresults how many results must be produced
+ * \param trap_ret if assigned a not `NULL` value then the called
+ *        function will trap with the returned error. Note that ownership of
+ *        trap is transferred to wasmtime.
+ * \param continuation_ret the returned continuation
+ *        that determines when the async function has completed executing.
+ *
+ * Only supported for async stores.
+ *
+ * See #wasmtime_func_callback_t for more information.
+ */
+typedef void (*wasmtime_func_async_callback_t)(
+    void *env, wasmtime_caller_t *caller, const wasmtime_val_t *args,
+    size_t nargs, wasmtime_val_t *results, size_t nresults,
+    wasm_trap_t **trap_ret, wasmtime_async_continuation_t *continuation_ret);
+
+/**
+ * \brief The structure representing a asynchronously running function.
+ *
+ * This structure is always owned by the caller and must be deleted using
+ * #wasmtime_call_future_delete.
+ *
+ * Functions that return this type require that the parameters to the function
+ * are unmodified until this future is destroyed.
+ */
+typedef struct wasmtime_call_future wasmtime_call_future_t;
+
+/**
+ * \brief Executes WebAssembly in the function.
+ *
+ * Returns true if the function call has completed. After this function returns
+ * true, it should *not* be called again for a given future.
+ *
+ * This function returns false if execution has yielded either due to being out
+ * of fuel (see wasmtime_context_fuel_async_yield_interval), or the epoch has
+ * been incremented enough (see
+ * wasmtime_context_epoch_deadline_async_yield_and_update). The function may
+ * also return false if asynchronous host functions have been called, which then
+ * calling this  function will call the continuation from the async host
+ * function.
+ *
+ * For more see the information at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#asynchronous-wasm
+ *
+ */
+WASM_API_EXTERN bool wasmtime_call_future_poll(wasmtime_call_future_t *future);
+
+/**
+ * /brief Frees the underlying memory for a future.
+ *
+ * All wasmtime_call_future_t are owned by the caller and should be deleted
+ * using this function.
+ */
+WASM_API_EXTERN void
+wasmtime_call_future_delete(wasmtime_call_future_t *future);
+
+/**
+ * \brief Invokes this function with the params given, returning the results
+ * asynchronously.
+ *
+ * This function is the same as wasmtime_func_call except that it is
+ * asynchronous. This is only compatible with stores associated with an
+ * asynchronous config.
+ *
+ * The result is a future that is owned by the caller and must be deleted via
+ * #wasmtime_call_future_delete.
+ *
+ * The `args` and `results` pointers may be `NULL` if the corresponding length
+ * is zero. The `trap_ret` and `error_ret` pointers may *not* be `NULL`.
+ *
+ * Does not take ownership of #wasmtime_val_t arguments or #wasmtime_val_t
+ * results, and all parameters to this function must be kept alive and not
+ * modified until the returned #wasmtime_call_future_t is deleted. This includes
+ * the context and store parameters. Only a single future can be alive for a
+ * given store at a single time (meaning only call this function after the
+ * previous call's future was deleted).
+ *
+ * See the header documentation for for more information.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Func.html#method.call_async
+ */
+WASM_API_EXTERN wasmtime_call_future_t *wasmtime_func_call_async(
+    wasmtime_context_t *context, const wasmtime_func_t *func,
+    const wasmtime_val_t *args, size_t nargs, wasmtime_val_t *results,
+    size_t nresults, wasm_trap_t **trap_ret, wasmtime_error_t **error_ret);
+
+/**
+ * \brief Defines a new async function in this linker.
+ *
+ * This function behaves similar to #wasmtime_linker_define_func, except it
+ * supports async callbacks.
+ *
+ * The callback `cb` will be invoked on another stack (fiber for Windows).
+ */
+WASM_API_EXTERN wasmtime_error_t *wasmtime_linker_define_async_func(
+    wasmtime_linker_t *linker, const char *module, size_t module_len,
+    const char *name, size_t name_len, const wasm_functype_t *ty,
+    wasmtime_func_async_callback_t cb, void *data, void (*finalizer)(void *));
+
+/**
+ * \brief Instantiates a #wasm_module_t with the items defined in this linker
+ * for an async store.
+ *
+ * This is the same as #wasmtime_linker_instantiate but used for async stores
+ * (which requires functions are called asynchronously). The returning
+ * #wasmtime_call_future_t must be polled using #wasmtime_call_future_poll, and
+ * is owned and must be deleted using #wasmtime_call_future_delete.
+ *
+ * The `trap_ret` and `error_ret` pointers may *not* be `NULL` and the returned
+ * memory is owned by the caller.
+ *
+ * All arguments to this function must outlive the returned future and be
+ * unmodified until the future is deleted.
+ */
+WASM_API_EXTERN wasmtime_call_future_t *wasmtime_linker_instantiate_async(
+    const wasmtime_linker_t *linker, wasmtime_context_t *store,
+    const wasmtime_module_t *module, wasmtime_instance_t *instance,
+    wasm_trap_t **trap_ret, wasmtime_error_t **error_ret);
+
+/**
+ * \brief Instantiates instance within the given store.
+ *
+ * This will also run the function's startup function, if there is one.
+ *
+ * For more information on async instantiation see
+ * #wasmtime_linker_instantiate_async.
+ *
+ * \param instance_pre the pre-initialized instance
+ * \param store the store in which to create the instance
+ * \param instance where to store the returned instance
+ * \param trap_ret where to store the returned trap
+ * \param error_ret where to store the returned trap
+ *
+ * The `trap_ret` and `error_ret` pointers may *not* be `NULL` and the returned
+ * memory is owned by the caller.
+ *
+ * All arguments to this function must outlive the returned future and be
+ * unmodified until the future is deleted.
+ */
+WASM_API_EXTERN wasmtime_call_future_t *wasmtime_instance_pre_instantiate_async(
+    const wasmtime_instance_pre_t *instance_pre, wasmtime_context_t *store,
+    wasmtime_instance_t *instance, wasm_trap_t **trap_ret,
+    wasmtime_error_t **error_ret);
+
+/**
+ * A callback to get the top of the stack address and the length of the stack,
+ * excluding guard pages.
+ *
+ * For more information about the parameters see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.StackMemory.html
+ */
+typedef uint8_t *(*wasmtime_stack_memory_get_callback_t)(void *env,
+                                                         size_t *out_len);
+
+/**
+ * A Stack instance created from a #wasmtime_new_stack_memory_callback_t.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.StackMemory.html
+ */
+typedef struct {
+  /// User provided value to be passed to get_memory and grow_memory
+  void *env;
+  /// Callback to get the memory and size of this LinearMemory
+  wasmtime_stack_memory_get_callback_t get_stack_memory;
+  /// An optional finalizer for env
+  void (*finalizer)(void *);
+} wasmtime_stack_memory_t;
+
+/**
+ * A callback to create a new StackMemory from the specified parameters.
+ *
+ * The result should be written to `stack_ret` and wasmtime will own the values
+ * written into that struct.
+ *
+ * This callback must be thread-safe.
+ *
+ * For more information about the parameters see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.StackCreator.html#tymethod.new_stack
+ */
+typedef wasmtime_error_t *(*wasmtime_new_stack_memory_callback_t)(
+    void *env, size_t size, wasmtime_stack_memory_t *stack_ret);
+
+/**
+ * A representation of custom stack creator.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.StackCreator.html
+ */
+typedef struct {
+  /// User provided value to be passed to new_stack
+  void *env;
+  /// The callback to create a new stack, must be thread safe
+  wasmtime_new_stack_memory_callback_t new_stack;
+  /// An optional finalizer for env.
+  void (*finalizer)(void *);
+} wasmtime_stack_creator_t;
+
+/**
+ * Sets a custom stack creator.
+ *
+ * Custom memory creators are used when creating creating async instance stacks
+ * for the on-demand instance allocation strategy.
+ *
+ * The config does **not** take ownership of the #wasmtime_stack_creator_t
+ * passed in, but instead copies all the values in the struct.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.with_host_stack
+ */
+WASM_API_EXTERN void
+wasmtime_config_host_stack_creator_set(wasm_config_t *,
+                                       wasmtime_stack_creator_t *);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_FEATURE_ASYNC
+
+#endif // WASMTIME_ASYNC_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/conf.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/conf.h
new file mode 100644
index 000000000..c82f08e30
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/conf.h
@@ -0,0 +1,35 @@
+/**
+ * \file wasmtime/conf.h
+ *
+ * \brief Build-time defines for how the C API was built.
+ */
+
+#ifndef WASMTIME_CONF_H
+#define WASMTIME_CONF_H
+
+// WASMTIME_FEATURE_LIST
+#define WASMTIME_FEATURE_PROFILING
+#define WASMTIME_FEATURE_WAT
+#define WASMTIME_FEATURE_CACHE
+#define WASMTIME_FEATURE_PARALLEL_COMPILATION
+#define WASMTIME_FEATURE_WASI
+#define WASMTIME_FEATURE_LOGGING
+/* #undef WASMTIME_FEATURE_DISABLE_LOGGING */
+#define WASMTIME_FEATURE_COREDUMP
+#define WASMTIME_FEATURE_ADDR2LINE
+#define WASMTIME_FEATURE_DEMANGLE
+#define WASMTIME_FEATURE_THREADS
+#define WASMTIME_FEATURE_GC
+#define WASMTIME_FEATURE_GC_DRC
+#define WASMTIME_FEATURE_GC_NULL
+#define WASMTIME_FEATURE_ASYNC
+#define WASMTIME_FEATURE_CRANELIFT
+#define WASMTIME_FEATURE_WINCH
+// ... if you add a line above this be sure to change the other locations
+// marked WASMTIME_FEATURE_LIST
+
+#if defined(WASMTIME_FEATURE_CRANELIFT) || defined(WASMTIME_FEATURE_WINCH)
+#define WASMTIME_FEATURE_COMPILER
+#endif
+
+#endif // WASMTIME_CONF_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/config.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/config.h
new file mode 100644
index 000000000..bafdb85e2
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/config.h
@@ -0,0 +1,549 @@
+/**
+ * \file wasmtime/config.h
+ *
+ * \brief Wasmtime-specific extensions to #wasm_config_t
+ */
+
+#ifndef WASMTIME_CONFIG_H
+#define WASMTIME_CONFIG_H
+
+#include <wasm.h>
+#include <wasmtime/conf.h>
+#include <wasmtime/error.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief Specifier for how Wasmtime will compile code, values are in
+ * #wasmtime_strategy_enum
+ */
+typedef uint8_t wasmtime_strategy_t;
+
+/**
+ * \brief Different ways that Wasmtime can compile WebAssembly
+ *
+ * The default value is #WASMTIME_STRATEGY_AUTO.
+ */
+enum wasmtime_strategy_enum { // Strategy
+  /// Automatically picks the compilation backend, currently always defaulting
+  /// to Cranelift.
+  WASMTIME_STRATEGY_AUTO,
+
+  /// Indicates that Wasmtime will unconditionally use Cranelift to compile
+  /// WebAssembly code.
+  WASMTIME_STRATEGY_CRANELIFT,
+};
+
+/**
+ * \brief Specifier of what optimization level to use for generated JIT code.
+ *
+ * See #wasmtime_opt_level_enum for possible values.
+ */
+typedef uint8_t wasmtime_opt_level_t;
+
+/**
+ * \brief Different ways Wasmtime can optimize generated code.
+ *
+ * The default value is #WASMTIME_OPT_LEVEL_SPEED.
+ */
+enum wasmtime_opt_level_enum { // OptLevel
+  /// Generated code will not be optimized at all.
+  WASMTIME_OPT_LEVEL_NONE,
+  /// Generated code will be optimized purely for speed.
+  WASMTIME_OPT_LEVEL_SPEED,
+  /// Generated code will be optimized, but some speed optimizations are
+  /// disabled if they cause the generated code to be significantly larger.
+  WASMTIME_OPT_LEVEL_SPEED_AND_SIZE,
+};
+
+/**
+ * \brief Different ways wasmtime can enable profiling JIT code.
+ *
+ * See #wasmtime_profiling_strategy_enum for possible values.
+ */
+typedef uint8_t wasmtime_profiling_strategy_t;
+
+/**
+ * \brief Different ways to profile JIT code.
+ *
+ * The default is #WASMTIME_PROFILING_STRATEGY_NONE.
+ */
+enum wasmtime_profiling_strategy_enum { // ProfilingStrategy
+  /// No profiling is enabled at runtime.
+  WASMTIME_PROFILING_STRATEGY_NONE,
+  /// Linux's "jitdump" support in `perf` is enabled and when Wasmtime is run
+  /// under `perf` necessary calls will be made to profile generated JIT code.
+  WASMTIME_PROFILING_STRATEGY_JITDUMP,
+  /// Support for VTune will be enabled and the VTune runtime will be informed,
+  /// at runtime, about JIT code.
+  ///
+  /// Note that this isn't always enabled at build time.
+  WASMTIME_PROFILING_STRATEGY_VTUNE,
+  /// Linux's simple "perfmap" support in `perf` is enabled and when Wasmtime is
+  /// run under `perf` necessary calls will be made to profile generated JIT
+  /// code.
+  WASMTIME_PROFILING_STRATEGY_PERFMAP,
+};
+
+#define WASMTIME_CONFIG_PROP(ret, name, ty)                                    \
+  WASM_API_EXTERN ret wasmtime_config_##name##_set(wasm_config_t *, ty);
+
+/**
+ * \brief Configures whether DWARF debug information is constructed at runtime
+ * to describe JIT code.
+ *
+ * This setting is `false` by default. When enabled it will attempt to inform
+ * native debuggers about DWARF debugging information for JIT code to more
+ * easily debug compiled WebAssembly via native debuggers. This can also
+ * sometimes improve the quality of output when profiling is enabled.
+ */
+WASMTIME_CONFIG_PROP(void, debug_info, bool)
+
+/**
+ * \brief Whether or not fuel is enabled for generated code.
+ *
+ * This setting is `false` by default. When enabled it will enable fuel counting
+ * meaning that fuel will be consumed every time a wasm instruction is executed,
+ * and trap when reaching zero.
+ */
+WASMTIME_CONFIG_PROP(void, consume_fuel, bool)
+
+/**
+ * \brief Whether or not epoch-based interruption is enabled for generated code.
+ *
+ * This setting is `false` by default. When enabled wasm code will check the
+ * current epoch periodically and abort if the current epoch is beyond a
+ * store-configured limit.
+ *
+ * Note that when this setting is enabled all stores will immediately trap and
+ * need to have their epoch deadline otherwise configured with
+ * #wasmtime_context_set_epoch_deadline.
+ *
+ * Note that the current epoch is engine-local and can be incremented with
+ * #wasmtime_engine_increment_epoch.
+ */
+WASMTIME_CONFIG_PROP(void, epoch_interruption, bool)
+
+/**
+ * \brief Configures the maximum stack size, in bytes, that JIT code can use.
+ *
+ * This setting is 2MB by default. Configuring this setting will limit the
+ * amount of native stack space that JIT code can use while it is executing. If
+ * you're hitting stack overflow you can try making this setting larger, or if
+ * you'd like to limit wasm programs to less stack you can also configure this.
+ *
+ * Note that this setting is not interpreted with 100% precision. Additionally
+ * the amount of stack space that wasm takes is always relative to the first
+ * invocation of wasm on the stack, so recursive calls with host frames in the
+ * middle will all need to fit within this setting.
+ */
+WASMTIME_CONFIG_PROP(void, max_wasm_stack, size_t)
+
+#ifdef WASMTIME_FEATURE_THREADS
+
+/**
+ * \brief Configures whether the WebAssembly threading proposal is enabled.
+ *
+ * This setting is `false` by default.
+ *
+ * Note that threads are largely unimplemented in Wasmtime at this time.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_threads, bool)
+
+#endif // WASMTIME_FEATURE_THREADS
+
+/**
+ * \brief Configures whether the WebAssembly tail call proposal is enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_tail_call, bool)
+
+/**
+ * \brief Configures whether the WebAssembly reference types proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_reference_types, bool)
+
+/**
+ * \brief Configures whether the WebAssembly typed function reference types
+ * proposal is enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_function_references, bool)
+
+/**
+ * \brief Configures whether the WebAssembly GC proposal is enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_gc, bool)
+
+/**
+ * \brief Configures whether the WebAssembly SIMD proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_simd, bool)
+
+/**
+ * \brief Configures whether the WebAssembly relaxed SIMD proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_relaxed_simd, bool)
+
+/**
+ * \brief Configures whether the WebAssembly relaxed SIMD proposal is
+ * in deterministic mode.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_relaxed_simd_deterministic, bool)
+
+/**
+ * \brief Configures whether the WebAssembly bulk memory proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_bulk_memory, bool)
+
+/**
+ * \brief Configures whether the WebAssembly multi value proposal is
+ * enabled.
+ *
+ * This setting is `true` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_multi_value, bool)
+
+/**
+ * \brief Configures whether the WebAssembly multi-memory proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_multi_memory, bool)
+
+/**
+ * \brief Configures whether the WebAssembly memory64 proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_memory64, bool)
+
+/**
+ * \brief Configures whether the WebAssembly wide-arithmetic proposal is
+ * enabled.
+ *
+ * This setting is `false` by default.
+ */
+WASMTIME_CONFIG_PROP(void, wasm_wide_arithmetic, bool)
+
+#ifdef WASMTIME_FEATURE_COMPILER
+
+/**
+ * \brief Configures how JIT code will be compiled.
+ *
+ * This setting is #WASMTIME_STRATEGY_AUTO by default.
+ */
+WASMTIME_CONFIG_PROP(void, strategy, wasmtime_strategy_t)
+
+#endif // WASMTIME_FEATURE_COMPILER
+
+#ifdef WASMTIME_FEATURE_PARALLEL_COMPILATION
+
+/**
+ * \brief Configure whether wasmtime should compile a module using multiple
+ * threads.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.parallel_compilation.
+ */
+WASMTIME_CONFIG_PROP(void, parallel_compilation, bool)
+
+#endif // WASMTIME_FEATURE_PARALLEL_COMPILATION
+
+#ifdef WASMTIME_FEATURE_COMPILER
+
+/**
+ * \brief Configures whether Cranelift's debug verifier is enabled.
+ *
+ * This setting in `false` by default.
+ *
+ * When cranelift is used for compilation this enables expensive debug checks
+ * within Cranelift itself to verify it's correct.
+ */
+WASMTIME_CONFIG_PROP(void, cranelift_debug_verifier, bool)
+
+/**
+ * \brief Configures whether Cranelift should perform a NaN-canonicalization
+ * pass.
+ *
+ * When Cranelift is used as a code generation backend this will configure
+ * it to replace NaNs with a single canonical value. This is useful for users
+ * requiring entirely deterministic WebAssembly computation.
+ *
+ * This is not required by the WebAssembly spec, so it is not enabled by
+ * default.
+ *
+ * The default value for this is `false`
+ */
+WASMTIME_CONFIG_PROP(void, cranelift_nan_canonicalization, bool)
+
+/**
+ * \brief Configures Cranelift's optimization level for JIT code.
+ *
+ * This setting in #WASMTIME_OPT_LEVEL_SPEED by default.
+ */
+WASMTIME_CONFIG_PROP(void, cranelift_opt_level, wasmtime_opt_level_t)
+
+#endif // WASMTIME_FEATURE_COMPILER
+
+/**
+ * \brief Configures the profiling strategy used for JIT code.
+ *
+ * This setting in #WASMTIME_PROFILING_STRATEGY_NONE by default.
+ */
+WASMTIME_CONFIG_PROP(void, profiler, wasmtime_profiling_strategy_t)
+
+/**
+ * \brief Configures whether `memory_reservation` is the maximal size of linear
+ * memory.
+ *
+ * This setting is `false` by default.
+ *
+ * For more information see the Rust documentation at
+ * https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.memory_may_move.
+ */
+WASMTIME_CONFIG_PROP(void, memory_may_move, bool)
+
+/**
+ * \brief Configures the size, in bytes, of initial memory reservation size for
+ * linear memories.
+ *
+ * For more information see the Rust documentation at
+ * https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.memory_reservation.
+ */
+WASMTIME_CONFIG_PROP(void, memory_reservation, uint64_t)
+
+/**
+ * \brief Configures the guard region size for linear memory.
+ *
+ * For more information see the Rust documentation at
+ * https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.memory_guard_size.
+ */
+WASMTIME_CONFIG_PROP(void, memory_guard_size, uint64_t)
+
+/**
+ * \brief Configures the size, in bytes, of the extra virtual memory space
+ * reserved for memories to grow into after being relocated.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.memory_reservation_for_growth
+ */
+WASMTIME_CONFIG_PROP(void, memory_reservation_for_growth, uint64_t)
+
+/**
+ * \brief Configures whether to generate native unwind information (e.g.
+ * .eh_frame on Linux).
+ *
+ * This option defaults to true.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.native_unwind_info
+ */
+WASMTIME_CONFIG_PROP(void, native_unwind_info, bool)
+
+#ifdef WASMTIME_FEATURE_CACHE
+
+/**
+ * \brief Enables Wasmtime's cache and loads configuration from the specified
+ * path.
+ *
+ * By default the Wasmtime compilation cache is disabled. The configuration path
+ * here can be `NULL` to use the default settings, and otherwise the argument
+ * here must be a file on the filesystem with TOML configuration -
+ * https://bytecodealliance.github.io/wasmtime/cli-cache.html.
+ *
+ * An error is returned if the cache configuration could not be loaded or if the
+ * cache could not be enabled.
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_config_cache_config_load(wasm_config_t *, const char *);
+
+#endif // WASMTIME_FEATURE_CACHE
+
+#ifdef WASMTIME_FEATURE_COMPILER
+
+/**
+ * \brief Configures the target triple that this configuration will produce
+ * machine code for.
+ *
+ * This option defaults to the native host. Calling this method will
+ * additionally disable inference of the native features of the host (e.g.
+ * detection of SSE4.2 on x86_64 hosts). Native features can be reenabled with
+ * the `cranelift_flag_{set,enable}` properties.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.config
+ */
+WASMTIME_CONFIG_PROP(wasmtime_error_t *, target, const char *)
+
+/**
+ * \brief Enables a target-specific flag in Cranelift.
+ *
+ * This can be used, for example, to enable SSE4.2 on x86_64 hosts. Settings can
+ * be explored with `wasmtime settings` on the CLI.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.cranelift_flag_enable
+ */
+WASM_API_EXTERN void wasmtime_config_cranelift_flag_enable(wasm_config_t *,
+                                                           const char *);
+
+/**
+ * \brief Sets a target-specific flag in Cranelift to the specified value.
+ *
+ * This can be used, for example, to enable SSE4.2 on x86_64 hosts. Settings can
+ * be explored with `wasmtime settings` on the CLI.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.cranelift_flag_set
+ */
+WASM_API_EXTERN void wasmtime_config_cranelift_flag_set(wasm_config_t *,
+                                                        const char *key,
+                                                        const char *value);
+
+#endif // WASMTIME_FEATURE_COMPILER
+
+/**
+ * \brief Configures whether, when on macOS, Mach ports are used for exception
+ * handling instead of traditional Unix-based signal handling.
+ *
+ * This option defaults to true, using Mach ports by default.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.macos_use_mach_ports
+ */
+WASMTIME_CONFIG_PROP(void, macos_use_mach_ports, bool)
+
+/**
+ * Return the data from a LinearMemory instance.
+ *
+ * The size in bytes as well as the maximum number of bytes that can be
+ * allocated should be returned as well.
+ *
+ * For more information about see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.LinearMemory.html
+ */
+typedef uint8_t *(*wasmtime_memory_get_callback_t)(void *env, size_t *byte_size,
+                                                   size_t *byte_capacity);
+
+/**
+ * Grow the memory to the `new_size` in bytes.
+ *
+ * For more information about the parameters see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.LinearMemory.html#tymethod.grow_to
+ */
+typedef wasmtime_error_t *(*wasmtime_memory_grow_callback_t)(void *env,
+                                                             size_t new_size);
+
+/**
+ * A LinearMemory instance created from a #wasmtime_new_memory_callback_t.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.LinearMemory.html
+ */
+typedef struct wasmtime_linear_memory {
+  /// User provided value to be passed to get_memory and grow_memory
+  void *env;
+  /// Callback to get the memory and size of this LinearMemory
+  wasmtime_memory_get_callback_t get_memory;
+  /// Callback to request growing the memory
+  wasmtime_memory_grow_callback_t grow_memory;
+  /// An optional finalizer for env
+  void (*finalizer)(void *);
+} wasmtime_linear_memory_t;
+
+/**
+ * A callback to create a new LinearMemory from the specified parameters.
+ *
+ * The result should be written to `memory_ret` and wasmtime will own the values
+ * written into that struct.
+ *
+ * This callback must be thread-safe.
+ *
+ * For more information about the parameters see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.MemoryCreator.html#tymethod.new_memory
+ */
+typedef wasmtime_error_t *(*wasmtime_new_memory_callback_t)(
+    void *env, const wasm_memorytype_t *ty, size_t minimum, size_t maximum,
+    size_t reserved_size_in_bytes, size_t guard_size_in_bytes,
+    wasmtime_linear_memory_t *memory_ret);
+
+/**
+ * A representation of custom memory creator and methods for an instance of
+ * LinearMemory.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/trait.MemoryCreator.html
+ */
+typedef struct wasmtime_memory_creator {
+  /// User provided value to be passed to new_memory
+  void *env;
+  /// The callback to create new memory, must be thread safe
+  wasmtime_new_memory_callback_t new_memory;
+  /// An optional finalizer for env.
+  void (*finalizer)(void *);
+} wasmtime_memory_creator_t;
+
+/**
+ * Sets a custom memory creator.
+ *
+ * Custom memory creators are used when creating host Memory objects or when
+ * creating instance linear memories for the on-demand instance allocation
+ * strategy.
+ *
+ * The config does **not** take ownership of the #wasmtime_memory_creator_t
+ * passed in, but instead copies all the values in the struct.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.with_host_memory
+ */
+WASM_API_EXTERN void
+wasmtime_config_host_memory_creator_set(wasm_config_t *,
+                                        wasmtime_memory_creator_t *);
+
+/**
+ * \brief Configures whether copy-on-write memory-mapped data is used to
+ * initialize a linear memory.
+ *
+ * Initializing linear memory via a copy-on-write mapping can drastically
+ * improve instantiation costs of a WebAssembly module because copying memory is
+ * deferred. Additionally if a page of memory is only ever read from WebAssembly
+ * and never written too then the same underlying page of data will be reused
+ * between all instantiations of a module meaning that if a module is
+ * instantiated many times this can lower the overall memory required needed to
+ * run that module.
+ *
+ * This option defaults to true.
+ *
+ * For more information see the Rust documentation at
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.memory_init_cow
+ */
+WASMTIME_CONFIG_PROP(void, memory_init_cow, bool)
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_CONFIG_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/engine.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/engine.h
similarity index 71%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/engine.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/engine.h
index 1b8336f46..6b666bf5f 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/engine.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/engine.h
@@ -13,6 +13,14 @@
 extern "C" {
 #endif
 
+/**
+ * \brief Create a new reference to the same underlying engine.
+ *
+ * This function clones the reference-counted pointer to the internal object,
+ * and must be freed using #wasm_engine_delete.
+ */
+WASM_API_EXTERN wasm_engine_t *wasmtime_engine_clone(wasm_engine_t *engine);
+
 /**
  * \brief Increments the engine-local epoch variable.
  *
@@ -28,9 +36,7 @@ extern "C" {
 WASM_API_EXTERN void wasmtime_engine_increment_epoch(wasm_engine_t *engine);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_ENGINE_H
-
-
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/error.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/error.h
similarity index 81%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/error.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/error.h
index cfa0c9690..ad9172543 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/error.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/error.h
@@ -30,6 +30,11 @@ extern "C" {
  */
 typedef struct wasmtime_error wasmtime_error_t;
 
+/**
+ * \brief Creates a new error with the provided message.
+ */
+WASM_API_EXTERN wasmtime_error_t *wasmtime_error_new(const char *);
+
 /**
  * \brief Deletes an error.
  */
@@ -43,10 +48,8 @@ WASM_API_EXTERN void wasmtime_error_delete(wasmtime_error_t *error);
  * uninitialized before this function is called and the caller is responsible
  * for deallocating it with #wasm_byte_vec_delete afterwards.
  */
-WASM_API_EXTERN void wasmtime_error_message(
-    const wasmtime_error_t *error,
-    wasm_name_t *message
-);
+WASM_API_EXTERN void wasmtime_error_message(const wasmtime_error_t *error,
+                                            wasm_name_t *message);
 
 /**
  * \brief Attempts to extract a WASI-specific exit status from this error.
@@ -55,7 +58,8 @@ WASM_API_EXTERN void wasmtime_error_message(
  * If `true` is returned then the exit status is returned through the `status`
  * pointer. If `false` is returned then this is not a wasi exit trap.
  */
-WASM_API_EXTERN bool wasmtime_error_exit_status(const wasmtime_error_t*, int *status);
+WASM_API_EXTERN bool wasmtime_error_exit_status(const wasmtime_error_t *,
+                                                int *status);
 
 /**
  * \brief Attempts to extract a WebAssembly trace from this error.
@@ -64,10 +68,11 @@ WASM_API_EXTERN bool wasmtime_error_exit_status(const wasmtime_error_t*, int *st
  * as input. The `out` argument will be filled in with the wasm trace, if
  * present.
  */
-WASM_API_EXTERN void wasmtime_error_wasm_trace(const wasmtime_error_t*, wasm_frame_vec_t *out);
+WASM_API_EXTERN void wasmtime_error_wasm_trace(const wasmtime_error_t *,
+                                               wasm_frame_vec_t *out);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_ERROR_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/extern.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/extern.h
similarity index 51%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/extern.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/extern.h
index 29dcb217f..347f2b51b 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/extern.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/extern.h
@@ -8,6 +8,7 @@
 #define WASMTIME_EXTERN_H
 
 #include <wasmtime/module.h>
+#include <wasmtime/sharedmemory.h>
 #include <wasmtime/store.h>
 
 #ifdef __cplusplus
@@ -16,58 +17,62 @@ extern "C" {
 
 /// \brief Representation of a function in Wasmtime.
 ///
-/// Functions are represented with a 64-bit identifying integer in Wasmtime.
-/// They do not have any destructor associated with them. Functions cannot
-/// interoperate between #wasmtime_store_t instances and if the wrong function
-/// is passed to the wrong store then it may trigger an assertion to abort the
-/// process.
+/// Functions in Wasmtime are represented as an index into a store and don't
+/// have any data or destructor associated with the #wasmtime_func_t value.
+/// Functions cannot interoperate between #wasmtime_store_t instances and if the
+/// wrong function is passed to the wrong store then it may trigger an assertion
+/// to abort the process.
 typedef struct wasmtime_func {
-  /// Internal identifier of what store this belongs to, never zero.
+  /// Internal identifier of what store this belongs to.
+  ///
+  /// This field may be zero when used in conjunction with #wasmtime_val_t
+  /// to represent a null `funcref` value in WebAssembly. For a valid function
+  /// this field is otherwise never zero.
   uint64_t store_id;
-  /// Internal index within the store.
-  size_t index;
+  /// Private field for Wasmtime, undefined if `store_id` is zero.
+  size_t __private;
 } wasmtime_func_t;
 
 /// \brief Representation of a table in Wasmtime.
 ///
-/// Tables are represented with a 64-bit identifying integer in Wasmtime.
-/// They do not have any destructor associated with them. Tables cannot
-/// interoperate between #wasmtime_store_t instances and if the wrong table
-/// is passed to the wrong store then it may trigger an assertion to abort the
-/// process.
+/// Tables in Wasmtime are represented as an index into a store and don't
+/// have any data or destructor associated with the #wasmtime_table_t value.
+/// Tables cannot interoperate between #wasmtime_store_t instances and if the
+/// wrong table is passed to the wrong store then it may trigger an assertion
+/// to abort the process.
 typedef struct wasmtime_table {
   /// Internal identifier of what store this belongs to, never zero.
   uint64_t store_id;
-  /// Internal index within the store.
-  size_t index;
+  /// Private field for Wasmtime.
+  size_t __private;
 } wasmtime_table_t;
 
 /// \brief Representation of a memory in Wasmtime.
 ///
-/// Memories are represented with a 64-bit identifying integer in Wasmtime.
-/// They do not have any destructor associated with them. Memories cannot
-/// interoperate between #wasmtime_store_t instances and if the wrong memory
-/// is passed to the wrong store then it may trigger an assertion to abort the
-/// process.
+/// Memories in Wasmtime are represented as an index into a store and don't
+/// have any data or destructor associated with the #wasmtime_memory_t value.
+/// Memories cannot interoperate between #wasmtime_store_t instances and if the
+/// wrong memory is passed to the wrong store then it may trigger an assertion
+/// to abort the process.
 typedef struct wasmtime_memory {
   /// Internal identifier of what store this belongs to, never zero.
   uint64_t store_id;
-  /// Internal index within the store.
-  size_t index;
+  /// Private field for Wasmtime.
+  size_t __private;
 } wasmtime_memory_t;
 
 /// \brief Representation of a global in Wasmtime.
 ///
-/// Globals are represented with a 64-bit identifying integer in Wasmtime.
-/// They do not have any destructor associated with them. Globals cannot
-/// interoperate between #wasmtime_store_t instances and if the wrong global
-/// is passed to the wrong store then it may trigger an assertion to abort the
-/// process.
+/// Globals in Wasmtime are represented as an index into a store and don't
+/// have any data or destructor associated with the #wasmtime_global_t value.
+/// Globals cannot interoperate between #wasmtime_store_t instances and if the
+/// wrong global is passed to the wrong store then it may trigger an assertion
+/// to abort the process.
 typedef struct wasmtime_global {
   /// Internal identifier of what store this belongs to, never zero.
   uint64_t store_id;
-  /// Internal index within the store.
-  size_t index;
+  /// Private field for Wasmtime.
+  size_t __private;
 } wasmtime_global_t;
 
 /// \brief Discriminant of #wasmtime_extern_t
@@ -85,6 +90,9 @@ typedef uint8_t wasmtime_extern_kind_t;
 /// \brief Value of #wasmtime_extern_kind_t meaning that #wasmtime_extern_t is a
 /// memory
 #define WASMTIME_EXTERN_MEMORY 3
+/// \brief Value of #wasmtime_extern_kind_t meaning that #wasmtime_extern_t is a
+/// shared memory
+#define WASMTIME_EXTERN_SHAREDMEMORY 4
 
 /**
  * \typedef wasmtime_extern_union_t
@@ -97,14 +105,16 @@ typedef uint8_t wasmtime_extern_kind_t;
  * various kinds of items an extern wasm item can be.
  */
 typedef union wasmtime_extern_union {
-    /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_FUNC
-    wasmtime_func_t func;
-    /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_GLOBAL
-    wasmtime_global_t global;
-    /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_TABLE
-    wasmtime_table_t table;
-    /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_MEMORY
-    wasmtime_memory_t memory;
+  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_FUNC
+  wasmtime_func_t func;
+  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_GLOBAL
+  wasmtime_global_t global;
+  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_TABLE
+  wasmtime_table_t table;
+  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_MEMORY
+  wasmtime_memory_t memory;
+  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_SHAREDMEMORY
+  struct wasmtime_sharedmemory *sharedmemory;
 } wasmtime_extern_union_t;
 
 /**
@@ -121,10 +131,10 @@ typedef union wasmtime_extern_union {
  * deallocate the value.
  */
 typedef struct wasmtime_extern {
-    /// Discriminant of which field of #of is valid.
-    wasmtime_extern_kind_t kind;
-    /// Container for the extern item's value.
-    wasmtime_extern_union_t of;
+  /// Discriminant of which field of #of is valid.
+  wasmtime_extern_kind_t kind;
+  /// Container for the extern item's value.
+  wasmtime_extern_union_t of;
 } wasmtime_extern_t;
 
 /// \brief Deletes a #wasmtime_extern_t.
@@ -135,11 +145,11 @@ void wasmtime_extern_delete(wasmtime_extern_t *val);
 ///
 /// Does not take ownership of `context` or `val`, but the returned
 /// #wasm_externtype_t is an owned value that needs to be deleted.
-wasm_externtype_t *wasmtime_extern_type(wasmtime_context_t *context, wasmtime_extern_t *val);
+wasm_externtype_t *wasmtime_extern_type(wasmtime_context_t *context,
+                                        wasmtime_extern_t *val);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_EXTERN_H
-
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/func.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/func.h
similarity index 81%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/func.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/func.h
index e65d002c6..41ff907c3 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/func.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/func.h
@@ -8,9 +8,9 @@
 #define WASMTIME_FUNC_H
 
 #include <wasm.h>
-#include <wasmtime/val.h>
-#include <wasmtime/store.h>
 #include <wasmtime/extern.h>
+#include <wasmtime/store.h>
+#include <wasmtime/val.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -54,13 +54,9 @@ typedef struct wasmtime_caller wasmtime_caller_t;
  * should be raised in WebAssembly. It's expected that in this case the caller
  * relinquishes ownership of the trap and it is passed back to the engine.
  */
-typedef wasm_trap_t* (*wasmtime_func_callback_t)(
-    void *env,
-    wasmtime_caller_t* caller,
-    const wasmtime_val_t *args,
-    size_t nargs,
-    wasmtime_val_t *results,
-    size_t nresults);
+typedef wasm_trap_t *(*wasmtime_func_callback_t)(
+    void *env, wasmtime_caller_t *caller, const wasmtime_val_t *args,
+    size_t nargs, wasmtime_val_t *results, size_t nresults);
 
 /**
  * \brief Creates a new host-defined function.
@@ -78,14 +74,11 @@ typedef wasm_trap_t* (*wasmtime_func_callback_t)(
  *
  * The returned function can only be used with the specified `store`.
  */
-WASM_API_EXTERN void wasmtime_func_new(
-  wasmtime_context_t *store,
-  const wasm_functype_t* type,
-  wasmtime_func_callback_t callback,
-  void *env,
-  void (*finalizer)(void*),
-  wasmtime_func_t *ret
-);
+WASM_API_EXTERN void wasmtime_func_new(wasmtime_context_t *store,
+                                       const wasm_functype_t *type,
+                                       wasmtime_func_callback_t callback,
+                                       void *env, void (*finalizer)(void *),
+                                       wasmtime_func_t *ret);
 
 /**
  * \brief Callback signature for #wasmtime_func_new_unchecked.
@@ -120,10 +113,8 @@ WASM_API_EXTERN void wasmtime_func_new(
  * array. Results are also written starting at index 0, which will overwrite
  * the arguments.
  */
-typedef wasm_trap_t* (*wasmtime_func_unchecked_callback_t)(
-    void *env,
-    wasmtime_caller_t* caller,
-    wasmtime_val_raw_t *args_and_results,
+typedef wasm_trap_t *(*wasmtime_func_unchecked_callback_t)(
+    void *env, wasmtime_caller_t *caller, wasmtime_val_raw_t *args_and_results,
     size_t num_args_and_results);
 
 /**
@@ -151,23 +142,18 @@ typedef wasm_trap_t* (*wasmtime_func_unchecked_callback_t)(
  * existence).
  */
 WASM_API_EXTERN void wasmtime_func_new_unchecked(
-  wasmtime_context_t *store,
-  const wasm_functype_t* type,
-  wasmtime_func_unchecked_callback_t callback,
-  void *env,
-  void (*finalizer)(void*),
-  wasmtime_func_t *ret
-);
+    wasmtime_context_t *store, const wasm_functype_t *type,
+    wasmtime_func_unchecked_callback_t callback, void *env,
+    void (*finalizer)(void *), wasmtime_func_t *ret);
 
 /**
  * \brief Returns the type of the function specified
  *
  * The returned #wasm_functype_t is owned by the caller.
  */
-WASM_API_EXTERN wasm_functype_t* wasmtime_func_type(
-    const wasmtime_context_t *store,
-    const wasmtime_func_t *func
-);
+WASM_API_EXTERN wasm_functype_t *
+wasmtime_func_type(const wasmtime_context_t *store,
+                   const wasmtime_func_t *func);
 
 /**
  * \brief Call a WebAssembly function.
@@ -204,15 +190,11 @@ WASM_API_EXTERN wasm_functype_t* wasmtime_func_type(
  * Does not take ownership of #wasmtime_val_t arguments. Gives ownership of
  * #wasmtime_val_t results.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_func_call(
-    wasmtime_context_t *store,
-    const wasmtime_func_t *func,
-    const wasmtime_val_t *args,
-    size_t nargs,
-    wasmtime_val_t *results,
-    size_t nresults,
-    wasm_trap_t **trap
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_func_call(wasmtime_context_t *store, const wasmtime_func_t *func,
+                   const wasmtime_val_t *args, size_t nargs,
+                   wasmtime_val_t *results, size_t nresults,
+                   wasm_trap_t **trap);
 
 /**
  * \brief Call a WebAssembly function in an "unchecked" fashion.
@@ -233,6 +215,8 @@ WASM_API_EXTERN wasmtime_error_t *wasmtime_func_call(
  *
  * * The `args_and_results` pointer has enough space to hold all the parameters
  *   and all the results (but not at the same time).
+ * * The `args_and_results_len` contains the length of the `args_and_results`
+ *   buffer.
  * * Parameters must all be configured as if they were the correct type.
  * * Values such as `externref` and `funcref` are valid within the store being
  *   called.
@@ -241,12 +225,11 @@ WASM_API_EXTERN wasmtime_error_t *wasmtime_func_call(
  * faster than that function, but the tradeoff is that embeddings must uphold
  * more invariants rather than relying on Wasmtime to check them for you.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_func_call_unchecked(
-    wasmtime_context_t *store,
-    const wasmtime_func_t *func,
-    wasmtime_val_raw_t *args_and_results,
-    wasm_trap_t **trap
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_func_call_unchecked(wasmtime_context_t *store,
+                             const wasmtime_func_t *func,
+                             wasmtime_val_raw_t *args_and_results,
+                             size_t args_and_results_len, wasm_trap_t **trap);
 
 /**
  * \brief Loads a #wasmtime_extern_t from the caller's context
@@ -266,17 +249,16 @@ WASM_API_EXTERN wasmtime_error_t *wasmtime_func_call_unchecked(
  * Returns a nonzero value if the export was found, or 0 if the export wasn't
  * found. If the export wasn't found then `item` isn't written to.
  */
-WASM_API_EXTERN bool wasmtime_caller_export_get(
-    wasmtime_caller_t *caller,
-    const char *name,
-    size_t name_len,
-    wasmtime_extern_t *item
-);
+WASM_API_EXTERN bool wasmtime_caller_export_get(wasmtime_caller_t *caller,
+                                                const char *name,
+                                                size_t name_len,
+                                                wasmtime_extern_t *item);
 
 /**
  * \brief Returns the store context of the caller object.
  */
-WASM_API_EXTERN wasmtime_context_t* wasmtime_caller_context(wasmtime_caller_t* caller);
+WASM_API_EXTERN wasmtime_context_t *
+wasmtime_caller_context(wasmtime_caller_t *caller);
 
 /**
  * \brief Converts a `raw` nonzero `funcref` value from #wasmtime_val_raw_t
@@ -291,21 +273,18 @@ WASM_API_EXTERN wasmtime_context_t* wasmtime_caller_context(wasmtime_caller_t* c
  * #wasmtime_context_t that they were produced from. Providing arbitrary values
  * to `raw` here or cross-context values with `context` is UB.
  */
-WASM_API_EXTERN void wasmtime_func_from_raw(
-    wasmtime_context_t* context,
-    size_t raw,
-    wasmtime_func_t *ret);
+WASM_API_EXTERN void wasmtime_func_from_raw(wasmtime_context_t *context,
+                                            void *raw, wasmtime_func_t *ret);
 
 /**
  * \brief Converts a `func`  which belongs to `context` into a `usize`
  * parameter that is suitable for insertion into a #wasmtime_val_raw_t.
  */
-WASM_API_EXTERN size_t wasmtime_func_to_raw(
-    wasmtime_context_t* context,
-    const wasmtime_func_t *func);
+WASM_API_EXTERN void *wasmtime_func_to_raw(wasmtime_context_t *context,
+                                           const wasmtime_func_t *func);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_FUNC_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/global.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/global.h
similarity index 68%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/global.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/global.h
index 4e244285a..8b20af915 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/global.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/global.h
@@ -33,22 +33,18 @@ extern "C" {
  * This function does not take ownership of any of its arguments but error is
  * owned by the caller.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_global_new(
-    wasmtime_context_t *store,
-    const wasm_globaltype_t *type,
-    const wasmtime_val_t *val,
-    wasmtime_global_t *ret
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_global_new(wasmtime_context_t *store, const wasm_globaltype_t *type,
+                    const wasmtime_val_t *val, wasmtime_global_t *ret);
 
 /**
  * \brief Returns the wasm type of the specified global.
  *
  * The returned #wasm_globaltype_t is owned by the caller.
  */
-WASM_API_EXTERN wasm_globaltype_t* wasmtime_global_type(
-    const wasmtime_context_t *store,
-    const wasmtime_global_t *global
-);
+WASM_API_EXTERN wasm_globaltype_t *
+wasmtime_global_type(const wasmtime_context_t *store,
+                     const wasmtime_global_t *global);
 
 /**
  * \brief Get the value of the specified global.
@@ -58,13 +54,11 @@ WASM_API_EXTERN wasm_globaltype_t* wasmtime_global_type(
  * \param out where to store the value in this global.
  *
  * This function returns ownership of the contents of `out`, so
- * #wasmtime_val_delete may need to be called on the value.
+ * #wasmtime_val_unroot may need to be called on the value.
  */
-WASM_API_EXTERN void wasmtime_global_get(
-    wasmtime_context_t *store,
-    const wasmtime_global_t *global,
-    wasmtime_val_t *out
-);
+WASM_API_EXTERN void wasmtime_global_get(wasmtime_context_t *store,
+                                         const wasmtime_global_t *global,
+                                         wasmtime_val_t *out);
 
 /**
  * \brief Sets a global to a new value.
@@ -76,16 +70,15 @@ WASM_API_EXTERN void wasmtime_global_get(
  * This function may return an error if `global` is not mutable or if `val` has
  * the wrong type for `global`.
  *
- * THis does not take ownership of any argument but returns ownership of the error.
+ * THis does not take ownership of any argument but returns ownership of the
+ * error.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_global_set(
-    wasmtime_context_t *store,
-    const wasmtime_global_t *global,
-    const wasmtime_val_t *val
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_global_set(wasmtime_context_t *store, const wasmtime_global_t *global,
+                    const wasmtime_val_t *val);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_GLOBAL_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/instance.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/instance.h
similarity index 58%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/instance.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/instance.h
index 544661f9d..0d63cfb7a 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/instance.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/instance.h
@@ -62,14 +62,11 @@ typedef struct wasmtime_instance {
  * This function does not take ownership of any of its arguments, but all return
  * values are owned by the caller.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_instance_new(
-    wasmtime_context_t *store,
-    const wasmtime_module_t *module,
-    const wasmtime_extern_t* imports,
-    size_t nimports,
-    wasmtime_instance_t *instance,
-    wasm_trap_t **trap
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_instance_new(wasmtime_context_t *store,
+                      const wasmtime_module_t *module,
+                      const wasmtime_extern_t *imports, size_t nimports,
+                      wasmtime_instance_t *instance, wasm_trap_t **trap);
 
 /**
  * \brief Get an export by name from an instance.
@@ -87,12 +84,8 @@ WASM_API_EXTERN wasmtime_error_t *wasmtime_instance_new(
  * #wasmtime_extern_t.
  */
 WASM_API_EXTERN bool wasmtime_instance_export_get(
-    wasmtime_context_t *store,
-    const wasmtime_instance_t *instance,
-    const char *name,
-    size_t name_len,
-    wasmtime_extern_t *item
-);
+    wasmtime_context_t *store, const wasmtime_instance_t *instance,
+    const char *name, size_t name_len, wasmtime_extern_t *item);
 
 /**
  * \brief Get an export by index from an instance.
@@ -113,16 +106,64 @@ WASM_API_EXTERN bool wasmtime_instance_export_get(
  * #wasmtime_context_t.
  */
 WASM_API_EXTERN bool wasmtime_instance_export_nth(
-    wasmtime_context_t *store,
-    const wasmtime_instance_t *instance,
-    size_t index,
-    char **name,
-    size_t *name_len,
-    wasmtime_extern_t *item
-);
+    wasmtime_context_t *store, const wasmtime_instance_t *instance,
+    size_t index, char **name, size_t *name_len, wasmtime_extern_t *item);
+
+/**
+ * \brief A #wasmtime_instance_t, pre-instantiation, that is ready to be
+ * instantiated.
+ *
+ * Must be deleted using #wasmtime_instance_pre_delete.
+ *
+ * For more information see the Rust documentation:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.InstancePre.html
+ */
+typedef struct wasmtime_instance_pre wasmtime_instance_pre_t;
+
+/**
+ * \brief Delete a previously created wasmtime_instance_pre_t.
+ */
+WASM_API_EXTERN void
+wasmtime_instance_pre_delete(wasmtime_instance_pre_t *instance_pre);
+
+/**
+ * \brief Instantiates instance within the given store.
+ *
+ * This will also run the function's startup function, if there is one.
+ *
+ * For more information on instantiation see #wasmtime_instance_new.
+ *
+ * \param instance_pre the pre-initialized instance
+ * \param store the store in which to create the instance
+ * \param instance where to store the returned instance
+ * \param trap_ptr where to store the returned trap
+ *
+ * \return One of three things can happen as a result of this function. First
+ * the module could be successfully instantiated and returned through
+ * `instance`, meaning the return value and `trap` are both set to `NULL`.
+ * Second the start function may trap, meaning the return value and `instance`
+ * are set to `NULL` and `trap` describes the trap that happens. Finally
+ * instantiation may fail for another reason, in which case an error is returned
+ * and `trap` and `instance` are set to `NULL`.
+ *
+ * This function does not take ownership of any of its arguments, and all return
+ * values are owned by the caller.
+ */
+WASM_API_EXTERN wasmtime_error_t *wasmtime_instance_pre_instantiate(
+    const wasmtime_instance_pre_t *instance_pre, wasmtime_store_t *store,
+    wasmtime_instance_t *instance, wasm_trap_t **trap_ptr);
+
+/**
+ * \brief Get the module (as a shallow clone) for a instance_pre.
+ *
+ * The returned module is owned by the caller and the caller **must**
+ * delete it via `wasmtime_module_delete`.
+ */
+WASM_API_EXTERN wasmtime_module_t *
+wasmtime_instance_pre_module(wasmtime_instance_pre_t *instance_pre);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_INSTANCE_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/linker.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/linker.h
similarity index 69%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/linker.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/linker.h
index edd52442d..0a793d1e6 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/linker.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/linker.h
@@ -8,9 +8,10 @@
 #define WASMTIME_LINKER_H
 
 #include <wasm.h>
+#include <wasmtime/conf.h>
 #include <wasmtime/error.h>
-#include <wasmtime/store.h>
 #include <wasmtime/extern.h>
+#include <wasmtime/store.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -40,12 +41,21 @@ typedef struct wasmtime_linker wasmtime_linker_t;
  * This function does not take ownership of the engine argument, and the caller
  * is expected to delete the returned linker.
  */
-WASM_API_EXTERN wasmtime_linker_t* wasmtime_linker_new(wasm_engine_t* engine);
+WASM_API_EXTERN wasmtime_linker_t *wasmtime_linker_new(wasm_engine_t *engine);
+
+/**
+ * \brief Clones existing linker.
+ *
+ * This function does not take ownership of the linker argument, and the caller
+ * is expected to delete the returned linker.
+ */
+WASM_API_EXTERN wasmtime_linker_t *
+wasmtime_linker_clone(wasmtime_linker_t *linker);
 
 /**
  * \brief Deletes a linker
  */
-WASM_API_EXTERN void wasmtime_linker_delete(wasmtime_linker_t* linker);
+WASM_API_EXTERN void wasmtime_linker_delete(wasmtime_linker_t *linker);
 
 /**
  * \brief Configures whether this linker allows later definitions to shadow
@@ -53,12 +63,14 @@ WASM_API_EXTERN void wasmtime_linker_delete(wasmtime_linker_t* linker);
  *
  * By default this setting is `false`.
  */
-WASM_API_EXTERN void wasmtime_linker_allow_shadowing(wasmtime_linker_t* linker, bool allow_shadowing);
+WASM_API_EXTERN void wasmtime_linker_allow_shadowing(wasmtime_linker_t *linker,
+                                                     bool allow_shadowing);
 
 /**
  * \brief Defines a new item in this linker.
  *
  * \param linker the linker the name is being defined in.
+ * \param store the store that the `item` is owned by.
  * \param module the module name the item is defined under.
  * \param module_len the byte length of `module`
  * \param name the field name the item is defined under
@@ -71,14 +83,10 @@ WASM_API_EXTERN void wasmtime_linker_allow_shadowing(wasmtime_linker_t* linker,
  * For more information about name resolution consult the [Rust
  * documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define(
-    wasmtime_linker_t *linker,
-    const char *module,
-    size_t module_len,
-    const char *name,
-    size_t name_len,
-    const wasmtime_extern_t *item
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_linker_define(wasmtime_linker_t *linker, wasmtime_context_t *store,
+                       const char *module, size_t module_len, const char *name,
+                       size_t name_len, const wasmtime_extern_t *item);
 
 /**
  * \brief Defines a new function in this linker.
@@ -90,7 +98,8 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define(
  * \param name_len the byte length of `name`
  * \param ty the type of the function that's being defined
  * \param cb the host callback to invoke when the function is called
- * \param data the host-provided data to provide as the first argument to the callback
+ * \param data the host-provided data to provide as the first argument to the
+ *        callback
  * \param finalizer an optional finalizer for the `data` argument.
  *
  * \return On success `NULL` is returned, otherwise an error is returned which
@@ -105,17 +114,10 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define(
  *
  * For more information about host callbacks see #wasmtime_func_new.
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_func(
-    wasmtime_linker_t *linker,
-    const char *module,
-    size_t module_len,
-    const char *name,
-    size_t name_len,
-    const wasm_functype_t *ty,
-    wasmtime_func_callback_t cb,
-    void *data,
-    void (*finalizer)(void*)
-);
+WASM_API_EXTERN wasmtime_error_t *wasmtime_linker_define_func(
+    wasmtime_linker_t *linker, const char *module, size_t module_len,
+    const char *name, size_t name_len, const wasm_functype_t *ty,
+    wasmtime_func_callback_t cb, void *data, void (*finalizer)(void *));
 
 /**
  * \brief Defines a new function in this linker.
@@ -126,17 +128,13 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_func(
  * information as well as #wasmtime_func_new_unchecked for why this is an
  * unsafe API.
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_func_unchecked(
-    wasmtime_linker_t *linker,
-    const char *module,
-    size_t module_len,
-    const char *name,
-    size_t name_len,
-    const wasm_functype_t *ty,
-    wasmtime_func_unchecked_callback_t cb,
-    void *data,
-    void (*finalizer)(void*)
-);
+WASM_API_EXTERN wasmtime_error_t *wasmtime_linker_define_func_unchecked(
+    wasmtime_linker_t *linker, const char *module, size_t module_len,
+    const char *name, size_t name_len, const wasm_functype_t *ty,
+    wasmtime_func_unchecked_callback_t cb, void *data,
+    void (*finalizer)(void *));
+
+#ifdef WASMTIME_FEATURE_WASI
 
 /**
  * \brief Defines WASI functions in this linker.
@@ -155,9 +153,10 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_func_unchecked(
  * For more information about name resolution consult the [Rust
  * documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_wasi(
-    wasmtime_linker_t *linker
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_linker_define_wasi(wasmtime_linker_t *linker);
+
+#endif // WASMTIME_FEATURE_WASI
 
 /**
  * \brief Defines an instance under the specified name in this linker.
@@ -178,13 +177,9 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_wasi(
  * For more information about name resolution consult the [Rust
  * documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_instance(
-    wasmtime_linker_t *linker,
-    wasmtime_context_t *store,
-    const char *name,
-    size_t name_len,
-    const wasmtime_instance_t *instance
-);
+WASM_API_EXTERN wasmtime_error_t *wasmtime_linker_define_instance(
+    wasmtime_linker_t *linker, wasmtime_context_t *store, const char *name,
+    size_t name_len, const wasmtime_instance_t *instance);
 
 /**
  * \brief Instantiates a #wasm_module_t with the items defined in this linker.
@@ -208,13 +203,11 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_define_instance(
  * defined in the linker than an error is returned. (or if the previously
  * defined item is of the wrong type).
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_instantiate(
-    const wasmtime_linker_t *linker,
-    wasmtime_context_t *store,
-    const wasmtime_module_t *module,
-    wasmtime_instance_t *instance,
-    wasm_trap_t **trap
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_linker_instantiate(const wasmtime_linker_t *linker,
+                            wasmtime_context_t *store,
+                            const wasmtime_module_t *module,
+                            wasmtime_instance_t *instance, wasm_trap_t **trap);
 
 /**
  * \brief Defines automatic instantiations of a #wasm_module_t in this linker.
@@ -235,13 +228,10 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_instantiate(
  * For more information see the [Rust
  * documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#method.module).
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_module(
-    wasmtime_linker_t *linker,
-    wasmtime_context_t *store,
-    const char *name,
-    size_t name_len,
-    const wasmtime_module_t *module
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_linker_module(wasmtime_linker_t *linker, wasmtime_context_t *store,
+                       const char *name, size_t name_len,
+                       const wasmtime_module_t *module);
 
 /**
  * \brief Acquires the "default export" of the named module in this linker.
@@ -258,13 +248,10 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_module(
  * For more information see the [Rust
  * documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#method.get_default).
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_get_default(
-    const wasmtime_linker_t *linker,
-    wasmtime_context_t *store,
-    const char *name,
-    size_t name_len,
-    wasmtime_func_t *func
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_linker_get_default(const wasmtime_linker_t *linker,
+                            wasmtime_context_t *store, const char *name,
+                            size_t name_len, wasmtime_func_t *func);
 
 /**
  * \brief Loads an item by name from this linker.
@@ -280,18 +267,32 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_linker_get_default(
  * \return A nonzero value if the item is defined, in which case `item` is also
  * filled in. Otherwise zero is returned.
  */
-WASM_API_EXTERN bool wasmtime_linker_get(
-    const wasmtime_linker_t *linker,
-    wasmtime_context_t *store,
-    const char *module,
-    size_t module_len,
-    const char *name,
-    size_t name_len,
-    wasmtime_extern_t *item
-);
+WASM_API_EXTERN bool wasmtime_linker_get(const wasmtime_linker_t *linker,
+                                         wasmtime_context_t *store,
+                                         const char *module, size_t module_len,
+                                         const char *name, size_t name_len,
+                                         wasmtime_extern_t *item);
+
+/**
+ * \brief Perform all the checks for instantiating `module` with the linker,
+ *        except that instantiation doesn't actually finish.
+ *
+ * \param linker the linker used to instantiate the provided module.
+ * \param module the module that is being instantiated.
+ * \param instance_pre the returned instance_pre, if successful.
+ *
+ * \return An error or `NULL` if successful.
+ *
+ * For more information see the Rust documentation at:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.instantiate_pre
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_linker_instantiate_pre(const wasmtime_linker_t *linker,
+                                const wasmtime_module_t *module,
+                                wasmtime_instance_pre_t **instance_pre);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_LINKER_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/memory.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/memory.h
similarity index 63%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/memory.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/memory.h
index 6aecbaffb..50ce7fa7b 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/memory.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/memory.h
@@ -8,9 +8,9 @@
 #define WASMTIME_MEMORY_H
 
 #include <wasm.h>
+#include <wasmtime/error.h>
 #include <wasmtime/extern.h>
 #include <wasmtime/store.h>
-#include <wasmtime/error.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -22,7 +22,9 @@ extern "C" {
  * Note that this function is preferred over #wasm_memorytype_new for
  * compatibility with the memory64 proposal.
  */
-WASM_API_EXTERN wasm_memorytype_t *wasmtime_memorytype_new(uint64_t min, bool max_present, uint64_t max, bool is_64);
+WASM_API_EXTERN wasm_memorytype_t *
+wasmtime_memorytype_new(uint64_t min, bool max_present, uint64_t max,
+                        bool is_64, bool shared);
 
 /**
  * \brief Returns the minimum size, in pages, of the specified memory type.
@@ -30,7 +32,8 @@ WASM_API_EXTERN wasm_memorytype_t *wasmtime_memorytype_new(uint64_t min, bool ma
  * Note that this function is preferred over #wasm_memorytype_limits for
  * compatibility with the memory64 proposal.
  */
-WASM_API_EXTERN uint64_t wasmtime_memorytype_minimum(const wasm_memorytype_t *ty);
+WASM_API_EXTERN uint64_t
+wasmtime_memorytype_minimum(const wasm_memorytype_t *ty);
 
 /**
  * \brief Returns the maximum size, in pages, of the specified memory type.
@@ -42,13 +45,19 @@ WASM_API_EXTERN uint64_t wasmtime_memorytype_minimum(const wasm_memorytype_t *ty
  * Note that this function is preferred over #wasm_memorytype_limits for
  * compatibility with the memory64 proposal.
  */
-WASM_API_EXTERN bool wasmtime_memorytype_maximum(const wasm_memorytype_t *ty, uint64_t *max);
+WASM_API_EXTERN bool wasmtime_memorytype_maximum(const wasm_memorytype_t *ty,
+                                                 uint64_t *max);
 
 /**
  * \brief Returns whether this type of memory represents a 64-bit memory.
  */
 WASM_API_EXTERN bool wasmtime_memorytype_is64(const wasm_memorytype_t *ty);
 
+/**
+ * \brief Returns whether this type of memory represents a shared memory.
+ */
+WASM_API_EXTERN bool wasmtime_memorytype_isshared(const wasm_memorytype_t *ty);
+
 /**
  * \brief Creates a new WebAssembly linear memory
  *
@@ -59,43 +68,34 @@ WASM_API_EXTERN bool wasmtime_memorytype_is64(const wasm_memorytype_t *ty);
  * If an error happens when creating the memory it's returned and owned by the
  * caller. If an error happens then `ret` is not filled in.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_memory_new(
-    wasmtime_context_t *store,
-    const wasm_memorytype_t* ty,
-    wasmtime_memory_t *ret
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_memory_new(wasmtime_context_t *store, const wasm_memorytype_t *ty,
+                    wasmtime_memory_t *ret);
 
 /**
- * \brief Returns the tyep of the memory specified
+ * \brief Returns the type of the memory specified
  */
-WASM_API_EXTERN wasm_memorytype_t* wasmtime_memory_type(
-    const wasmtime_context_t *store,
-    const wasmtime_memory_t *memory
-);
+WASM_API_EXTERN wasm_memorytype_t *
+wasmtime_memory_type(const wasmtime_context_t *store,
+                     const wasmtime_memory_t *memory);
 
 /**
  * \brief Returns the base pointer in memory where the linear memory starts.
  */
-WASM_API_EXTERN uint8_t *wasmtime_memory_data(
-    const wasmtime_context_t *store,
-    const wasmtime_memory_t *memory
-);
+WASM_API_EXTERN uint8_t *wasmtime_memory_data(const wasmtime_context_t *store,
+                                              const wasmtime_memory_t *memory);
 
 /**
  * \brief Returns the byte length of this linear memory.
  */
 WASM_API_EXTERN size_t wasmtime_memory_data_size(
-    const wasmtime_context_t *store,
-    const wasmtime_memory_t *memory
-);
+    const wasmtime_context_t *store, const wasmtime_memory_t *memory);
 
 /**
  * \brief Returns the length, in WebAssembly pages, of this linear memory
  */
-WASM_API_EXTERN uint64_t wasmtime_memory_size(
-    const wasmtime_context_t *store,
-    const wasmtime_memory_t *memory
-);
+WASM_API_EXTERN uint64_t wasmtime_memory_size(const wasmtime_context_t *store,
+                                              const wasmtime_memory_t *memory);
 
 /**
  * \brief Attempts to grow the specified memory by `delta` pages.
@@ -109,15 +109,12 @@ WASM_API_EXTERN uint64_t wasmtime_memory_size(
  * returned. Otherwise `prev_size` is set to the previous size of the memory, in
  * WebAssembly pages, and `NULL` is returned.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_memory_grow(
-    wasmtime_context_t *store,
-    const wasmtime_memory_t *memory,
-    uint64_t delta,
-    uint64_t *prev_size
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_memory_grow(wasmtime_context_t *store, const wasmtime_memory_t *memory,
+                     uint64_t delta, uint64_t *prev_size);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_MEMORY_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/module.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/module.h
similarity index 63%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/module.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/module.h
index deb6bcec1..286f784bd 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/module.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/module.h
@@ -27,6 +27,8 @@ extern "C" {
  */
 typedef struct wasmtime_module wasmtime_module_t;
 
+#ifdef WASMTIME_FEATURE_COMPILER
+
 /**
  * \brief Compiles a WebAssembly binary into a #wasmtime_module_t
  *
@@ -41,12 +43,12 @@ typedef struct wasmtime_module wasmtime_module_t;
  * This function does not take ownership of any of its arguments, but the
  * returned error and module are owned by the caller.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_module_new(
-    wasm_engine_t *engine,
-    const uint8_t *wasm,
-    size_t wasm_len,
-    wasmtime_module_t **ret
-);
+WASM_API_EXTERN wasmtime_error_t *wasmtime_module_new(wasm_engine_t *engine,
+                                                      const uint8_t *wasm,
+                                                      size_t wasm_len,
+                                                      wasmtime_module_t **ret);
+
+#endif // WASMTIME_FEATURE_COMPILER
 
 /**
  * \brief Deletes a module.
@@ -62,18 +64,16 @@ WASM_API_EXTERN wasmtime_module_t *wasmtime_module_clone(wasmtime_module_t *m);
 /**
  * \brief Same as #wasm_module_imports, but for #wasmtime_module_t.
  */
-WASM_API_EXTERN void wasmtime_module_imports(
-    const wasmtime_module_t *module,
-    wasm_importtype_vec_t *out
-);
+WASM_API_EXTERN void wasmtime_module_imports(const wasmtime_module_t *module,
+                                             wasm_importtype_vec_t *out);
 
 /**
  * \brief Same as #wasm_module_exports, but for #wasmtime_module_t.
  */
-WASM_API_EXTERN void wasmtime_module_exports(
-    const wasmtime_module_t *module,
-    wasm_exporttype_vec_t *out
-);
+WASM_API_EXTERN void wasmtime_module_exports(const wasmtime_module_t *module,
+                                             wasm_exporttype_vec_t *out);
+
+#ifdef WASMTIME_FEATURE_COMPILER
 
 /**
  * \brief Validate a WebAssembly binary.
@@ -87,18 +87,16 @@ WASM_API_EXTERN void wasmtime_module_exports(
  * If the binary validates then `NULL` is returned, otherwise the error returned
  * describes why the binary did not validate.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_module_validate(
-    wasm_engine_t *engine,
-    const uint8_t *wasm,
-    size_t wasm_len
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_module_validate(wasm_engine_t *engine, const uint8_t *wasm,
+                         size_t wasm_len);
 
 /**
  * \brief This function serializes compiled module artifacts as blob data.
  *
  * \param module the module
- * \param ret if the conversion is successful, this byte vector is filled in with
- *   the serialized compiled module.
+ * \param ret if the conversion is successful, this byte vector is filled in
+ * with the serialized compiled module.
  *
  * \return a non-null error if parsing fails, or returns `NULL`. If parsing
  * fails then `ret` isn't touched.
@@ -106,10 +104,10 @@ WASM_API_EXTERN wasmtime_error_t *wasmtime_module_validate(
  * This function does not take ownership of `module`, and the caller is
  * expected to deallocate the returned #wasmtime_error_t and #wasm_byte_vec_t.
  */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_module_serialize(
-    wasmtime_module_t* module,
-    wasm_byte_vec_t *ret
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_module_serialize(wasmtime_module_t *module, wasm_byte_vec_t *ret);
+
+#endif // WASMTIME_FEATURE_COMPILER
 
 /**
  * \brief Build a module from serialized data.
@@ -119,14 +117,11 @@ WASM_API_EXTERN wasmtime_error_t* wasmtime_module_serialize(
  *
  * This function is not safe to receive arbitrary user input. See the Rust
  * documentation for more information on what inputs are safe to pass in here
- * (e.g. only that of #wasmtime_module_serialize)
+ * (e.g. only that of `wasmtime_module_serialize`)
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_module_deserialize(
-    wasm_engine_t *engine,
-    const uint8_t *bytes,
-    size_t bytes_len,
-    wasmtime_module_t **ret
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_module_deserialize(wasm_engine_t *engine, const uint8_t *bytes,
+                            size_t bytes_len, wasmtime_module_t **ret);
 
 /**
  * \brief Deserialize a module from an on-disk file.
@@ -140,16 +135,29 @@ WASM_API_EXTERN wasmtime_error_t *wasmtime_module_deserialize(
  *
  * This function is not safe to receive arbitrary user input. See the Rust
  * documentation for more information on what inputs are safe to pass in here
- * (e.g. only that of #wasmtime_module_serialize)
+ * (e.g. only that of `wasmtime_module_serialize`)
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_module_deserialize_file(wasm_engine_t *engine, const char *path,
+                                 wasmtime_module_t **ret);
+
+/**
+ * \brief Returns the range of bytes in memory where this modules compilation
+ * image resides.
+ *
+ * The compilation image for a module contains executable code, data, debug
+ * information, etc. This is roughly the same as the wasmtime_module_serialize
+ * but not the exact same.
+ *
+ * For more details see:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.Module.html#method.image_range
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_module_deserialize_file(
-    wasm_engine_t *engine,
-    const char *path,
-    wasmtime_module_t **ret
-);
+WASM_API_EXTERN void
+wasmtime_module_image_range(const wasmtime_module_t *module, void **start,
+                            void **end);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_MODULE_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/profiling.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/profiling.h
new file mode 100644
index 000000000..55e95d372
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/profiling.h
@@ -0,0 +1,123 @@
+/**
+ * \file wasmtime/profiling.h
+ *
+ * \brief API for Wasmtime guest profiler
+ */
+
+#ifndef WASMTIME_PROFILING_H
+#define WASMTIME_PROFILING_H
+
+#include <wasm.h>
+#include <wasmtime/conf.h>
+#include <wasmtime/error.h>
+
+#ifdef WASMTIME_FEATURE_PROFILING
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief Collects basic profiling data for a single WebAssembly guest.
+ *
+ * To use this, youll need to arrange to call #wasmtime_guestprofiler_sample at
+ * regular intervals while the guest is on the stack. The most straightforward
+ * way to do that is to call it from a callback registered with
+ * #wasmtime_store_epoch_deadline_callback.
+ *
+ * For more information see the Rust documentation at:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.GuestProfiler.html
+ */
+typedef struct wasmtime_guestprofiler wasmtime_guestprofiler_t;
+
+/**
+ * \brief Deletes profiler without finishing it.
+ *
+ * \param guestprofiler profiler that is being deleted
+ */
+WASM_API_EXTERN void wasmtime_guestprofiler_delete(
+    /* own */ wasmtime_guestprofiler_t *guestprofiler);
+
+/**
+ * \typedef wasmtime_guestprofiler_modules_t
+ * \brief Alias to #wasmtime_guestprofiler_modules
+ *
+ * \struct #wasmtime_guestprofiler_modules
+ * \brief Tuple of name and module for passing into #wasmtime_guestprofiler_new.
+ */
+typedef struct wasmtime_guestprofiler_modules {
+  const wasm_name_t *name; //!< Name recorded in the profile.
+  const wasmtime_module_t
+      *mod; //!< Module that is being allowed to appear in captured stack trace.
+} wasmtime_guestprofiler_modules_t;
+
+/**
+ * \brief Begin profiling a new guest.
+ *
+ * \param module_name    name recorded in the profile
+ * \param interval_nanos intended sampling interval in nanoseconds recorded in
+ *                       the profile
+ * \param modules        modules and associated names that will appear in
+ *                       captured stack traces, pointer to the first element
+ * \param modules_len    count of elements in `modules`
+ *
+ * \return Created profiler that is owned by the caller.
+ *
+ * This function does not take ownership of the arguments.
+ *
+ * For more information see the Rust documentation at:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.GuestProfiler.html#method.new
+ */
+WASM_API_EXTERN /* own */ wasmtime_guestprofiler_t *wasmtime_guestprofiler_new(
+    const wasm_name_t *module_name, uint64_t interval_nanos,
+    const wasmtime_guestprofiler_modules_t *modules, size_t modules_len);
+
+/**
+ * \brief Add a sample to the profile.
+ *
+ * \param guestprofiler the profiler the sample is being added to
+ * \param store         store that is being used to collect the backtraces
+ * \param delta_nanos   CPU time in nanoseconds that was used by this guest
+ *                      since the previous sample
+ *
+ * Zero can be passed as `delta_nanos` if recording CPU usage information
+ * is not needed.
+ * This function does not take ownership of the arguments.
+ *
+ * For more information see the Rust documentation at:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.GuestProfiler.html#method.sample
+ */
+WASM_API_EXTERN void
+wasmtime_guestprofiler_sample(wasmtime_guestprofiler_t *guestprofiler,
+                              const wasmtime_store_t *store,
+                              uint64_t delta_nanos);
+
+/**
+ * \brief Writes out the captured profile.
+ *
+ * \param guestprofiler the profiler which is being finished and deleted
+ * \param out           pointer to where #wasm_byte_vec_t containing generated
+ *                      file will be written
+ *
+ * \return Returns #wasmtime_error_t owned by the caller in case of error,
+ * `NULL` otherwise.
+ *
+ * This function takes ownership of `guestprofiler`, even when error is
+ * returned.
+ * Only when returning without error `out` is filled with #wasm_byte_vec_t owned
+ * by the caller.
+ *
+ * For more information see the Rust documentation at:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.GuestProfiler.html#method.finish
+ */
+WASM_API_EXTERN /* own */ wasmtime_error_t *
+wasmtime_guestprofiler_finish(/* own */ wasmtime_guestprofiler_t *guestprofiler,
+                              /* own */ wasm_byte_vec_t *out);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_FEATURE_PROFILING
+
+#endif // WASMTIME_PROFILING_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/sharedmemory.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/sharedmemory.h
new file mode 100644
index 000000000..3065a0ef1
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/sharedmemory.h
@@ -0,0 +1,108 @@
+/**
+ * \file wasmtime/sharedmemory.h
+ *
+ * Wasmtime API for interacting with wasm shared memories.
+ */
+
+#ifndef WASMTIME_SHAREDMEMORY_H
+#define WASMTIME_SHAREDMEMORY_H
+
+#include <wasm.h>
+#include <wasmtime/conf.h>
+#include <wasmtime/error.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief Interface for shared memories.
+ *
+ * For more information see the Rust documentation at:
+ * https://docs.wasmtime.dev/api/wasmtime/struct.SharedMemory.html
+ */
+typedef struct wasmtime_sharedmemory wasmtime_sharedmemory_t;
+
+#ifdef WASMTIME_FEATURE_THREADS
+
+/**
+ * \brief Creates a new WebAssembly shared linear memory
+ *
+ * \param engine engine that created shared memory is associated with
+ * \param ty the type of the memory to create
+ * \param ret where to store the returned memory
+ *
+ * If an error happens when creating the memory it's returned and owned by the
+ * caller. If an error happens then `ret` is not filled in.
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_sharedmemory_new(const wasm_engine_t *engine,
+                          const wasm_memorytype_t *ty,
+                          wasmtime_sharedmemory_t **ret);
+
+#endif // WASMTIME_FEATURE_THREADS
+
+/**
+ * \brief Deletes shared linear memory
+ *
+ * \param memory memory to be deleted
+ */
+WASM_API_EXTERN void
+wasmtime_sharedmemory_delete(wasmtime_sharedmemory_t *memory);
+
+/**
+ * \brief Clones shared linear memory
+ *
+ * \param memory memory to be cloned
+ *
+ * This function makes shallow clone, ie. copy of reference counted
+ * memory handle.
+ */
+WASM_API_EXTERN wasmtime_sharedmemory_t *
+wasmtime_sharedmemory_clone(const wasmtime_sharedmemory_t *memory);
+
+/**
+ * \brief Returns the type of the shared memory specified
+ */
+WASM_API_EXTERN wasm_memorytype_t *
+wasmtime_sharedmemory_type(const wasmtime_sharedmemory_t *memory);
+
+/**
+ * \brief Returns the base pointer in memory where
+          the shared linear memory starts.
+ */
+WASM_API_EXTERN uint8_t *
+wasmtime_sharedmemory_data(const wasmtime_sharedmemory_t *memory);
+
+/**
+ * \brief Returns the byte length of this shared linear memory.
+ */
+WASM_API_EXTERN size_t
+wasmtime_sharedmemory_data_size(const wasmtime_sharedmemory_t *memory);
+
+/**
+ * \brief Returns the length, in WebAssembly pages, of this shared linear memory
+ */
+WASM_API_EXTERN uint64_t
+wasmtime_sharedmemory_size(const wasmtime_sharedmemory_t *memory);
+
+/**
+ * \brief Attempts to grow the specified shared memory by `delta` pages.
+ *
+ * \param memory the memory to grow
+ * \param delta the number of pages to grow by
+ * \param prev_size where to store the previous size of memory
+ *
+ * If memory cannot be grown then `prev_size` is left unchanged and an error is
+ * returned. Otherwise `prev_size` is set to the previous size of the memory, in
+ * WebAssembly pages, and `NULL` is returned.
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_sharedmemory_grow(const wasmtime_sharedmemory_t *memory,
+                           uint64_t delta, uint64_t *prev_size);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_SHAREDMEMORY_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/store.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/store.h
new file mode 100644
index 000000000..65613041c
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/store.h
@@ -0,0 +1,249 @@
+/**
+ * \file wasmtime/store.h
+ *
+ * Wasmtime definition of a "store".
+ */
+
+#ifndef WASMTIME_STORE_H
+#define WASMTIME_STORE_H
+
+#include <wasi.h>
+#include <wasm.h>
+#include <wasmtime/conf.h>
+#include <wasmtime/error.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \typedef wasmtime_store_t
+ * \brief Convenience alias for #wasmtime_store_t
+ *
+ * \struct wasmtime_store
+ * \brief Storage of WebAssembly objects
+ *
+ * A store is the unit of isolation between WebAssembly instances in an
+ * embedding of Wasmtime. Values in one #wasmtime_store_t cannot flow into
+ * another #wasmtime_store_t. Stores are cheap to create and cheap to dispose.
+ * It's expected that one-off stores are common in embeddings.
+ *
+ * Objects stored within a #wasmtime_store_t are referenced with integer handles
+ * rather than interior pointers. This means that most APIs require that the
+ * store be explicitly passed in, which is done via #wasmtime_context_t. It is
+ * safe to move a #wasmtime_store_t to any thread at any time. A store generally
+ * cannot be concurrently used, however.
+ */
+typedef struct wasmtime_store wasmtime_store_t;
+
+/**
+ * \typedef wasmtime_context_t
+ * \brief Convenience alias for #wasmtime_context
+ *
+ * \struct wasmtime_context
+ * \brief An interior pointer into a #wasmtime_store_t which is used as
+ * "context" for many functions.
+ *
+ * This context pointer is used pervasively throughout Wasmtime's API. This can
+ * be acquired from #wasmtime_store_context or #wasmtime_caller_context. The
+ * context pointer for a store is the same for the entire lifetime of a store,
+ * so it can safely be stored adjacent to a #wasmtime_store_t itself.
+ *
+ * Usage of a #wasmtime_context_t must not outlive the original
+ * #wasmtime_store_t. Additionally #wasmtime_context_t can only be used in
+ * situations where it has explicitly been granted access to doing so. For
+ * example finalizers cannot use #wasmtime_context_t because they are not given
+ * access to it.
+ */
+typedef struct wasmtime_context wasmtime_context_t;
+
+/**
+ * \brief Creates a new store within the specified engine.
+ *
+ * \param engine the compilation environment with configuration this store is
+ * connected to
+ * \param data user-provided data to store, can later be acquired with
+ * #wasmtime_context_get_data.
+ * \param finalizer an optional finalizer for `data`
+ *
+ * This function creates a fresh store with the provided configuration settings.
+ * The returned store must be deleted with #wasmtime_store_delete.
+ */
+WASM_API_EXTERN wasmtime_store_t *wasmtime_store_new(wasm_engine_t *engine,
+                                                     void *data,
+                                                     void (*finalizer)(void *));
+
+/**
+ * \brief Returns the interior #wasmtime_context_t pointer to this store
+ */
+WASM_API_EXTERN wasmtime_context_t *
+wasmtime_store_context(wasmtime_store_t *store);
+
+/**
+ * \brief Provides limits for a store. Used by hosts to limit resource
+ * consumption of instances. Use negative value to keep the default value
+ * for the limit.
+ *
+ * \param store store where the limits should be set.
+ * \param memory_size the maximum number of bytes a linear memory can grow to.
+ * Growing a linear memory beyond this limit will fail. By default,
+ * linear memory will not be limited.
+ * \param table_elements the maximum number of elements in a table.
+ * Growing a table beyond this limit will fail. By default, table elements
+ * will not be limited.
+ * \param instances the maximum number of instances that can be created
+ * for a Store. Module instantiation will fail if this limit is exceeded.
+ * This value defaults to 10,000.
+ * \param tables the maximum number of tables that can be created for a Store.
+ * Module instantiation will fail if this limit is exceeded. This value
+ * defaults to 10,000.
+ * \param memories the maximum number of linear memories that can be created
+ * for a Store. Instantiation will fail with an error if this limit is exceeded.
+ * This value defaults to 10,000.
+ *
+ * Use any negative value for the parameters that should be kept on
+ * the default values.
+ *
+ * Note that the limits are only used to limit the creation/growth of
+ * resources in the future, this does not retroactively attempt to apply
+ * limits to the store.
+ */
+WASM_API_EXTERN void wasmtime_store_limiter(wasmtime_store_t *store,
+                                            int64_t memory_size,
+                                            int64_t table_elements,
+                                            int64_t instances, int64_t tables,
+                                            int64_t memories);
+
+/**
+ * \brief Deletes a store.
+ */
+WASM_API_EXTERN void wasmtime_store_delete(wasmtime_store_t *store);
+
+/**
+ * \brief Returns the user-specified data associated with the specified store
+ */
+WASM_API_EXTERN void *
+wasmtime_context_get_data(const wasmtime_context_t *context);
+
+/**
+ * \brief Overwrites the user-specified data associated with this store.
+ *
+ * Note that this does not execute the original finalizer for the provided data,
+ * and the original finalizer will be executed for the provided data when the
+ * store is deleted.
+ */
+WASM_API_EXTERN void wasmtime_context_set_data(wasmtime_context_t *context,
+                                               void *data);
+
+/**
+ * \brief Perform garbage collection within the given context.
+ *
+ * Garbage collects `externref`s that are used within this store. Any
+ * `externref`s that are discovered to be unreachable by other code or objects
+ * will have their finalizers run.
+ *
+ * The `context` argument must not be NULL.
+ */
+WASM_API_EXTERN void wasmtime_context_gc(wasmtime_context_t *context);
+
+/**
+ * \brief Set fuel to this context's store for wasm to consume while executing.
+ *
+ * For this method to work fuel consumption must be enabled via
+ * #wasmtime_config_consume_fuel_set. By default a store starts with 0 fuel
+ * for wasm to execute with (meaning it will immediately trap).
+ * This function must be called for the store to have
+ * some fuel to allow WebAssembly to execute.
+ *
+ * Note that when fuel is entirely consumed it will cause wasm to trap.
+ *
+ * If fuel is not enabled within this store then an error is returned. If fuel
+ * is successfully added then NULL is returned.
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_context_set_fuel(wasmtime_context_t *store, uint64_t fuel);
+
+/**
+ * \brief Returns the amount of fuel remaining in this context's store.
+ *
+ * If fuel consumption is not enabled via #wasmtime_config_consume_fuel_set
+ * then this function will return an error. Otherwise `NULL` is returned and the
+ * fuel parameter is filled in with fuel consumed so far.
+ *
+ * Also note that fuel, if enabled, must be originally configured via
+ * #wasmtime_context_set_fuel.
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_context_get_fuel(const wasmtime_context_t *context, uint64_t *fuel);
+
+#ifdef WASMTIME_FEATURE_WASI
+
+/**
+ * \brief Configures WASI state within the specified store.
+ *
+ * This function is required if #wasmtime_linker_define_wasi is called. This
+ * will configure the WASI state for instances defined within this store to the
+ * configuration specified.
+ *
+ * This function does not take ownership of `context` but it does take ownership
+ * of `wasi`. The caller should no longer use `wasi` after calling this function
+ * (even if an error is returned).
+ */
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_context_set_wasi(wasmtime_context_t *context, wasi_config_t *wasi);
+
+#endif // WASMTIME_FEATURE_WASI
+
+/**
+ * \brief Configures the relative deadline at which point WebAssembly code will
+ * trap or invoke the callback function.
+ *
+ * This function configures the store-local epoch deadline after which point
+ * WebAssembly code will trap or invoke the callback function.
+ *
+ * See also #wasmtime_config_epoch_interruption_set and
+ * #wasmtime_store_epoch_deadline_callback.
+ */
+WASM_API_EXTERN void
+wasmtime_context_set_epoch_deadline(wasmtime_context_t *context,
+                                    uint64_t ticks_beyond_current);
+
+/// \brief An enum for the behavior before extending the epoch deadline.
+typedef uint8_t wasmtime_update_deadline_kind_t;
+/// \brief Directly continue to updating the deadline and executing WebAssembly.
+#define WASMTIME_UPDATE_DEADLINE_CONTINUE 0
+/// \brief Yield control (via async support) then update the deadline.
+#define WASMTIME_UPDATE_DEADLINE_YIELD 1
+
+/**
+ * \brief Configures epoch deadline callback to C function.
+ *
+ * This function configures a store-local callback function that will be
+ * called when the running WebAssembly function has exceeded its epoch
+ * deadline. That function can:
+ * - return a #wasmtime_error_t to terminate the function
+ * - set the delta argument and return NULL to update the
+ *   epoch deadline delta and resume function execution.
+ * - set the delta argument, update the epoch deadline,
+ *   set update_kind to WASMTIME_UPDATE_DEADLINE_YIELD,
+ *   and return NULL to yield (via async support) and
+ *   resume function execution.
+ *
+ * To use WASMTIME_UPDATE_DEADLINE_YIELD async support must be enabled
+ * for this store.
+ *
+ * See also #wasmtime_config_epoch_interruption_set and
+ * #wasmtime_context_set_epoch_deadline.
+ */
+WASM_API_EXTERN void wasmtime_store_epoch_deadline_callback(
+    wasmtime_store_t *store,
+    wasmtime_error_t *(*func)(wasmtime_context_t *context, void *data,
+                              uint64_t *epoch_deadline_delta,
+                              wasmtime_update_deadline_kind_t *update_kind),
+    void *data, void (*finalizer)(void *));
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_STORE_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/table.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/table.h
similarity index 68%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/table.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/table.h
index 630cee9ec..7a648691c 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/table.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/table.h
@@ -8,9 +8,9 @@
 #define WASMTIME_TABLE_H
 
 #include <wasm.h>
+#include <wasmtime/error.h>
 #include <wasmtime/extern.h>
 #include <wasmtime/store.h>
-#include <wasmtime/error.h>
 #include <wasmtime/val.h>
 
 #ifdef __cplusplus
@@ -29,22 +29,19 @@ extern "C" {
  * ownership of returned error. This function may return an error if the `init`
  * value does not match `ty`, for example.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_table_new(
-    wasmtime_context_t *store,
-    const wasm_tabletype_t *ty,
-    const wasmtime_val_t *init,
-    wasmtime_table_t *table
-);
+WASM_API_EXTERN wasmtime_error_t *wasmtime_table_new(wasmtime_context_t *store,
+                                                     const wasm_tabletype_t *ty,
+                                                     const wasmtime_val_t *init,
+                                                     wasmtime_table_t *table);
 
 /**
  * \brief Returns the type of this table.
  *
  * The caller has ownership of the returned #wasm_tabletype_t
  */
-WASM_API_EXTERN wasm_tabletype_t* wasmtime_table_type(
-    const wasmtime_context_t *store,
-    const wasmtime_table_t *table
-);
+WASM_API_EXTERN wasm_tabletype_t *
+wasmtime_table_type(const wasmtime_context_t *store,
+                    const wasmtime_table_t *table);
 
 /**
  * \brief Gets a value in a table.
@@ -58,12 +55,9 @@ WASM_API_EXTERN wasm_tabletype_t* wasmtime_table_type(
  * returned then `val` is filled in and is owned by the caller. Otherwise zero
  * is returned because the `index` is out-of-bounds.
  */
-WASM_API_EXTERN bool wasmtime_table_get(
-    wasmtime_context_t *store,
-    const wasmtime_table_t *table,
-    uint32_t index,
-    wasmtime_val_t *val
-);
+WASM_API_EXTERN bool wasmtime_table_get(wasmtime_context_t *store,
+                                        const wasmtime_table_t *table,
+                                        uint64_t index, wasmtime_val_t *val);
 
 /**
  * \brief Sets a value in a table.
@@ -78,20 +72,15 @@ WASM_API_EXTERN bool wasmtime_table_get(
  * This function can fail if `value` has the wrong type for the table, or if
  * `index` is out of bounds.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_table_set(
-    wasmtime_context_t *store,
-    const wasmtime_table_t *table,
-    uint32_t index,
-    const wasmtime_val_t *value
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_table_set(wasmtime_context_t *store, const wasmtime_table_t *table,
+                   uint64_t index, const wasmtime_val_t *value);
 
 /**
  * \brief Returns the size, in elements, of the specified table
  */
-WASM_API_EXTERN uint32_t wasmtime_table_size(
-    const wasmtime_context_t *store,
-    const wasmtime_table_t *table
-);
+WASM_API_EXTERN uint64_t wasmtime_table_size(const wasmtime_context_t *store,
+                                             const wasmtime_table_t *table);
 
 /**
  * \brief Grows a table.
@@ -110,17 +99,13 @@ WASM_API_EXTERN uint32_t wasmtime_table_size(
  *
  * This function does not take ownership of any of its arguments.
  */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_table_grow(
-    wasmtime_context_t *store,
-    const wasmtime_table_t *table,
-    uint32_t delta,
-    const wasmtime_val_t *init,
-    uint32_t *prev_size
-);
+WASM_API_EXTERN wasmtime_error_t *
+wasmtime_table_grow(wasmtime_context_t *store, const wasmtime_table_t *table,
+                    uint64_t delta, const wasmtime_val_t *init,
+                    uint64_t *prev_size);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_TABLE_H
-
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/trap.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/trap.h
similarity index 86%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/trap.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/trap.h
index 6346cf443..0d2385bb0 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/trap.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/trap.h
@@ -28,7 +28,8 @@ enum wasmtime_trap_code_enum {
   WASMTIME_TRAP_CODE_STACK_OVERFLOW,
   /// An out-of-bounds memory access.
   WASMTIME_TRAP_CODE_MEMORY_OUT_OF_BOUNDS,
-  /// A wasm atomic operation was presented with a not-naturally-aligned linear-memory address.
+  /// A wasm atomic operation was presented with a not-naturally-aligned
+  /// linear-memory address.
   WASMTIME_TRAP_CODE_HEAP_MISALIGNED,
   /// An out-of-bounds access to a table.
   WASMTIME_TRAP_CODE_TABLE_OUT_OF_BOUNDS,
@@ -46,6 +47,8 @@ enum wasmtime_trap_code_enum {
   WASMTIME_TRAP_CODE_UNREACHABLE_CODE_REACHED,
   /// Execution has potentially run too long and may be interrupted.
   WASMTIME_TRAP_CODE_INTERRUPT,
+  /// Execution has run out of the configured fuel amount.
+  WASMTIME_TRAP_CODE_OUT_OF_FUEL,
 };
 
 /**
@@ -67,7 +70,8 @@ WASM_API_EXTERN wasm_trap_t *wasmtime_trap_new(const char *msg, size_t msg_len);
  * an instruction trap -- traps can also be created using wasm_trap_new,
  * or occur with WASI modules exiting with a certain exit code.
  */
-WASM_API_EXTERN bool wasmtime_trap_code(const wasm_trap_t*, wasmtime_trap_code_t *code);
+WASM_API_EXTERN bool wasmtime_trap_code(const wasm_trap_t *,
+                                        wasmtime_trap_code_t *code);
 
 /**
  * \brief Returns a human-readable name for this frame's function.
@@ -77,7 +81,8 @@ WASM_API_EXTERN bool wasmtime_trap_code(const wasm_trap_t*, wasmtime_trap_code_t
  *
  * The lifetime of the returned name is the same as the #wasm_frame_t itself.
  */
-WASM_API_EXTERN const wasm_name_t *wasmtime_frame_func_name(const wasm_frame_t*);
+WASM_API_EXTERN const wasm_name_t *
+wasmtime_frame_func_name(const wasm_frame_t *);
 
 /**
  * \brief Returns a human-readable name for this frame's module.
@@ -87,11 +92,11 @@ WASM_API_EXTERN const wasm_name_t *wasmtime_frame_func_name(const wasm_frame_t*)
  *
  * The lifetime of the returned name is the same as the #wasm_frame_t itself.
  */
-WASM_API_EXTERN const wasm_name_t *wasmtime_frame_module_name(const wasm_frame_t*);
-
+WASM_API_EXTERN const wasm_name_t *
+wasmtime_frame_module_name(const wasm_frame_t *);
 
 #ifdef __cplusplus
-}  // extern "C"
+} // extern "C"
 #endif
 
 #endif // WASMTIME_TRAP_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/val.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/val.h
new file mode 100644
index 000000000..bdac5b9c7
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime/val.h
@@ -0,0 +1,477 @@
+/**
+ * \file wasmtime/val.h
+ *
+ * APIs for interacting with WebAssembly values in Wasmtime.
+ */
+
+#ifndef WASMTIME_VAL_H
+#define WASMTIME_VAL_H
+
+#include <stdalign.h>
+#include <wasm.h>
+#include <wasmtime/extern.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \typedef wasmtime_anyref_t
+ * \brief Convenience alias for #wasmtime_anyref
+ *
+ * \struct wasmtime_anyref
+ * \brief A WebAssembly value in the `any` hierarchy of GC types.
+ *
+ * This structure represents an `anyref` that WebAssembly can create and
+ * pass back to the host. The host can also create values to pass to a guest.
+ *
+ * Note that this structure does not itself contain the data that it refers to.
+ * Instead to contains metadata to point back within a #wasmtime_context_t, so
+ * referencing the internal data requires using a `wasmtime_context_t`.
+ *
+ * Anyref values are required to be explicitly unrooted via
+ * #wasmtime_anyref_unroot to enable them to be garbage-collected.
+ *
+ * Null anyref values are represented by this structure and can be tested and
+ * created with the `wasmtime_anyref_is_null` and `wasmtime_anyref_set_null`
+ * functions.
+ */
+typedef struct wasmtime_anyref {
+  /// Internal metadata tracking within the store, embedders should not
+  /// configure or modify these fields.
+  uint64_t store_id;
+  /// Internal to Wasmtime.
+  uint32_t __private1;
+  /// Internal to Wasmtime.
+  uint32_t __private2;
+} wasmtime_anyref_t;
+
+/// \brief Helper function to initialize the `ref` provided to a null anyref
+/// value.
+static inline void wasmtime_anyref_set_null(wasmtime_anyref_t *ref) {
+  ref->store_id = 0;
+}
+
+/// \brief Helper function to return whether the provided `ref` points to a null
+/// `anyref` value.
+///
+/// Note that `ref` itself should not be null as null is represented internally
+/// within a #wasmtime_anyref_t value.
+static inline bool wasmtime_anyref_is_null(const wasmtime_anyref_t *ref) {
+  return ref->store_id == 0;
+}
+
+/**
+ * \brief Creates a new reference pointing to the same data that `anyref`
+ * points to (depending on the configured collector this might increase a
+ * reference count or create a new GC root).
+ *
+ * The returned reference is stored in `out`.
+ */
+WASM_API_EXTERN void wasmtime_anyref_clone(wasmtime_context_t *context,
+                                           const wasmtime_anyref_t *anyref,
+                                           wasmtime_anyref_t *out);
+
+/**
+ * \brief Unroots the `ref` provided within the `context`.
+ *
+ * This API is required to enable the `ref` value provided to be
+ * garbage-collected. This API itself does not necessarily garbage-collect the
+ * value, but it's possible to collect it in the future after this.
+ *
+ * This may modify `ref` and the contents of `ref` are left in an undefined
+ * state after this API is called and it should no longer be used.
+ *
+ * Note that null or i32 anyref values do not need to be unrooted but are still
+ * valid to pass to this function.
+ */
+WASM_API_EXTERN void wasmtime_anyref_unroot(wasmtime_context_t *context,
+                                            wasmtime_anyref_t *ref);
+
+/**
+ * \brief Converts a raw `anyref` value coming from #wasmtime_val_raw_t into
+ * a #wasmtime_anyref_t.
+ *
+ * The provided `out` pointer is filled in with a reference converted from
+ * `raw`.
+ */
+WASM_API_EXTERN void wasmtime_anyref_from_raw(wasmtime_context_t *context,
+                                              uint32_t raw,
+                                              wasmtime_anyref_t *out);
+
+/**
+ * \brief Converts a #wasmtime_anyref_t to a raw value suitable for storing
+ * into a #wasmtime_val_raw_t.
+ *
+ * Note that the returned underlying value is not tracked by Wasmtime's garbage
+ * collector until it enters WebAssembly. This means that a GC may release the
+ * context's reference to the raw value, making the raw value invalid within the
+ * context of the store. Do not perform a GC between calling this function and
+ * passing it to WebAssembly.
+ */
+WASM_API_EXTERN uint32_t wasmtime_anyref_to_raw(wasmtime_context_t *context,
+                                                const wasmtime_anyref_t *ref);
+
+/**
+ * \brief Create a new `i31ref` value.
+ *
+ * Creates a new `i31ref` value (which is a subtype of `anyref`) and returns a
+ * pointer to it.
+ *
+ * If `i31val` does not fit in 31 bits, it is wrapped.
+ */
+WASM_API_EXTERN void wasmtime_anyref_from_i31(wasmtime_context_t *context,
+                                              uint32_t i31val,
+                                              wasmtime_anyref_t *out);
+
+/**
+ * \brief Get the `anyref`'s underlying `i31ref` value, zero extended, if any.
+ *
+ * If the given `anyref` is an instance of `i31ref`, then its value is zero
+ * extended to 32 bits, written to `dst`, and `true` is returned.
+ *
+ * If the given `anyref` is not an instance of `i31ref`, then `false` is
+ * returned and `dst` is left unmodified.
+ */
+WASM_API_EXTERN bool wasmtime_anyref_i31_get_u(wasmtime_context_t *context,
+                                               const wasmtime_anyref_t *anyref,
+                                               uint32_t *dst);
+
+/**
+ * \brief Get the `anyref`'s underlying `i31ref` value, sign extended, if any.
+ *
+ * If the given `anyref` is an instance of `i31ref`, then its value is sign
+ * extended to 32 bits, written to `dst`, and `true` is returned.
+ *
+ * If the given `anyref` is not an instance of `i31ref`, then `false` is
+ * returned and `dst` is left unmodified.
+ */
+WASM_API_EXTERN bool wasmtime_anyref_i31_get_s(wasmtime_context_t *context,
+                                               const wasmtime_anyref_t *anyref,
+                                               int32_t *dst);
+
+/**
+ * \typedef wasmtime_externref_t
+ * \brief Convenience alias for #wasmtime_externref
+ *
+ * \struct wasmtime_externref
+ * \brief A host-defined un-forgeable reference to pass into WebAssembly.
+ *
+ * This structure represents an `externref` that can be passed to WebAssembly.
+ * It cannot be forged by WebAssembly itself and is guaranteed to have been
+ * created by the host.
+ *
+ * This structure is similar to #wasmtime_anyref_t but represents the
+ * `externref` type in WebAssembly. This can be created on the host from
+ * arbitrary host pointers/destructors. Note that this value is itself a
+ * reference into a #wasmtime_context_t and must be explicitly unrooted to
+ * enable garbage collection.
+ *
+ * Note that null is represented with this structure and created with
+ * `wasmtime_externref_set_null`. Null can be tested for with the
+ * `wasmtime_externref_is_null` function.
+ */
+typedef struct wasmtime_externref {
+  /// Internal metadata tracking within the store, embedders should not
+  /// configure or modify these fields.
+  uint64_t store_id;
+  /// Internal to Wasmtime.
+  uint32_t __private1;
+  /// Internal to Wasmtime.
+  uint32_t __private2;
+} wasmtime_externref_t;
+
+/// \brief Helper function to initialize the `ref` provided to a null externref
+/// value.
+static inline void wasmtime_externref_set_null(wasmtime_externref_t *ref) {
+  ref->store_id = 0;
+}
+
+/// \brief Helper function to return whether the provided `ref` points to a null
+/// `externref` value.
+///
+/// Note that `ref` itself should not be null as null is represented internally
+/// within a #wasmtime_externref_t value.
+static inline bool wasmtime_externref_is_null(const wasmtime_externref_t *ref) {
+  return ref->store_id == 0;
+}
+
+/**
+ * \brief Create a new `externref` value.
+ *
+ * Creates a new `externref` value wrapping the provided data, returning whether
+ * it was created or not.
+ *
+ * \param context the store context to allocate this externref within
+ * \param data the host-specific data to wrap
+ * \param finalizer an optional finalizer for `data`
+ * \param out where to store the created value.
+ *
+ * When the reference is reclaimed, the wrapped data is cleaned up with the
+ * provided `finalizer`.
+ *
+ * If `true` is returned then `out` has been filled in and must be unrooted
+ * in the future with #wasmtime_externref_unroot. If `false` is returned then
+ * the host wasn't able to create more GC values at this time. Performing a GC
+ * may free up enough space to try again.
+ */
+WASM_API_EXTERN bool wasmtime_externref_new(wasmtime_context_t *context,
+                                            void *data,
+                                            void (*finalizer)(void *),
+                                            wasmtime_externref_t *out);
+
+/**
+ * \brief Get an `externref`'s wrapped data
+ *
+ * Returns the original `data` passed to #wasmtime_externref_new. It is required
+ * that `data` is not `NULL`.
+ */
+WASM_API_EXTERN void *wasmtime_externref_data(wasmtime_context_t *context,
+                                              const wasmtime_externref_t *data);
+
+/**
+ * \brief Creates a new reference pointing to the same data that `ref` points
+ * to (depending on the configured collector this might increase a reference
+ * count or create a new GC root).
+ *
+ * The `out` parameter stores the cloned reference. This reference must
+ * eventually be unrooted with #wasmtime_externref_unroot in the future to
+ * enable GC'ing it.
+ */
+WASM_API_EXTERN void wasmtime_externref_clone(wasmtime_context_t *context,
+                                              const wasmtime_externref_t *ref,
+                                              wasmtime_externref_t *out);
+
+/**
+ * \brief Unroots the pointer `ref` from the `context` provided.
+ *
+ * This function will enable future garbage collection of the value pointed to
+ * by `ref` once there are no more references. The `ref` value may be mutated in
+ * place by this function and its contents are undefined after this function
+ * returns. It should not be used until after re-initializing it.
+ *
+ * Note that null externref values do not need to be unrooted but are still
+ * valid to pass to this function.
+ */
+WASM_API_EXTERN void wasmtime_externref_unroot(wasmtime_context_t *context,
+                                               wasmtime_externref_t *ref);
+
+/**
+ * \brief Converts a raw `externref` value coming from #wasmtime_val_raw_t into
+ * a #wasmtime_externref_t.
+ *
+ * The `out` reference is filled in with the non-raw version of this externref.
+ * It must eventually be unrooted with #wasmtime_externref_unroot.
+ */
+WASM_API_EXTERN void wasmtime_externref_from_raw(wasmtime_context_t *context,
+                                                 uint32_t raw,
+                                                 wasmtime_externref_t *out);
+
+/**
+ * \brief Converts a #wasmtime_externref_t to a raw value suitable for storing
+ * into a #wasmtime_val_raw_t.
+ *
+ * Note that the returned underlying value is not tracked by Wasmtime's garbage
+ * collector until it enters WebAssembly. This means that a GC may release the
+ * context's reference to the raw value, making the raw value invalid within the
+ * context of the store. Do not perform a GC between calling this function and
+ * passing it to WebAssembly.
+ */
+WASM_API_EXTERN uint32_t wasmtime_externref_to_raw(
+    wasmtime_context_t *context, const wasmtime_externref_t *ref);
+
+/// \brief Discriminant stored in #wasmtime_val::kind
+typedef uint8_t wasmtime_valkind_t;
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an i32
+#define WASMTIME_I32 0
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an i64
+#define WASMTIME_I64 1
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a f32
+#define WASMTIME_F32 2
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a f64
+#define WASMTIME_F64 3
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a v128
+#define WASMTIME_V128 4
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a
+/// funcref
+#define WASMTIME_FUNCREF 5
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an
+/// externref
+#define WASMTIME_EXTERNREF 6
+/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an
+/// anyref
+#define WASMTIME_ANYREF 7
+
+/// \brief A 128-bit value representing the WebAssembly `v128` type. Bytes are
+/// stored in little-endian order.
+typedef uint8_t wasmtime_v128[16];
+
+/**
+ * \typedef wasmtime_valunion_t
+ * \brief Convenience alias for #wasmtime_valunion
+ *
+ * \union wasmtime_valunion
+ * \brief Container for different kinds of wasm values.
+ *
+ * This type is contained in #wasmtime_val_t and contains the payload for the
+ * various kinds of items a value can be.
+ */
+typedef union wasmtime_valunion {
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I32
+  int32_t i32;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I64
+  int64_t i64;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F32
+  float32_t f32;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F64
+  float64_t f64;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_ANYREF
+  wasmtime_anyref_t anyref;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_EXTERNREF
+  wasmtime_externref_t externref;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_FUNCREF
+  ///
+  /// Use `wasmtime_funcref_is_null` to test whether this is a null function
+  /// reference.
+  wasmtime_func_t funcref;
+  /// Field used if #wasmtime_val_t::kind is #WASMTIME_V128
+  wasmtime_v128 v128;
+} wasmtime_valunion_t;
+
+/// \brief Initialize a `wasmtime_func_t` value as a null function reference.
+///
+/// This function will initialize the `func` provided to be a null function
+/// reference. Used in conjunction with #wasmtime_val_t and
+/// #wasmtime_valunion_t.
+static inline void wasmtime_funcref_set_null(wasmtime_func_t *func) {
+  func->store_id = 0;
+}
+
+/// \brief Helper function to test whether the `func` provided is a null
+/// function reference.
+///
+/// This function is used with #wasmtime_val_t and #wasmtime_valunion_t and its
+/// `funcref` field. This will test whether the field represents a null funcref.
+static inline bool wasmtime_funcref_is_null(const wasmtime_func_t *func) {
+  return func->store_id == 0;
+}
+
+/**
+ * \typedef wasmtime_val_raw_t
+ * \brief Convenience alias for #wasmtime_val_raw
+ *
+ * \union wasmtime_val_raw
+ * \brief Container for possible wasm values.
+ *
+ * This type is used on conjunction with #wasmtime_func_new_unchecked as well
+ * as #wasmtime_func_call_unchecked. Instances of this type do not have type
+ * information associated with them, it's up to the embedder to figure out
+ * how to interpret the bits contained within, often using some other channel
+ * to determine the type.
+ */
+typedef union wasmtime_val_raw {
+  /// Field for when this val is a WebAssembly `i32` value.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  int32_t i32;
+  /// Field for when this val is a WebAssembly `i64` value.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  int64_t i64;
+  /// Field for when this val is a WebAssembly `f32` value.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  float32_t f32;
+  /// Field for when this val is a WebAssembly `f64` value.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  float64_t f64;
+  /// Field for when this val is a WebAssembly `v128` value.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  wasmtime_v128 v128;
+  /// Field for when this val is a WebAssembly `anyref` value.
+  ///
+  /// If this is set to 0 then it's a null anyref, otherwise this must be
+  /// passed to `wasmtime_anyref_from_raw` to determine the
+  /// `wasmtime_anyref_t`.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  uint32_t anyref;
+  /// Field for when this val is a WebAssembly `externref` value.
+  ///
+  /// If this is set to 0 then it's a null externref, otherwise this must be
+  /// passed to `wasmtime_externref_from_raw` to determine the
+  /// `wasmtime_externref_t`.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  uint32_t externref;
+  /// Field for when this val is a WebAssembly `funcref` value.
+  ///
+  /// If this is set to 0 then it's a null funcref, otherwise this must be
+  /// passed to `wasmtime_func_from_raw` to determine the `wasmtime_func_t`.
+  ///
+  /// Note that this field is always stored in a little-endian format.
+  void *funcref;
+} wasmtime_val_raw_t;
+
+// Assert that the shape of this type is as expected since it needs to match
+// Rust.
+static inline void __wasmtime_val_assertions() {
+  static_assert(sizeof(wasmtime_valunion_t) == 16, "should be 16-bytes large");
+  static_assert(__alignof(wasmtime_valunion_t) == 8,
+                "should be 8-byte aligned");
+  static_assert(sizeof(wasmtime_val_raw_t) == 16, "should be 16 bytes large");
+  static_assert(__alignof(wasmtime_val_raw_t) == 8, "should be 8-byte aligned");
+}
+
+/**
+ * \typedef wasmtime_val_t
+ * \brief Convenience alias for #wasmtime_val_t
+ *
+ * \union wasmtime_val
+ * \brief Container for different kinds of wasm values.
+ *
+ * Note that this structure may contain an owned value, namely rooted GC
+ * references, depending on the context in which this is used. APIs which
+ * consume a #wasmtime_val_t do not take ownership, but APIs that return
+ * #wasmtime_val_t require that #wasmtime_val_unroot is called to clean up
+ * any possible GC roots in the value.
+ */
+typedef struct wasmtime_val {
+  /// Discriminant of which field of #of is valid.
+  wasmtime_valkind_t kind;
+  /// Container for the extern item's value.
+  wasmtime_valunion_t of;
+} wasmtime_val_t;
+
+/**
+ * \brief Unroot the value contained by `val`.
+ *
+ * This function will unroot any GC references that `val` points to, for
+ * example if it has the `WASMTIME_EXTERNREF` or `WASMTIME_ANYREF` kinds. This
+ * function leaves `val` in an undefined state and it should not be used again
+ * without re-initializing.
+ *
+ * This method does not need to be called for integers, floats, v128, or
+ * funcref values.
+ */
+WASM_API_EXTERN void wasmtime_val_unroot(wasmtime_context_t *context,
+                                         wasmtime_val_t *val);
+
+/**
+ * \brief Clones the value pointed to by `src` into the `dst` provided.
+ *
+ * This function will clone any rooted GC values in `src` and have them
+ * newly rooted inside of `dst`. When using this API the `dst` should be
+ * later unrooted with #wasmtime_val_unroot if it contains GC values.
+ */
+WASM_API_EXTERN void wasmtime_val_clone(wasmtime_context_t *context,
+                                        const wasmtime_val_t *src,
+                                        wasmtime_val_t *dst);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // WASMTIME_VAL_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64/libwasmtime.a b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64/libwasmtime.a
similarity index 77%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64/libwasmtime.a
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64/libwasmtime.a
index b76b5d9ac..9fdc4a8f1 100644
Binary files a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64/libwasmtime.a and b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64/libwasmtime.a differ
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64/libwasmtime.a b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64/libwasmtime.a
similarity index 79%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64/libwasmtime.a
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64/libwasmtime.a
index ae507a6b7..1e26c04de 100644
Binary files a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64/libwasmtime.a and b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64/libwasmtime.a differ
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64/libwasmtime.a b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64/libwasmtime.a
similarity index 75%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64/libwasmtime.a
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64/libwasmtime.a
index d017a269f..a3a552b7d 100644
Binary files a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64/libwasmtime.a and b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64/libwasmtime.a differ
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64/libwasmtime.a b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64/libwasmtime.a
similarity index 74%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64/libwasmtime.a
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64/libwasmtime.a
index e3a8a1dc6..b9a382cb2 100644
Binary files a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64/libwasmtime.a and b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64/libwasmtime.a differ
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64/empty.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64/empty.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64/empty.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64/empty.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64/libwasmtime.a b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64/libwasmtime.a
similarity index 67%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64/libwasmtime.a
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64/libwasmtime.a
index b5b3046fd..41185502e 100644
Binary files a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64/libwasmtime.a and b/vendor/github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64/libwasmtime.a differ
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/config.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/config.go
similarity index 50%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/config.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/config.go
index 129070884..95ad1124d 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/config.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/config.go
@@ -51,7 +51,7 @@ type Config struct {
 func NewConfig() *Config {
 	config := &Config{_ptr: C.wasm_config_new()}
 	runtime.SetFinalizer(config, func(config *Config) {
-		C.wasm_config_delete(config._ptr)
+		config.Close()
 	})
 	return config
 }
@@ -62,6 +62,15 @@ func (cfg *Config) SetDebugInfo(enabled bool) {
 	runtime.KeepAlive(cfg)
 }
 
+// SetMaxWasmStack configures the maximum stack size, in bytes, that JIT code can use.
+// The amount of stack space that wasm takes is always relative to the first invocation of wasm on the stack.
+// Recursive calls with host frames in the middle will all need to fit within this setting.
+// Note that this setting is not interpreted with 100% precision.
+func (cfg *Config) SetMaxWasmStack(size int) {
+	C.wasmtime_config_max_wasm_stack_set(cfg.ptr(), C.size_t(size))
+	runtime.KeepAlive(cfg)
+}
+
 // SetWasmThreads configures whether the wasm threads proposal is enabled
 func (cfg *Config) SetWasmThreads(enabled bool) {
 	C.wasmtime_config_wasm_threads_set(cfg.ptr(), C.bool(enabled))
@@ -80,6 +89,18 @@ func (cfg *Config) SetWasmSIMD(enabled bool) {
 	runtime.KeepAlive(cfg)
 }
 
+// SetWasmRelaxedSIMD configures whether the wasm relaxed SIMD proposal is enabled
+func (cfg *Config) SetWasmRelaxedSIMD(enabled bool) {
+	C.wasmtime_config_wasm_relaxed_simd_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetWasmRelaxedSIMDDeterministic configures whether the wasm relaxed SIMD proposal is in deterministic mode
+func (cfg *Config) SetWasmRelaxedSIMDDeterministic(enabled bool) {
+	C.wasmtime_config_wasm_relaxed_simd_deterministic_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
 // SetWasmBulkMemory configures whether the wasm bulk memory proposal is enabled
 func (cfg *Config) SetWasmBulkMemory(enabled bool) {
 	C.wasmtime_config_wasm_bulk_memory_set(cfg.ptr(), C.bool(enabled))
@@ -104,12 +125,79 @@ func (cfg *Config) SetWasmMemory64(enabled bool) {
 	runtime.KeepAlive(cfg)
 }
 
+// SetTailCall configures whether tail calls are enabled
+func (cfg *Config) SetWasmTailCall(enabled bool) {
+	C.wasmtime_config_wasm_tail_call_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetFunctionReferences configures whether function references are enabled
+func (cfg *Config) SetWasmFunctionReferences(enabled bool) {
+	C.wasmtime_config_wasm_function_references_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetGC configures whether garbage collection is enabled
+func (cfg *Config) SetWasmGC(enabled bool) {
+	C.wasmtime_config_wasm_gc_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetWideArithmetic configures whether wide arithmetic is enabled
+func (cfg *Config) SetWasmWideArithmetic(enabled bool) {
+	C.wasmtime_config_wasm_wide_arithmetic_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
 // SetConsumFuel configures whether fuel is enabled
 func (cfg *Config) SetConsumeFuel(enabled bool) {
 	C.wasmtime_config_consume_fuel_set(cfg.ptr(), C.bool(enabled))
 	runtime.KeepAlive(cfg)
 }
 
+// SetParallelCompilation configures whether compilation should use multiple threads
+func (cfg *Config) SetParallelCompilation(enabled bool) {
+	C.wasmtime_config_parallel_compilation_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetCraneliftNanCanonicalization configures whether whether Cranelift should perform a
+// NaN-canonicalization pass.
+//
+// When Cranelift is used as a code generation backend this will configure it to replace NaNs with a single
+// canonical value. This is useful for users requiring entirely deterministic WebAssembly computation.
+//
+// This is not required by the WebAssembly spec, so it is not enabled by default.
+func (cfg *Config) SetCraneliftNanCanonicalization(enabled bool) {
+	C.wasmtime_config_cranelift_nan_canonicalization_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetNativeUnwindInfo whether to generate native unwind information (e.g. .eh_frame on Linux).
+func (cfg *Config) SetNativeUnwindInfo(enabled bool) {
+	C.wasmtime_config_native_unwind_info_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetMacOSUseMachPorts configures whether, when on macOS, Mach ports are used for exception handling instead
+// of traditional Unix-based signal handling.
+func (cfg *Config) SetMacOSUseMachPorts(enabled bool) {
+	C.wasmtime_config_macos_use_mach_ports_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
+// SetMemoryInitCOWSet Configures whether copy-on-write memory-mapped data is used to initialize a linear memory.
+//
+// Initializing linear memory via a copy-on-write mapping can drastically improve instantiation costs of a
+// WebAssembly module because copying memory is deferred. Additionally if a page of memory is only ever read from
+// WebAssembly and never written too then the same underlying page of data will be reused between all
+// instantiations of a module meaning that if a module is instantiated many times this can lower the overall
+// memory required needed to run that module.
+func (cfg *Config) SetMemoryInitCOWSet(enabled bool) {
+	C.wasmtime_config_memory_init_cow_set(cfg.ptr(), C.bool(enabled))
+	runtime.KeepAlive(cfg)
+}
+
 // SetStrategy configures what compilation strategy is used to compile wasm code
 func (cfg *Config) SetStrategy(strat Strategy) {
 	C.wasmtime_config_strategy_set(cfg.ptr(), C.wasmtime_strategy_t(strat))
@@ -173,12 +261,75 @@ func (cfg *Config) SetEpochInterruption(enable bool) {
 	runtime.KeepAlive(cfg)
 }
 
+// SetTarget configures the target triple that this configuration will produce
+// machine code for.
+//
+// This option defaults to the native host. Calling this method will
+// additionally disable inference of the native features of the host (e.g.
+// detection of SSE4.2 on x86_64 hosts). Native features can be reenabled with
+// the `cranelift_flag_{set,enable}` properties.
+//
+// For more information see the Rust documentation at
+// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.config
+func (cfg *Config) SetTarget(target string) error {
+	cstr := C.CString(target)
+	err := C.wasmtime_config_target_set(cfg.ptr(), cstr)
+	C.free(unsafe.Pointer(cstr))
+	runtime.KeepAlive(cfg)
+	if err != nil {
+		return mkError(err)
+	}
+	return nil
+}
+
+// EnableCraneliftFlag enables a target-specific flag in Cranelift.
+//
+// This can be used, for example, to enable SSE4.2 on x86_64 hosts. Settings can
+// be explored with `wasmtime settings` on the CLI.
+//
+// For more information see the Rust documentation at
+// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.cranelift_flag_enable
+func (cfg *Config) EnableCraneliftFlag(flag string) {
+	cstr := C.CString(flag)
+	C.wasmtime_config_cranelift_flag_enable(cfg.ptr(), cstr)
+	C.free(unsafe.Pointer(cstr))
+	runtime.KeepAlive(cfg)
+}
+
+// SetCraneliftFlag sets a target-specific flag in Cranelift to the specified value.
+//
+// This can be used, for example, to enable SSE4.2 on x86_64 hosts. Settings can
+// be explored with `wasmtime settings` on the CLI.
+//
+// For more information see the Rust documentation at
+// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.cranelift_flag_set
+func (cfg *Config) SetCraneliftFlag(name string, value string) {
+	cstrName := C.CString(name)
+	cstrValue := C.CString(value)
+	C.wasmtime_config_cranelift_flag_set(cfg.ptr(), cstrName, cstrValue)
+	C.free(unsafe.Pointer(cstrName))
+	C.free(unsafe.Pointer(cstrValue))
+	runtime.KeepAlive(cfg)
+}
+
 // See comments in `ffi.go` for what's going on here
 func (cfg *Config) ptr() *C.wasm_config_t {
 	ret := cfg._ptr
-	maybeGC()
 	if ret == nil {
 		panic("Config has already been used up")
 	}
+	maybeGC()
 	return ret
 }
+
+// Close will deallocate this config's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (cfg *Config) Close() {
+	if cfg._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(cfg, nil)
+	C.wasm_config_delete(cfg._ptr)
+	cfg._ptr = nil
+}
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/doc.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/doc.go
similarity index 93%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/doc.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/doc.go
index ef44184bc..a37191bbf 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/doc.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/doc.go
@@ -14,5 +14,6 @@ https://github.com/bytecodealliance/wasmtime-go/issues/new.
 
 It's also worth pointing out that the authors of this package up to this point
 primarily work in Rust, so if you've got suggestions of how to make this package
-more idiomatic for Go we'd love to hear your thoughts! */
+more idiomatic for Go we'd love to hear your thoughts!
+*/
 package wasmtime
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/engine.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/engine.go
similarity index 57%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/engine.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/engine.go
index f3e5c1c50..74744908e 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/engine.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/engine.go
@@ -18,7 +18,7 @@ type Engine struct {
 func NewEngine() *Engine {
 	engine := &Engine{_ptr: C.wasm_engine_new()}
 	runtime.SetFinalizer(engine, func(engine *Engine) {
-		C.wasm_engine_delete(engine._ptr)
+		engine.Close()
 	})
 	return engine
 }
@@ -34,13 +34,41 @@ func NewEngineWithConfig(config *Config) *Engine {
 	runtime.SetFinalizer(config, nil)
 	config._ptr = nil
 	runtime.SetFinalizer(engine, func(engine *Engine) {
-		C.wasm_engine_delete(engine._ptr)
+		engine.Close()
 	})
 	return engine
 }
 
+// Close will deallocate this engine's state explicitly.
+//
+// By default state is cleaned up automatically when an engine is garbage
+// collected but the Go GC. The Go GC, however, does not provide strict
+// guarantees about finalizers especially in terms of timing. Additionally the
+// Go GC is not aware of the full weight of an engine because it holds onto
+// allocations in Wasmtime not tracked by the Go GC. For these reasons, it's
+// recommended to where possible explicitly call this method and deallocate an
+// engine to avoid relying on the Go GC.
+//
+// This method will deallocate Wasmtime-owned state. Future use of the engine
+// will panic because the Wasmtime state is no longer there.
+//
+// Close can be called multiple times without error. Only the first time will
+// deallocate resources.
+func (engine *Engine) Close() {
+	if engine._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(engine, nil)
+	C.wasm_engine_delete(engine.ptr())
+	engine._ptr = nil
+
+}
+
 func (engine *Engine) ptr() *C.wasm_engine_t {
 	ret := engine._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/error.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/error.go
similarity index 73%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/error.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/error.go
index 4f7d66669..33eddc793 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/error.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/error.go
@@ -11,13 +11,16 @@ type Error struct {
 func mkError(ptr *C.wasmtime_error_t) *Error {
 	err := &Error{_ptr: ptr}
 	runtime.SetFinalizer(err, func(err *Error) {
-		C.wasmtime_error_delete(err._ptr)
+		err.Close()
 	})
 	return err
 }
 
 func (e *Error) ptr() *C.wasmtime_error_t {
 	ret := e._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -40,3 +43,16 @@ func (e *Error) ExitStatus() (int32, bool) {
 	runtime.KeepAlive(e)
 	return int32(status), bool(ok)
 }
+
+// Close will deallocate this error's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (e *Error) Close() {
+	if e._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(e, nil)
+	C.wasmtime_error_delete(e._ptr)
+	e._ptr = nil
+
+}
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/exporttype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/exporttype.go
similarity index 82%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/exporttype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/exporttype.go
index 393e23099..72341ed3b 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/exporttype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/exporttype.go
@@ -32,7 +32,7 @@ func mkExportType(ptr *C.wasm_exporttype_t, owner interface{}) *ExportType {
 	exporttype := &ExportType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(exporttype, func(exporttype *ExportType) {
-			C.wasm_exporttype_delete(exporttype._ptr)
+			exporttype.Close()
 		})
 	}
 	return exporttype
@@ -40,6 +40,9 @@ func mkExportType(ptr *C.wasm_exporttype_t, owner interface{}) *ExportType {
 
 func (ty *ExportType) ptr() *C.wasm_exporttype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -51,6 +54,18 @@ func (ty *ExportType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *ExportType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_exporttype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // Name returns the name in the module this export type is exporting
 func (ty *ExportType) Name() string {
 	ptr := C.wasm_exporttype_name(ty.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/extern.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/extern.go
similarity index 85%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/extern.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/extern.go
index 77166d5ea..1fc4d6df9 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/extern.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/extern.go
@@ -7,7 +7,6 @@ import "runtime"
 // Extern is an external value, which is the runtime representation of an entity that can be imported or exported.
 // It is an address denoting either a function instance, table instance, memory instance, or global instances in the shared store.
 // Read more in [spec](https://webassembly.github.io/spec/core/exec/runtime.html#external-values)
-//
 type Extern struct {
 	_ptr *C.wasmtime_extern_t
 }
@@ -19,18 +18,34 @@ type AsExtern interface {
 
 func mkExtern(ptr *C.wasmtime_extern_t) *Extern {
 	f := &Extern{_ptr: ptr}
-	runtime.SetFinalizer(f, func(f *Extern) {
-		C.wasmtime_extern_delete(f._ptr)
+	runtime.SetFinalizer(f, func(e *Extern) {
+		e.Close()
 	})
 	return f
 }
 
 func (e *Extern) ptr() *C.wasmtime_extern_t {
 	ret := e._ptr
+	if ret == nil {
+		panic("object already closed")
+	}
 	maybeGC()
 	return ret
 }
 
+// Close will deallocate this extern's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (e *Extern) Close() {
+	if e._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(e, nil)
+	C.wasmtime_extern_delete(e._ptr)
+	e._ptr = nil
+
+}
+
 // Type returns the type of this export
 func (e *Extern) Type(store Storelike) *ExternType {
 	ptr := C.wasmtime_extern_type(store.Context(), e.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/externtype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/externtype.go
similarity index 84%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/externtype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/externtype.go
index 622904c55..20943a78b 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/externtype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/externtype.go
@@ -19,7 +19,7 @@ func mkExternType(ptr *C.wasm_externtype_t, owner interface{}) *ExternType {
 	externtype := &ExternType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(externtype, func(externtype *ExternType) {
-			C.wasm_externtype_delete(externtype._ptr)
+			externtype.Close()
 		})
 	}
 	return externtype
@@ -27,6 +27,9 @@ func mkExternType(ptr *C.wasm_externtype_t, owner interface{}) *ExternType {
 
 func (ty *ExternType) ptr() *C.wasm_externtype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -38,6 +41,18 @@ func (ty *ExternType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *ExternType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_externtype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // FuncType returns the underlying `FuncType` for this `ExternType` if it's a function
 // type. Otherwise returns `nil`.
 func (ty *ExternType) FuncType() *FuncType {
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/ffi.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/ffi.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/ffi.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/ffi.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/func.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/func.go
similarity index 95%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/func.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/func.go
index 9759ec008..a6e9b53ba 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/func.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/func.go
@@ -86,7 +86,7 @@ func goTrampolineNew(
 	base := unsafe.Pointer(argsPtr)
 	for i := 0; i < len(params); i++ {
 		ptr := (*C.wasmtime_val_t)(unsafe.Pointer(uintptr(base) + uintptr(i)*unsafe.Sizeof(val)))
-		params[i] = mkVal(ptr)
+		params[i] = mkVal(caller, ptr)
 	}
 
 	var results []Val
@@ -126,7 +126,7 @@ func goTrampolineNew(
 	base = unsafe.Pointer(resultsPtr)
 	for i := 0; i < len(results); i++ {
 		ptr := (*C.wasmtime_val_t)(unsafe.Pointer(uintptr(base) + uintptr(i)*unsafe.Sizeof(val)))
-		C.wasmtime_val_copy(ptr, results[i].ptr())
+		results[i].initialize(caller, ptr)
 	}
 	runtime.KeepAlive(results)
 	return nil
@@ -262,7 +262,7 @@ func goTrampolineWrap(
 			params[i] = reflect.ValueOf(caller)
 		} else {
 			ptr := (*C.wasmtime_val_t)(base)
-			val := mkVal(ptr)
+			val := mkVal(caller, ptr)
 			params[i] = reflect.ValueOf(val.Get())
 			base = unsafe.Pointer(uintptr(base) + unsafe.Sizeof(raw))
 		}
@@ -290,15 +290,15 @@ func goTrampolineWrap(
 		ptr := (*C.wasmtime_val_t)(base)
 		switch val := result.Interface().(type) {
 		case int32:
-			*ptr = *ValI32(val).ptr()
+			ValI32(val).initialize(caller, ptr)
 		case int64:
-			*ptr = *ValI64(val).ptr()
+			ValI64(val).initialize(caller, ptr)
 		case float32:
-			*ptr = *ValF32(val).ptr()
+			ValF32(val).initialize(caller, ptr)
 		case float64:
-			*ptr = *ValF64(val).ptr()
+			ValF64(val).initialize(caller, ptr)
 		case *Func:
-			*ptr = *ValFuncref(val).ptr()
+			ValFuncref(val).initialize(caller, ptr)
 		case *Trap:
 			if val != nil {
 				runtime.SetFinalizer(val, nil)
@@ -312,9 +312,7 @@ func goTrampolineWrap(
 				}
 			}
 		default:
-			raw := ValExternref(val)
-			C.wasmtime_val_copy(ptr, raw.ptr())
-			runtime.KeepAlive(raw)
+			ValExternref(val).initialize(caller, ptr)
 		}
 		base = unsafe.Pointer(uintptr(base) + unsafe.Sizeof(raw))
 	}
@@ -401,14 +399,19 @@ func (f *Func) Call(store Storelike, args ...interface{}) (interface{}, error) {
 			C.go_wasmtime_val_f64_set(dst, C.double(val))
 		case *Func:
 			dst.kind = C.WASMTIME_FUNCREF
-			C.go_wasmtime_val_funcref_set(dst, val.val)
+			if val != nil {
+				C.go_wasmtime_val_funcref_set(dst, val.val)
+			} else {
+				empty := C.wasmtime_func_t{}
+				C.go_wasmtime_val_funcref_set(dst, empty)
+			}
 		case Val:
-			*dst = *val.ptr()
+			val.initialize(store, dst)
 
 		default:
 			externref := ValExternref(val)
 			externrefs = append(externrefs, externref)
-			*dst = *externref.ptr()
+			externref.initialize(store, dst)
 		}
 
 	}
@@ -447,12 +450,12 @@ func (f *Func) Call(store Storelike, args ...interface{}) (interface{}, error) {
 	if len(resultVals) == 0 {
 		return nil, nil
 	} else if len(resultVals) == 1 {
-		ret := takeVal(&resultVals[0]).Get()
+		ret := takeVal(store, &resultVals[0]).Get()
 		return ret, nil
 	} else {
 		results := make([]Val, len(resultVals))
 		for i := 0; i < len(results); i++ {
-			results[i] = takeVal(&resultVals[i])
+			results[i] = takeVal(store, &resultVals[i])
 		}
 		return results, nil
 	}
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/functype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/functype.go
similarity index 86%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/functype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/functype.go
index 8c071c362..dda8b5e92 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/functype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/functype.go
@@ -40,7 +40,7 @@ func mkFuncType(ptr *C.wasm_functype_t, owner interface{}) *FuncType {
 	functype := &FuncType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(functype, func(functype *FuncType) {
-			C.wasm_functype_delete(functype._ptr)
+			functype.Close()
 		})
 	}
 	return functype
@@ -48,6 +48,9 @@ func mkFuncType(ptr *C.wasm_functype_t, owner interface{}) *FuncType {
 
 func (ty *FuncType) ptr() *C.wasm_functype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -59,6 +62,18 @@ func (ty *FuncType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *FuncType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_functype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // Params returns the parameter types of this function type
 func (ty *FuncType) Params() []*ValType {
 	ptr := C.wasm_functype_params(ty.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/global.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/global.go
similarity index 83%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/global.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/global.go
index 63e1b7c25..5529a9e0d 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/global.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/global.go
@@ -19,15 +19,17 @@ func NewGlobal(
 	val Val,
 ) (*Global, error) {
 	var ret C.wasmtime_global_t
+	var raw_val C.wasmtime_val_t
+	val.initialize(store, &raw_val)
 	err := C.wasmtime_global_new(
 		store.Context(),
 		ty.ptr(),
-		val.ptr(),
+		&raw_val,
 		&ret,
 	)
+	C.wasmtime_val_unroot(store.Context(), &raw_val)
 	runtime.KeepAlive(store)
 	runtime.KeepAlive(ty)
-	runtime.KeepAlive(val)
 	if err != nil {
 		return nil, mkError(err)
 	}
@@ -51,14 +53,16 @@ func (g *Global) Get(store Storelike) Val {
 	ret := C.wasmtime_val_t{}
 	C.wasmtime_global_get(store.Context(), &g.val, &ret)
 	runtime.KeepAlive(store)
-	return takeVal(&ret)
+	return takeVal(store, &ret)
 }
 
 // Set sets the value of this global
 func (g *Global) Set(store Storelike, val Val) error {
-	err := C.wasmtime_global_set(store.Context(), &g.val, val.ptr())
+	var raw_val C.wasmtime_val_t
+	val.initialize(store, &raw_val)
+	err := C.wasmtime_global_set(store.Context(), &g.val, &raw_val)
+	C.wasmtime_val_unroot(store.Context(), &raw_val)
 	runtime.KeepAlive(store)
-	runtime.KeepAlive(val)
 	if err == nil {
 		return nil
 	}
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/globaltype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/globaltype.go
similarity index 82%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/globaltype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/globaltype.go
index b948febaf..f1ef0f873 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/globaltype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/globaltype.go
@@ -28,7 +28,7 @@ func mkGlobalType(ptr *C.wasm_globaltype_t, owner interface{}) *GlobalType {
 	globaltype := &GlobalType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(globaltype, func(globaltype *GlobalType) {
-			C.wasm_globaltype_delete(globaltype._ptr)
+			globaltype.Close()
 		})
 	}
 	return globaltype
@@ -36,6 +36,9 @@ func mkGlobalType(ptr *C.wasm_globaltype_t, owner interface{}) *GlobalType {
 
 func (ty *GlobalType) ptr() *C.wasm_globaltype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -47,6 +50,18 @@ func (ty *GlobalType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *GlobalType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_globaltype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // Content returns the type of value stored in this global
 func (ty *GlobalType) Content() *ValType {
 	ptr := C.wasm_globaltype_content(ty.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/importtype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/importtype.go
similarity index 85%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/importtype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/importtype.go
index a8f2fced5..770398254 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/importtype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/importtype.go
@@ -34,7 +34,7 @@ func mkImportType(ptr *C.wasm_importtype_t, owner interface{}) *ImportType {
 	importtype := &ImportType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(importtype, func(importtype *ImportType) {
-			C.wasm_importtype_delete(importtype._ptr)
+			importtype.Close()
 		})
 	}
 	return importtype
@@ -42,6 +42,9 @@ func mkImportType(ptr *C.wasm_importtype_t, owner interface{}) *ImportType {
 
 func (ty *ImportType) ptr() *C.wasm_importtype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -53,6 +56,18 @@ func (ty *ImportType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *ImportType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_importtype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // Module returns the name in the module this import type is importing
 func (ty *ImportType) Module() string {
 	ptr := C.wasm_importtype_module(ty.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v28/includebuild.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/includebuild.go
new file mode 100644
index 000000000..6ebb2abf3
--- /dev/null
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/includebuild.go
@@ -0,0 +1,22 @@
+//go:build includebuild
+// +build includebuild
+
+package wasmtime
+
+// This file is not built and not included in BUILD.bazel;
+// it is only used to prevent "go mod vendor" to prune the
+// build directory.
+
+import (
+	// Import these build directories in order to have them
+	// included in vendored dependencies.
+	// Cf. https://github.com/golang/go/issues/26366
+
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/include"
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime"
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64"
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64"
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64"
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64"
+	_ "github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64"
+)
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/instance.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/instance.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/instance.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/instance.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/linker.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/linker.go
similarity index 93%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/linker.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/linker.go
index df2f06896..a7eb8eff7 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/linker.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/linker.go
@@ -20,17 +20,33 @@ func NewLinker(engine *Engine) *Linker {
 	ptr := C.wasmtime_linker_new(engine.ptr())
 	linker := &Linker{_ptr: ptr, Engine: engine}
 	runtime.SetFinalizer(linker, func(linker *Linker) {
-		C.wasmtime_linker_delete(linker._ptr)
+		linker.Close()
 	})
 	return linker
 }
 
 func (l *Linker) ptr() *C.wasmtime_linker_t {
 	ret := l._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
 
+// Close will deallocate this linker's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (l *Linker) Close() {
+	if l._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(l, nil)
+	C.wasmtime_linker_delete(l._ptr)
+	l._ptr = nil
+
+}
+
 // AllowShadowing configures whether names can be redefined after they've already been defined
 // in this linker.
 func (l *Linker) AllowShadowing(allow bool) {
@@ -40,10 +56,11 @@ func (l *Linker) AllowShadowing(allow bool) {
 
 // Define defines a new item in this linker with the given module/name pair. Returns
 // an error if shadowing is disallowed and the module/name is already defined.
-func (l *Linker) Define(module, name string, item AsExtern) error {
+func (l *Linker) Define(store Storelike, module, name string, item AsExtern) error {
 	extern := item.AsExtern()
 	err := C.wasmtime_linker_define(
 		l.ptr(),
+		store.Context(),
 		C._GoStringPtr(module),
 		C._GoStringLen(module),
 		C._GoStringPtr(name),
@@ -54,6 +71,7 @@ func (l *Linker) Define(module, name string, item AsExtern) error {
 	runtime.KeepAlive(module)
 	runtime.KeepAlive(name)
 	runtime.KeepAlive(item)
+	runtime.KeepAlive(store)
 	if err == nil {
 		return nil
 	}
@@ -65,7 +83,7 @@ func (l *Linker) Define(module, name string, item AsExtern) error {
 //
 // Returns an error if shadowing is disabled and the name is already defined.
 func (l *Linker) DefineFunc(store Storelike, module, name string, f interface{}) error {
-	return l.Define(module, name, WrapFunc(store, f))
+	return l.Define(store, module, name, WrapFunc(store, f))
 }
 
 // FuncNew defines a function in this linker in the same style as `NewFunc`
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/maybe_gc_actual.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/maybe_gc_actual.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/maybe_gc_actual.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/maybe_gc_actual.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/maybe_gc_no.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/maybe_gc_no.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/maybe_gc_no.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/maybe_gc_no.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/memory.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/memory.go
similarity index 93%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/memory.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/memory.go
index 4b0d1fd6e..d5f222b0f 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/memory.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/memory.go
@@ -56,13 +56,8 @@ func (mem *Memory) Data(store Storelike) unsafe.Pointer {
 // `m` alive for long enough while you're using the `[]byte` slice. If the
 // `[]byte` slice is used after `m` is GC'd then that is undefined behavior.
 func (mem *Memory) UnsafeData(store Storelike) []byte {
-	// see https://github.com/golang/go/wiki/cgo#turning-c-arrays-into-go-slices
-	const MaxLen = 1 << 32
 	length := mem.DataSize(store)
-	if length >= MaxLen {
-		panic("memory is too big")
-	}
-	return (*[MaxLen]byte)(mem.Data(store))[:length:length]
+	return unsafe.Slice((*byte)(mem.Data(store)), length)
 }
 
 // DataSize returns the size, in bytes, that `Data()` is valid for
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/memorytype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/memorytype.go
similarity index 78%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/memorytype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/memorytype.go
index 3a5b7d6ce..ba22b198d 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/memorytype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/memorytype.go
@@ -19,11 +19,11 @@ type MemoryType struct {
 //
 // Note that this will create a 32-bit memory type, the default outside of the
 // memory64 proposal.
-func NewMemoryType(min uint32, has_max bool, max uint32) *MemoryType {
+func NewMemoryType(min uint32, has_max bool, max uint32, shared bool) *MemoryType {
 	if min > (1<<16) || max > (1<<16) {
 		panic("provided sizes are too large")
 	}
-	ptr := C.wasmtime_memorytype_new(C.uint64_t(min), C._Bool(has_max), C.uint64_t(max), false)
+	ptr := C.wasmtime_memorytype_new(C.uint64_t(min), C._Bool(has_max), C.uint64_t(max), false, C._Bool(shared))
 	return mkMemoryType(ptr, nil)
 }
 
@@ -34,11 +34,11 @@ func NewMemoryType(min uint32, has_max bool, max uint32) *MemoryType {
 // `max` is used as the maximum size of memory, in wasm pages.
 //
 // Note that 64-bit memories are part of the memory64 WebAssembly proposal.
-func NewMemoryType64(min uint64, has_max bool, max uint64) *MemoryType {
+func NewMemoryType64(min uint64, has_max bool, max uint64, shared bool) *MemoryType {
 	if min > (1<<48) || max > (1<<48) {
 		panic("provided sizes are too large")
 	}
-	ptr := C.wasmtime_memorytype_new(C.uint64_t(min), C._Bool(has_max), C.uint64_t(max), true)
+	ptr := C.wasmtime_memorytype_new(C.uint64_t(min), C._Bool(has_max), C.uint64_t(max), true, C._Bool(shared))
 	return mkMemoryType(ptr, nil)
 }
 
@@ -46,7 +46,7 @@ func mkMemoryType(ptr *C.wasm_memorytype_t, owner interface{}) *MemoryType {
 	memorytype := &MemoryType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(memorytype, func(memorytype *MemoryType) {
-			C.wasm_memorytype_delete(memorytype._ptr)
+			memorytype.Close()
 		})
 	}
 	return memorytype
@@ -54,6 +54,9 @@ func mkMemoryType(ptr *C.wasm_memorytype_t, owner interface{}) *MemoryType {
 
 func (ty *MemoryType) ptr() *C.wasm_memorytype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -65,6 +68,18 @@ func (ty *MemoryType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *MemoryType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_memorytype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // Minimum returns the minimum size of this memory, in WebAssembly pages
 func (ty *MemoryType) Minimum() uint64 {
 	ret := C.wasmtime_memorytype_minimum(ty.ptr())
@@ -91,6 +106,13 @@ func (ty *MemoryType) Is64() bool {
 	return bool(ok)
 }
 
+// IsShared returns whether this is a shared memory or not.
+func (ty *MemoryType) IsShared() bool {
+	ok := C.wasmtime_memorytype_isshared(ty.ptr())
+	runtime.KeepAlive(ty)
+	return bool(ok)
+}
+
 // AsExternType converts this type to an instance of `ExternType`
 func (ty *MemoryType) AsExternType() *ExternType {
 	ptr := C.wasm_memorytype_as_externtype_const(ty.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/module.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/module.go
similarity index 95%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/module.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/module.go
index c2ea718e0..a92f05add 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/module.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/module.go
@@ -81,17 +81,33 @@ func ModuleValidate(engine *Engine, wasm []byte) error {
 func mkModule(ptr *C.wasmtime_module_t) *Module {
 	module := &Module{_ptr: ptr}
 	runtime.SetFinalizer(module, func(module *Module) {
-		C.wasmtime_module_delete(module._ptr)
+		module.Close()
 	})
 	return module
 }
 
 func (m *Module) ptr() *C.wasmtime_module_t {
 	ret := m._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
 
+// Close will deallocate this module's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (m *Module) Close() {
+	if m._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(m, nil)
+	C.wasmtime_module_delete(m._ptr)
+	m._ptr = nil
+
+}
+
 // Imports returns a list of `ImportType` which are the items imported by
 // this module and are required for instantiation
 func (m *Module) Imports() []*ImportType {
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/shims.c b/vendor/github.com/bytecodealliance/wasmtime-go/v28/shims.c
similarity index 91%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/shims.c
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/shims.c
index 6940f95fe..412702a9a 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/shims.c
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/shims.c
@@ -63,8 +63,8 @@ wasmtime_error_t *go_linker_define_func(
   return wasmtime_linker_define_func(linker, module, module_len, name, name_len, ty, cb, (void*) env, finalizer);
 }
 
-wasmtime_externref_t *go_externref_new(size_t env) {
-  return wasmtime_externref_new((void*) env, goFinalizeExternref);
+bool go_externref_new(wasmtime_context_t *cx, size_t env, wasmtime_externref_t *ref) {
+  return wasmtime_externref_new(cx, (void*) env, goFinalizeExternref, ref);
 }
 
 #define UNION_ACCESSOR(name, field, ty) \
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/shims.h b/vendor/github.com/bytecodealliance/wasmtime-go/v28/shims.h
similarity index 88%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/shims.h
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/shims.h
index 3b42c48e7..c1098ecc4 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/shims.h
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/shims.h
@@ -13,14 +13,14 @@ wasmtime_error_t *go_linker_define_func(
     int wrap,
     size_t env
 );
-wasmtime_externref_t *go_externref_new(size_t env);
+bool go_externref_new(wasmtime_context_t *cx, size_t env, wasmtime_externref_t *ref);
 
 #define EACH_UNION_ACCESSOR(name) \
   UNION_ACCESSOR(wasmtime_val, i32, int32_t) \
   UNION_ACCESSOR(wasmtime_val, i64, int64_t) \
   UNION_ACCESSOR(wasmtime_val, f32, float) \
   UNION_ACCESSOR(wasmtime_val, f64, double) \
-  UNION_ACCESSOR(wasmtime_val, externref, wasmtime_externref_t*) \
+  UNION_ACCESSOR(wasmtime_val, externref, wasmtime_externref_t) \
   UNION_ACCESSOR(wasmtime_val, funcref, wasmtime_func_t) \
   \
   UNION_ACCESSOR(wasmtime_extern, func, wasmtime_func_t) \
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/slab.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/slab.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/slab.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/slab.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/store.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/store.go
similarity index 82%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/store.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/store.go
index 7dc8c59fa..f8b3abc60 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/store.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/store.go
@@ -69,7 +69,7 @@ func NewStore(engine *Engine) *Store {
 		Engine: engine,
 	}
 	runtime.SetFinalizer(store, func(store *Store) {
-		C.wasmtime_store_delete(store._ptr)
+		store.Close()
 	})
 	return store
 }
@@ -87,6 +87,27 @@ func goFinalizeStore(env unsafe.Pointer) {
 	gStoreSlab.deallocate(idx)
 }
 
+func (store *Store) ptr() *C.wasmtime_store_t {
+	ret := store._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
+	maybeGC()
+	return ret
+}
+
+// Close will deallocate this store's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (store *Store) Close() {
+	if store._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(store, nil)
+	C.wasmtime_store_delete(store._ptr)
+	store._ptr = nil
+}
+
 // GC will clean up any `externref` values that are no longer actually
 // referenced.
 //
@@ -106,17 +127,15 @@ func (store *Store) SetWasi(wasi *WasiConfig) {
 	runtime.SetFinalizer(wasi, nil)
 	ptr := wasi.ptr()
 	wasi._ptr = nil
-	if ptr == nil {
-		panic("reuse of already-consumed WasiConfig")
-	}
 	C.wasmtime_context_set_wasi(store.Context(), ptr)
 	runtime.KeepAlive(store)
 }
 
 // Implementation of the `Storelike` interface
 func (store *Store) Context() *C.wasmtime_context_t {
-	ret := C.wasmtime_store_context(store._ptr)
+	ret := C.wasmtime_store_context(store.ptr())
 	maybeGC()
+	runtime.KeepAlive(store)
 	return ret
 }
 
@@ -227,23 +246,27 @@ func goFinalizeFuncWrap(env unsafe.Pointer) {
 	gEngineFuncWrapSlab.deallocate(idx)
 }
 
-// FuelConsumed returns the amount of fuel consumed by this context's store
-// execution so far.
+// GetFuel returns the amount of fuel remaining in this store.
 //
-// If fuel consumption is not enabled via `Config.SetConsumeFuel` then this function
-// will return false. Otherwise true is returned and the fuel parameter is
-// filled in with fuel consumed so far.
+// If fuel consumption is not enabled via `Config.SetConsumeFuel` then
+// this function will return an error. Otherwise this will retrieve the fuel
+// remaining and return it.
 //
-// Also note that fuel, if enabled, must be originally configured via `Store.AddFuel`.
-func (store *Store) FuelConsumed() (uint64, bool) {
-	fuel := C.uint64_t(0)
-	enable := C.wasmtime_context_fuel_consumed(store.Context(), &fuel)
+// Also note that fuel, if enabled, must be originally configured via
+// `Store.SetFuel`.
+func (store *Store) GetFuel() (uint64, error) {
+	var remaining uint64
+	c_remaining := C.uint64_t(remaining)
+	err := C.wasmtime_context_get_fuel(store.Context(), &c_remaining)
 	runtime.KeepAlive(store)
+	if err != nil {
+		return 0, mkError(err)
+	}
 
-	return uint64(fuel), bool(enable)
+	return uint64(c_remaining), nil
 }
 
-// AddFuel adds fuel to this context's store for wasm to consume while executing.
+// SetFuel sets this store's fuel to the specified value.
 //
 // For this method to work fuel consumption must be enabled via
 // `Config.SetConsumeFuel`. By default a store starts with 0 fuel
@@ -255,8 +278,8 @@ func (store *Store) FuelConsumed() (uint64, bool) {
 // wasm to trap. More usages of fuel are planned for the future.
 //
 // If fuel is not enabled within this store then an error is returned.
-func (store *Store) AddFuel(fuel uint64) error {
-	err := C.wasmtime_context_add_fuel(store.Context(), C.uint64_t(fuel))
+func (store *Store) SetFuel(fuel uint64) error {
+	err := C.wasmtime_context_set_fuel(store.Context(), C.uint64_t(fuel))
 	runtime.KeepAlive(store)
 	if err != nil {
 		return mkError(err)
@@ -265,24 +288,23 @@ func (store *Store) AddFuel(fuel uint64) error {
 	return nil
 }
 
-// ConsumeFuel attempts to manually consume fuel from the store.
-//
-// If fuel consumption is not enabled via `Config.SetConsumeFuel` then
-// this function will return an error. Otherwise this will attempt to consume
-// the specified amount of `fuel` from the store. If successful the remaining
-// amount of fuel is returned. If `fuel` couldn't be consumed
-// then an error is returned.
-//
-// Also note that fuel, if enabled, must be originally configured via
-// `Store.AddFuel`.
-func (store *Store) ConsumeFuel(fuel uint64) (uint64, error) {
-	var remaining uint64
-	c_remaining := C.uint64_t(remaining)
-	err := C.wasmtime_context_consume_fuel(store.Context(), C.uint64_t(fuel), &c_remaining)
+// Limiter provides limits for a store. Used by hosts to limit resource
+// consumption of instances. Use negative value to keep the default value
+// for the limit.
+func (store *Store) Limiter(
+	memorySize int64,
+	tableElements int64,
+	instances int64,
+	tables int64,
+	memories int64,
+) {
+	C.wasmtime_store_limiter(
+		store.ptr(),
+		C.int64_t(memorySize),
+		C.int64_t(tableElements),
+		C.int64_t(instances),
+		C.int64_t(tables),
+		C.int64_t(memories),
+	)
 	runtime.KeepAlive(store)
-	if err != nil {
-		return 0, mkError(err)
-	}
-
-	return uint64(c_remaining), nil
 }
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/table.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/table.go
similarity index 70%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/table.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/table.go
index c0804fa23..9224f2f3b 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/table.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/table.go
@@ -23,10 +23,12 @@ type Table struct {
 // `ty`.
 func NewTable(store Storelike, ty *TableType, init Val) (*Table, error) {
 	var ret C.wasmtime_table_t
-	err := C.wasmtime_table_new(store.Context(), ty.ptr(), init.ptr(), &ret)
+	var raw_val C.wasmtime_val_t
+	init.initialize(store, &raw_val)
+	err := C.wasmtime_table_new(store.Context(), ty.ptr(), &raw_val, &ret)
+	C.wasmtime_val_unroot(store.Context(), &raw_val)
 	runtime.KeepAlive(store)
 	runtime.KeepAlive(ty)
-	runtime.KeepAlive(init)
 	if err != nil {
 		return nil, mkError(err)
 	}
@@ -38,10 +40,10 @@ func mkTable(val C.wasmtime_table_t) *Table {
 }
 
 // Size returns the size of this table in units of elements.
-func (t *Table) Size(store Storelike) uint32 {
+func (t *Table) Size(store Storelike) uint64 {
 	ret := C.wasmtime_table_size(store.Context(), &t.val)
 	runtime.KeepAlive(store)
-	return uint32(ret)
+	return uint64(ret)
 }
 
 // Grow grows this table by the number of units specified, using the
@@ -49,16 +51,18 @@ func (t *Table) Size(store Storelike) uint32 {
 //
 // Returns an error if the table failed to grow, or the previous size of the
 // table if growth was successful.
-func (t *Table) Grow(store Storelike, delta uint32, init Val) (uint32, error) {
-	var prev C.uint32_t
-	err := C.wasmtime_table_grow(store.Context(), &t.val, C.uint32_t(delta), init.ptr(), &prev)
+func (t *Table) Grow(store Storelike, delta uint64, init Val) (uint64, error) {
+	var prev C.uint64_t
+	var raw_val C.wasmtime_val_t
+	init.initialize(store, &raw_val)
+	err := C.wasmtime_table_grow(store.Context(), &t.val, C.uint64_t(delta), &raw_val, &prev)
+	C.wasmtime_val_unroot(store.Context(), &raw_val)
 	runtime.KeepAlive(store)
-	runtime.KeepAlive(init)
 	if err != nil {
 		return 0, mkError(err)
 	}
 
-	return uint32(prev), nil
+	return uint64(prev), nil
 }
 
 // Get gets an item from this table from the specified index.
@@ -66,23 +70,25 @@ func (t *Table) Grow(store Storelike, delta uint32, init Val) (uint32, error) {
 // Returns an error if the index is out of bounds, or returns a value (which
 // may be internally null) if the index is in bounds corresponding to the entry
 // at the specified index.
-func (t *Table) Get(store Storelike, idx uint32) (Val, error) {
+func (t *Table) Get(store Storelike, idx uint64) (Val, error) {
 	var val C.wasmtime_val_t
-	ok := C.wasmtime_table_get(store.Context(), &t.val, C.uint32_t(idx), &val)
+	ok := C.wasmtime_table_get(store.Context(), &t.val, C.uint64_t(idx), &val)
 	runtime.KeepAlive(store)
 	if !ok {
 		return Val{}, errors.New("index out of bounds")
 	}
-	return takeVal(&val), nil
+	return takeVal(store, &val), nil
 }
 
 // Set sets an item in this table at the specified index.
 //
 // Returns an error if the index is out of bounds.
-func (t *Table) Set(store Storelike, idx uint32, val Val) error {
-	err := C.wasmtime_table_set(store.Context(), &t.val, C.uint32_t(idx), val.ptr())
+func (t *Table) Set(store Storelike, idx uint64, val Val) error {
+	var raw_val C.wasmtime_val_t
+	val.initialize(store, &raw_val)
+	err := C.wasmtime_table_set(store.Context(), &t.val, C.uint64_t(idx), &raw_val)
+	C.wasmtime_val_unroot(store.Context(), &raw_val)
 	runtime.KeepAlive(store)
-	runtime.KeepAlive(val)
 	if err != nil {
 		return mkError(err)
 	}
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/tabletype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/tabletype.go
similarity index 86%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/tabletype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/tabletype.go
index 50da0c8ac..42a8635ab 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/tabletype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/tabletype.go
@@ -35,7 +35,7 @@ func mkTableType(ptr *C.wasm_tabletype_t, owner interface{}) *TableType {
 	tabletype := &TableType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(tabletype, func(tabletype *TableType) {
-			C.wasm_tabletype_delete(tabletype._ptr)
+			tabletype.Close()
 		})
 	}
 	return tabletype
@@ -43,6 +43,9 @@ func mkTableType(ptr *C.wasm_tabletype_t, owner interface{}) *TableType {
 
 func (ty *TableType) ptr() *C.wasm_tabletype_t {
 	ret := ty._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -54,6 +57,18 @@ func (ty *TableType) owner() interface{} {
 	return ty
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *TableType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_tabletype_delete(ty._ptr)
+	ty._ptr = nil
+}
+
 // Element returns the type of value stored in this table
 func (ty *TableType) Element() *ValType {
 	ptr := C.wasm_tabletype_element(ty.ptr())
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/trap.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/trap.go
similarity index 91%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/trap.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/trap.go
index 3860e3d1c..3eedf603a 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/trap.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/trap.go
@@ -50,6 +50,8 @@ const (
 	UnreachableCodeReached
 	// Interrupt: execution has been interrupted.
 	Interrupt
+	// OutOfFuel: Execution has run out of the configured fuel amount.
+	OutOfFuel
 )
 
 // NewTrap creates a new `Trap` with the `name` and the type provided.
@@ -69,10 +71,25 @@ func mkTrap(ptr *C.wasm_trap_t) *Trap {
 
 func (t *Trap) ptr() *C.wasm_trap_t {
 	ret := t._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
 
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (t *Trap) Close() {
+	if t._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(t, nil)
+	C.wasm_trap_delete(t._ptr)
+	t._ptr = nil
+}
+
 // Message returns the message of the `Trap`
 func (t *Trap) Message() string {
 	message := C.wasm_byte_vec_t{}
@@ -136,6 +153,9 @@ func (t *Trap) Frames() []*Frame {
 
 func (f *Frame) ptr() *C.wasm_frame_t {
 	ret := f._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/val.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/val.go
similarity index 50%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/val.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/val.go
index bdb8dadd9..42db83543 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/val.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/val.go
@@ -16,46 +16,35 @@ var gExternrefSlab slab
 // Val is a primitive numeric value.
 // Moreover, in the definition of programs, immutable sequences of values occur to represent more complex data, such as text strings or other vectors.
 type Val struct {
-	_raw *C.wasmtime_val_t
+	kind C.wasmtime_valkind_t
+	val  interface{}
 }
 
 // ValI32 converts a go int32 to a i32 Val
 func ValI32(val int32) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{kind: C.WASMTIME_I32}}
-	C.go_wasmtime_val_i32_set(ret.ptr(), C.int32_t(val))
-	return ret
+	return Val{kind: C.WASMTIME_I32, val: val}
 }
 
 // ValI64 converts a go int64 to a i64 Val
 func ValI64(val int64) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{kind: C.WASMTIME_I64}}
-	C.go_wasmtime_val_i64_set(ret.ptr(), C.int64_t(val))
-	return ret
+	return Val{kind: C.WASMTIME_I64, val: val}
 }
 
 // ValF32 converts a go float32 to a f32 Val
 func ValF32(val float32) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{kind: C.WASMTIME_F32}}
-	C.go_wasmtime_val_f32_set(ret.ptr(), C.float(val))
-	return ret
+	return Val{kind: C.WASMTIME_F32, val: val}
 }
 
 // ValF64 converts a go float64 to a f64 Val
 func ValF64(val float64) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{kind: C.WASMTIME_F64}}
-	C.go_wasmtime_val_f64_set(ret.ptr(), C.double(val))
-	return ret
+	return Val{kind: C.WASMTIME_F64, val: val}
 }
 
 // ValFuncref converts a Func to a funcref Val
 //
 // Note that `f` can be `nil` to represent a null `funcref`.
 func ValFuncref(f *Func) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{kind: C.WASMTIME_FUNCREF}}
-	if f != nil {
-		C.go_wasmtime_val_funcref_set(ret.ptr(), f.val)
-	}
-	return ret
+	return Val{kind: C.WASMTIME_FUNCREF, val: f}
 }
 
 // ValExternref converts a go value to a externref Val
@@ -64,24 +53,7 @@ func ValFuncref(f *Func) Val {
 // module for it to store. Later, when you get a `Val`, you can extract the type
 // with the `Externref()` method.
 func ValExternref(val interface{}) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{kind: C.WASMTIME_EXTERNREF}}
-
-	// If we have a non-nil value then store it in our global map of all
-	// externref values. Otherwise there's nothing for us to do since the
-	// `ref` field will already be a nil pointer.
-	//
-	// Note that we add 1 so all non-null externref values are created with
-	// non-null pointers.
-	if val != nil {
-		gExternrefLock.Lock()
-		defer gExternrefLock.Unlock()
-		index := gExternrefSlab.allocate()
-		gExternrefMap[index] = val
-		ptr := C.go_externref_new(C.size_t(index + 1))
-		C.go_wasmtime_val_externref_set(ret.ptr(), ptr)
-		ret.setDtor()
-	}
-	return ret
+	return Val{kind: C.WASMTIME_EXTERNREF, val: val}
 }
 
 //export goFinalizeExternref
@@ -93,35 +65,48 @@ func goFinalizeExternref(env unsafe.Pointer) {
 	gExternrefSlab.deallocate(idx)
 }
 
-func mkVal(src *C.wasmtime_val_t) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{}}
-	C.wasmtime_val_copy(ret.ptr(), src)
-	ret.setDtor()
-	return ret
-}
-
-func takeVal(src *C.wasmtime_val_t) Val {
-	ret := Val{_raw: &C.wasmtime_val_t{}}
-	*ret.ptr() = *src
-	ret.setDtor()
-	return ret
-}
+func mkVal(store Storelike, src *C.wasmtime_val_t) Val {
+	switch src.kind {
+	case C.WASMTIME_I32:
+		return ValI32(int32(C.go_wasmtime_val_i32_get(src)))
+	case C.WASMTIME_I64:
+		return ValI64(int64(C.go_wasmtime_val_i64_get(src)))
+	case C.WASMTIME_F32:
+		return ValF32(float32(C.go_wasmtime_val_f32_get(src)))
+	case C.WASMTIME_F64:
+		return ValF64(float64(C.go_wasmtime_val_f64_get(src)))
+	case C.WASMTIME_FUNCREF:
+		val := C.go_wasmtime_val_funcref_get(src)
+		if val.store_id == 0 {
+			return ValFuncref(nil)
+		} else {
+			return ValFuncref(mkFunc(val))
+		}
+	case C.WASMTIME_EXTERNREF:
+		val := C.go_wasmtime_val_externref_get(src)
+		if val.store_id == 0 {
+			return ValExternref(nil)
+		}
+		data := C.wasmtime_externref_data(store.Context(), &val)
+		runtime.KeepAlive(store)
 
-func (v Val) setDtor() {
-	runtime.SetFinalizer(v.ptr(), func(ptr *C.wasmtime_val_t) {
-		C.wasmtime_val_delete(ptr)
-	})
+		gExternrefLock.Lock()
+		defer gExternrefLock.Unlock()
+		return ValExternref(gExternrefMap[int(uintptr(data))-1])
+	}
+	panic("failed to get kind of `Val`")
 }
 
-func (v Val) ptr() *C.wasmtime_val_t {
-	ret := v._raw
-	maybeGC()
+func takeVal(store Storelike, src *C.wasmtime_val_t) Val {
+	ret := mkVal(store, src)
+	C.wasmtime_val_unroot(store.Context(), src)
+	runtime.KeepAlive(store)
 	return ret
 }
 
 // Kind returns the kind of value that this `Val` contains.
 func (v Val) Kind() ValKind {
-	switch v.ptr().kind {
+	switch v.kind {
 	case C.WASMTIME_I32:
 		return KindI32
 	case C.WASMTIME_I64:
@@ -143,7 +128,7 @@ func (v Val) I32() int32 {
 	if v.Kind() != KindI32 {
 		panic("not an i32")
 	}
-	return int32(C.go_wasmtime_val_i32_get(v.ptr()))
+	return v.val.(int32)
 }
 
 // I64 returns the underlying 64-bit integer if this is an `i64`, or panics.
@@ -151,7 +136,7 @@ func (v Val) I64() int64 {
 	if v.Kind() != KindI64 {
 		panic("not an i64")
 	}
-	return int64(C.go_wasmtime_val_i64_get(v.ptr()))
+	return v.val.(int64)
 }
 
 // F32 returns the underlying 32-bit float if this is an `f32`, or panics.
@@ -159,7 +144,7 @@ func (v Val) F32() float32 {
 	if v.Kind() != KindF32 {
 		panic("not an f32")
 	}
-	return float32(C.go_wasmtime_val_f32_get(v.ptr()))
+	return v.val.(float32)
 }
 
 // F64 returns the underlying 64-bit float if this is an `f64`, or panics.
@@ -167,7 +152,7 @@ func (v Val) F64() float64 {
 	if v.Kind() != KindF64 {
 		panic("not an f64")
 	}
-	return float64(C.go_wasmtime_val_f64_get(v.ptr()))
+	return v.val.(float64)
 }
 
 // Funcref returns the underlying function if this is a `funcref`, or panics.
@@ -177,12 +162,7 @@ func (v Val) Funcref() *Func {
 	if v.Kind() != KindFuncref {
 		panic("not a funcref")
 	}
-	val := C.go_wasmtime_val_funcref_get(v.ptr())
-	if val.store_id == 0 {
-		return nil
-	} else {
-		return mkFunc(val)
-	}
+	return v.val.(*Func)
 }
 
 // Externref returns the underlying value if this is an `externref`, or panics.
@@ -192,32 +172,57 @@ func (v Val) Externref() interface{} {
 	if v.Kind() != KindExternref {
 		panic("not an externref")
 	}
-	val := C.go_wasmtime_val_externref_get(v.ptr())
-	if val == nil {
-		return nil
-	}
-	data := C.wasmtime_externref_data(val)
-
-	gExternrefLock.Lock()
-	defer gExternrefLock.Unlock()
-	return gExternrefMap[int(uintptr(data))-1]
+	return v.val
 }
 
 // Get returns the underlying 64-bit float if this is an `f64`, or panics.
 func (v Val) Get() interface{} {
-	switch v.Kind() {
-	case KindI32:
-		return v.I32()
-	case KindI64:
-		return v.I64()
-	case KindF32:
-		return v.F32()
-	case KindF64:
-		return v.F64()
-	case KindFuncref:
-		return v.Funcref()
-	case KindExternref:
-		return v.Externref()
+	return v.val
+}
+
+func (v Val) initialize(store Storelike, ptr *C.wasmtime_val_t) {
+	ptr.kind = v.kind
+	switch v.kind {
+	case C.WASMTIME_I32:
+		C.go_wasmtime_val_i32_set(ptr, C.int32_t(v.val.(int32)))
+	case C.WASMTIME_I64:
+		C.go_wasmtime_val_i64_set(ptr, C.int64_t(v.val.(int64)))
+	case C.WASMTIME_F32:
+		C.go_wasmtime_val_f32_set(ptr, C.float(v.val.(float32)))
+	case C.WASMTIME_F64:
+		C.go_wasmtime_val_f64_set(ptr, C.double(v.val.(float64)))
+	case C.WASMTIME_FUNCREF:
+		val := v.val.(*Func)
+		if val != nil {
+			C.go_wasmtime_val_funcref_set(ptr, val.val)
+		} else {
+			empty := C.wasmtime_func_t{}
+			C.go_wasmtime_val_funcref_set(ptr, empty)
+		}
+	case C.WASMTIME_EXTERNREF:
+		// If we have a non-nil value then store it in our global map
+		// of all externref values. Otherwise there's nothing for us to
+		// do since the `ref` field will already be a nil pointer.
+		//
+		// Note that we add 1 so all non-null externref values are
+		// created with non-null pointers.
+		if v.val == nil {
+			C.go_wasmtime_val_externref_set(ptr, C.wasmtime_externref_t{})
+		} else {
+			gExternrefLock.Lock()
+			defer gExternrefLock.Unlock()
+			index := gExternrefSlab.allocate()
+			gExternrefMap[index] = v.val
+			var ref C.wasmtime_externref_t
+			ok := C.go_externref_new(store.Context(), C.size_t(index+1), &ref)
+			runtime.KeepAlive(store)
+			if ok {
+				C.go_wasmtime_val_externref_set(ptr, ref)
+			} else {
+				panic("failed to create an externref")
+			}
+		}
+	default:
+		panic("failed to get kind of `Val`")
 	}
-	panic("failed to get value of `Val`")
 }
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/valtype.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/valtype.go
similarity index 86%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/valtype.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/valtype.go
index 1ddb00a6a..106f35dee 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/valtype.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/valtype.go
@@ -17,7 +17,7 @@ const (
 	// KindF64 is the types f64 classify 64 bit floating-point data. They correspond to the respective binary floating-point representations, also known as single and double precision, as defined by the IEEE 754-2019 standard.
 	KindF64 ValKind = C.WASM_F64
 	// TODO: Unknown
-	KindExternref ValKind = C.WASM_ANYREF
+	KindExternref ValKind = C.WASM_EXTERNREF
 	// KindFuncref is the infinite union of all function types.
 	KindFuncref ValKind = C.WASM_FUNCREF
 )
@@ -57,7 +57,7 @@ func mkValType(ptr *C.wasm_valtype_t, owner interface{}) *ValType {
 	valtype := &ValType{_ptr: ptr, _owner: owner}
 	if owner == nil {
 		runtime.SetFinalizer(valtype, func(valtype *ValType) {
-			C.wasm_valtype_delete(valtype._ptr)
+			valtype.Close()
 		})
 	}
 	return valtype
@@ -78,6 +78,9 @@ func (t *ValType) String() string {
 
 func (t *ValType) ptr() *C.wasm_valtype_t {
 	ret := t._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
@@ -88,3 +91,15 @@ func (t *ValType) owner() interface{} {
 	}
 	return t
 }
+
+// Close will deallocate this type's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (ty *ValType) Close() {
+	if ty._ptr == nil || ty._owner != nil {
+		return
+	}
+	runtime.SetFinalizer(ty, nil)
+	C.wasm_valtype_delete(ty._ptr)
+	ty._ptr = nil
+}
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/wasi.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/wasi.go
similarity index 75%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/wasi.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/wasi.go
index 21900ffeb..da4bc6192 100644
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/wasi.go
+++ b/vendor/github.com/bytecodealliance/wasmtime-go/v28/wasi.go
@@ -17,17 +17,33 @@ func NewWasiConfig() *WasiConfig {
 	ptr := C.wasi_config_new()
 	config := &WasiConfig{_ptr: ptr}
 	runtime.SetFinalizer(config, func(config *WasiConfig) {
-		C.wasi_config_delete(config._ptr)
+		config.Close()
 	})
 	return config
 }
 
 func (c *WasiConfig) ptr() *C.wasi_config_t {
 	ret := c._ptr
+	if ret == nil {
+		panic("object has been closed already")
+	}
 	maybeGC()
 	return ret
 }
 
+// Close will deallocate this WASI configuration's state explicitly.
+//
+// For more information see the documentation for engine.Close()
+func (c *WasiConfig) Close() {
+	if c._ptr == nil {
+		return
+	}
+	runtime.SetFinalizer(c, nil)
+	C.wasi_config_delete(c._ptr)
+	c._ptr = nil
+
+}
+
 // SetArgv will explicitly configure the argv for this WASI configuration.
 // Note that this field can only be set, it cannot be read
 func (c *WasiConfig) SetArgv(argv []string) {
@@ -39,7 +55,7 @@ func (c *WasiConfig) SetArgv(argv []string) {
 	if len(ptrs) > 0 {
 		argvRaw = &ptrs[0]
 	}
-	C.wasi_config_set_argv(c.ptr(), C.int(len(argv)), argvRaw)
+	C.wasi_config_set_argv(c.ptr(), C.size_t(len(argv)), argvRaw)
 	runtime.KeepAlive(c)
 	for _, ptr := range ptrs {
 		C.free(unsafe.Pointer(ptr))
@@ -71,7 +87,7 @@ func (c *WasiConfig) SetEnv(keys, values []string) {
 		namesRaw = &namePtrs[0]
 		valuesRaw = &valuePtrs[0]
 	}
-	C.wasi_config_set_env(c.ptr(), C.int(len(keys)), namesRaw, valuesRaw)
+	C.wasi_config_set_env(c.ptr(), C.size_t(len(keys)), namesRaw, valuesRaw)
 	runtime.KeepAlive(c)
 	for i, ptr := range namePtrs {
 		C.free(unsafe.Pointer(ptr))
@@ -135,10 +151,21 @@ func (c *WasiConfig) InheritStderr() {
 	runtime.KeepAlive(c)
 }
 
-func (c *WasiConfig) PreopenDir(path, guestPath string) error {
+type WasiDirPerms uint8
+type WasiFilePerms uint8
+
+const (
+	DIR_READ   WasiDirPerms  = C.WASMTIME_WASI_DIR_PERMS_READ
+	DIR_WRITE  WasiDirPerms  = C.WASMTIME_WASI_DIR_PERMS_WRITE
+	FILE_READ  WasiFilePerms = C.WASMTIME_WASI_FILE_PERMS_READ
+	FILE_WRITE WasiFilePerms = C.WASMTIME_WASI_FILE_PERMS_WRITE
+)
+
+func (c *WasiConfig) PreopenDir(path, guestPath string, dirPerms WasiDirPerms, filePerms WasiFilePerms) error {
 	pathC := C.CString(path)
 	guestPathC := C.CString(guestPath)
-	ok := C.wasi_config_preopen_dir(c.ptr(), pathC, guestPathC)
+	ok := C.wasi_config_preopen_dir(c.ptr(), pathC, guestPathC,
+		C.wasi_dir_perms(dirPerms), C.wasi_file_perms(filePerms))
 	runtime.KeepAlive(c)
 	C.free(unsafe.Pointer(pathC))
 	C.free(unsafe.Pointer(guestPathC))
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/wat2wasm.go b/vendor/github.com/bytecodealliance/wasmtime-go/v28/wat2wasm.go
similarity index 100%
rename from vendor/github.com/bytecodealliance/wasmtime-go/v3/wat2wasm.go
rename to vendor/github.com/bytecodealliance/wasmtime-go/v28/wat2wasm.go
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasi.h b/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasi.h
deleted file mode 100644
index f3d1dfd45..000000000
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasi.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/**
- * \file wasi.h
- *
- * C API for WASI
- */
-
-#ifndef WASI_H
-#define WASI_H
-
-#include "wasm.h"
-
-#ifndef WASI_API_EXTERN
-#ifdef _WIN32
-#define WASI_API_EXTERN __declspec(dllimport)
-#else
-#define WASI_API_EXTERN
-#endif
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define own
-
-#define WASI_DECLARE_OWN(name) \
-  typedef struct wasi_##name##_t wasi_##name##_t; \
-  WASI_API_EXTERN void wasi_##name##_delete(own wasi_##name##_t*);
-
-/**
- * \typedef wasi_config_t
- * \brief Convenience alias for #wasi_config_t
- *
- * \struct wasi_config_t
- * \brief TODO
- *
- * \fn void wasi_config_delete(wasi_config_t *);
- * \brief Deletes a configuration object.
- */
-WASI_DECLARE_OWN(config)
-
-/**
- * \brief Creates a new empty configuration object.
- *
- * The caller is expected to deallocate the returned configuration
- */
-WASI_API_EXTERN own wasi_config_t* wasi_config_new();
-
-/**
- * \brief Sets the argv list for this configuration object.
- *
- * By default WASI programs have an empty argv list, but this can be used to
- * explicitly specify what the argv list for the program is.
- *
- * The arguments are copied into the `config` object as part of this function
- * call, so the `argv` pointer only needs to stay alive for this function call.
- */
-WASI_API_EXTERN void wasi_config_set_argv(wasi_config_t* config, int argc, const char* argv[]);
-
-/**
- * \brief Indicates that the argv list should be inherited from this process's
- * argv list.
- */
-WASI_API_EXTERN void wasi_config_inherit_argv(wasi_config_t* config);
-
-/**
- * \brief Sets the list of environment variables available to the WASI instance.
- *
- * By default WASI programs have a blank environment, but this can be used to
- * define some environment variables for them.
- *
- * It is required that the `names` and `values` lists both have `envc` entries.
- *
- * The env vars are copied into the `config` object as part of this function
- * call, so the `names` and `values` pointers only need to stay alive for this
- * function call.
- */
-WASI_API_EXTERN void wasi_config_set_env(wasi_config_t* config, int envc, const char* names[], const char* values[]);
-
-/**
- * \brief Indicates that the entire environment of the calling process should be
- * inherited by this WASI configuration.
- */
-WASI_API_EXTERN void wasi_config_inherit_env(wasi_config_t* config);
-
-/**
- * \brief Configures standard input to be taken from the specified file.
- *
- * By default WASI programs have no stdin, but this configures the specified
- * file to be used as stdin for this configuration.
- *
- * If the stdin location does not exist or it cannot be opened for reading then
- * `false` is returned. Otherwise `true` is returned.
- */
-WASI_API_EXTERN bool wasi_config_set_stdin_file(wasi_config_t* config, const char* path);
-
-/**
- * \brief Configures standard input to be taken from the specified #wasm_byte_vec_t.
- *
- * By default WASI programs have no stdin, but this configures the specified
- * bytes to be used as stdin for this configuration.
- *
- * This function takes ownership of the `binary` argument.
- */
-WASI_API_EXTERN void wasi_config_set_stdin_bytes(wasi_config_t* config, wasm_byte_vec_t* binary);
-
-/**
- * \brief Configures this process's own stdin stream to be used as stdin for
- * this WASI configuration.
- */
-WASI_API_EXTERN void wasi_config_inherit_stdin(wasi_config_t* config);
-
-/**
- * \brief Configures standard output to be written to the specified file.
- *
- * By default WASI programs have no stdout, but this configures the specified
- * file to be used as stdout.
- *
- * If the stdout location could not be opened for writing then `false` is
- * returned. Otherwise `true` is returned.
- */
-WASI_API_EXTERN bool wasi_config_set_stdout_file(wasi_config_t* config, const char* path);
-
-/**
- * \brief Configures this process's own stdout stream to be used as stdout for
- * this WASI configuration.
- */
-WASI_API_EXTERN void wasi_config_inherit_stdout(wasi_config_t* config);
-
-/**
- * \brief Configures standard output to be written to the specified file.
- *
- * By default WASI programs have no stderr, but this configures the specified
- * file to be used as stderr.
- *
- * If the stderr location could not be opened for writing then `false` is
- * returned. Otherwise `true` is returned.
- */
-WASI_API_EXTERN bool wasi_config_set_stderr_file(wasi_config_t* config, const char* path);
-
-/**
- * \brief Configures this process's own stderr stream to be used as stderr for
- * this WASI configuration.
- */
-WASI_API_EXTERN void wasi_config_inherit_stderr(wasi_config_t* config);
-
-/**
- * \brief Configures a "preopened directory" to be available to WASI APIs.
- *
- * By default WASI programs do not have access to anything on the filesystem.
- * This API can be used to grant WASI programs access to a directory on the
- * filesystem, but only that directory (its whole contents but nothing above it).
- *
- * The `path` argument here is a path name on the host filesystem, and
- * `guest_path` is the name by which it will be known in wasm.
- */
-WASI_API_EXTERN bool wasi_config_preopen_dir(wasi_config_t* config, const char* path, const char* guest_path);
-
-#undef own
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif  // #ifdef WASI_H
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/config.h b/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/config.h
deleted file mode 100644
index 77c119363..000000000
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/config.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/**
- * \file wasmtime/config.h
- *
- * \brief Wasmtime-specific extensions to #wasm_config_t
- */
-
-#ifndef WASMTIME_CONFIG_H
-#define WASMTIME_CONFIG_H
-
-#include <wasm.h>
-#include <wasmtime/error.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \brief Specifier for how Wasmtime will compile code, values are in
- * #wasmtime_strategy_enum
- */
-typedef uint8_t wasmtime_strategy_t;
-
-/**
- * \brief Different ways that Wasmtime can compile WebAssembly
- *
- * The default value is #WASMTIME_STRATEGY_AUTO.
- */
-enum wasmtime_strategy_enum { // Strategy
-  /// Automatically picks the compilation backend, currently always defaulting
-  /// to Cranelift.
-  WASMTIME_STRATEGY_AUTO,
-
-  /// Indicates that Wasmtime will unconditionally use Cranelift to compile
-  /// WebAssembly code.
-  WASMTIME_STRATEGY_CRANELIFT,
-};
-
-/**
- * \brief Specifier of what optimization level to use for generated JIT code.
- *
- * See #wasmtime_opt_level_enum for possible values.
- */
-typedef uint8_t wasmtime_opt_level_t;
-
-/**
- * \brief Different ways Wasmtime can optimize generated code.
- *
- * The default value is #WASMTIME_OPT_LEVEL_SPEED.
- */
-enum wasmtime_opt_level_enum { // OptLevel
-  /// Generated code will not be optimized at all.
-  WASMTIME_OPT_LEVEL_NONE,
-  /// Generated code will be optimized purely for speed.
-  WASMTIME_OPT_LEVEL_SPEED,
-  /// Generated code will be optimized, but some speed optimizations are
-  /// disabled if they cause the generated code to be significantly larger.
-  WASMTIME_OPT_LEVEL_SPEED_AND_SIZE,
-};
-
-/**
- * \brief Different ways wasmtime can enable profiling JIT code.
- *
- * See #wasmtime_profiling_strategy_enum for possible values.
- */
-typedef uint8_t wasmtime_profiling_strategy_t;
-
-/**
- * \brief Different ways to profile JIT code.
- *
- * The default is #WASMTIME_PROFILING_STRATEGY_NONE.
- */
-enum wasmtime_profiling_strategy_enum { // ProfilingStrategy
-  /// No profiling is enabled at runtime.
-  WASMTIME_PROFILING_STRATEGY_NONE,
-  /// Linux's "jitdump" support in `perf` is enabled and when Wasmtime is run
-  /// under `perf` necessary calls will be made to profile generated JIT code.
-  WASMTIME_PROFILING_STRATEGY_JITDUMP,
-  /// Support for VTune will be enabled and the VTune runtime will be informed,
-  /// at runtime, about JIT code.
-  ///
-  /// Note that this isn't always enabled at build time.
-  WASMTIME_PROFILING_STRATEGY_VTUNE,
-};
-
-#define WASMTIME_CONFIG_PROP(ret, name, ty) \
-    WASM_API_EXTERN ret wasmtime_config_##name##_set(wasm_config_t*, ty);
-
-/**
- * \brief Configures whether DWARF debug information is constructed at runtime
- * to describe JIT code.
- *
- * This setting is `false` by default. When enabled it will attempt to inform
- * native debuggers about DWARF debugging information for JIT code to more
- * easily debug compiled WebAssembly via native debuggers. This can also
- * sometimes improve the quality of output when profiling is enabled.
- */
-WASMTIME_CONFIG_PROP(void, debug_info, bool)
-
-/**
- * \brief Whether or not fuel is enabled for generated code.
- *
- * This setting is `false` by default. When enabled it will enable fuel counting
- * meaning that fuel will be consumed every time a wasm instruction is executed,
- * and trap when reaching zero.
- */
-WASMTIME_CONFIG_PROP(void, consume_fuel, bool)
-
-/**
- * \brief Whether or not epoch-based interruption is enabled for generated code.
- *
- * This setting is `false` by default. When enabled wasm code will check the
- * current epoch periodically and abort if the current epoch is beyond a
- * store-configured limit.
- *
- * Note that when this setting is enabled all stores will immediately trap and
- * need to have their epoch deadline otherwise configured with
- * #wasmtime_context_set_epoch_deadline.
- *
- * Note that the current epoch is engine-local and can be incremented with
- * #wasmtime_engine_increment_epoch.
- */
-WASMTIME_CONFIG_PROP(void, epoch_interruption, bool)
-
-/**
- * \brief Configures the maximum stack size, in bytes, that JIT code can use.
- *
- * This setting is 2MB by default. Configuring this setting will limit the
- * amount of native stack space that JIT code can use while it is executing. If
- * you're hitting stack overflow you can try making this setting larger, or if
- * you'd like to limit wasm programs to less stack you can also configure this.
- *
- * Note that this setting is not interpreted with 100% precision. Additionally
- * the amount of stack space that wasm takes is always relative to the first
- * invocation of wasm on the stack, so recursive calls with host frames in the
- * middle will all need to fit within this setting.
- */
-WASMTIME_CONFIG_PROP(void, max_wasm_stack, size_t)
-
-/**
- * \brief Configures whether the WebAssembly threading proposal is enabled.
- *
- * This setting is `false` by default.
- *
- * Note that threads are largely unimplemented in Wasmtime at this time.
- */
-WASMTIME_CONFIG_PROP(void, wasm_threads, bool)
-
-/**
- * \brief Configures whether the WebAssembly reference types proposal is
- * enabled.
- *
- * This setting is `false` by default.
- */
-WASMTIME_CONFIG_PROP(void, wasm_reference_types, bool)
-
-/**
- * \brief Configures whether the WebAssembly SIMD proposal is
- * enabled.
- *
- * This setting is `false` by default.
- */
-WASMTIME_CONFIG_PROP(void, wasm_simd, bool)
-
-/**
- * \brief Configures whether the WebAssembly bulk memory proposal is
- * enabled.
- *
- * This setting is `false` by default.
- */
-WASMTIME_CONFIG_PROP(void, wasm_bulk_memory, bool)
-
-/**
- * \brief Configures whether the WebAssembly multi value proposal is
- * enabled.
- *
- * This setting is `true` by default.
- */
-WASMTIME_CONFIG_PROP(void, wasm_multi_value, bool)
-
-/**
- * \brief Configures whether the WebAssembly multi-memory proposal is
- * enabled.
- *
- * This setting is `false` by default.
- */
-WASMTIME_CONFIG_PROP(void, wasm_multi_memory, bool)
-
-/**
- * \brief Configures whether the WebAssembly memory64 proposal is
- * enabled.
- *
- * This setting is `false` by default.
- */
-WASMTIME_CONFIG_PROP(void, wasm_memory64, bool)
-
-/**
- * \brief Configures how JIT code will be compiled.
- *
- * This setting is #WASMTIME_STRATEGY_AUTO by default.
- */
-WASMTIME_CONFIG_PROP(void, strategy, wasmtime_strategy_t)
-
-/**
- * \brief Configures whether Cranelift's debug verifier is enabled.
- *
- * This setting in `false` by default.
- *
- * When cranelift is used for compilation this enables expensive debug checks
- * within Cranelift itself to verify it's correct.
- */
-WASMTIME_CONFIG_PROP(void, cranelift_debug_verifier, bool)
-
-/**
- * \brief Configures whether Cranelift should perform a NaN-canonicalization pass.
- *
- * When Cranelift is used as a code generation backend this will configure
- * it to replace NaNs with a single canonical value. This is useful for users
- * requiring entirely deterministic WebAssembly computation.
- * 
- * This is not required by the WebAssembly spec, so it is not enabled by default.
- * 
- * The default value for this is `false`
- */
-WASMTIME_CONFIG_PROP(void, cranelift_nan_canonicalization, bool)
-  
-/**
- * \brief Configures Cranelift's optimization level for JIT code.
- *
- * This setting in #WASMTIME_OPT_LEVEL_SPEED by default.
- */
-WASMTIME_CONFIG_PROP(void, cranelift_opt_level, wasmtime_opt_level_t)
-
-/**
- * \brief Configures the profiling strategy used for JIT code.
- *
- * This setting in #WASMTIME_PROFILING_STRATEGY_NONE by default.
- */
-WASMTIME_CONFIG_PROP(void, profiler, wasmtime_profiling_strategy_t)
-
-/**
- * \brief Configures the maximum size for memory to be considered "static"
- *
- * For more information see the Rust documentation at
- * https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.static_memory_maximum_size.
- */
-WASMTIME_CONFIG_PROP(void, static_memory_maximum_size, uint64_t)
-
-/**
- * \brief Configures the guard region size for "static" memory.
- *
- * For more information see the Rust documentation at
- * https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.static_memory_guard_size.
- */
-WASMTIME_CONFIG_PROP(void, static_memory_guard_size, uint64_t)
-
-/**
- * \brief Configures the guard region size for "dynamic" memory.
- *
- * For more information see the Rust documentation at
- * https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.dynamic_memory_guard_size.
- */
-WASMTIME_CONFIG_PROP(void, dynamic_memory_guard_size, uint64_t)
-
-/**
- * \brief Enables Wasmtime's cache and loads configuration from the specified
- * path.
- *
- * By default the Wasmtime compilation cache is disabled. The configuration path
- * here can be `NULL` to use the default settings, and otherwise the argument
- * here must be a file on the filesystem with TOML configuration -
- * https://bytecodealliance.github.io/wasmtime/cli-cache.html.
- *
- * An error is returned if the cache configuration could not be loaded or if the
- * cache could not be enabled.
- */
-WASM_API_EXTERN wasmtime_error_t* wasmtime_config_cache_config_load(wasm_config_t*, const char*);
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif // WASMTIME_CONFIG_H
-
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/store.h b/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/store.h
deleted file mode 100644
index 55c9f680b..000000000
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/store.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/**
- * \file wasmtime/store.h
- *
- * Wasmtime definition of a "store".
- */
-
-#ifndef WASMTIME_STORE_H
-#define WASMTIME_STORE_H
-
-#include <wasm.h>
-#include <wasi.h>
-#include <wasmtime/error.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \typedef wasmtime_store_t
- * \brief Convenience alias for #wasmtime_store_t
- *
- * \struct wasmtime_store
- * \brief Storage of WebAssembly objects
- *
- * A store is the unit of isolation between WebAssembly instances in an
- * embedding of Wasmtime. Values in one #wasmtime_store_t cannot flow into
- * another #wasmtime_store_t. Stores are cheap to create and cheap to dispose.
- * It's expected that one-off stores are common in embeddings.
- *
- * Objects stored within a #wasmtime_store_t are referenced with integer handles
- * rather than interior pointers. This means that most APIs require that the
- * store be explicitly passed in, which is done via #wasmtime_context_t. It is
- * safe to move a #wasmtime_store_t to any thread at any time. A store generally
- * cannot be concurrently used, however.
- */
-typedef struct wasmtime_store wasmtime_store_t;
-
-/**
- * \typedef wasmtime_context_t
- * \brief Convenience alias for #wasmtime_context
- *
- * \struct wasmtime_context
- * \brief An interior pointer into a #wasmtime_store_t which is used as
- * "context" for many functions.
- *
- * This context pointer is used pervasively throught Wasmtime's API. This can be
- * acquired from #wasmtime_store_context or #wasmtime_caller_context. The
- * context pointer for a store is the same for the entire lifetime of a store,
- * so it can safely be stored adjacent to a #wasmtime_store_t itself.
- *
- * Usage of a #wasmtime_context_t must not outlive the original
- * #wasmtime_store_t. Additionally #wasmtime_context_t can only be used in
- * situations where it has explicitly been granted access to doing so. For
- * example finalizers cannot use #wasmtime_context_t because they are not given
- * access to it.
- */
-typedef struct wasmtime_context wasmtime_context_t;
-
-/**
- * \brief Creates a new store within the specified engine.
- *
- * \param engine the compilation environment with configuration this store is
- * connected to
- * \param data user-provided data to store, can later be acquired with
- * #wasmtime_context_get_data.
- * \param finalizer an optional finalizer for `data`
- *
- * This function creates a fresh store with the provided configuration settings.
- * The returned store must be deleted with #wasmtime_store_delete.
- */
-WASM_API_EXTERN wasmtime_store_t *wasmtime_store_new(
-    wasm_engine_t *engine,
-    void *data,
-    void (*finalizer)(void*)
-);
-
-/**
- * \brief Returns the interior #wasmtime_context_t pointer to this store
- */
-WASM_API_EXTERN wasmtime_context_t *wasmtime_store_context(wasmtime_store_t *store);
-
-/**
- * \brief Deletes a store.
- */
-WASM_API_EXTERN void wasmtime_store_delete(wasmtime_store_t *store);
-
-/**
- * \brief Returns the user-specified data associated with the specified store
- */
-WASM_API_EXTERN void *wasmtime_context_get_data(const wasmtime_context_t* context);
-
-/**
- * \brief Overwrites the user-specified data associated with this store.
- *
- * Note that this does not execute the original finalizer for the provided data,
- * and the original finalizer will be executed for the provided data when the
- * store is deleted.
- */
-WASM_API_EXTERN void wasmtime_context_set_data(wasmtime_context_t* context, void *data);
-
-/**
- * \brief Perform garbage collection within the given context.
- *
- * Garbage collects `externref`s that are used within this store. Any
- * `externref`s that are discovered to be unreachable by other code or objects
- * will have their finalizers run.
- *
- * The `context` argument must not be NULL.
- */
-WASM_API_EXTERN void wasmtime_context_gc(wasmtime_context_t* context);
-
-/**
- * \brief Adds fuel to this context's store for wasm to consume while executing.
- *
- * For this method to work fuel consumption must be enabled via
- * #wasmtime_config_consume_fuel_set. By default a store starts with 0 fuel
- * for wasm to execute with (meaning it will immediately trap).
- * This function must be called for the store to have
- * some fuel to allow WebAssembly to execute.
- *
- * Note that at this time when fuel is entirely consumed it will cause
- * wasm to trap. More usages of fuel are planned for the future.
- *
- * If fuel is not enabled within this store then an error is returned. If fuel
- * is successfully added then NULL is returned.
- */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_context_add_fuel(wasmtime_context_t *store, uint64_t fuel);
-
-/**
- * \brief Returns the amount of fuel consumed by this context's store execution
- * so far.
- *
- * If fuel consumption is not enabled via #wasmtime_config_consume_fuel_set
- * then this function will return false. Otherwise true is returned and the
- * fuel parameter is filled in with fuel consuemd so far.
- *
- * Also note that fuel, if enabled, must be originally configured via
- * #wasmtime_context_add_fuel.
- */
-WASM_API_EXTERN bool wasmtime_context_fuel_consumed(const wasmtime_context_t *context, uint64_t *fuel);
-
-/**
- * \brief Attempt to manually consume fuel from the store.
- *
- * If fuel consumption is not enabled via #wasmtime_config_consume_fuel_set then
- * this function will return an error. Otherwise this will attempt to consume
- * the specified amount of `fuel` from the store. If successful the remaining
- * amount of fuel is stored into `remaining`. If `fuel` couldn't be consumed
- * then an error is returned.
- *
- * Also note that fuel, if enabled, must be originally configured via
- * #wasmtime_context_add_fuel.
- */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_context_consume_fuel(wasmtime_context_t *context, uint64_t fuel, uint64_t *remaining);
-
-/**
- * \brief Configures WASI state within the specified store.
- *
- * This function is required if #wasmtime_linker_define_wasi is called. This
- * will configure the WASI state for instances defined within this store to the
- * configuration specified.
- *
- * This function does not take ownership of `context` but it does take ownership
- * of `wasi`. The caller should no longer use `wasi` after calling this function
- * (even if an error is returned).
- */
-WASM_API_EXTERN wasmtime_error_t *wasmtime_context_set_wasi(wasmtime_context_t *context, wasi_config_t *wasi);
-
-/**
- * \brief Configures the relative deadline at which point WebAssembly code will
- * trap.
- *
- * This function configures the store-local epoch deadline after which point
- * WebAssembly code will trap.
- *
- * See also #wasmtime_config_epoch_interruption_set.
- */
-WASM_API_EXTERN void wasmtime_context_set_epoch_deadline(wasmtime_context_t *context, uint64_t ticks_beyond_current);
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif // WASMTIME_STORE_H
-
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/val.h b/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/val.h
deleted file mode 100644
index ae0a1961c..000000000
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime/val.h
+++ /dev/null
@@ -1,232 +0,0 @@
-/**
- * \file wasmtime/val.h
- *
- * APIs for interacting with WebAssembly values in Wasmtime.
- */
-
-#ifndef WASMTIME_VAL_H
-#define WASMTIME_VAL_H
-
-#include <wasm.h>
-#include <wasmtime/extern.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \typedef wasmtime_externref_t
- * \brief Convenience alias for #wasmtime_externref
- *
- * \struct wasmtime_externref
- * \brief A host-defined un-forgeable reference to pass into WebAssembly.
- *
- * This structure represents an `externref` that can be passed to WebAssembly.
- * It cannot be forged by WebAssembly itself and is guaranteed to have been
- * created by the host.
- */
-typedef struct wasmtime_externref wasmtime_externref_t;
-
-/**
- * \brief Create a new `externref` value.
- *
- * Creates a new `externref` value wrapping the provided data, returning the
- * pointer to the externref.
- *
- * \param data the host-specific data to wrap
- * \param finalizer an optional finalizer for `data`
- *
- * When the reference is reclaimed, the wrapped data is cleaned up with the
- * provided `finalizer`.
- *
- * The returned value must be deleted with #wasmtime_externref_delete
- */
-WASM_API_EXTERN wasmtime_externref_t *wasmtime_externref_new(void *data, void (*finalizer)(void*));
-
-/**
- * \brief Get an `externref`'s wrapped data
- *
- * Returns the original `data` passed to #wasmtime_externref_new. It is required
- * that `data` is not `NULL`.
- */
-WASM_API_EXTERN void *wasmtime_externref_data(wasmtime_externref_t *data);
-
-/**
- * \brief Creates a shallow copy of the `externref` argument, returning a
- * separately owned pointer (increases the reference count).
- */
-WASM_API_EXTERN wasmtime_externref_t *wasmtime_externref_clone(wasmtime_externref_t *ref);
-
-/**
- * \brief Decrements the reference count of the `ref`, deleting it if it's the
- * last reference.
- */
-WASM_API_EXTERN void wasmtime_externref_delete(wasmtime_externref_t *ref);
-
-/**
- * \brief Converts a raw `externref` value coming from #wasmtime_val_raw_t into
- * a #wasmtime_externref_t.
- *
- * Note that the returned #wasmtime_externref_t is an owned value that must be
- * deleted via #wasmtime_externref_delete by the caller if it is non-null.
- */
-WASM_API_EXTERN wasmtime_externref_t *wasmtime_externref_from_raw(wasmtime_context_t *context, size_t raw);
-
-/**
- * \brief Converts a #wasmtime_externref_t to a raw value suitable for storing
- * into a #wasmtime_val_raw_t.
- *
- * Note that the returned underlying value is not tracked by Wasmtime's garbage
- * collector until it enters WebAssembly. This means that a GC may release the
- * context's reference to the raw value, making the raw value invalid within the
- * context of the store. Do not perform a GC between calling this function and
- * passing it to WebAssembly.
- */
-WASM_API_EXTERN size_t wasmtime_externref_to_raw(
-    wasmtime_context_t *context,
-    const wasmtime_externref_t *ref);
-
-/// \brief Discriminant stored in #wasmtime_val::kind
-typedef uint8_t wasmtime_valkind_t;
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an i32
-#define WASMTIME_I32 0
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an i64
-#define WASMTIME_I64 1
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a f32
-#define WASMTIME_F32 2
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a f64
-#define WASMTIME_F64 3
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a v128
-#define WASMTIME_V128 4
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is a funcref
-#define WASMTIME_FUNCREF 5
-/// \brief Value of #wasmtime_valkind_t meaning that #wasmtime_val_t is an externref
-#define WASMTIME_EXTERNREF 6
-
-/// \brief A 128-bit value representing the WebAssembly `v128` type. Bytes are
-/// stored in little-endian order.
-typedef uint8_t wasmtime_v128[16];
-
-/**
- * \typedef wasmtime_valunion_t
- * \brief Convenience alias for #wasmtime_valunion
- *
- * \union wasmtime_valunion
- * \brief Container for different kinds of wasm values.
- *
- * This type is contained in #wasmtime_val_t and contains the payload for the
- * various kinds of items a value can be.
- */
-typedef union wasmtime_valunion {
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I32
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  int32_t i32;
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I64
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  int64_t i64;
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F32
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  float32_t f32;
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F64
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  float64_t f64;
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_FUNCREF
-  ///
-  /// If this value represents a `ref.null func` value then the `store_id` field
-  /// is set to zero.
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  wasmtime_func_t funcref;
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_EXTERNREF
-  ///
-  /// If this value represents a `ref.null extern` value then this pointer will
-  /// be `NULL`.
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  wasmtime_externref_t *externref;
-  /// Field used if #wasmtime_val_t::kind is #WASMTIME_V128
-  ///
-  /// Note that this field is always stored in a little-endian format.
-  wasmtime_v128 v128;
-} wasmtime_valunion_t;
-
-/**
- * \typedef wasmtime_val_raw_t
- * \brief Convenience alias for #wasmtime_val_raw
- *
- * \union wasmtime_val_raw
- * \brief Container for possible wasm values.
- *
- * This type is used on conjunction with #wasmtime_func_new_unchecked as well
- * as #wasmtime_func_call_unchecked. Instances of this type do not have type
- * information associated with them, it's up to the embedder to figure out
- * how to interpret the bits contained within, often using some other channel
- * to determine the type.
- */
-typedef union wasmtime_val_raw {
-  /// Field for when this val is a WebAssembly `i32` value.
-  int32_t i32;
-  /// Field for when this val is a WebAssembly `i64` value.
-  int64_t i64;
-  /// Field for when this val is a WebAssembly `f32` value.
-  float32_t f32;
-  /// Field for when this val is a WebAssembly `f64` value.
-  float64_t f64;
-  /// Field for when this val is a WebAssembly `v128` value.
-  wasmtime_v128 v128;
-  /// Field for when this val is a WebAssembly `funcref` value.
-  ///
-  /// If this is set to 0 then it's a null funcref, otherwise this must be
-  /// passed to `wasmtime_func_from_raw` to determine the `wasmtime_func_t`.
-  size_t funcref;
-  /// Field for when this val is a WebAssembly `externref` value.
-  ///
-  /// If this is set to 0 then it's a null externref, otherwise this must be
-  /// passed to `wasmtime_externref_from_raw` to determine the
-  /// `wasmtime_externref_t`.
-  size_t externref;
-} wasmtime_val_raw_t;
-
-/**
- * \typedef wasmtime_val_t
- * \brief Convenience alias for #wasmtime_val_t
- *
- * \union wasmtime_val
- * \brief Container for different kinds of wasm values.
- *
- * Note that this structure may contain an owned value, namely
- * #wasmtime_externref_t, depending on the context in which this is used. APIs
- * which consume a #wasmtime_val_t do not take ownership, but APIs that return
- * #wasmtime_val_t require that #wasmtime_val_delete is called to deallocate
- * the value.
- */
-typedef struct wasmtime_val {
-  /// Discriminant of which field of #of is valid.
-  wasmtime_valkind_t kind;
-  /// Container for the extern item's value.
-  wasmtime_valunion_t of;
-} wasmtime_val_t;
-
-/**
- * \brief Delets an owned #wasmtime_val_t.
- *
- * Note that this only deletes the contents, not the memory that `val` points to
- * itself (which is owned by the caller).
- */
-WASM_API_EXTERN void wasmtime_val_delete(wasmtime_val_t *val);
-
-/**
- * \brief Copies `src` into `dst`.
- */
-WASM_API_EXTERN void wasmtime_val_copy(wasmtime_val_t *dst, const wasmtime_val_t *src);
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif // WASMTIME_VAL_H
-
diff --git a/vendor/github.com/bytecodealliance/wasmtime-go/v3/includebuild.go b/vendor/github.com/bytecodealliance/wasmtime-go/v3/includebuild.go
deleted file mode 100644
index 6b234afcd..000000000
--- a/vendor/github.com/bytecodealliance/wasmtime-go/v3/includebuild.go
+++ /dev/null
@@ -1,22 +0,0 @@
-//go:build includebuild
-// +build includebuild
-
-package wasmtime
-
-// This file is not built and not included in BUILD.bazel;
-// it is only used to prevent "go mod vendor" to prune the
-// build directory.
-
-import (
-	// Import these build directories in order to have them
-	// included in vendored dependencies.
-	// Cf. https://github.com/golang/go/issues/26366
-
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/include"
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime"
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64"
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64"
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64"
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64"
-	_ "github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64"
-)
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 05e7c082b..c746f0504 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -13,16 +13,16 @@ github.com/andreyvit/diff
 # github.com/beorn7/perks v1.0.1
 ## explicit; go 1.11
 github.com/beorn7/perks/quantile
-# github.com/bytecodealliance/wasmtime-go/v3 v3.0.2
+# github.com/bytecodealliance/wasmtime-go/v28 v28.0.0
 ## explicit; go 1.18
-github.com/bytecodealliance/wasmtime-go/v3
-github.com/bytecodealliance/wasmtime-go/v3/build/include
-github.com/bytecodealliance/wasmtime-go/v3/build/include/wasmtime
-github.com/bytecodealliance/wasmtime-go/v3/build/linux-aarch64
-github.com/bytecodealliance/wasmtime-go/v3/build/linux-x86_64
-github.com/bytecodealliance/wasmtime-go/v3/build/macos-aarch64
-github.com/bytecodealliance/wasmtime-go/v3/build/macos-x86_64
-github.com/bytecodealliance/wasmtime-go/v3/build/windows-x86_64
+github.com/bytecodealliance/wasmtime-go/v28
+github.com/bytecodealliance/wasmtime-go/v28/build/include
+github.com/bytecodealliance/wasmtime-go/v28/build/include/wasmtime
+github.com/bytecodealliance/wasmtime-go/v28/build/linux-aarch64
+github.com/bytecodealliance/wasmtime-go/v28/build/linux-x86_64
+github.com/bytecodealliance/wasmtime-go/v28/build/macos-aarch64
+github.com/bytecodealliance/wasmtime-go/v28/build/macos-x86_64
+github.com/bytecodealliance/wasmtime-go/v28/build/windows-x86_64
 # github.com/cenkalti/backoff/v4 v4.3.0
 ## explicit; go 1.18
 github.com/cenkalti/backoff/v4
