From 4478cfb004d3db7797e99fd3bdb23bf880a9c85b Mon Sep 17 00:00:00 2001
From: John Lane <1786613+johnlane@users.noreply.github.com>
Date: Wed, 3 Dec 2025 21:19:33 +0000
Subject: [PATCH 1/2] Remove additional backslashes and add missing cpp and h
 files

---
 openterfaceQT.pro | 28 +++++++++++++++++++---------
 1 file changed, 19 insertions(+), 9 deletions(-)

diff --git a/openterfaceQT.pro b/openterfaceQT.pro
index 3460dbac..f0d878e8 100644
--- a/openterfaceQT.pro
+++ b/openterfaceQT.pro
@@ -84,16 +84,26 @@ SOURCES += main.cpp \
 !win32 {
     SOURCES += host/backend/ffmpegbackendhandler.cpp \
                host/backend/gstreamerbackendhandler.cpp \
-               host/backend/gstreamer/sinkselector.cpp \\
-               host/backend/gstreamer/queueconfigurator.cpp \\
-               host/backend/gstreamer/videooverlaymanager.cpp \\
-               host/backend/gstreamer/pipelinebuilder.cpp
+	       host/backend/gstreamer/pipelinefactory.cpp \
+	       host/backend/gstreamer/externalgstrunner.cpp \
+	       host/backend/gstreamer/inprocessgstrunner.cpp \
+               host/backend/gstreamer/sinkselector.cpp \
+               host/backend/gstreamer/queueconfigurator.cpp \
+               host/backend/gstreamer/videooverlaymanager.cpp \
+               host/backend/gstreamer/pipelinebuilder.cpp \
+               host/backend/gstreamer/recordingmanager.cpp \
+               host/backend/gstreamer/gstreamerhelpers.cpp
     HEADERS += host/backend/ffmpegbackendhandler.h \
                host/backend/gstreamerbackendhandler.h \
-               host/backend/gstreamer/sinkselector.h \\
-               host/backend/gstreamer/queueconfigurator.h \\
-               host/backend/gstreamer/videooverlaymanager.h \\
-               host/backend/gstreamer/pipelinebuilder.h
+	       host/backend/gstreamer/pipelinefactory.h \
+	       host/backend/gstreamer/externalgstrunner.h \
+	       host/backend/gstreamer/inprocessgstrunner.h \
+               host/backend/gstreamer/sinkselector.h \
+               host/backend/gstreamer/queueconfigurator.h \
+               host/backend/gstreamer/videooverlaymanager.h \
+               host/backend/gstreamer/pipelinebuilder.h \
+               host/backend/gstreamer/recordingmanager.h \
+               host/backend/gstreamer/gstreamerhelpers.h
 }
 
 
@@ -263,4 +273,4 @@ TRANSLATIONS += config/languages/openterface_en.ts \
                 config/languages/openterface_se.ts \
                 config/languages/openterface_de.ts \
                 config/languages/openterface_zh.ts
-                # Add more languages here
\ No newline at end of file
+                # Add more languages here

From ccd8f51fe510684439edf0d5f8083e4dd1423836 Mon Sep 17 00:00:00 2001
From: John Lane <1786613+johnlane@users.noreply.github.com>
Date: Wed, 3 Dec 2025 21:26:20 +0000
Subject: [PATCH 2/2] De-duplicate logging categories

---
 host/backend/gstreamer/gstreamerhelpers.cpp   |  22 ++--
 host/backend/gstreamer/queueconfigurator.cpp  |   8 +-
 .../backend/gstreamer/videooverlaymanager.cpp | 118 +++++++++---------
 3 files changed, 74 insertions(+), 74 deletions(-)

diff --git a/host/backend/gstreamer/gstreamerhelpers.cpp b/host/backend/gstreamer/gstreamerhelpers.cpp
index 6fc1dd6e..4739da17 100644
--- a/host/backend/gstreamer/gstreamerhelpers.cpp
+++ b/host/backend/gstreamer/gstreamerhelpers.cpp
@@ -4,7 +4,7 @@
 #include <QDebug>
 #include <QLoggingCategory>
 
-Q_LOGGING_CATEGORY(log_gstreamer_backend, "opf.backend.gstreamer")
+Q_LOGGING_CATEGORY(log_gstreamer_gstreamerhelpers, "opf.backend.gstreamerhelpers")
 
 using namespace Openterface::GStreamer::GstHelpers;
 
@@ -16,7 +16,7 @@ bool Openterface::GStreamer::GstHelpers::setPipelineStateWithTimeout(void* eleme
 {
     if (!elementPtr) {
         if (outError) *outError = QStringLiteral("Element pointer is null");
-        qCWarning(log_gstreamer_backend) << "setPipelineStateWithTimeout: element pointer is null";
+        qCWarning(log_gstreamer_gstreamerhelpers) << "setPipelineStateWithTimeout: element pointer is null";
         return false;
     }
 
@@ -24,7 +24,7 @@ bool Openterface::GStreamer::GstHelpers::setPipelineStateWithTimeout(void* eleme
 
     GstStateChangeReturn ret = gst_element_set_state(element, static_cast<GstState>(targetState));
     if (ret == GST_STATE_CHANGE_FAILURE) {
-        qCCritical(log_gstreamer_backend) << "Failed to set element state to" << targetState;
+        qCCritical(log_gstreamer_gstreamerhelpers) << "Failed to set element state to" << targetState;
         // Try to pull any error from the bus for diagnostics
         // Caller may pass a bus to parseAndLogGstErrorMessage, but we don't have it here.
         if (outError) *outError = QStringLiteral("Failed to set state (GST_STATE_CHANGE_FAILURE)");
@@ -35,13 +35,13 @@ bool Openterface::GStreamer::GstHelpers::setPipelineStateWithTimeout(void* eleme
     ret = gst_element_get_state(element, &state, &pending, static_cast<GstClockTime>(timeoutMs) * GST_MSECOND);
     if (ret == GST_STATE_CHANGE_FAILURE) {
         if (outError) *outError = QStringLiteral("State change failure");
-        qCCritical(log_gstreamer_backend) << "State change failure waiting for target state";
+        qCCritical(log_gstreamer_gstreamerhelpers) << "State change failure waiting for target state";
         return false;
     }
 
     if (state != static_cast<GstState>(targetState)) {
         if (outError) *outError = QStringLiteral("Element did not reach target state in timeout");
-        qCCritical(log_gstreamer_backend) << "Element failed to reach state" << targetState << "(current:" << state << ", pending:" << pending << ")";
+        qCCritical(log_gstreamer_gstreamerhelpers) << "Element failed to reach state" << targetState << "(current:" << state << ", pending:" << pending << ")";
         return false;
     }
 
@@ -51,14 +51,14 @@ bool Openterface::GStreamer::GstHelpers::setPipelineStateWithTimeout(void* eleme
 void Openterface::GStreamer::GstHelpers::parseAndLogGstErrorMessage(void* busPtr, const char* context)
 {
     if (!busPtr) {
-        qCWarning(log_gstreamer_backend) << "Bus not available for error details" << (context ? context : "");
+        qCWarning(log_gstreamer_gstreamerhelpers) << "Bus not available for error details" << (context ? context : "");
         return;
     }
 
     GstBus* bus = static_cast<GstBus*>(busPtr);
     GstMessage* msg = gst_bus_pop_filtered(bus, GST_MESSAGE_ERROR);
     if (!msg) {
-        qCDebug(log_gstreamer_backend) << "No error message available on bus" << (context ? context : "");
+        qCDebug(log_gstreamer_gstreamerhelpers) << "No error message available on bus" << (context ? context : "");
         return;
     }
 
@@ -66,8 +66,8 @@ void Openterface::GStreamer::GstHelpers::parseAndLogGstErrorMessage(void* busPtr
     gchar* debug_info = nullptr;
     gst_message_parse_error(msg, &error, &debug_info);
 
-    qCCritical(log_gstreamer_backend) << "GStreamer Error:" << (error ? error->message : "Unknown") << (context ? context : "");
-    qCCritical(log_gstreamer_backend) << "Debug info:" << (debug_info ? debug_info : "None");
+    qCCritical(log_gstreamer_gstreamerhelpers) << "GStreamer Error:" << (error ? error->message : "Unknown") << (context ? context : "");
+    qCCritical(log_gstreamer_gstreamerhelpers) << "Debug info:" << (debug_info ? debug_info : "None");
 
     if (error) g_error_free(error);
     if (debug_info) g_free(debug_info);
@@ -79,13 +79,13 @@ void Openterface::GStreamer::GstHelpers::parseAndLogGstErrorMessage(void* busPtr
 bool Openterface::GStreamer::GstHelpers::setPipelineStateWithTimeout(void* /*elementPtr*/, int /*targetState*/, int /*timeoutMs*/, QString* outError)
 {
     if (outError) *outError = QStringLiteral("GStreamer not available in this build");
-    qCWarning(log_gstreamer_backend) << "setPipelineStateWithTimeout called but GStreamer is not compiled in";
+    qCWarning(log_gstreamer_gstreamerhelpers) << "setPipelineStateWithTimeout called but GStreamer is not compiled in";
     return false;
 }
 
 void Openterface::GStreamer::GstHelpers::parseAndLogGstErrorMessage(void* /*busPtr*/, const char* context)
 {
-    qCDebug(log_gstreamer_backend) << "GStreamer not compiled in - no bus to parse" << (context ? context : "");
+    qCDebug(log_gstreamer_gstreamerhelpers) << "GStreamer not compiled in - no bus to parse" << (context ? context : "");
 }
 
 #endif // HAVE_GSTREAMER
diff --git a/host/backend/gstreamer/queueconfigurator.cpp b/host/backend/gstreamer/queueconfigurator.cpp
index b7bea42e..12290193 100644
--- a/host/backend/gstreamer/queueconfigurator.cpp
+++ b/host/backend/gstreamer/queueconfigurator.cpp
@@ -8,7 +8,7 @@
 #include <gst/gst.h>
 #endif
 
-Q_LOGGING_CATEGORY(log_gstreamer_backend, "opf.backend.gstreamer")
+Q_LOGGING_CATEGORY(log_gstreamer_queueconfigurator, "opf.backend.queueconfigurator")
 
 using namespace Openterface::GStreamer;
 
@@ -26,10 +26,10 @@ void QueueConfigurator::configureDisplayQueue(void* pipeline)
                      "max-size-time", G_GUINT64_CONSTANT(100000000), // 100ms
                      "leaky", 2, // GST_QUEUE_LEAK_DOWNSTREAM
                      NULL);
-        qCDebug(log_gstreamer_backend) << "✓ Configured display queue with higher priority for qtsink";
+        qCDebug(log_gstreamer_queueconfigurator) << "✓ Configured display queue with higher priority for qtsink";
         gst_object_unref(displayQueue);
     } else {
-        qCDebug(log_gstreamer_backend) << "Display queue element not found (no named display-queue)";
+        qCDebug(log_gstreamer_queueconfigurator) << "Display queue element not found (no named display-queue)";
     }
 #else
     Q_UNUSED(pipeline);
@@ -50,7 +50,7 @@ void QueueConfigurator::configureRecordingQueue(void* pipeline)
                      "max-size-time", G_GUINT64_CONSTANT(500000000), // 500ms
                      "leaky", 1, // GST_QUEUE_LEAK_UPSTREAM
                      NULL);
-        qCDebug(log_gstreamer_backend) << "✓ Configured recording queue with lower priority relative to display";
+        qCDebug(log_gstreamer_queueconfigurator) << "✓ Configured recording queue with lower priority relative to display";
         gst_object_unref(recordingQueue);
     }
 #else
diff --git a/host/backend/gstreamer/videooverlaymanager.cpp b/host/backend/gstreamer/videooverlaymanager.cpp
index d8bf42f3..2dbe3bbf 100644
--- a/host/backend/gstreamer/videooverlaymanager.cpp
+++ b/host/backend/gstreamer/videooverlaymanager.cpp
@@ -22,7 +22,7 @@ static int x11_overlay_error_handler_local(Display* display, XErrorEvent* error)
 }
 #endif
 
-Q_LOGGING_CATEGORY(log_gstreamer_backend, "opf.backend.gstreamer")
+Q_LOGGING_CATEGORY(log_gstreamer_videooverlaymanager, "opf.backend.videooverlaymanager")
 
 using namespace Openterface::GStreamer;
 
@@ -30,36 +30,36 @@ bool VideoOverlayManager::embedVideoInWidget(void* pipeline, QWidget* widget)
 {
 #ifdef HAVE_GSTREAMER
     if (!widget || !pipeline) {
-        qCWarning(log_gstreamer_backend) << "Cannot embed video: widget or pipeline is null";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Cannot embed video: widget or pipeline is null";
         return false;
     }
 
     GstElement* videoSink = gst_bin_get_by_name(GST_BIN(pipeline), "videosink");
     if (!videoSink) {
-        qCWarning(log_gstreamer_backend) << "No video sink element named 'videosink' found in pipeline";
+        qCWarning(log_gstreamer_videooverlaymanager) << "No video sink element named 'videosink' found in pipeline";
         videoSink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);
         if (!videoSink) {
-            qCWarning(log_gstreamer_backend) << "No video overlay interface found in pipeline either";
+            qCWarning(log_gstreamer_videooverlaymanager) << "No video overlay interface found in pipeline either";
             return false;
         }
     }
 
     WId winId = widget->winId();
     if (winId) {
-        qCDebug(log_gstreamer_backend) << "Embedding video in widget with window ID:" << winId;
+        qCDebug(log_gstreamer_videooverlaymanager) << "Embedding video in widget with window ID:" << winId;
         gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(videoSink), winId);
         gst_object_unref(videoSink);
-        qCDebug(log_gstreamer_backend) << "Video embedded in widget successfully";
+        qCDebug(log_gstreamer_videooverlaymanager) << "Video embedded in widget successfully";
         return true;
     } else {
-        qCWarning(log_gstreamer_backend) << "Widget window ID is null, cannot embed video";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Widget window ID is null, cannot embed video";
         gst_object_unref(videoSink);
         return false;
     }
 #else
     Q_UNUSED(pipeline)
     Q_UNUSED(widget)
-    qCDebug(log_gstreamer_backend) << "Using autovideosink for video output (no in-process GStreamer)";
+    qCDebug(log_gstreamer_videooverlaymanager) << "Using autovideosink for video output (no in-process GStreamer)";
     return true;
 #endif
 }
@@ -68,36 +68,36 @@ bool VideoOverlayManager::embedVideoInGraphicsView(void* pipeline, QGraphicsView
 {
 #ifdef HAVE_GSTREAMER
     if (!view || !pipeline) {
-        qCWarning(log_gstreamer_backend) << "Cannot embed video: graphics view or pipeline is null";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Cannot embed video: graphics view or pipeline is null";
         return false;
     }
 
     GstElement* videoSink = gst_bin_get_by_name(GST_BIN(pipeline), "videosink");
     if (!videoSink) {
-        qCWarning(log_gstreamer_backend) << "No video sink element named 'videosink' found in pipeline";
+        qCWarning(log_gstreamer_videooverlaymanager) << "No video sink element named 'videosink' found in pipeline";
         videoSink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);
         if (!videoSink) {
-            qCWarning(log_gstreamer_backend) << "No video overlay interface found in pipeline either";
+            qCWarning(log_gstreamer_videooverlaymanager) << "No video overlay interface found in pipeline either";
             return false;
         }
     }
 
     WId winId = view->winId();
     if (winId) {
-        qCDebug(log_gstreamer_backend) << "Embedding video in graphics view with window ID:" << winId;
+        qCDebug(log_gstreamer_videooverlaymanager) << "Embedding video in graphics view with window ID:" << winId;
         gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(videoSink), winId);
         gst_object_unref(videoSink);
-        qCDebug(log_gstreamer_backend) << "Video embedded in graphics view successfully";
+        qCDebug(log_gstreamer_videooverlaymanager) << "Video embedded in graphics view successfully";
         return true;
     } else {
-        qCWarning(log_gstreamer_backend) << "Graphics view window ID is null, cannot embed video";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Graphics view window ID is null, cannot embed video";
         gst_object_unref(videoSink);
         return false;
     }
 #else
     Q_UNUSED(pipeline)
     Q_UNUSED(view)
-    qCDebug(log_gstreamer_backend) << "Using autovideosink for video output (no in-process GStreamer)";
+    qCDebug(log_gstreamer_videooverlaymanager) << "Using autovideosink for video output (no in-process GStreamer)";
     return true;
 #endif
 }
@@ -106,36 +106,36 @@ bool VideoOverlayManager::embedVideoInVideoPane(void* pipeline, ::VideoPane* vid
 {
 #ifdef HAVE_GSTREAMER
     if (!videoPane || !pipeline) {
-        qCWarning(log_gstreamer_backend) << "Cannot embed video: VideoPane or pipeline is null";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Cannot embed video: VideoPane or pipeline is null";
         return false;
     }
 
     GstElement* videoSink = gst_bin_get_by_name(GST_BIN(pipeline), "videosink");
     if (!videoSink) {
-        qCWarning(log_gstreamer_backend) << "No video sink element named 'videosink' found in pipeline";
+        qCWarning(log_gstreamer_videooverlaymanager) << "No video sink element named 'videosink' found in pipeline";
         videoSink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);
         if (!videoSink) {
-            qCWarning(log_gstreamer_backend) << "No video overlay interface found in pipeline either";
+            qCWarning(log_gstreamer_videooverlaymanager) << "No video overlay interface found in pipeline either";
             return false;
         }
     }
 
     WId winId = videoPane->getVideoOverlayWindowId();
     if (winId) {
-        qCDebug(log_gstreamer_backend) << "Embedding video in VideoPane overlay with window ID:" << winId;
+        qCDebug(log_gstreamer_videooverlaymanager) << "Embedding video in VideoPane overlay with window ID:" << winId;
         gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(videoSink), winId);
         gst_object_unref(videoSink);
-        qCDebug(log_gstreamer_backend) << "Video embedded in VideoPane overlay successfully";
+        qCDebug(log_gstreamer_videooverlaymanager) << "Video embedded in VideoPane overlay successfully";
         return true;
     } else {
-        qCWarning(log_gstreamer_backend) << "VideoPane overlay window ID is null, cannot embed video";
+        qCWarning(log_gstreamer_videooverlaymanager) << "VideoPane overlay window ID is null, cannot embed video";
         gst_object_unref(videoSink);
         return false;
     }
 #else
     Q_UNUSED(pipeline)
     Q_UNUSED(videoPane)
-    qCDebug(log_gstreamer_backend) << "Using autovideosink for video output (no in-process GStreamer)";
+    qCDebug(log_gstreamer_videooverlaymanager) << "Using autovideosink for video output (no in-process GStreamer)";
     return true;
 #endif
 }
@@ -144,7 +144,7 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
 {
 #ifdef HAVE_GSTREAMER
     if (!videoSinkPtr || windowId == 0) {
-        qCWarning(log_gstreamer_backend) << "Invalid parameters for overlay setup: sink=" << videoSinkPtr << "windowId=" << windowId;
+        qCWarning(log_gstreamer_videooverlaymanager) << "Invalid parameters for overlay setup: sink=" << videoSinkPtr << "windowId=" << windowId;
         return false;
     }
 
@@ -152,7 +152,7 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
 
     // Check if the sink supports video overlay interface
     if (GST_IS_VIDEO_OVERLAY(videoSink)) {
-        qCDebug(log_gstreamer_backend) << "Sink supports video overlay - setting up overlay with window ID:" << windowId;
+        qCDebug(log_gstreamer_videooverlaymanager) << "Sink supports video overlay - setting up overlay with window ID:" << windowId;
 
 #ifdef Q_OS_LINUX
         // Add X11 error handling to prevent segmentation fault
@@ -175,12 +175,12 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
             if (g_object_class_find_property(G_OBJECT_GET_CLASS(videoSink), "force-aspect-ratio")) {
                 // Allow the sink to stretch to the configured render rectangle so overlay scales to widget size
                 g_object_set(videoSink, "force-aspect-ratio", FALSE, NULL);
-                qCDebug(log_gstreamer_backend) << "Disabled force-aspect-ratio on video sink to allow fill scaling";
+                qCDebug(log_gstreamer_videooverlaymanager) << "Disabled force-aspect-ratio on video sink to allow fill scaling";
             }
 
             if (g_object_class_find_property(G_OBJECT_GET_CLASS(videoSink), "pixel-aspect-ratio")) {
                 g_object_set(videoSink, "pixel-aspect-ratio", "1/1", NULL);
-                qCDebug(log_gstreamer_backend) << "Set pixel-aspect-ratio to 1:1 on video sink";
+                qCDebug(log_gstreamer_videooverlaymanager) << "Set pixel-aspect-ratio to 1:1 on video sink";
             }
 
             // Configure render rectangle based on provided targets
@@ -188,13 +188,13 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
                 QSize widgetSize = videoWidget->size();
                 if (widgetSize.width() > 0 && widgetSize.height() > 0) {
                     gst_video_overlay_set_render_rectangle(GST_VIDEO_OVERLAY(videoSink), 0, 0, widgetSize.width(), widgetSize.height());
-                    qCDebug(log_gstreamer_backend) << "Set render rectangle to widget size:" << widgetSize;
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Set render rectangle to widget size:" << widgetSize;
                 }
             } else if (graphicsVideoItem) {
                 QRectF itemRect = graphicsVideoItem->boundingRect();
                 if (itemRect.width() > 0 && itemRect.height() > 0) {
                     gst_video_overlay_set_render_rectangle(GST_VIDEO_OVERLAY(videoSink), 0, 0, (gint)itemRect.width(), (gint)itemRect.height());
-                    qCDebug(log_gstreamer_backend) << "Set render rectangle to video item size:" << itemRect.size();
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Set render rectangle to video item size:" << itemRect.size();
                 }
             }
 
@@ -205,18 +205,18 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
                 XCloseDisplay(display);
 
                 if (x11_overlay_error_occurred_local) {
-                    qCWarning(log_gstreamer_backend) << "X11 error occurred during overlay setup - continuing without embedding";
+                    qCWarning(log_gstreamer_videooverlaymanager) << "X11 error occurred during overlay setup - continuing without embedding";
                 } else {
-                    qCDebug(log_gstreamer_backend) << "Video overlay setup completed successfully";
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Video overlay setup completed successfully";
                 }
             } else if (!old_handler) {
-                qCDebug(log_gstreamer_backend) << "Video overlay setup completed (no X11 error handling)";
+                qCDebug(log_gstreamer_videooverlaymanager) << "Video overlay setup completed (no X11 error handling)";
             }
 #endif
 
-            qCDebug(log_gstreamer_backend) << "Overlay setup completed";
+            qCDebug(log_gstreamer_videooverlaymanager) << "Overlay setup completed";
         } catch (...) {
-            qCCritical(log_gstreamer_backend) << "Exception during video overlay setup - continuing without embedding";
+            qCCritical(log_gstreamer_videooverlaymanager) << "Exception during video overlay setup - continuing without embedding";
 #ifdef Q_OS_LINUX
             if (display && old_handler) {
                 XSetErrorHandler(old_handler);
@@ -242,17 +242,17 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
             if (gst_iterator_next(iter, &item) == GST_ITERATOR_OK) {
                 actualSink = GST_ELEMENT(g_value_get_object(&item));
                 if (actualSink && GST_IS_VIDEO_OVERLAY(actualSink)) {
-                    qCDebug(log_gstreamer_backend) << "Found overlay-capable sink inside autovideosink";
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Found overlay-capable sink inside autovideosink";
                     gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(actualSink), windowId);
                     // Use target widget size if available to set explicit render rectangle so scaling works
                     if (videoWidget) {
                         QSize widgetSize = videoWidget->size();
                         if (widgetSize.width() > 0 && widgetSize.height() > 0) {
                             gst_video_overlay_set_render_rectangle(GST_VIDEO_OVERLAY(actualSink), 0, 0, widgetSize.width(), widgetSize.height());
-                            qCDebug(log_gstreamer_backend) << "Set render rectangle to widget size for autovideosink child sink:" << widgetSize;
+                            qCDebug(log_gstreamer_videooverlaymanager) << "Set render rectangle to widget size for autovideosink child sink:" << widgetSize;
                             if (g_object_class_find_property(G_OBJECT_GET_CLASS(actualSink), "force-aspect-ratio")) {
                                 g_object_set(actualSink, "force-aspect-ratio", FALSE, NULL);
-                                qCDebug(log_gstreamer_backend) << "Disabled force-aspect-ratio on autovideosink child sink";
+                                qCDebug(log_gstreamer_videooverlaymanager) << "Disabled force-aspect-ratio on autovideosink child sink";
                             }
                         } else {
                             gst_video_overlay_set_render_rectangle(GST_VIDEO_OVERLAY(actualSink), 0, 0, -1, -1);
@@ -269,18 +269,18 @@ bool VideoOverlayManager::setupVideoOverlay(void* videoSinkPtr, WId windowId, QW
             }
             gst_iterator_free(iter);
         }
-        qCDebug(log_gstreamer_backend) << "autovideosink selected sink doesn't support overlay - video will display in separate window";
+        qCDebug(log_gstreamer_videooverlaymanager) << "autovideosink selected sink doesn't support overlay - video will display in separate window";
         return false;
     }
 
-    qCWarning(log_gstreamer_backend) << "Sink does not support video overlay:" << sinkName;
+    qCWarning(log_gstreamer_videooverlaymanager) << "Sink does not support video overlay:" << sinkName;
     return false;
 #else
     Q_UNUSED(videoSinkPtr)
     Q_UNUSED(windowId)
     Q_UNUSED(videoWidget)
     Q_UNUSED(graphicsVideoItem)
-    qCDebug(log_gstreamer_backend) << "No in-process GStreamer - overlay unavailable";
+    qCDebug(log_gstreamer_videooverlaymanager) << "No in-process GStreamer - overlay unavailable";
     return false;
 #endif
 }
@@ -300,7 +300,7 @@ bool VideoOverlayManager::setupVideoOverlayForPipeline(void* pipeline, WId windo
         gst_object_unref(videoSink);
         return ok;
     }
-    qCWarning(log_gstreamer_backend) << "No video sink found in pipeline";
+    qCWarning(log_gstreamer_videooverlaymanager) << "No video sink found in pipeline";
     return false;
 #else
     Q_UNUSED(pipeline)
@@ -315,10 +315,10 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
                                                     ::VideoPane* videoPane,
                                                     bool &pendingFlag)
 {
-    qCDebug(log_gstreamer_backend) << "VideoOverlayManager: Completing pending overlay setup...";
+    qCDebug(log_gstreamer_videooverlaymanager) << "VideoOverlayManager: Completing pending overlay setup...";
 
     if (!pendingFlag || !pipeline) {
-        qCDebug(log_gstreamer_backend) << "No pending setup or no pipeline";
+        qCDebug(log_gstreamer_videooverlaymanager) << "No pending setup or no pipeline";
         return false;
     }
 
@@ -326,7 +326,7 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
     const bool isXcb = platform.contains("xcb", Qt::CaseInsensitive);
     const bool hasXDisplay = !qgetenv("DISPLAY").isEmpty();
     if (!isXcb || !hasXDisplay) {
-        qCWarning(log_gstreamer_backend) << "Skipping deferred overlay setup: platform is" << platform << "(DISPLAY set:" << hasXDisplay << ")";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Skipping deferred overlay setup: platform is" << platform << "(DISPLAY set:" << hasXDisplay << ")";
         pendingFlag = false;
         return false;
     }
@@ -335,7 +335,7 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
 
     if (videoPane) {
         windowId = videoPane->getVideoOverlayWindowId();
-        qCDebug(log_gstreamer_backend) << "Completing overlay setup with VideoPane window ID:" << windowId;
+        qCDebug(log_gstreamer_videooverlaymanager) << "Completing overlay setup with VideoPane window ID:" << windowId;
     } else if (graphicsVideoItem) {
         if (graphicsVideoItem->scene()) {
             QList<QGraphicsView*> views = graphicsVideoItem->scene()->views();
@@ -344,21 +344,21 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
                 if (auto pane = qobject_cast<VideoPane*>(view)) {
                     if (pane->isDirectGStreamerModeEnabled() && pane->getOverlayWidget()) {
                         windowId = pane->getVideoOverlayWindowId();
-                        qCDebug(log_gstreamer_backend) << "Completing overlay setup with VideoPane overlay widget window ID:" << windowId;
+                        qCDebug(log_gstreamer_videooverlaymanager) << "Completing overlay setup with VideoPane overlay widget window ID:" << windowId;
                     } else {
-                        qCDebug(log_gstreamer_backend) << "VideoPane overlay widget still not ready";
+                        qCDebug(log_gstreamer_videooverlaymanager) << "VideoPane overlay widget still not ready";
                         return false;
                     }
                 } else {
                     windowId = view->winId();
-                    qCDebug(log_gstreamer_backend) << "Completing overlay setup with graphics view window ID:" << windowId;
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Completing overlay setup with graphics view window ID:" << windowId;
                 }
             } else {
-                qCWarning(log_gstreamer_backend) << "Graphics video item has no associated view";
+                qCWarning(log_gstreamer_videooverlaymanager) << "Graphics video item has no associated view";
                 return false;
             }
         } else {
-            qCWarning(log_gstreamer_backend) << "Graphics video item has no scene";
+            qCWarning(log_gstreamer_videooverlaymanager) << "Graphics video item has no scene";
             return false;
         }
     }
@@ -367,7 +367,7 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
         GstElement* videoSink = gst_bin_get_by_name(GST_BIN(pipeline), "videosink");
         if (!videoSink) {
             videoSink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);
-            if (videoSink) qCDebug(log_gstreamer_backend) << "Deferred path: found sink by overlay interface";
+            if (videoSink) qCDebug(log_gstreamer_videooverlaymanager) << "Deferred path: found sink by overlay interface";
         }
 
         if (videoSink) {
@@ -384,14 +384,14 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
                     targetWidget = videoWidget;
                 }
                 if (targetWidget) {
-                    qCDebug(log_gstreamer_backend) << "Deferred: binding qt6videosink to QWidget" << targetWidget;
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Deferred: binding qt6videosink to QWidget" << targetWidget;
                     g_object_set(G_OBJECT(videoSink), "widget", (gpointer)targetWidget, nullptr);
                     gst_object_unref(videoSink);
                     pendingFlag = false;
-                    qCDebug(log_gstreamer_backend) << "Deferred qt6videosink binding completed";
+                    qCDebug(log_gstreamer_videooverlaymanager) << "Deferred qt6videosink binding completed";
                     return true;
                 } else {
-                    qCWarning(log_gstreamer_backend) << "Deferred: no target QWidget available to bind qt6videosink";
+                    qCWarning(log_gstreamer_videooverlaymanager) << "Deferred: no target QWidget available to bind qt6videosink";
                 }
             }
 
@@ -399,30 +399,30 @@ bool VideoOverlayManager::completePendingOverlaySetup(void* pipeline,
             const bool looksLikeXSink = sinkNameBA.contains("xvimage") || sinkNameBA.contains("ximage");
 
             if (!supportsOverlay) {
-                qCWarning(log_gstreamer_backend) << "Deferred overlay skipped: sink does not support overlay interface (" << sinkName << ")";
+                qCWarning(log_gstreamer_videooverlaymanager) << "Deferred overlay skipped: sink does not support overlay interface (" << sinkName << ")";
                 gst_object_unref(videoSink);
                 pendingFlag = false;
                 return false;
             }
 
             if (!looksLikeXSink) {
-                qCWarning(log_gstreamer_backend) << "Deferred overlay skipped: sink is not an X sink (" << sinkName << ") on platform" << QGuiApplication::platformName();
+                qCWarning(log_gstreamer_videooverlaymanager) << "Deferred overlay skipped: sink is not an X sink (" << sinkName << ") on platform" << QGuiApplication::platformName();
                 gst_object_unref(videoSink);
                 pendingFlag = false;
                 return false;
             }
 
-            qCDebug(log_gstreamer_backend) << "Setting up deferred video overlay with window ID:" << windowId << "using sink" << sinkName;
+            qCDebug(log_gstreamer_videooverlaymanager) << "Setting up deferred video overlay with window ID:" << windowId << "using sink" << sinkName;
             gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(videoSink), windowId);
             gst_object_unref(videoSink);
             pendingFlag = false;
-            qCDebug(log_gstreamer_backend) << "Deferred overlay setup completed successfully";
+            qCDebug(log_gstreamer_videooverlaymanager) << "Deferred overlay setup completed successfully";
             return true;
         } else {
-            qCWarning(log_gstreamer_backend) << "Could not find video sink for deferred overlay setup";
+            qCWarning(log_gstreamer_videooverlaymanager) << "Could not find video sink for deferred overlay setup";
         }
     } else {
-        qCWarning(log_gstreamer_backend) << "Still no valid window ID available for deferred overlay setup";
+        qCWarning(log_gstreamer_videooverlaymanager) << "Still no valid window ID available for deferred overlay setup";
     }
 
     return false;
