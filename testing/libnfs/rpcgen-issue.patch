From 47d89b326a0d93a890d961d70a22fec8eaf5e389 Mon Sep 17 00:00:00 2001
From: Carlo Landmeter <clandmeter@gmail.com>
Date: Tue, 27 Nov 2012 16:45:05 +0100
Subject: [PATCH] add generated c file and header so it can be used with
 uclibc

---
 nfs/Makefile.am      |    3 -
 nfs/libnfs-raw-nfs.c | 2093 ++++++++++++++++++++++++++++++++++++++++++++++++++
 nfs/libnfs-raw-nfs.h | 1456 +++++++++++++++++++++++++++++++++++
 3 files changed, 3549 insertions(+), 3 deletions(-)
 create mode 100644 nfs/libnfs-raw-nfs.c
 create mode 100644 nfs/libnfs-raw-nfs.h

diff --git a/nfs/Makefile.am b/nfs/Makefile.am
index 5052369..9942e5c 100644
--- a/nfs/Makefile.am
+++ b/nfs/Makefile.am
@@ -13,8 +13,5 @@ libnfs_la_SOURCES = \
 
 $(nfs_GENERATED) : nfs-stamp
 nfs-stamp : nfs.x
-	rm -f $(nfs_GENERATED)
-	rpcgen -h @RPCGENFLAGS@ $< > libnfs-raw-nfs.h
-	rpcgen -c @RPCGENFLAGS@ $< | sed -e "s/#include \".*nfs.h\"/#include \"libnfs-raw-nfs.h\"/" > libnfs-raw-nfs.c
 	touch nfs-stamp
 	
diff --git a/nfs/libnfs-raw-nfs.c b/nfs/libnfs-raw-nfs.c
new file mode 100644
index 0000000..f9cb039
--- /dev/null
+++ b/nfs/libnfs-raw-nfs.c
@@ -0,0 +1,2093 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "libnfs-raw-nfs.h"
+
+bool_t
+xdr_cookieverf3 (XDR *xdrs, cookieverf3 objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_opaque (xdrs, objp, NFS3_COOKIEVERFSIZE))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_uint64 (XDR *xdrs, uint64 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_quad_t (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_cookie3 (XDR *xdrs, cookie3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_nfs_fh3 (XDR *xdrs, nfs_fh3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, NFS3_FHSIZE))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_filename3 (XDR *xdrs, filename3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, objp, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_diropargs3 (XDR *xdrs, diropargs3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->dir))
+		 return FALSE;
+	 if (!xdr_filename3 (xdrs, &objp->name))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_ftype3 (XDR *xdrs, ftype3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_mode3 (XDR *xdrs, mode3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_int (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_uid3 (XDR *xdrs, uid3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_int (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_gid3 (XDR *xdrs, gid3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_int (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_size3 (XDR *xdrs, size3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_fileid3 (XDR *xdrs, fileid3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_specdata3 (XDR *xdrs, specdata3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_int (xdrs, &objp->specdata1))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->specdata2))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_nfstime3 (XDR *xdrs, nfstime3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_int (xdrs, &objp->seconds))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->nseconds))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_fattr3 (XDR *xdrs, fattr3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_ftype3 (xdrs, &objp->type))
+		 return FALSE;
+	 if (!xdr_mode3 (xdrs, &objp->mode))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->nlink))
+		 return FALSE;
+	 if (!xdr_uid3 (xdrs, &objp->uid))
+		 return FALSE;
+	 if (!xdr_gid3 (xdrs, &objp->gid))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->size))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->used))
+		 return FALSE;
+	 if (!xdr_specdata3 (xdrs, &objp->rdev))
+		 return FALSE;
+	 if (!xdr_uint64 (xdrs, &objp->fsid))
+		 return FALSE;
+	 if (!xdr_fileid3 (xdrs, &objp->fileid))
+		 return FALSE;
+	 if (!xdr_nfstime3 (xdrs, &objp->atime))
+		 return FALSE;
+	 if (!xdr_nfstime3 (xdrs, &objp->mtime))
+		 return FALSE;
+	 if (!xdr_nfstime3 (xdrs, &objp->ctime))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_post_op_attr (XDR *xdrs, post_op_attr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->attributes_follow))
+		 return FALSE;
+	switch (objp->attributes_follow) {
+	case TRUE:
+		 if (!xdr_fattr3 (xdrs, &objp->post_op_attr_u.attributes))
+			 return FALSE;
+		break;
+	case FALSE:
+		break;
+	default:
+		return FALSE;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_nfsstat3 (XDR *xdrs, nfsstat3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_stable_how (XDR *xdrs, stable_how *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_offset3 (XDR *xdrs, offset3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_count3 (XDR *xdrs, count3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_int (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_wcc_attr (XDR *xdrs, wcc_attr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_size3 (xdrs, &objp->size))
+		 return FALSE;
+	 if (!xdr_nfstime3 (xdrs, &objp->mtime))
+		 return FALSE;
+	 if (!xdr_nfstime3 (xdrs, &objp->ctime))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_pre_op_attr (XDR *xdrs, pre_op_attr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->attributes_follow))
+		 return FALSE;
+	switch (objp->attributes_follow) {
+	case TRUE:
+		 if (!xdr_wcc_attr (xdrs, &objp->pre_op_attr_u.attributes))
+			 return FALSE;
+		break;
+	case FALSE:
+		break;
+	default:
+		return FALSE;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_wcc_data (XDR *xdrs, wcc_data *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_pre_op_attr (xdrs, &objp->before))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->after))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_WRITE3args (XDR *xdrs, WRITE3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->file))
+		 return FALSE;
+	 if (!xdr_offset3 (xdrs, &objp->offset))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->count))
+		 return FALSE;
+	 if (!xdr_stable_how (xdrs, &objp->stable))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_writeverf3 (XDR *xdrs, writeverf3 objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_opaque (xdrs, objp, NFS3_WRITEVERFSIZE))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_WRITE3resok (XDR *xdrs, WRITE3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->file_wcc))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->count))
+		 return FALSE;
+	 if (!xdr_stable_how (xdrs, &objp->committed))
+		 return FALSE;
+	 if (!xdr_writeverf3 (xdrs, objp->verf))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_WRITE3resfail (XDR *xdrs, WRITE3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->file_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_WRITE3res (XDR *xdrs, WRITE3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_WRITE3resok (xdrs, &objp->WRITE3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_WRITE3resfail (xdrs, &objp->WRITE3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_LOOKUP3args (XDR *xdrs, LOOKUP3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->what))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_LOOKUP3resok (XDR *xdrs, LOOKUP3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->object))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->dir_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_LOOKUP3resfail (XDR *xdrs, LOOKUP3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->dir_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_LOOKUP3res (XDR *xdrs, LOOKUP3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_LOOKUP3resok (xdrs, &objp->LOOKUP3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_LOOKUP3resfail (xdrs, &objp->LOOKUP3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_COMMIT3args (XDR *xdrs, COMMIT3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->file))
+		 return FALSE;
+	 if (!xdr_offset3 (xdrs, &objp->offset))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->count))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_COMMIT3resok (XDR *xdrs, COMMIT3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->file_wcc))
+		 return FALSE;
+	 if (!xdr_writeverf3 (xdrs, objp->verf))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_COMMIT3resfail (XDR *xdrs, COMMIT3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->file_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_COMMIT3res (XDR *xdrs, COMMIT3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_COMMIT3resok (xdrs, &objp->COMMIT3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_COMMIT3resfail (xdrs, &objp->COMMIT3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_ACCESS3args (XDR *xdrs, ACCESS3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->object))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->access))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_ACCESS3resok (XDR *xdrs, ACCESS3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->access))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_ACCESS3resfail (XDR *xdrs, ACCESS3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_ACCESS3res (XDR *xdrs, ACCESS3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_ACCESS3resok (xdrs, &objp->ACCESS3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_ACCESS3resfail (xdrs, &objp->ACCESS3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_GETATTR3args (XDR *xdrs, GETATTR3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->object))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_GETATTR3resok (XDR *xdrs, GETATTR3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_fattr3 (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_GETATTR3res (XDR *xdrs, GETATTR3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_GETATTR3resok (xdrs, &objp->GETATTR3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_time_how (XDR *xdrs, time_how *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_set_mode3 (XDR *xdrs, set_mode3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->set_it))
+		 return FALSE;
+	switch (objp->set_it) {
+	case TRUE:
+		 if (!xdr_mode3 (xdrs, &objp->set_mode3_u.mode))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_set_uid3 (XDR *xdrs, set_uid3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->set_it))
+		 return FALSE;
+	switch (objp->set_it) {
+	case TRUE:
+		 if (!xdr_uid3 (xdrs, &objp->set_uid3_u.uid))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_set_gid3 (XDR *xdrs, set_gid3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->set_it))
+		 return FALSE;
+	switch (objp->set_it) {
+	case TRUE:
+		 if (!xdr_gid3 (xdrs, &objp->set_gid3_u.gid))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_set_size3 (XDR *xdrs, set_size3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->set_it))
+		 return FALSE;
+	switch (objp->set_it) {
+	case TRUE:
+		 if (!xdr_size3 (xdrs, &objp->set_size3_u.size))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_set_atime (XDR *xdrs, set_atime *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_time_how (xdrs, &objp->set_it))
+		 return FALSE;
+	switch (objp->set_it) {
+	case SET_TO_CLIENT_TIME:
+		 if (!xdr_nfstime3 (xdrs, &objp->set_atime_u.atime))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_set_mtime (XDR *xdrs, set_mtime *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_time_how (xdrs, &objp->set_it))
+		 return FALSE;
+	switch (objp->set_it) {
+	case SET_TO_CLIENT_TIME:
+		 if (!xdr_nfstime3 (xdrs, &objp->set_mtime_u.mtime))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_sattr3 (XDR *xdrs, sattr3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_set_mode3 (xdrs, &objp->mode))
+		 return FALSE;
+	 if (!xdr_set_uid3 (xdrs, &objp->uid))
+		 return FALSE;
+	 if (!xdr_set_gid3 (xdrs, &objp->gid))
+		 return FALSE;
+	 if (!xdr_set_size3 (xdrs, &objp->size))
+		 return FALSE;
+	 if (!xdr_set_atime (xdrs, &objp->atime))
+		 return FALSE;
+	 if (!xdr_set_mtime (xdrs, &objp->mtime))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_createmode3 (XDR *xdrs, createmode3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_createverf3 (XDR *xdrs, createverf3 objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_opaque (xdrs, objp, NFS3_CREATEVERFSIZE))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_createhow3 (XDR *xdrs, createhow3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_createmode3 (xdrs, &objp->mode))
+		 return FALSE;
+	switch (objp->mode) {
+	case UNCHECKED:
+		 if (!xdr_sattr3 (xdrs, &objp->createhow3_u.obj_attributes))
+			 return FALSE;
+		break;
+	case GUARDED:
+		 if (!xdr_sattr3 (xdrs, &objp->createhow3_u.g_obj_attributes))
+			 return FALSE;
+		break;
+	case EXCLUSIVE:
+		 if (!xdr_createverf3 (xdrs, objp->createhow3_u.verf))
+			 return FALSE;
+		break;
+	default:
+		return FALSE;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_CREATE3args (XDR *xdrs, CREATE3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->where))
+		 return FALSE;
+	 if (!xdr_createhow3 (xdrs, &objp->how))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_post_op_fh3 (XDR *xdrs, post_op_fh3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->handle_follows))
+		 return FALSE;
+	switch (objp->handle_follows) {
+	case TRUE:
+		 if (!xdr_nfs_fh3 (xdrs, &objp->post_op_fh3_u.handle))
+			 return FALSE;
+		break;
+	case FALSE:
+		break;
+	default:
+		return FALSE;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_CREATE3resok (XDR *xdrs, CREATE3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_fh3 (xdrs, &objp->obj))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_CREATE3resfail (XDR *xdrs, CREATE3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_CREATE3res (XDR *xdrs, CREATE3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_CREATE3resok (xdrs, &objp->CREATE3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_CREATE3resfail (xdrs, &objp->CREATE3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_REMOVE3args (XDR *xdrs, REMOVE3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->object))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_REMOVE3resok (XDR *xdrs, REMOVE3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_REMOVE3resfail (XDR *xdrs, REMOVE3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_REMOVE3res (XDR *xdrs, REMOVE3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_REMOVE3resok (xdrs, &objp->REMOVE3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_REMOVE3resfail (xdrs, &objp->REMOVE3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_READ3args (XDR *xdrs, READ3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->file))
+		 return FALSE;
+	 if (!xdr_offset3 (xdrs, &objp->offset))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->count))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READ3resok (XDR *xdrs, READ3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->file_attributes))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->count))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->eof))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READ3resfail (XDR *xdrs, READ3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->file_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READ3res (XDR *xdrs, READ3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_READ3resok (xdrs, &objp->READ3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_READ3resfail (xdrs, &objp->READ3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_FSINFO3args (XDR *xdrs, FSINFO3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->fsroot))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_FSINFO3resok (XDR *xdrs, FSINFO3resok *objp)
+{
+	register int32_t *buf;
+
+
+	if (xdrs->x_op == XDR_ENCODE) {
+		 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+			 return FALSE;
+		buf = XDR_INLINE (xdrs, 7 * BYTES_PER_XDR_UNIT);
+		if (buf == NULL) {
+			 if (!xdr_u_int (xdrs, &objp->rtmax))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->rtpref))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->rtmult))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->wtmax))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->wtpref))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->wtmult))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->dtpref))
+				 return FALSE;
+
+		} else {
+		IXDR_PUT_U_LONG(buf, objp->rtmax);
+		IXDR_PUT_U_LONG(buf, objp->rtpref);
+		IXDR_PUT_U_LONG(buf, objp->rtmult);
+		IXDR_PUT_U_LONG(buf, objp->wtmax);
+		IXDR_PUT_U_LONG(buf, objp->wtpref);
+		IXDR_PUT_U_LONG(buf, objp->wtmult);
+		IXDR_PUT_U_LONG(buf, objp->dtpref);
+		}
+		 if (!xdr_size3 (xdrs, &objp->maxfilesize))
+			 return FALSE;
+		 if (!xdr_nfstime3 (xdrs, &objp->time_delta))
+			 return FALSE;
+		 if (!xdr_u_int (xdrs, &objp->properties))
+			 return FALSE;
+		return TRUE;
+	} else if (xdrs->x_op == XDR_DECODE) {
+		 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+			 return FALSE;
+		buf = XDR_INLINE (xdrs, 7 * BYTES_PER_XDR_UNIT);
+		if (buf == NULL) {
+			 if (!xdr_u_int (xdrs, &objp->rtmax))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->rtpref))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->rtmult))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->wtmax))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->wtpref))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->wtmult))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->dtpref))
+				 return FALSE;
+
+		} else {
+		objp->rtmax = IXDR_GET_U_LONG(buf);
+		objp->rtpref = IXDR_GET_U_LONG(buf);
+		objp->rtmult = IXDR_GET_U_LONG(buf);
+		objp->wtmax = IXDR_GET_U_LONG(buf);
+		objp->wtpref = IXDR_GET_U_LONG(buf);
+		objp->wtmult = IXDR_GET_U_LONG(buf);
+		objp->dtpref = IXDR_GET_U_LONG(buf);
+		}
+		 if (!xdr_size3 (xdrs, &objp->maxfilesize))
+			 return FALSE;
+		 if (!xdr_nfstime3 (xdrs, &objp->time_delta))
+			 return FALSE;
+		 if (!xdr_u_int (xdrs, &objp->properties))
+			 return FALSE;
+	 return TRUE;
+	}
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->rtmax))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->rtpref))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->rtmult))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->wtmax))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->wtpref))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->wtmult))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->dtpref))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->maxfilesize))
+		 return FALSE;
+	 if (!xdr_nfstime3 (xdrs, &objp->time_delta))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->properties))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_FSINFO3resfail (XDR *xdrs, FSINFO3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_FSINFO3res (XDR *xdrs, FSINFO3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_FSINFO3resok (xdrs, &objp->FSINFO3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_FSINFO3resfail (xdrs, &objp->FSINFO3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_FSSTAT3args (XDR *xdrs, FSSTAT3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->fsroot))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_FSSTAT3resok (XDR *xdrs, FSSTAT3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->tbytes))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->fbytes))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->abytes))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->tfiles))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->ffiles))
+		 return FALSE;
+	 if (!xdr_size3 (xdrs, &objp->afiles))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->invarsec))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_FSSTAT3resfail (XDR *xdrs, FSSTAT3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_FSSTAT3res (XDR *xdrs, FSSTAT3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_FSSTAT3resok (xdrs, &objp->FSSTAT3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_FSSTAT3resfail (xdrs, &objp->FSSTAT3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_PATHCONF3args (XDR *xdrs, PATHCONF3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->object))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_PATHCONF3resok (XDR *xdrs, PATHCONF3resok *objp)
+{
+	register int32_t *buf;
+
+
+	if (xdrs->x_op == XDR_ENCODE) {
+		 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+			 return FALSE;
+		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
+		if (buf == NULL) {
+			 if (!xdr_u_int (xdrs, &objp->linkmax))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->name_max))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->no_trunc))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->chown_restricted))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->case_insensitive))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->case_preserving))
+				 return FALSE;
+		} else {
+			IXDR_PUT_U_LONG(buf, objp->linkmax);
+			IXDR_PUT_U_LONG(buf, objp->name_max);
+			IXDR_PUT_BOOL(buf, objp->no_trunc);
+			IXDR_PUT_BOOL(buf, objp->chown_restricted);
+			IXDR_PUT_BOOL(buf, objp->case_insensitive);
+			IXDR_PUT_BOOL(buf, objp->case_preserving);
+		}
+		return TRUE;
+	} else if (xdrs->x_op == XDR_DECODE) {
+		 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+			 return FALSE;
+		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
+		if (buf == NULL) {
+			 if (!xdr_u_int (xdrs, &objp->linkmax))
+				 return FALSE;
+			 if (!xdr_u_int (xdrs, &objp->name_max))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->no_trunc))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->chown_restricted))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->case_insensitive))
+				 return FALSE;
+			 if (!xdr_bool (xdrs, &objp->case_preserving))
+				 return FALSE;
+		} else {
+			objp->linkmax = IXDR_GET_U_LONG(buf);
+			objp->name_max = IXDR_GET_U_LONG(buf);
+			objp->no_trunc = IXDR_GET_BOOL(buf);
+			objp->chown_restricted = IXDR_GET_BOOL(buf);
+			objp->case_insensitive = IXDR_GET_BOOL(buf);
+			objp->case_preserving = IXDR_GET_BOOL(buf);
+		}
+	 return TRUE;
+	}
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->linkmax))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->name_max))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->no_trunc))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->chown_restricted))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->case_insensitive))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->case_preserving))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_PATHCONF3resfail (XDR *xdrs, PATHCONF3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_PATHCONF3res (XDR *xdrs, PATHCONF3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_PATHCONF3resok (xdrs, &objp->PATHCONF3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_PATHCONF3resfail (xdrs, &objp->PATHCONF3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_nfspath3 (XDR *xdrs, nfspath3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, objp, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_symlinkdata3 (XDR *xdrs, symlinkdata3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_sattr3 (xdrs, &objp->symlink_attributes))
+		 return FALSE;
+	 if (!xdr_nfspath3 (xdrs, &objp->symlink_data))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SYMLINK3args (XDR *xdrs, SYMLINK3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->where))
+		 return FALSE;
+	 if (!xdr_symlinkdata3 (xdrs, &objp->symlink))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SYMLINK3resok (XDR *xdrs, SYMLINK3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_fh3 (xdrs, &objp->obj))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SYMLINK3resfail (XDR *xdrs, SYMLINK3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SYMLINK3res (XDR *xdrs, SYMLINK3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_SYMLINK3resok (xdrs, &objp->SYMLINK3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_SYMLINK3resfail (xdrs, &objp->SYMLINK3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_READLINK3args (XDR *xdrs, READLINK3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->symlink))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READLINK3resok (XDR *xdrs, READLINK3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->symlink_attributes))
+		 return FALSE;
+	 if (!xdr_nfspath3 (xdrs, &objp->data))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READLINK3resfail (XDR *xdrs, READLINK3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->symlink_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READLINK3res (XDR *xdrs, READLINK3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_READLINK3resok (xdrs, &objp->READLINK3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_READLINK3resfail (xdrs, &objp->READLINK3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_devicedata3 (XDR *xdrs, devicedata3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_sattr3 (xdrs, &objp->dev_attributes))
+		 return FALSE;
+	 if (!xdr_specdata3 (xdrs, &objp->spec))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_mknoddata3 (XDR *xdrs, mknoddata3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_ftype3 (xdrs, &objp->type))
+		 return FALSE;
+	switch (objp->type) {
+	case NF3CHR:
+		 if (!xdr_devicedata3 (xdrs, &objp->mknoddata3_u.chr_device))
+			 return FALSE;
+		break;
+	case NF3BLK:
+		 if (!xdr_devicedata3 (xdrs, &objp->mknoddata3_u.blk_device))
+			 return FALSE;
+		break;
+	case NF3SOCK:
+		 if (!xdr_sattr3 (xdrs, &objp->mknoddata3_u.sock_attributes))
+			 return FALSE;
+		break;
+	case NF3FIFO:
+		 if (!xdr_sattr3 (xdrs, &objp->mknoddata3_u.pipe_attributes))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_MKNOD3args (XDR *xdrs, MKNOD3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->where))
+		 return FALSE;
+	 if (!xdr_mknoddata3 (xdrs, &objp->what))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_MKNOD3resok (XDR *xdrs, MKNOD3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_fh3 (xdrs, &objp->obj))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_MKNOD3resfail (XDR *xdrs, MKNOD3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_MKNOD3res (XDR *xdrs, MKNOD3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_MKNOD3resok (xdrs, &objp->MKNOD3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_MKNOD3resfail (xdrs, &objp->MKNOD3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_MKDIR3args (XDR *xdrs, MKDIR3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->where))
+		 return FALSE;
+	 if (!xdr_sattr3 (xdrs, &objp->attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_MKDIR3resok (XDR *xdrs, MKDIR3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_fh3 (xdrs, &objp->obj))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->obj_attributes))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_MKDIR3resfail (XDR *xdrs, MKDIR3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_MKDIR3res (XDR *xdrs, MKDIR3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_MKDIR3resok (xdrs, &objp->MKDIR3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_MKDIR3resfail (xdrs, &objp->MKDIR3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_RMDIR3args (XDR *xdrs, RMDIR3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->object))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_RMDIR3resok (XDR *xdrs, RMDIR3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_RMDIR3resfail (XDR *xdrs, RMDIR3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->dir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_RMDIR3res (XDR *xdrs, RMDIR3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_RMDIR3resok (xdrs, &objp->RMDIR3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_RMDIR3resfail (xdrs, &objp->RMDIR3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_RENAME3args (XDR *xdrs, RENAME3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_diropargs3 (xdrs, &objp->from))
+		 return FALSE;
+	 if (!xdr_diropargs3 (xdrs, &objp->to))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_RENAME3resok (XDR *xdrs, RENAME3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->fromdir_wcc))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->todir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_RENAME3resfail (XDR *xdrs, RENAME3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->fromdir_wcc))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->todir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_RENAME3res (XDR *xdrs, RENAME3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_RENAME3resok (xdrs, &objp->RENAME3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_RENAME3resfail (xdrs, &objp->RENAME3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_READDIRPLUS3args (XDR *xdrs, READDIRPLUS3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->dir))
+		 return FALSE;
+	 if (!xdr_cookie3 (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_cookieverf3 (xdrs, objp->cookieverf))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->dircount))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->maxcount))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_entryplus3 (XDR *xdrs, entryplus3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_fileid3 (xdrs, &objp->fileid))
+		 return FALSE;
+	 if (!xdr_filename3 (xdrs, &objp->name))
+		 return FALSE;
+	 if (!xdr_cookie3 (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_post_op_attr (xdrs, &objp->name_attributes))
+		 return FALSE;
+	 if (!xdr_post_op_fh3 (xdrs, &objp->name_handle))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->nextentry, sizeof (entryplus3), (xdrproc_t) xdr_entryplus3))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_dirlistplus3 (XDR *xdrs, dirlistplus3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_pointer (xdrs, (char **)&objp->entries, sizeof (entryplus3), (xdrproc_t) xdr_entryplus3))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->eof))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READDIRPLUS3resok (XDR *xdrs, READDIRPLUS3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->dir_attributes))
+		 return FALSE;
+	 if (!xdr_cookieverf3 (xdrs, objp->cookieverf))
+		 return FALSE;
+	 if (!xdr_dirlistplus3 (xdrs, &objp->reply))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READDIRPLUS3resfail (XDR *xdrs, READDIRPLUS3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->dir_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READDIRPLUS3res (XDR *xdrs, READDIRPLUS3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_READDIRPLUS3resok (xdrs, &objp->READDIRPLUS3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_READDIRPLUS3resfail (xdrs, &objp->READDIRPLUS3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_READDIR3args (XDR *xdrs, READDIR3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->dir))
+		 return FALSE;
+	 if (!xdr_cookie3 (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_cookieverf3 (xdrs, objp->cookieverf))
+		 return FALSE;
+	 if (!xdr_count3 (xdrs, &objp->count))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_entry3 (XDR *xdrs, entry3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_fileid3 (xdrs, &objp->fileid))
+		 return FALSE;
+	 if (!xdr_filename3 (xdrs, &objp->name))
+		 return FALSE;
+	 if (!xdr_cookie3 (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->nextentry, sizeof (entry3), (xdrproc_t) xdr_entry3))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_dirlist3 (XDR *xdrs, dirlist3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_pointer (xdrs, (char **)&objp->entries, sizeof (entry3), (xdrproc_t) xdr_entry3))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->eof))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READDIR3resok (XDR *xdrs, READDIR3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->dir_attributes))
+		 return FALSE;
+	 if (!xdr_cookieverf3 (xdrs, objp->cookieverf))
+		 return FALSE;
+	 if (!xdr_dirlist3 (xdrs, &objp->reply))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READDIR3resfail (XDR *xdrs, READDIR3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->dir_attributes))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_READDIR3res (XDR *xdrs, READDIR3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_READDIR3resok (xdrs, &objp->READDIR3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_READDIR3resfail (xdrs, &objp->READDIR3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_LINK3args (XDR *xdrs, LINK3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->file))
+		 return FALSE;
+	 if (!xdr_diropargs3 (xdrs, &objp->link))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_LINK3resok (XDR *xdrs, LINK3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->file_attributes))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->linkdir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_LINK3resfail (XDR *xdrs, LINK3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->file_attributes))
+		 return FALSE;
+	 if (!xdr_wcc_data (xdrs, &objp->linkdir_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_LINK3res (XDR *xdrs, LINK3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_LINK3resok (xdrs, &objp->LINK3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_LINK3resfail (xdrs, &objp->LINK3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_sattrguard3 (XDR *xdrs, sattrguard3 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->check))
+		 return FALSE;
+	switch (objp->check) {
+	case TRUE:
+		 if (!xdr_nfstime3 (xdrs, &objp->sattrguard3_u.obj_ctime))
+			 return FALSE;
+		break;
+	case FALSE:
+		break;
+	default:
+		return FALSE;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_SETATTR3args (XDR *xdrs, SETATTR3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->object))
+		 return FALSE;
+	 if (!xdr_sattr3 (xdrs, &objp->new_attributes))
+		 return FALSE;
+	 if (!xdr_sattrguard3 (xdrs, &objp->guard))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SETATTR3resok (XDR *xdrs, SETATTR3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->obj_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SETATTR3resfail (XDR *xdrs, SETATTR3resfail *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_wcc_data (xdrs, &objp->obj_wcc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SETATTR3res (XDR *xdrs, SETATTR3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_SETATTR3resok (xdrs, &objp->SETATTR3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		 if (!xdr_SETATTR3resfail (xdrs, &objp->SETATTR3res_u.resfail))
+			 return FALSE;
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_nfsacl_type (XDR *xdrs, nfsacl_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_nfsacl_ace (XDR *xdrs, nfsacl_ace *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsacl_type (xdrs, &objp->type))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->id))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->perm))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_GETACL3args (XDR *xdrs, GETACL3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->dir))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->mask))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_GETACL3resok (XDR *xdrs, GETACL3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->attr))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->mask))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->ace_count))
+		 return FALSE;
+	 if (!xdr_array (xdrs, (char **)&objp->ace.ace_val, (u_int *) &objp->ace.ace_len, ~0,
+		sizeof (nfsacl_ace), (xdrproc_t) xdr_nfsacl_ace))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->default_ace_count))
+		 return FALSE;
+	 if (!xdr_array (xdrs, (char **)&objp->default_ace.default_ace_val, (u_int *) &objp->default_ace.default_ace_len, ~0,
+		sizeof (nfsacl_ace), (xdrproc_t) xdr_nfsacl_ace))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_GETACL3res (XDR *xdrs, GETACL3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_GETACL3resok (xdrs, &objp->GETACL3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_SETACL3args (XDR *xdrs, SETACL3args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfs_fh3 (xdrs, &objp->dir))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->mask))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->ace_count))
+		 return FALSE;
+	 if (!xdr_array (xdrs, (char **)&objp->ace.ace_val, (u_int *) &objp->ace.ace_len, ~0,
+		sizeof (nfsacl_ace), (xdrproc_t) xdr_nfsacl_ace))
+		 return FALSE;
+	 if (!xdr_u_int (xdrs, &objp->default_ace_count))
+		 return FALSE;
+	 if (!xdr_array (xdrs, (char **)&objp->default_ace.default_ace_val, (u_int *) &objp->default_ace.default_ace_len, ~0,
+		sizeof (nfsacl_ace), (xdrproc_t) xdr_nfsacl_ace))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SETACL3resok (XDR *xdrs, SETACL3resok *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_post_op_attr (xdrs, &objp->attr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_SETACL3res (XDR *xdrs, SETACL3res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_nfsstat3 (xdrs, &objp->status))
+		 return FALSE;
+	switch (objp->status) {
+	case NFS3_OK:
+		 if (!xdr_SETACL3resok (xdrs, &objp->SETACL3res_u.resok))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
diff --git a/nfs/libnfs-raw-nfs.h b/nfs/libnfs-raw-nfs.h
new file mode 100644
index 0000000..9a125b5
--- /dev/null
+++ b/nfs/libnfs-raw-nfs.h
@@ -0,0 +1,1456 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _NFS_H_RPCGEN
+#define _NFS_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NFS3_FHSIZE 64
+#define NFS3_WRITEVERFSIZE 8
+#define NFS3_CREATEVERFSIZE 8
+#define NFS3_COOKIEVERFSIZE 8
+
+typedef char cookieverf3[NFS3_COOKIEVERFSIZE];
+
+typedef u_quad_t uint64;
+
+typedef uint64 cookie3;
+
+struct nfs_fh3 {
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct nfs_fh3 nfs_fh3;
+
+typedef char *filename3;
+
+struct diropargs3 {
+	nfs_fh3 dir;
+	filename3 name;
+};
+typedef struct diropargs3 diropargs3;
+
+enum ftype3 {
+	NF3REG = 1,
+	NF3DIR = 2,
+	NF3BLK = 3,
+	NF3CHR = 4,
+	NF3LNK = 5,
+	NF3SOCK = 6,
+	NF3FIFO = 7,
+};
+typedef enum ftype3 ftype3;
+
+typedef u_int mode3;
+
+typedef u_int uid3;
+
+typedef u_int gid3;
+
+typedef uint64 size3;
+
+typedef uint64 fileid3;
+
+struct specdata3 {
+	u_int specdata1;
+	u_int specdata2;
+};
+typedef struct specdata3 specdata3;
+
+struct nfstime3 {
+	u_int seconds;
+	u_int nseconds;
+};
+typedef struct nfstime3 nfstime3;
+
+struct fattr3 {
+	ftype3 type;
+	mode3 mode;
+	u_int nlink;
+	uid3 uid;
+	gid3 gid;
+	size3 size;
+	size3 used;
+	specdata3 rdev;
+	uint64 fsid;
+	fileid3 fileid;
+	nfstime3 atime;
+	nfstime3 mtime;
+	nfstime3 ctime;
+};
+typedef struct fattr3 fattr3;
+
+struct post_op_attr {
+	bool_t attributes_follow;
+	union {
+		fattr3 attributes;
+	} post_op_attr_u;
+};
+typedef struct post_op_attr post_op_attr;
+
+enum nfsstat3 {
+	NFS3_OK = 0,
+	NFS3ERR_PERM = 1,
+	NFS3ERR_NOENT = 2,
+	NFS3ERR_IO = 5,
+	NFS3ERR_NXIO = 6,
+	NFS3ERR_ACCES = 13,
+	NFS3ERR_EXIST = 17,
+	NFS3ERR_XDEV = 18,
+	NFS3ERR_NODEV = 19,
+	NFS3ERR_NOTDIR = 20,
+	NFS3ERR_ISDIR = 21,
+	NFS3ERR_INVAL = 22,
+	NFS3ERR_FBIG = 27,
+	NFS3ERR_NOSPC = 28,
+	NFS3ERR_ROFS = 30,
+	NFS3ERR_MLINK = 31,
+	NFS3ERR_NAMETOOLONG = 63,
+	NFS3ERR_NOTEMPTY = 66,
+	NFS3ERR_DQUOT = 69,
+	NFS3ERR_STALE = 70,
+	NFS3ERR_REMOTE = 71,
+	NFS3ERR_BADHANDLE = 10001,
+	NFS3ERR_NOT_SYNC = 10002,
+	NFS3ERR_BAD_COOKIE = 10003,
+	NFS3ERR_NOTSUPP = 10004,
+	NFS3ERR_TOOSMALL = 10005,
+	NFS3ERR_SERVERFAULT = 10006,
+	NFS3ERR_BADTYPE = 10007,
+	NFS3ERR_JUKEBOX = 10008,
+};
+typedef enum nfsstat3 nfsstat3;
+
+enum stable_how {
+	UNSTABLE = 0,
+	DATA_SYNC = 1,
+	FILE_SYNC = 2,
+};
+typedef enum stable_how stable_how;
+
+typedef uint64 offset3;
+
+typedef u_int count3;
+
+struct wcc_attr {
+	size3 size;
+	nfstime3 mtime;
+	nfstime3 ctime;
+};
+typedef struct wcc_attr wcc_attr;
+
+struct pre_op_attr {
+	bool_t attributes_follow;
+	union {
+		wcc_attr attributes;
+	} pre_op_attr_u;
+};
+typedef struct pre_op_attr pre_op_attr;
+
+struct wcc_data {
+	pre_op_attr before;
+	post_op_attr after;
+};
+typedef struct wcc_data wcc_data;
+
+struct WRITE3args {
+	nfs_fh3 file;
+	offset3 offset;
+	count3 count;
+	stable_how stable;
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct WRITE3args WRITE3args;
+
+typedef char writeverf3[NFS3_WRITEVERFSIZE];
+
+struct WRITE3resok {
+	wcc_data file_wcc;
+	count3 count;
+	stable_how committed;
+	writeverf3 verf;
+};
+typedef struct WRITE3resok WRITE3resok;
+
+struct WRITE3resfail {
+	wcc_data file_wcc;
+};
+typedef struct WRITE3resfail WRITE3resfail;
+
+struct WRITE3res {
+	nfsstat3 status;
+	union {
+		WRITE3resok resok;
+		WRITE3resfail resfail;
+	} WRITE3res_u;
+};
+typedef struct WRITE3res WRITE3res;
+
+struct LOOKUP3args {
+	diropargs3 what;
+};
+typedef struct LOOKUP3args LOOKUP3args;
+
+struct LOOKUP3resok {
+	nfs_fh3 object;
+	post_op_attr obj_attributes;
+	post_op_attr dir_attributes;
+};
+typedef struct LOOKUP3resok LOOKUP3resok;
+
+struct LOOKUP3resfail {
+	post_op_attr dir_attributes;
+};
+typedef struct LOOKUP3resfail LOOKUP3resfail;
+
+struct LOOKUP3res {
+	nfsstat3 status;
+	union {
+		LOOKUP3resok resok;
+		LOOKUP3resfail resfail;
+	} LOOKUP3res_u;
+};
+typedef struct LOOKUP3res LOOKUP3res;
+
+struct COMMIT3args {
+	nfs_fh3 file;
+	offset3 offset;
+	count3 count;
+};
+typedef struct COMMIT3args COMMIT3args;
+
+struct COMMIT3resok {
+	wcc_data file_wcc;
+	writeverf3 verf;
+};
+typedef struct COMMIT3resok COMMIT3resok;
+
+struct COMMIT3resfail {
+	wcc_data file_wcc;
+};
+typedef struct COMMIT3resfail COMMIT3resfail;
+
+struct COMMIT3res {
+	nfsstat3 status;
+	union {
+		COMMIT3resok resok;
+		COMMIT3resfail resfail;
+	} COMMIT3res_u;
+};
+typedef struct COMMIT3res COMMIT3res;
+#define ACCESS3_READ 0x0001
+#define ACCESS3_LOOKUP 0x0002
+#define ACCESS3_MODIFY 0x0004
+#define ACCESS3_EXTEND 0x0008
+#define ACCESS3_DELETE 0x0010
+#define ACCESS3_EXECUTE 0x0020
+
+struct ACCESS3args {
+	nfs_fh3 object;
+	u_int access;
+};
+typedef struct ACCESS3args ACCESS3args;
+
+struct ACCESS3resok {
+	post_op_attr obj_attributes;
+	u_int access;
+};
+typedef struct ACCESS3resok ACCESS3resok;
+
+struct ACCESS3resfail {
+	post_op_attr obj_attributes;
+};
+typedef struct ACCESS3resfail ACCESS3resfail;
+
+struct ACCESS3res {
+	nfsstat3 status;
+	union {
+		ACCESS3resok resok;
+		ACCESS3resfail resfail;
+	} ACCESS3res_u;
+};
+typedef struct ACCESS3res ACCESS3res;
+
+struct GETATTR3args {
+	nfs_fh3 object;
+};
+typedef struct GETATTR3args GETATTR3args;
+
+struct GETATTR3resok {
+	fattr3 obj_attributes;
+};
+typedef struct GETATTR3resok GETATTR3resok;
+
+struct GETATTR3res {
+	nfsstat3 status;
+	union {
+		GETATTR3resok resok;
+	} GETATTR3res_u;
+};
+typedef struct GETATTR3res GETATTR3res;
+
+enum time_how {
+	DONT_CHANGE = 0,
+	SET_TO_SERVER_TIME = 1,
+	SET_TO_CLIENT_TIME = 2,
+};
+typedef enum time_how time_how;
+
+struct set_mode3 {
+	bool_t set_it;
+	union {
+		mode3 mode;
+	} set_mode3_u;
+};
+typedef struct set_mode3 set_mode3;
+
+struct set_uid3 {
+	bool_t set_it;
+	union {
+		uid3 uid;
+	} set_uid3_u;
+};
+typedef struct set_uid3 set_uid3;
+
+struct set_gid3 {
+	bool_t set_it;
+	union {
+		gid3 gid;
+	} set_gid3_u;
+};
+typedef struct set_gid3 set_gid3;
+
+struct set_size3 {
+	bool_t set_it;
+	union {
+		size3 size;
+	} set_size3_u;
+};
+typedef struct set_size3 set_size3;
+
+struct set_atime {
+	time_how set_it;
+	union {
+		nfstime3 atime;
+	} set_atime_u;
+};
+typedef struct set_atime set_atime;
+
+struct set_mtime {
+	time_how set_it;
+	union {
+		nfstime3 mtime;
+	} set_mtime_u;
+};
+typedef struct set_mtime set_mtime;
+
+struct sattr3 {
+	set_mode3 mode;
+	set_uid3 uid;
+	set_gid3 gid;
+	set_size3 size;
+	set_atime atime;
+	set_mtime mtime;
+};
+typedef struct sattr3 sattr3;
+
+enum createmode3 {
+	UNCHECKED = 0,
+	GUARDED = 1,
+	EXCLUSIVE = 2,
+};
+typedef enum createmode3 createmode3;
+
+typedef char createverf3[NFS3_CREATEVERFSIZE];
+
+struct createhow3 {
+	createmode3 mode;
+	union {
+		sattr3 obj_attributes;
+		sattr3 g_obj_attributes;
+		createverf3 verf;
+	} createhow3_u;
+};
+typedef struct createhow3 createhow3;
+
+struct CREATE3args {
+	diropargs3 where;
+	createhow3 how;
+};
+typedef struct CREATE3args CREATE3args;
+
+struct post_op_fh3 {
+	bool_t handle_follows;
+	union {
+		nfs_fh3 handle;
+	} post_op_fh3_u;
+};
+typedef struct post_op_fh3 post_op_fh3;
+
+struct CREATE3resok {
+	post_op_fh3 obj;
+	post_op_attr obj_attributes;
+	wcc_data dir_wcc;
+};
+typedef struct CREATE3resok CREATE3resok;
+
+struct CREATE3resfail {
+	wcc_data dir_wcc;
+};
+typedef struct CREATE3resfail CREATE3resfail;
+
+struct CREATE3res {
+	nfsstat3 status;
+	union {
+		CREATE3resok resok;
+		CREATE3resfail resfail;
+	} CREATE3res_u;
+};
+typedef struct CREATE3res CREATE3res;
+
+struct REMOVE3args {
+	diropargs3 object;
+};
+typedef struct REMOVE3args REMOVE3args;
+
+struct REMOVE3resok {
+	wcc_data dir_wcc;
+};
+typedef struct REMOVE3resok REMOVE3resok;
+
+struct REMOVE3resfail {
+	wcc_data dir_wcc;
+};
+typedef struct REMOVE3resfail REMOVE3resfail;
+
+struct REMOVE3res {
+	nfsstat3 status;
+	union {
+		REMOVE3resok resok;
+		REMOVE3resfail resfail;
+	} REMOVE3res_u;
+};
+typedef struct REMOVE3res REMOVE3res;
+
+struct READ3args {
+	nfs_fh3 file;
+	offset3 offset;
+	count3 count;
+};
+typedef struct READ3args READ3args;
+
+struct READ3resok {
+	post_op_attr file_attributes;
+	count3 count;
+	bool_t eof;
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct READ3resok READ3resok;
+
+struct READ3resfail {
+	post_op_attr file_attributes;
+};
+typedef struct READ3resfail READ3resfail;
+
+struct READ3res {
+	nfsstat3 status;
+	union {
+		READ3resok resok;
+		READ3resfail resfail;
+	} READ3res_u;
+};
+typedef struct READ3res READ3res;
+#define FSF3_LINK 0x0001
+#define FSF3_SYMLINK 0x0002
+#define FSF3_HOMOGENEOUS 0x0008
+#define FSF3_CANSETTIME 0x0010
+
+struct FSINFO3args {
+	nfs_fh3 fsroot;
+};
+typedef struct FSINFO3args FSINFO3args;
+
+struct FSINFO3resok {
+	post_op_attr obj_attributes;
+	u_int rtmax;
+	u_int rtpref;
+	u_int rtmult;
+	u_int wtmax;
+	u_int wtpref;
+	u_int wtmult;
+	u_int dtpref;
+	size3 maxfilesize;
+	nfstime3 time_delta;
+	u_int properties;
+};
+typedef struct FSINFO3resok FSINFO3resok;
+
+struct FSINFO3resfail {
+	post_op_attr obj_attributes;
+};
+typedef struct FSINFO3resfail FSINFO3resfail;
+
+struct FSINFO3res {
+	nfsstat3 status;
+	union {
+		FSINFO3resok resok;
+		FSINFO3resfail resfail;
+	} FSINFO3res_u;
+};
+typedef struct FSINFO3res FSINFO3res;
+
+struct FSSTAT3args {
+	nfs_fh3 fsroot;
+};
+typedef struct FSSTAT3args FSSTAT3args;
+
+struct FSSTAT3resok {
+	post_op_attr obj_attributes;
+	size3 tbytes;
+	size3 fbytes;
+	size3 abytes;
+	size3 tfiles;
+	size3 ffiles;
+	size3 afiles;
+	u_int invarsec;
+};
+typedef struct FSSTAT3resok FSSTAT3resok;
+
+struct FSSTAT3resfail {
+	post_op_attr obj_attributes;
+};
+typedef struct FSSTAT3resfail FSSTAT3resfail;
+
+struct FSSTAT3res {
+	nfsstat3 status;
+	union {
+		FSSTAT3resok resok;
+		FSSTAT3resfail resfail;
+	} FSSTAT3res_u;
+};
+typedef struct FSSTAT3res FSSTAT3res;
+
+struct PATHCONF3args {
+	nfs_fh3 object;
+};
+typedef struct PATHCONF3args PATHCONF3args;
+
+struct PATHCONF3resok {
+	post_op_attr obj_attributes;
+	u_int linkmax;
+	u_int name_max;
+	bool_t no_trunc;
+	bool_t chown_restricted;
+	bool_t case_insensitive;
+	bool_t case_preserving;
+};
+typedef struct PATHCONF3resok PATHCONF3resok;
+
+struct PATHCONF3resfail {
+	post_op_attr obj_attributes;
+};
+typedef struct PATHCONF3resfail PATHCONF3resfail;
+
+struct PATHCONF3res {
+	nfsstat3 status;
+	union {
+		PATHCONF3resok resok;
+		PATHCONF3resfail resfail;
+	} PATHCONF3res_u;
+};
+typedef struct PATHCONF3res PATHCONF3res;
+
+typedef char *nfspath3;
+
+struct symlinkdata3 {
+	sattr3 symlink_attributes;
+	nfspath3 symlink_data;
+};
+typedef struct symlinkdata3 symlinkdata3;
+
+struct SYMLINK3args {
+	diropargs3 where;
+	symlinkdata3 symlink;
+};
+typedef struct SYMLINK3args SYMLINK3args;
+
+struct SYMLINK3resok {
+	post_op_fh3 obj;
+	post_op_attr obj_attributes;
+	wcc_data dir_wcc;
+};
+typedef struct SYMLINK3resok SYMLINK3resok;
+
+struct SYMLINK3resfail {
+	wcc_data dir_wcc;
+};
+typedef struct SYMLINK3resfail SYMLINK3resfail;
+
+struct SYMLINK3res {
+	nfsstat3 status;
+	union {
+		SYMLINK3resok resok;
+		SYMLINK3resfail resfail;
+	} SYMLINK3res_u;
+};
+typedef struct SYMLINK3res SYMLINK3res;
+
+struct READLINK3args {
+	nfs_fh3 symlink;
+};
+typedef struct READLINK3args READLINK3args;
+
+struct READLINK3resok {
+	post_op_attr symlink_attributes;
+	nfspath3 data;
+};
+typedef struct READLINK3resok READLINK3resok;
+
+struct READLINK3resfail {
+	post_op_attr symlink_attributes;
+};
+typedef struct READLINK3resfail READLINK3resfail;
+
+struct READLINK3res {
+	nfsstat3 status;
+	union {
+		READLINK3resok resok;
+		READLINK3resfail resfail;
+	} READLINK3res_u;
+};
+typedef struct READLINK3res READLINK3res;
+
+struct devicedata3 {
+	sattr3 dev_attributes;
+	specdata3 spec;
+};
+typedef struct devicedata3 devicedata3;
+
+struct mknoddata3 {
+	ftype3 type;
+	union {
+		devicedata3 chr_device;
+		devicedata3 blk_device;
+		sattr3 sock_attributes;
+		sattr3 pipe_attributes;
+	} mknoddata3_u;
+};
+typedef struct mknoddata3 mknoddata3;
+
+struct MKNOD3args {
+	diropargs3 where;
+	mknoddata3 what;
+};
+typedef struct MKNOD3args MKNOD3args;
+
+struct MKNOD3resok {
+	post_op_fh3 obj;
+	post_op_attr obj_attributes;
+	wcc_data dir_wcc;
+};
+typedef struct MKNOD3resok MKNOD3resok;
+
+struct MKNOD3resfail {
+	wcc_data dir_wcc;
+};
+typedef struct MKNOD3resfail MKNOD3resfail;
+
+struct MKNOD3res {
+	nfsstat3 status;
+	union {
+		MKNOD3resok resok;
+		MKNOD3resfail resfail;
+	} MKNOD3res_u;
+};
+typedef struct MKNOD3res MKNOD3res;
+
+struct MKDIR3args {
+	diropargs3 where;
+	sattr3 attributes;
+};
+typedef struct MKDIR3args MKDIR3args;
+
+struct MKDIR3resok {
+	post_op_fh3 obj;
+	post_op_attr obj_attributes;
+	wcc_data dir_wcc;
+};
+typedef struct MKDIR3resok MKDIR3resok;
+
+struct MKDIR3resfail {
+	wcc_data dir_wcc;
+};
+typedef struct MKDIR3resfail MKDIR3resfail;
+
+struct MKDIR3res {
+	nfsstat3 status;
+	union {
+		MKDIR3resok resok;
+		MKDIR3resfail resfail;
+	} MKDIR3res_u;
+};
+typedef struct MKDIR3res MKDIR3res;
+
+struct RMDIR3args {
+	diropargs3 object;
+};
+typedef struct RMDIR3args RMDIR3args;
+
+struct RMDIR3resok {
+	wcc_data dir_wcc;
+};
+typedef struct RMDIR3resok RMDIR3resok;
+
+struct RMDIR3resfail {
+	wcc_data dir_wcc;
+};
+typedef struct RMDIR3resfail RMDIR3resfail;
+
+struct RMDIR3res {
+	nfsstat3 status;
+	union {
+		RMDIR3resok resok;
+		RMDIR3resfail resfail;
+	} RMDIR3res_u;
+};
+typedef struct RMDIR3res RMDIR3res;
+
+struct RENAME3args {
+	diropargs3 from;
+	diropargs3 to;
+};
+typedef struct RENAME3args RENAME3args;
+
+struct RENAME3resok {
+	wcc_data fromdir_wcc;
+	wcc_data todir_wcc;
+};
+typedef struct RENAME3resok RENAME3resok;
+
+struct RENAME3resfail {
+	wcc_data fromdir_wcc;
+	wcc_data todir_wcc;
+};
+typedef struct RENAME3resfail RENAME3resfail;
+
+struct RENAME3res {
+	nfsstat3 status;
+	union {
+		RENAME3resok resok;
+		RENAME3resfail resfail;
+	} RENAME3res_u;
+};
+typedef struct RENAME3res RENAME3res;
+
+struct READDIRPLUS3args {
+	nfs_fh3 dir;
+	cookie3 cookie;
+	cookieverf3 cookieverf;
+	count3 dircount;
+	count3 maxcount;
+};
+typedef struct READDIRPLUS3args READDIRPLUS3args;
+
+struct entryplus3 {
+	fileid3 fileid;
+	filename3 name;
+	cookie3 cookie;
+	post_op_attr name_attributes;
+	post_op_fh3 name_handle;
+	struct entryplus3 *nextentry;
+};
+typedef struct entryplus3 entryplus3;
+
+struct dirlistplus3 {
+	entryplus3 *entries;
+	bool_t eof;
+};
+typedef struct dirlistplus3 dirlistplus3;
+
+struct READDIRPLUS3resok {
+	post_op_attr dir_attributes;
+	cookieverf3 cookieverf;
+	dirlistplus3 reply;
+};
+typedef struct READDIRPLUS3resok READDIRPLUS3resok;
+
+struct READDIRPLUS3resfail {
+	post_op_attr dir_attributes;
+};
+typedef struct READDIRPLUS3resfail READDIRPLUS3resfail;
+
+struct READDIRPLUS3res {
+	nfsstat3 status;
+	union {
+		READDIRPLUS3resok resok;
+		READDIRPLUS3resfail resfail;
+	} READDIRPLUS3res_u;
+};
+typedef struct READDIRPLUS3res READDIRPLUS3res;
+
+struct READDIR3args {
+	nfs_fh3 dir;
+	cookie3 cookie;
+	cookieverf3 cookieverf;
+	count3 count;
+};
+typedef struct READDIR3args READDIR3args;
+
+struct entry3 {
+	fileid3 fileid;
+	filename3 name;
+	cookie3 cookie;
+	struct entry3 *nextentry;
+};
+typedef struct entry3 entry3;
+
+struct dirlist3 {
+	entry3 *entries;
+	bool_t eof;
+};
+typedef struct dirlist3 dirlist3;
+
+struct READDIR3resok {
+	post_op_attr dir_attributes;
+	cookieverf3 cookieverf;
+	dirlist3 reply;
+};
+typedef struct READDIR3resok READDIR3resok;
+
+struct READDIR3resfail {
+	post_op_attr dir_attributes;
+};
+typedef struct READDIR3resfail READDIR3resfail;
+
+struct READDIR3res {
+	nfsstat3 status;
+	union {
+		READDIR3resok resok;
+		READDIR3resfail resfail;
+	} READDIR3res_u;
+};
+typedef struct READDIR3res READDIR3res;
+
+struct LINK3args {
+	nfs_fh3 file;
+	diropargs3 link;
+};
+typedef struct LINK3args LINK3args;
+
+struct LINK3resok {
+	post_op_attr file_attributes;
+	wcc_data linkdir_wcc;
+};
+typedef struct LINK3resok LINK3resok;
+
+struct LINK3resfail {
+	post_op_attr file_attributes;
+	wcc_data linkdir_wcc;
+};
+typedef struct LINK3resfail LINK3resfail;
+
+struct LINK3res {
+	nfsstat3 status;
+	union {
+		LINK3resok resok;
+		LINK3resfail resfail;
+	} LINK3res_u;
+};
+typedef struct LINK3res LINK3res;
+
+struct sattrguard3 {
+	bool_t check;
+	union {
+		nfstime3 obj_ctime;
+	} sattrguard3_u;
+};
+typedef struct sattrguard3 sattrguard3;
+
+struct SETATTR3args {
+	nfs_fh3 object;
+	sattr3 new_attributes;
+	sattrguard3 guard;
+};
+typedef struct SETATTR3args SETATTR3args;
+
+struct SETATTR3resok {
+	wcc_data obj_wcc;
+};
+typedef struct SETATTR3resok SETATTR3resok;
+
+struct SETATTR3resfail {
+	wcc_data obj_wcc;
+};
+typedef struct SETATTR3resfail SETATTR3resfail;
+
+struct SETATTR3res {
+	nfsstat3 status;
+	union {
+		SETATTR3resok resok;
+		SETATTR3resfail resfail;
+	} SETATTR3res_u;
+};
+typedef struct SETATTR3res SETATTR3res;
+
+enum nfsacl_type {
+	NFSACL_TYPE_USER_OBJ = 0x0001,
+	NFSACL_TYPE_USER = 0x0002,
+	NFSACL_TYPE_GROUP_OBJ = 0x0004,
+	NFSACL_TYPE_GROUP = 0x0008,
+	NFSACL_TYPE_CLASS_OBJ = 0x0010,
+	NFSACL_TYPE_CLASS = 0x0020,
+	NFSACL_TYPE_DEFAULT = 0x1000,
+	NFSACL_TYPE_DEFAULT_USER_OBJ = 0x1001,
+	NFSACL_TYPE_DEFAULT_USER = 0x1002,
+	NFSACL_TYPE_DEFAULT_GROUP_OBJ = 0x1004,
+	NFSACL_TYPE_DEFAULT_GROUP = 0x1008,
+	NFSACL_TYPE_DEFAULT_CLASS_OBJ = 0x1010,
+	NFSACL_TYPE_DEFAULT_OTHER_OBJ = 0x1020,
+};
+typedef enum nfsacl_type nfsacl_type;
+#define NFSACL_PERM_READ 0x04
+#define NFSACL_PERM_WRITE 0x02
+#define NFSACL_PERM_EXEC 0x01
+
+struct nfsacl_ace {
+	enum nfsacl_type type;
+	u_int id;
+	u_int perm;
+};
+typedef struct nfsacl_ace nfsacl_ace;
+#define NFSACL_MASK_ACL_ENTRY 0x0001
+#define NFSACL_MASK_ACL_COUNT 0x0002
+#define NFSACL_MASK_ACL_DEFAULT_ENTRY 0x0004
+#define NFSACL_MASK_ACL_DEFAULT_COUNT 0x0008
+
+struct GETACL3args {
+	nfs_fh3 dir;
+	u_int mask;
+};
+typedef struct GETACL3args GETACL3args;
+
+struct GETACL3resok {
+	post_op_attr attr;
+	u_int mask;
+	u_int ace_count;
+	struct {
+		u_int ace_len;
+		struct nfsacl_ace *ace_val;
+	} ace;
+	u_int default_ace_count;
+	struct {
+		u_int default_ace_len;
+		struct nfsacl_ace *default_ace_val;
+	} default_ace;
+};
+typedef struct GETACL3resok GETACL3resok;
+
+struct GETACL3res {
+	nfsstat3 status;
+	union {
+		GETACL3resok resok;
+	} GETACL3res_u;
+};
+typedef struct GETACL3res GETACL3res;
+
+struct SETACL3args {
+	nfs_fh3 dir;
+	u_int mask;
+	u_int ace_count;
+	struct {
+		u_int ace_len;
+		struct nfsacl_ace *ace_val;
+	} ace;
+	u_int default_ace_count;
+	struct {
+		u_int default_ace_len;
+		struct nfsacl_ace *default_ace_val;
+	} default_ace;
+};
+typedef struct SETACL3args SETACL3args;
+
+struct SETACL3resok {
+	post_op_attr attr;
+};
+typedef struct SETACL3resok SETACL3resok;
+
+struct SETACL3res {
+	nfsstat3 status;
+	union {
+		SETACL3resok resok;
+	} SETACL3res_u;
+};
+typedef struct SETACL3res SETACL3res;
+
+#define NFS_PROGRAM 100003
+#define NFS_V3 3
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define NFS3_NULL 0
+extern  void * nfs3_null_3(void *, CLIENT *);
+extern  void * nfs3_null_3_svc(void *, struct svc_req *);
+#define NFS3_GETATTR 1
+extern  GETATTR3res * nfs3_getattr_3(GETATTR3args *, CLIENT *);
+extern  GETATTR3res * nfs3_getattr_3_svc(GETATTR3args *, struct svc_req *);
+#define NFS3_SETATTR 2
+extern  SETATTR3res * nfs3_setattr_3(SETATTR3args *, CLIENT *);
+extern  SETATTR3res * nfs3_setattr_3_svc(SETATTR3args *, struct svc_req *);
+#define NFS3_LOOKUP 3
+extern  LOOKUP3res * nfs3_lookup_3(LOOKUP3args *, CLIENT *);
+extern  LOOKUP3res * nfs3_lookup_3_svc(LOOKUP3args *, struct svc_req *);
+#define NFS3_ACCESS 4
+extern  ACCESS3res * nfs3_access_3(ACCESS3args *, CLIENT *);
+extern  ACCESS3res * nfs3_access_3_svc(ACCESS3args *, struct svc_req *);
+#define NFS3_READLINK 5
+extern  READLINK3res * nfs3_readlink_3(READLINK3args *, CLIENT *);
+extern  READLINK3res * nfs3_readlink_3_svc(READLINK3args *, struct svc_req *);
+#define NFS3_READ 6
+extern  READ3res * nfs3_read_3(READ3args *, CLIENT *);
+extern  READ3res * nfs3_read_3_svc(READ3args *, struct svc_req *);
+#define NFS3_WRITE 7
+extern  WRITE3res * nfs3_write_3(WRITE3args *, CLIENT *);
+extern  WRITE3res * nfs3_write_3_svc(WRITE3args *, struct svc_req *);
+#define NFS3_CREATE 8
+extern  CREATE3res * nfs3_create_3(CREATE3args *, CLIENT *);
+extern  CREATE3res * nfs3_create_3_svc(CREATE3args *, struct svc_req *);
+#define NFS3_MKDIR 9
+extern  MKDIR3res * nfs3_mkdir_3(MKDIR3args *, CLIENT *);
+extern  MKDIR3res * nfs3_mkdir_3_svc(MKDIR3args *, struct svc_req *);
+#define NFS3_SYMLINK 10
+extern  SYMLINK3res * nfs3_symlink_3(SYMLINK3args *, CLIENT *);
+extern  SYMLINK3res * nfs3_symlink_3_svc(SYMLINK3args *, struct svc_req *);
+#define NFS3_MKNOD 11
+extern  MKNOD3res * nfs3_mknod_3(MKNOD3args *, CLIENT *);
+extern  MKNOD3res * nfs3_mknod_3_svc(MKNOD3args *, struct svc_req *);
+#define NFS3_REMOVE 12
+extern  REMOVE3res * nfs3_remove_3(REMOVE3args *, CLIENT *);
+extern  REMOVE3res * nfs3_remove_3_svc(REMOVE3args *, struct svc_req *);
+#define NFS3_RMDIR 13
+extern  RMDIR3res * nfs3_rmdir_3(RMDIR3args *, CLIENT *);
+extern  RMDIR3res * nfs3_rmdir_3_svc(RMDIR3args *, struct svc_req *);
+#define NFS3_RENAME 14
+extern  RENAME3res * nfs3_rename_3(RENAME3args *, CLIENT *);
+extern  RENAME3res * nfs3_rename_3_svc(RENAME3args *, struct svc_req *);
+#define NFS3_LINK 15
+extern  LINK3res * nfs3_link_3(LINK3args *, CLIENT *);
+extern  LINK3res * nfs3_link_3_svc(LINK3args *, struct svc_req *);
+#define NFS3_READDIR 16
+extern  READDIR3res * nfs3_readdir_3(READDIR3args *, CLIENT *);
+extern  READDIR3res * nfs3_readdir_3_svc(READDIR3args *, struct svc_req *);
+#define NFS3_READDIRPLUS 17
+extern  READDIRPLUS3res * nfs3_readdirplus_3(READDIRPLUS3args *, CLIENT *);
+extern  READDIRPLUS3res * nfs3_readdirplus_3_svc(READDIRPLUS3args *, struct svc_req *);
+#define NFS3_FSSTAT 18
+extern  FSSTAT3res * nfs3_fsstat_3(FSSTAT3args *, CLIENT *);
+extern  FSSTAT3res * nfs3_fsstat_3_svc(FSSTAT3args *, struct svc_req *);
+#define NFS3_FSINFO 19
+extern  FSINFO3res * nfs3_fsinfo_3(FSINFO3args *, CLIENT *);
+extern  FSINFO3res * nfs3_fsinfo_3_svc(FSINFO3args *, struct svc_req *);
+#define NFS3_PATHCONF 20
+extern  PATHCONF3res * nfs3_pathconf_3(PATHCONF3args *, CLIENT *);
+extern  PATHCONF3res * nfs3_pathconf_3_svc(PATHCONF3args *, struct svc_req *);
+#define NFS3_COMMIT 21
+extern  COMMIT3res * nfs3_commit_3(COMMIT3args *, CLIENT *);
+extern  COMMIT3res * nfs3_commit_3_svc(COMMIT3args *, struct svc_req *);
+extern int nfs_program_3_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define NFS3_NULL 0
+extern  void * nfs3_null_3();
+extern  void * nfs3_null_3_svc();
+#define NFS3_GETATTR 1
+extern  GETATTR3res * nfs3_getattr_3();
+extern  GETATTR3res * nfs3_getattr_3_svc();
+#define NFS3_SETATTR 2
+extern  SETATTR3res * nfs3_setattr_3();
+extern  SETATTR3res * nfs3_setattr_3_svc();
+#define NFS3_LOOKUP 3
+extern  LOOKUP3res * nfs3_lookup_3();
+extern  LOOKUP3res * nfs3_lookup_3_svc();
+#define NFS3_ACCESS 4
+extern  ACCESS3res * nfs3_access_3();
+extern  ACCESS3res * nfs3_access_3_svc();
+#define NFS3_READLINK 5
+extern  READLINK3res * nfs3_readlink_3();
+extern  READLINK3res * nfs3_readlink_3_svc();
+#define NFS3_READ 6
+extern  READ3res * nfs3_read_3();
+extern  READ3res * nfs3_read_3_svc();
+#define NFS3_WRITE 7
+extern  WRITE3res * nfs3_write_3();
+extern  WRITE3res * nfs3_write_3_svc();
+#define NFS3_CREATE 8
+extern  CREATE3res * nfs3_create_3();
+extern  CREATE3res * nfs3_create_3_svc();
+#define NFS3_MKDIR 9
+extern  MKDIR3res * nfs3_mkdir_3();
+extern  MKDIR3res * nfs3_mkdir_3_svc();
+#define NFS3_SYMLINK 10
+extern  SYMLINK3res * nfs3_symlink_3();
+extern  SYMLINK3res * nfs3_symlink_3_svc();
+#define NFS3_MKNOD 11
+extern  MKNOD3res * nfs3_mknod_3();
+extern  MKNOD3res * nfs3_mknod_3_svc();
+#define NFS3_REMOVE 12
+extern  REMOVE3res * nfs3_remove_3();
+extern  REMOVE3res * nfs3_remove_3_svc();
+#define NFS3_RMDIR 13
+extern  RMDIR3res * nfs3_rmdir_3();
+extern  RMDIR3res * nfs3_rmdir_3_svc();
+#define NFS3_RENAME 14
+extern  RENAME3res * nfs3_rename_3();
+extern  RENAME3res * nfs3_rename_3_svc();
+#define NFS3_LINK 15
+extern  LINK3res * nfs3_link_3();
+extern  LINK3res * nfs3_link_3_svc();
+#define NFS3_READDIR 16
+extern  READDIR3res * nfs3_readdir_3();
+extern  READDIR3res * nfs3_readdir_3_svc();
+#define NFS3_READDIRPLUS 17
+extern  READDIRPLUS3res * nfs3_readdirplus_3();
+extern  READDIRPLUS3res * nfs3_readdirplus_3_svc();
+#define NFS3_FSSTAT 18
+extern  FSSTAT3res * nfs3_fsstat_3();
+extern  FSSTAT3res * nfs3_fsstat_3_svc();
+#define NFS3_FSINFO 19
+extern  FSINFO3res * nfs3_fsinfo_3();
+extern  FSINFO3res * nfs3_fsinfo_3_svc();
+#define NFS3_PATHCONF 20
+extern  PATHCONF3res * nfs3_pathconf_3();
+extern  PATHCONF3res * nfs3_pathconf_3_svc();
+#define NFS3_COMMIT 21
+extern  COMMIT3res * nfs3_commit_3();
+extern  COMMIT3res * nfs3_commit_3_svc();
+extern int nfs_program_3_freeresult ();
+#endif /* K&R C */
+
+#define NFSACL_PROGRAM 100227
+#define NFSACL_V3 3
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define NFSACL3_NULL 0
+extern  void * nfsacl3_null_3(void *, CLIENT *);
+extern  void * nfsacl3_null_3_svc(void *, struct svc_req *);
+#define NFSACL3_GETACL 1
+extern  GETACL3res * nfsacl3_getacl_3(GETACL3args *, CLIENT *);
+extern  GETACL3res * nfsacl3_getacl_3_svc(GETACL3args *, struct svc_req *);
+#define NFSACL3_SETACL 2
+extern  SETACL3res * nfsacl3_setacl_3(SETACL3args *, CLIENT *);
+extern  SETACL3res * nfsacl3_setacl_3_svc(SETACL3args *, struct svc_req *);
+extern int nfsacl_program_3_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define NFSACL3_NULL 0
+extern  void * nfsacl3_null_3();
+extern  void * nfsacl3_null_3_svc();
+#define NFSACL3_GETACL 1
+extern  GETACL3res * nfsacl3_getacl_3();
+extern  GETACL3res * nfsacl3_getacl_3_svc();
+#define NFSACL3_SETACL 2
+extern  SETACL3res * nfsacl3_setacl_3();
+extern  SETACL3res * nfsacl3_setacl_3_svc();
+extern int nfsacl_program_3_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_cookieverf3 (XDR *, cookieverf3);
+extern  bool_t xdr_uint64 (XDR *, uint64*);
+extern  bool_t xdr_cookie3 (XDR *, cookie3*);
+extern  bool_t xdr_nfs_fh3 (XDR *, nfs_fh3*);
+extern  bool_t xdr_filename3 (XDR *, filename3*);
+extern  bool_t xdr_diropargs3 (XDR *, diropargs3*);
+extern  bool_t xdr_ftype3 (XDR *, ftype3*);
+extern  bool_t xdr_mode3 (XDR *, mode3*);
+extern  bool_t xdr_uid3 (XDR *, uid3*);
+extern  bool_t xdr_gid3 (XDR *, gid3*);
+extern  bool_t xdr_size3 (XDR *, size3*);
+extern  bool_t xdr_fileid3 (XDR *, fileid3*);
+extern  bool_t xdr_specdata3 (XDR *, specdata3*);
+extern  bool_t xdr_nfstime3 (XDR *, nfstime3*);
+extern  bool_t xdr_fattr3 (XDR *, fattr3*);
+extern  bool_t xdr_post_op_attr (XDR *, post_op_attr*);
+extern  bool_t xdr_nfsstat3 (XDR *, nfsstat3*);
+extern  bool_t xdr_stable_how (XDR *, stable_how*);
+extern  bool_t xdr_offset3 (XDR *, offset3*);
+extern  bool_t xdr_count3 (XDR *, count3*);
+extern  bool_t xdr_wcc_attr (XDR *, wcc_attr*);
+extern  bool_t xdr_pre_op_attr (XDR *, pre_op_attr*);
+extern  bool_t xdr_wcc_data (XDR *, wcc_data*);
+extern  bool_t xdr_WRITE3args (XDR *, WRITE3args*);
+extern  bool_t xdr_writeverf3 (XDR *, writeverf3);
+extern  bool_t xdr_WRITE3resok (XDR *, WRITE3resok*);
+extern  bool_t xdr_WRITE3resfail (XDR *, WRITE3resfail*);
+extern  bool_t xdr_WRITE3res (XDR *, WRITE3res*);
+extern  bool_t xdr_LOOKUP3args (XDR *, LOOKUP3args*);
+extern  bool_t xdr_LOOKUP3resok (XDR *, LOOKUP3resok*);
+extern  bool_t xdr_LOOKUP3resfail (XDR *, LOOKUP3resfail*);
+extern  bool_t xdr_LOOKUP3res (XDR *, LOOKUP3res*);
+extern  bool_t xdr_COMMIT3args (XDR *, COMMIT3args*);
+extern  bool_t xdr_COMMIT3resok (XDR *, COMMIT3resok*);
+extern  bool_t xdr_COMMIT3resfail (XDR *, COMMIT3resfail*);
+extern  bool_t xdr_COMMIT3res (XDR *, COMMIT3res*);
+extern  bool_t xdr_ACCESS3args (XDR *, ACCESS3args*);
+extern  bool_t xdr_ACCESS3resok (XDR *, ACCESS3resok*);
+extern  bool_t xdr_ACCESS3resfail (XDR *, ACCESS3resfail*);
+extern  bool_t xdr_ACCESS3res (XDR *, ACCESS3res*);
+extern  bool_t xdr_GETATTR3args (XDR *, GETATTR3args*);
+extern  bool_t xdr_GETATTR3resok (XDR *, GETATTR3resok*);
+extern  bool_t xdr_GETATTR3res (XDR *, GETATTR3res*);
+extern  bool_t xdr_time_how (XDR *, time_how*);
+extern  bool_t xdr_set_mode3 (XDR *, set_mode3*);
+extern  bool_t xdr_set_uid3 (XDR *, set_uid3*);
+extern  bool_t xdr_set_gid3 (XDR *, set_gid3*);
+extern  bool_t xdr_set_size3 (XDR *, set_size3*);
+extern  bool_t xdr_set_atime (XDR *, set_atime*);
+extern  bool_t xdr_set_mtime (XDR *, set_mtime*);
+extern  bool_t xdr_sattr3 (XDR *, sattr3*);
+extern  bool_t xdr_createmode3 (XDR *, createmode3*);
+extern  bool_t xdr_createverf3 (XDR *, createverf3);
+extern  bool_t xdr_createhow3 (XDR *, createhow3*);
+extern  bool_t xdr_CREATE3args (XDR *, CREATE3args*);
+extern  bool_t xdr_post_op_fh3 (XDR *, post_op_fh3*);
+extern  bool_t xdr_CREATE3resok (XDR *, CREATE3resok*);
+extern  bool_t xdr_CREATE3resfail (XDR *, CREATE3resfail*);
+extern  bool_t xdr_CREATE3res (XDR *, CREATE3res*);
+extern  bool_t xdr_REMOVE3args (XDR *, REMOVE3args*);
+extern  bool_t xdr_REMOVE3resok (XDR *, REMOVE3resok*);
+extern  bool_t xdr_REMOVE3resfail (XDR *, REMOVE3resfail*);
+extern  bool_t xdr_REMOVE3res (XDR *, REMOVE3res*);
+extern  bool_t xdr_READ3args (XDR *, READ3args*);
+extern  bool_t xdr_READ3resok (XDR *, READ3resok*);
+extern  bool_t xdr_READ3resfail (XDR *, READ3resfail*);
+extern  bool_t xdr_READ3res (XDR *, READ3res*);
+extern  bool_t xdr_FSINFO3args (XDR *, FSINFO3args*);
+extern  bool_t xdr_FSINFO3resok (XDR *, FSINFO3resok*);
+extern  bool_t xdr_FSINFO3resfail (XDR *, FSINFO3resfail*);
+extern  bool_t xdr_FSINFO3res (XDR *, FSINFO3res*);
+extern  bool_t xdr_FSSTAT3args (XDR *, FSSTAT3args*);
+extern  bool_t xdr_FSSTAT3resok (XDR *, FSSTAT3resok*);
+extern  bool_t xdr_FSSTAT3resfail (XDR *, FSSTAT3resfail*);
+extern  bool_t xdr_FSSTAT3res (XDR *, FSSTAT3res*);
+extern  bool_t xdr_PATHCONF3args (XDR *, PATHCONF3args*);
+extern  bool_t xdr_PATHCONF3resok (XDR *, PATHCONF3resok*);
+extern  bool_t xdr_PATHCONF3resfail (XDR *, PATHCONF3resfail*);
+extern  bool_t xdr_PATHCONF3res (XDR *, PATHCONF3res*);
+extern  bool_t xdr_nfspath3 (XDR *, nfspath3*);
+extern  bool_t xdr_symlinkdata3 (XDR *, symlinkdata3*);
+extern  bool_t xdr_SYMLINK3args (XDR *, SYMLINK3args*);
+extern  bool_t xdr_SYMLINK3resok (XDR *, SYMLINK3resok*);
+extern  bool_t xdr_SYMLINK3resfail (XDR *, SYMLINK3resfail*);
+extern  bool_t xdr_SYMLINK3res (XDR *, SYMLINK3res*);
+extern  bool_t xdr_READLINK3args (XDR *, READLINK3args*);
+extern  bool_t xdr_READLINK3resok (XDR *, READLINK3resok*);
+extern  bool_t xdr_READLINK3resfail (XDR *, READLINK3resfail*);
+extern  bool_t xdr_READLINK3res (XDR *, READLINK3res*);
+extern  bool_t xdr_devicedata3 (XDR *, devicedata3*);
+extern  bool_t xdr_mknoddata3 (XDR *, mknoddata3*);
+extern  bool_t xdr_MKNOD3args (XDR *, MKNOD3args*);
+extern  bool_t xdr_MKNOD3resok (XDR *, MKNOD3resok*);
+extern  bool_t xdr_MKNOD3resfail (XDR *, MKNOD3resfail*);
+extern  bool_t xdr_MKNOD3res (XDR *, MKNOD3res*);
+extern  bool_t xdr_MKDIR3args (XDR *, MKDIR3args*);
+extern  bool_t xdr_MKDIR3resok (XDR *, MKDIR3resok*);
+extern  bool_t xdr_MKDIR3resfail (XDR *, MKDIR3resfail*);
+extern  bool_t xdr_MKDIR3res (XDR *, MKDIR3res*);
+extern  bool_t xdr_RMDIR3args (XDR *, RMDIR3args*);
+extern  bool_t xdr_RMDIR3resok (XDR *, RMDIR3resok*);
+extern  bool_t xdr_RMDIR3resfail (XDR *, RMDIR3resfail*);
+extern  bool_t xdr_RMDIR3res (XDR *, RMDIR3res*);
+extern  bool_t xdr_RENAME3args (XDR *, RENAME3args*);
+extern  bool_t xdr_RENAME3resok (XDR *, RENAME3resok*);
+extern  bool_t xdr_RENAME3resfail (XDR *, RENAME3resfail*);
+extern  bool_t xdr_RENAME3res (XDR *, RENAME3res*);
+extern  bool_t xdr_READDIRPLUS3args (XDR *, READDIRPLUS3args*);
+extern  bool_t xdr_entryplus3 (XDR *, entryplus3*);
+extern  bool_t xdr_dirlistplus3 (XDR *, dirlistplus3*);
+extern  bool_t xdr_READDIRPLUS3resok (XDR *, READDIRPLUS3resok*);
+extern  bool_t xdr_READDIRPLUS3resfail (XDR *, READDIRPLUS3resfail*);
+extern  bool_t xdr_READDIRPLUS3res (XDR *, READDIRPLUS3res*);
+extern  bool_t xdr_READDIR3args (XDR *, READDIR3args*);
+extern  bool_t xdr_entry3 (XDR *, entry3*);
+extern  bool_t xdr_dirlist3 (XDR *, dirlist3*);
+extern  bool_t xdr_READDIR3resok (XDR *, READDIR3resok*);
+extern  bool_t xdr_READDIR3resfail (XDR *, READDIR3resfail*);
+extern  bool_t xdr_READDIR3res (XDR *, READDIR3res*);
+extern  bool_t xdr_LINK3args (XDR *, LINK3args*);
+extern  bool_t xdr_LINK3resok (XDR *, LINK3resok*);
+extern  bool_t xdr_LINK3resfail (XDR *, LINK3resfail*);
+extern  bool_t xdr_LINK3res (XDR *, LINK3res*);
+extern  bool_t xdr_sattrguard3 (XDR *, sattrguard3*);
+extern  bool_t xdr_SETATTR3args (XDR *, SETATTR3args*);
+extern  bool_t xdr_SETATTR3resok (XDR *, SETATTR3resok*);
+extern  bool_t xdr_SETATTR3resfail (XDR *, SETATTR3resfail*);
+extern  bool_t xdr_SETATTR3res (XDR *, SETATTR3res*);
+extern  bool_t xdr_nfsacl_type (XDR *, nfsacl_type*);
+extern  bool_t xdr_nfsacl_ace (XDR *, nfsacl_ace*);
+extern  bool_t xdr_GETACL3args (XDR *, GETACL3args*);
+extern  bool_t xdr_GETACL3resok (XDR *, GETACL3resok*);
+extern  bool_t xdr_GETACL3res (XDR *, GETACL3res*);
+extern  bool_t xdr_SETACL3args (XDR *, SETACL3args*);
+extern  bool_t xdr_SETACL3resok (XDR *, SETACL3resok*);
+extern  bool_t xdr_SETACL3res (XDR *, SETACL3res*);
+
+#else /* K&R C */
+extern bool_t xdr_cookieverf3 ();
+extern bool_t xdr_uint64 ();
+extern bool_t xdr_cookie3 ();
+extern bool_t xdr_nfs_fh3 ();
+extern bool_t xdr_filename3 ();
+extern bool_t xdr_diropargs3 ();
+extern bool_t xdr_ftype3 ();
+extern bool_t xdr_mode3 ();
+extern bool_t xdr_uid3 ();
+extern bool_t xdr_gid3 ();
+extern bool_t xdr_size3 ();
+extern bool_t xdr_fileid3 ();
+extern bool_t xdr_specdata3 ();
+extern bool_t xdr_nfstime3 ();
+extern bool_t xdr_fattr3 ();
+extern bool_t xdr_post_op_attr ();
+extern bool_t xdr_nfsstat3 ();
+extern bool_t xdr_stable_how ();
+extern bool_t xdr_offset3 ();
+extern bool_t xdr_count3 ();
+extern bool_t xdr_wcc_attr ();
+extern bool_t xdr_pre_op_attr ();
+extern bool_t xdr_wcc_data ();
+extern bool_t xdr_WRITE3args ();
+extern bool_t xdr_writeverf3 ();
+extern bool_t xdr_WRITE3resok ();
+extern bool_t xdr_WRITE3resfail ();
+extern bool_t xdr_WRITE3res ();
+extern bool_t xdr_LOOKUP3args ();
+extern bool_t xdr_LOOKUP3resok ();
+extern bool_t xdr_LOOKUP3resfail ();
+extern bool_t xdr_LOOKUP3res ();
+extern bool_t xdr_COMMIT3args ();
+extern bool_t xdr_COMMIT3resok ();
+extern bool_t xdr_COMMIT3resfail ();
+extern bool_t xdr_COMMIT3res ();
+extern bool_t xdr_ACCESS3args ();
+extern bool_t xdr_ACCESS3resok ();
+extern bool_t xdr_ACCESS3resfail ();
+extern bool_t xdr_ACCESS3res ();
+extern bool_t xdr_GETATTR3args ();
+extern bool_t xdr_GETATTR3resok ();
+extern bool_t xdr_GETATTR3res ();
+extern bool_t xdr_time_how ();
+extern bool_t xdr_set_mode3 ();
+extern bool_t xdr_set_uid3 ();
+extern bool_t xdr_set_gid3 ();
+extern bool_t xdr_set_size3 ();
+extern bool_t xdr_set_atime ();
+extern bool_t xdr_set_mtime ();
+extern bool_t xdr_sattr3 ();
+extern bool_t xdr_createmode3 ();
+extern bool_t xdr_createverf3 ();
+extern bool_t xdr_createhow3 ();
+extern bool_t xdr_CREATE3args ();
+extern bool_t xdr_post_op_fh3 ();
+extern bool_t xdr_CREATE3resok ();
+extern bool_t xdr_CREATE3resfail ();
+extern bool_t xdr_CREATE3res ();
+extern bool_t xdr_REMOVE3args ();
+extern bool_t xdr_REMOVE3resok ();
+extern bool_t xdr_REMOVE3resfail ();
+extern bool_t xdr_REMOVE3res ();
+extern bool_t xdr_READ3args ();
+extern bool_t xdr_READ3resok ();
+extern bool_t xdr_READ3resfail ();
+extern bool_t xdr_READ3res ();
+extern bool_t xdr_FSINFO3args ();
+extern bool_t xdr_FSINFO3resok ();
+extern bool_t xdr_FSINFO3resfail ();
+extern bool_t xdr_FSINFO3res ();
+extern bool_t xdr_FSSTAT3args ();
+extern bool_t xdr_FSSTAT3resok ();
+extern bool_t xdr_FSSTAT3resfail ();
+extern bool_t xdr_FSSTAT3res ();
+extern bool_t xdr_PATHCONF3args ();
+extern bool_t xdr_PATHCONF3resok ();
+extern bool_t xdr_PATHCONF3resfail ();
+extern bool_t xdr_PATHCONF3res ();
+extern bool_t xdr_nfspath3 ();
+extern bool_t xdr_symlinkdata3 ();
+extern bool_t xdr_SYMLINK3args ();
+extern bool_t xdr_SYMLINK3resok ();
+extern bool_t xdr_SYMLINK3resfail ();
+extern bool_t xdr_SYMLINK3res ();
+extern bool_t xdr_READLINK3args ();
+extern bool_t xdr_READLINK3resok ();
+extern bool_t xdr_READLINK3resfail ();
+extern bool_t xdr_READLINK3res ();
+extern bool_t xdr_devicedata3 ();
+extern bool_t xdr_mknoddata3 ();
+extern bool_t xdr_MKNOD3args ();
+extern bool_t xdr_MKNOD3resok ();
+extern bool_t xdr_MKNOD3resfail ();
+extern bool_t xdr_MKNOD3res ();
+extern bool_t xdr_MKDIR3args ();
+extern bool_t xdr_MKDIR3resok ();
+extern bool_t xdr_MKDIR3resfail ();
+extern bool_t xdr_MKDIR3res ();
+extern bool_t xdr_RMDIR3args ();
+extern bool_t xdr_RMDIR3resok ();
+extern bool_t xdr_RMDIR3resfail ();
+extern bool_t xdr_RMDIR3res ();
+extern bool_t xdr_RENAME3args ();
+extern bool_t xdr_RENAME3resok ();
+extern bool_t xdr_RENAME3resfail ();
+extern bool_t xdr_RENAME3res ();
+extern bool_t xdr_READDIRPLUS3args ();
+extern bool_t xdr_entryplus3 ();
+extern bool_t xdr_dirlistplus3 ();
+extern bool_t xdr_READDIRPLUS3resok ();
+extern bool_t xdr_READDIRPLUS3resfail ();
+extern bool_t xdr_READDIRPLUS3res ();
+extern bool_t xdr_READDIR3args ();
+extern bool_t xdr_entry3 ();
+extern bool_t xdr_dirlist3 ();
+extern bool_t xdr_READDIR3resok ();
+extern bool_t xdr_READDIR3resfail ();
+extern bool_t xdr_READDIR3res ();
+extern bool_t xdr_LINK3args ();
+extern bool_t xdr_LINK3resok ();
+extern bool_t xdr_LINK3resfail ();
+extern bool_t xdr_LINK3res ();
+extern bool_t xdr_sattrguard3 ();
+extern bool_t xdr_SETATTR3args ();
+extern bool_t xdr_SETATTR3resok ();
+extern bool_t xdr_SETATTR3resfail ();
+extern bool_t xdr_SETATTR3res ();
+extern bool_t xdr_nfsacl_type ();
+extern bool_t xdr_nfsacl_ace ();
+extern bool_t xdr_GETACL3args ();
+extern bool_t xdr_GETACL3resok ();
+extern bool_t xdr_GETACL3res ();
+extern bool_t xdr_SETACL3args ();
+extern bool_t xdr_SETACL3resok ();
+extern bool_t xdr_SETACL3res ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_NFS_H_RPCGEN */
+
-- 
1.8.0

