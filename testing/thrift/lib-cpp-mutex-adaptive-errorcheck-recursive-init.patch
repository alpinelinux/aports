diff --git a/lib/cpp/src/thrift/concurrency/Mutex.cpp b/lib/cpp/src/thrift/concurrency/Mutex.cpp
index a526461..085daca 100644
--- a/lib/cpp/src/thrift/concurrency/Mutex.cpp
+++ b/lib/cpp/src/thrift/concurrency/Mutex.cpp
@@ -236,7 +236,6 @@ void Mutex::DEFAULT_INITIALIZER(void* arg) {
   THROW_SRE_ONFAIL(pthread_mutex_init(pthread_mutex, NULL));
 }
 
-#if defined(PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP) || defined(PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) || defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
 static void init_with_kind(pthread_mutex_t* mutex, int kind) {
   pthread_mutexattr_t mutexattr;
   THROW_SRE_ONFAIL(pthread_mutexattr_init(&mutexattr));
@@ -244,33 +243,18 @@ static void init_with_kind(pthread_mutex_t* mutex, int kind) {
   THROW_SRE_ONFAIL(pthread_mutex_init(mutex, &mutexattr));
   THROW_SRE_ONFAIL(pthread_mutexattr_destroy(&mutexattr));
 }
-#endif
 
-#ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 void Mutex::ADAPTIVE_INITIALIZER(void* arg) {
-  // From mysql source: mysys/my_thr_init.c
-  // Set mutex type to "fast" a.k.a "adaptive"
-  //
-  // In this case the thread may steal the mutex from some other thread
-  // that is waiting for the same mutex. This will save us some
-  // context switches but may cause a thread to 'starve forever' while
-  // waiting for the mutex (not likely if the code within the mutex is
-  // short).
-  init_with_kind((pthread_mutex_t*)arg, PTHREAD_MUTEX_ADAPTIVE_NP);
+  init_with_kind((pthread_mutex_t*)arg, PTHREAD_MUTEX_DEFAULT );
 }
-#endif
 
-#ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 void Mutex::ERRORCHECK_INITIALIZER(void* arg) {
   init_with_kind((pthread_mutex_t*)arg, PTHREAD_MUTEX_ERRORCHECK);
 }
-#endif
 
-#ifdef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 void Mutex::RECURSIVE_INITIALIZER(void* arg) {
-  init_with_kind((pthread_mutex_t*)arg, PTHREAD_MUTEX_RECURSIVE_NP);
+  init_with_kind((pthread_mutex_t*)arg, PTHREAD_MUTEX_RECURSIVE);
 }
-#endif
 
 /**
  * Implementation of ReadWriteMutex class using POSIX rw lock
