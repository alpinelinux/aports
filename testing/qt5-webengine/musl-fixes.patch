--- a/src/3rdparty/chromium/base/native_library_posix.cc
+++ b/src/3rdparty/chromium/base/native_library_posix.cc
@@ -12,6 +12,10 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/thread_restrictions.h"
 
+#ifndef RTLD_DEEPBIND
+#define RTLD_DEEPBIND 0
+#endif
+
 namespace base {
 
 std::string NativeLibraryLoadError::ToString() const {
--- a/src/3rdparty/chromium/device/serial/serial_io_handler_posix.cc
+++ b/src/3rdparty/chromium/device/serial/serial_io_handler_posix.cc
@@ -6,6 +6,7 @@
 
 #include <sys/ioctl.h>
 #include <termios.h>
+#include <asm-generic/ioctls.h>
 
 #include "base/files/file_util.h"
 #include "base/posix/eintr_wrapper.h"
--- a/src/3rdparty/chromium/net/dns/dns_config_service_posix.cc
+++ b/src/3rdparty/chromium/net/dns/dns_config_service_posix.cc
@@ -120,7 +120,7 @@
 ConfigParsePosixResult ReadDnsConfig(DnsConfig* config) {
   ConfigParsePosixResult result;
   config->unhandled_options = false;
-#if defined(OS_OPENBSD)
+#if defined(OS_OPENBSD) || defined(_GNU_SOURCE)
   // Note: res_ninit in glibc always returns 0 and sets RES_INIT.
   // res_init behaves the same way.
   memset(&_res, 0, sizeof(_res));
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
@@ -168,7 +168,7 @@
   // most versions of glibc don't include this information in siginfo_t. So,
   // we need to explicitly copy it into a arch_sigsys structure.
   struct arch_sigsys sigsys;
-  memcpy(&sigsys, &info->_sifields, sizeof(sigsys));
+  memcpy(&sigsys, &info->__si_fields, sizeof(sigsys));
 
 #if defined(__mips__)
   // When indirect syscall (syscall(__NR_foo, ...)) is made on Mips, the
--- a/src/3rdparty/chromium/sandbox/linux/suid/process_util.h
+++ b/src/3rdparty/chromium/sandbox/linux/suid/process_util.h
@@ -12,6 +12,14 @@
 #include <stdint.h>
 #include <sys/types.h>
 
+// Some additional functions
+# define TEMP_FAILURE_RETRY(expression) \
+	(__extension__			\
+	 ({ long int __result;		\
+	  do __result = (long int) (expression); \
+	  while (__result == -1L && errno == EINTR); \
+	  __result; }))
+
 // This adjusts /proc/process/oom_score_adj so the Linux OOM killer
 // will prefer certain process types over others. The range for the
 // adjustment is [-1000, 1000], with [0, 1000] being user accessible.
--- a/src/3rdparty/chromium/third_party/ffmpeg/libavutil/cpu.c
+++ b/src/3rdparty/chromium/third_party/ffmpeg/libavutil/cpu.c
@@ -39,7 +39,6 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
-#include <sys/sysctl.h>
 #endif
 #if HAVE_UNISTD_H
 #include <unistd.h>
--- a/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
+++ b/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
@@ -1211,6 +1211,12 @@
 #ifndef __NR_fallocate
 #define __NR_fallocate          285
 #endif
+
+#undef __NR_pread
+#define __NR_pread __NR_pread64
+#undef __NR_pwrite
+#define __NR_pwrite __NR_pwrite64
+
 /* End of x86-64 definitions                                                 */
 #elif defined(__mips__)
 #if _MIPS_SIM == _MIPS_SIM_ABI32
--- a/src/3rdparty/chromium/third_party/ots/include/opentype-sanitiser.h
+++ b/src/3rdparty/chromium/third_party/ots/include/opentype-sanitiser.h
@@ -20,6 +20,7 @@
 #define htonl(x) _byteswap_ulong (x)
 #define htons(x) _byteswap_ushort (x)
 #else
+#include <sys/types.h>
 #include <arpa/inet.h>
 #include <stdint.h>
 #endif
