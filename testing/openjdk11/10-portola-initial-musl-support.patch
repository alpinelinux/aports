Author: Mikael Vidstedt <mikael.vidstedt@oracle.com>
URL: https://hg.openjdk.java.net/portola/jdk11/rev/055b2c860236
Summary: Initial musl support (ported from old repository layout)
----

diff -upr a/make/ReleaseFile.gmk b/make/ReleaseFile.gmk
--- a/make/ReleaseFile.gmk
+++ b/make/ReleaseFile.gmk
@@ -53,6 +53,7 @@ define create-info-file
   $(call info-file-item, "JAVA_VERSION_DATE", "$(VERSION_DATE)")
   $(call info-file-item, "OS_NAME", "$(RELEASE_FILE_OS_NAME)")
   $(call info-file-item, "OS_ARCH", "$(RELEASE_FILE_OS_ARCH)")
+  $(call info-file-item, "LIBC", "$(OPENJDK_TARGET_LIBC)")
 endef

 # Param 1 - The file containing the MODULES list
diff -upr a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -30,6 +30,17 @@
 DIR=`dirname $0`
 OUT=`. $DIR/autoconf-config.guess`

+# config.guess doesn't identify systems running the musl C library, and will
+# instead return a string with a -gnu suffix. This block detects musl and
+# modifies the string to have a -musl suffix instead.
+echo $OUT | grep -- -linux- > /dev/null 2> /dev/null
+if test $? = 0; then
+  ldd_version=`ldd --version 2>&1 | head -1 | cut -f1 -d' '`
+  if [ x"${ldd_version}" = x"musl" ]; then
+    OUT=`echo $OUT | sed 's/-gnu/-musl/'`
+  fi
+fi
+
 # Test and fix solaris on x86_64
 echo $OUT | grep i386-pc-solaris > /dev/null 2> /dev/null
 if test $? = 0; then
diff -upr a/make/autoconf/build-aux/config.sub b/make/autoconf/build-aux/config.sub
--- a/make/autoconf/build-aux/config.sub
+++ b/make/autoconf/build-aux/config.sub
@@ -29,6 +29,11 @@

 DIR=`dirname $0`

+if [ "$1"x = "x86_64-unknown-linux-musl"x ]; then
+    echo $1
+    exit
+fi
+
 # First, filter out everything that doesn't begin with "aarch64-"
 if ! echo $* | grep '^aarch64-' >/dev/null ; then
     . $DIR/autoconf-config.sub "$@"
diff -upr a/make/autoconf/buildjdk-spec.gmk.in b/make/autoconf/buildjdk-spec.gmk.in
--- a/make/autoconf/buildjdk-spec.gmk.in
+++ b/make/autoconf/buildjdk-spec.gmk.in
@@ -50,11 +50,13 @@ IMAGES_OUTPUTDIR := $(patsubst $(OUTPUTD

 OPENJDK_BUILD_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
 OPENJDK_BUILD_CPU_LEGACY_LIB := @OPENJDK_BUILD_CPU_LEGACY_LIB@
+OPENJDK_BUILD_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_CPU := @OPENJDK_BUILD_CPU@
 OPENJDK_TARGET_CPU_ARCH := @OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS := @OPENJDK_BUILD_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN := @OPENJDK_BUILD_CPU_ENDIAN@
 OPENJDK_TARGET_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
+OPENJDK_TARGET_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_OS_INCLUDE_SUBDIR := @OPENJDK_BUILD_OS_INCLUDE_SUBDIR@

 HOTSPOT_TARGET_OS := @HOTSPOT_BUILD_OS@
@@ -62,6 +64,7 @@ HOTSPOT_TARGET_OS_TYPE := @HOTSPOT_BUILD
 HOTSPOT_TARGET_CPU := @HOTSPOT_BUILD_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_BUILD_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_BUILD_CPU_DEFINE@
+HOTSPOT_TARGET_LIBC := @HOTSPOT_BUILD_LIBC@

 CFLAGS_JDKLIB := @OPENJDK_BUILD_CFLAGS_JDKLIB@
 CXXFLAGS_JDKLIB := @OPENJDK_BUILD_CXXFLAGS_JDKLIB@
diff -upr a/make/autoconf/configure.ac b/make/autoconf/configure.ac
--- a/make/autoconf/configure.ac
+++ b/make/autoconf/configure.ac
@@ -203,6 +203,7 @@ JDKOPT_SETUP_ADDRESS_SANITIZER

 # Need toolchain to setup dtrace
 HOTSPOT_SETUP_DTRACE
+HOTSPOT_SETUP_SA
 HOTSPOT_ENABLE_DISABLE_AOT
 HOTSPOT_ENABLE_DISABLE_CDS
 HOTSPOT_ENABLE_DISABLE_GTEST
diff -upr a/make/autoconf/hotspot.m4 b/make/autoconf/hotspot.m4
--- a/make/autoconf/hotspot.m4
+++ b/make/autoconf/hotspot.m4
@@ -264,6 +264,50 @@ AC_DEFUN_ONCE([HOTSPOT_ENABLE_DISABLE_CD
 ])

 ###############################################################################
+# Check if the serviceability agent attach functionality should be included.
+#
+AC_DEFUN_ONCE([HOTSPOT_SETUP_SA],
+[
+  # Test for serviceability agent attach dependencies
+  AC_ARG_ENABLE([sa-attach], [AS_HELP_STRING([--enable-sa-attach@<:@=yes/no/auto@:>@],
+      [enable serviceability agent attach. Default is auto, where it is enabled if all dependencies
+      are present.])])
+
+  SA_ATTACH_DEP_MISSING=false
+
+  AC_CHECK_HEADERS([thread_db.h], [SA_ATTACH_HEADERS_OK=yes],[SA_ATTACH_HEADERS_OK=no])
+  if test "x$SA_ATTACH_HEADERS_OK" != "xyes"; then
+    SA_ATTACH_DEP_MISSING=true
+  fi
+
+  AC_MSG_CHECKING([if serviceability agent attach should be included])
+  if test "x$enable_sa_attach" = "xyes"; then
+    if test "x$SA_ATTACH_DEP_MISSING" = "xtrue"; then
+      AC_MSG_RESULT([no, missing dependencies])
+      HELP_MSG_MISSING_DEPENDENCY([sa-attach])
+      AC_MSG_ERROR([Cannot enable sa-attach with missing dependencies. See above. $HELP_MSG])
+    else
+      INCLUDE_SA_ATTACH=true
+      AC_MSG_RESULT([yes, forced])
+    fi
+  elif test "x$enable_sa_attach" = "xno"; then
+    INCLUDE_SA_ATTACH=false
+    AC_MSG_RESULT([no, forced])
+  elif test "x$enable_sa_attach" = "xauto" || test "x$enable_sa_attach" = "x"; then
+    if test "x$SA_ATTACH_DEP_MISSING" = "xtrue"; then
+      INCLUDE_SA_ATTACH=false
+      AC_MSG_RESULT([no, missing dependencies])
+    else
+      INCLUDE_SA_ATTACH=true
+      AC_MSG_RESULT([yes, dependencies present])
+    fi
+  else
+    AC_MSG_ERROR([Invalid value for --enable-sa-attach: $enable_sa_attach])
+  fi
+  AC_SUBST(INCLUDE_SA_ATTACH)
+])
+
+###############################################################################
 # Set up all JVM features for each JVM variant.
 #
 AC_DEFUN_ONCE([HOTSPOT_SETUP_JVM_FEATURES],
diff -upr a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -194,6 +194,18 @@ AC_DEFUN([PLATFORM_EXTRACT_VARS_FROM_OS]
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+
+  case "$1" in
+    *linux*-musl)
+      VAR_LIBC=musl
+      ;;
+    *linux*-gnu)
+      VAR_LIBC=gnu
+      ;;
+    *)
+      VAR_LIBC=default
+      ;;
+  esac
 ])

 # Expects $host_os $host_cpu $build_os and $build_cpu
@@ -232,6 +244,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BU
   OPENJDK_BUILD_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_BUILD_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_BUILD_CPU_ENDIAN="$VAR_CPU_ENDIAN"
+  OPENJDK_BUILD_LIBC="$VAR_LIBC"
   AC_SUBST(OPENJDK_BUILD_OS)
   AC_SUBST(OPENJDK_BUILD_OS_TYPE)
   AC_SUBST(OPENJDK_BUILD_OS_ENV)
@@ -239,10 +252,16 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BU
   AC_SUBST(OPENJDK_BUILD_CPU_ARCH)
   AC_SUBST(OPENJDK_BUILD_CPU_BITS)
   AC_SUBST(OPENJDK_BUILD_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_BUILD_LIBC)

   AC_MSG_CHECKING([openjdk-build os-cpu])
   AC_MSG_RESULT([$OPENJDK_BUILD_OS-$OPENJDK_BUILD_CPU])

+  if test "x$OPENJDK_BUILD_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-build C library])
+    AC_MSG_RESULT([$OPENJDK_BUILD_LIBC])
+  fi
+
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
@@ -263,6 +282,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BU
   OPENJDK_TARGET_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_TARGET_CPU_ENDIAN="$VAR_CPU_ENDIAN"
   OPENJDK_TARGET_OS_UPPERCASE=`$ECHO $OPENJDK_TARGET_OS | $TR 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  OPENJDK_TARGET_LIBC="$VAR_LIBC"

   AC_SUBST(OPENJDK_TARGET_OS)
   AC_SUBST(OPENJDK_TARGET_OS_TYPE)
@@ -272,9 +292,15 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BU
   AC_SUBST(OPENJDK_TARGET_CPU_ARCH)
   AC_SUBST(OPENJDK_TARGET_CPU_BITS)
   AC_SUBST(OPENJDK_TARGET_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_TARGET_LIBC)

   AC_MSG_CHECKING([openjdk-target os-cpu])
   AC_MSG_RESULT([$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])
+
+  if test "x$OPENJDK_TARGET_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-target C library])
+    AC_MSG_RESULT([$OPENJDK_TARGET_LIBC])
+  fi
 ])

 # Check if a reduced build (32-bit on 64-bit platforms) is requested, and modify behaviour
@@ -409,7 +435,13 @@ AC_DEFUN([PLATFORM_SETUP_LEGACY_VARS_HEL
   else
     OPENJDK_$1_CPU_BUNDLE="$OPENJDK_$1_CPU"
   fi
-  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}"
+
+  OPENJDK_$1_LIBC_BUNDLE=""
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then
+    OPENJDK_$1_LIBC_BUNDLE="-$OPENJDK_$1_LIBC"
+  fi
+
+  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}${OPENJDK_$1_LIBC_BUNDLE}"
   AC_SUBST(OPENJDK_$1_BUNDLE_PLATFORM)

   if test "x$COMPILE_TYPE" = "xcross"; then
@@ -478,6 +510,13 @@ AC_DEFUN([PLATFORM_SETUP_LEGACY_VARS_HEL
   fi
   AC_SUBST(HOTSPOT_$1_CPU_DEFINE)

+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then
+    HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC
+  else
+    HOTSPOT_$1_LIBC=""
+  fi
+  AC_SUBST(HOTSPOT_$1_LIBC)
+
   # For historical reasons, the OS include directories have odd names.
   OPENJDK_$1_OS_INCLUDE_SUBDIR="$OPENJDK_TARGET_OS"
   if test "x$OPENJDK_TARGET_OS" = "xwindows"; then
diff -upr a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -72,6 +72,8 @@ OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET
 OPENJDK_TARGET_CPU_BITS:=@OPENJDK_TARGET_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN:=@OPENJDK_TARGET_CPU_ENDIAN@

+OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@
+
 COMPILE_TYPE:=@COMPILE_TYPE@

 # Legacy support
@@ -88,6 +90,8 @@ HOTSPOT_TARGET_CPU := @HOTSPOT_TARGET_CP
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_TARGET_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_TARGET_CPU_DEFINE@

+HOTSPOT_TARGET_LIBC := @HOTSPOT_TARGET_LIBC@
+
 OPENJDK_TARGET_BUNDLE_PLATFORM:=@OPENJDK_TARGET_BUNDLE_PLATFORM@
 JDK_ARCH_ABI_PROP_NAME := @JDK_ARCH_ABI_PROP_NAME@

@@ -102,6 +106,8 @@ OPENJDK_BUILD_CPU_ARCH:=@OPENJDK_BUILD_C
 OPENJDK_BUILD_CPU_BITS:=@OPENJDK_BUILD_CPU_BITS@
 OPENJDK_BUILD_CPU_ENDIAN:=@OPENJDK_BUILD_CPU_ENDIAN@

+OPENJDK_BUILD_LIBC:=@OPENJDK_BUILD_LIBC@
+
 OPENJDK_BUILD_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@

 # Target platform value in ModuleTarget class file attribute.
@@ -815,6 +821,7 @@ PNG_CFLAGS:=@PNG_CFLAGS@
 #

 INCLUDE_SA=@INCLUDE_SA@
+INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@
 INCLUDE_GRAAL=@INCLUDE_GRAAL@
 INCLUDE_JVMCI=@INCLUDE_JVMCI@

diff -upr a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -58,8 +58,10 @@
  * input.build_id
  * input.target_os
  * input.target_cpu
+ * input.target_libc
  * input.build_os
  * input.build_cpu
+ * input.build_libc
  * input.target_platform
  * input.build_platform
  * // The build_osenv_* variables describe the unix layer on Windows systems,
@@ -99,13 +101,17 @@
  *       target_os; <string>
  *       // Name of cpu the profile is built to run on
  *       target_cpu; <string>
- *       // Combination of target_os and target_cpu for convenience
+ *       // Optional libc string if non standard
+ *       target_libc; <string>
+ *       // Optional combination of target_os and target_cpu for convenience
  *       target_platform; <string>
  *       // Name of os the profile is built on
  *       build_os; <string>
  *       // Name of cpu the profile is built on
  *       build_cpu; <string>
- *       // Combination of build_os and build_cpu for convenience
+ *       // Optional libc string if non standard
+ *       build_libc; <string>
+ *       // Optional combination of build_os and build_cpu for convenience
  *       build_platform; <string>
  *
  *       // List of dependencies needed to build this profile
@@ -231,7 +237,7 @@ var getJibProfilesCommon = function (inp

     // List of the main profile names used for iteration
     common.main_profile_names = [
-        "linux-x64", "linux-x86", "macosx-x64", "solaris-x64",
+        "linux-x64", "linux-x64-musl", "linux-x86", "macosx-x64", "solaris-x64",
         "solaris-sparcv9", "windows-x64", "windows-x86",
         "linux-aarch64", "linux-arm32", "linux-arm64", "linux-arm-vfp-hflt",
         "linux-arm-vfp-hflt-dyn"
@@ -385,6 +391,14 @@ var getJibProfilesProfiles = function (i
             default_make_targets: ["docs-bundles"],
         },

+        "linux-x64-musl": {
+            target_os: "linux",
+            target_cpu: "x64",
+            target_libc: "musl",
+            configure_args: concat(common.configure_args_64bit,
+                "--with-zlib=system"),
+        },
+
         "linux-x86": {
             target_os: "linux",
             target_cpu: "x86",
@@ -592,6 +606,10 @@ var getJibProfilesProfiles = function (i
         "linux-x64": {
             platform: "linux-x64",
         },
+        "linux-x64-musl": {
+            platform: "linux-x64-musl",
+            demo_ext: "tar.gz"
+        },
         "linux-x86": {
             platform: "linux-x86",
         },
@@ -859,7 +877,8 @@ var getJibProfilesDependencies = functio
         : input.target_platform);

     var boot_jdk_platform = (input.build_os == "macosx" ? "osx" : input.build_os)
-        + "-" + input.build_cpu;
+        + "-" + input.build_cpu +
+        (input.build_libc ? "-" + input.build_libc : "");

     var makeBinDir = (input.build_os == "windows"
         ? input.get("gnumake", "install_path") + "/cygwin/bin"
@@ -869,7 +888,7 @@ var getJibProfilesDependencies = functio

         boot_jdk: {
             server: "jpg",
-            product: "jdk",
+            product: input.build_libc == "musl" ? "jdk-portola" : "jdk",
             version: common.boot_jdk_version,
             build_number: "46",
             file: "bundles/" + boot_jdk_platform + "/jdk-" + common.boot_jdk_version + "_"
diff -upr a/make/hotspot/lib/CompileJvm.gmk b/make/hotspot/lib/CompileJvm.gmk
--- a/make/hotspot/lib/CompileJvm.gmk
+++ b/make/hotspot/lib/CompileJvm.gmk
@@ -70,6 +70,10 @@ else
   OPENJDK_TARGET_CPU_VM_VERSION := $(OPENJDK_TARGET_CPU)
 endif

+ifneq ($(HOTSPOT_TARGET_LIBC),)
+  LIBC_DEFINE := -DHOTSPOT_LIBC='"$(HOTSPOT_TARGET_LIBC)"'
+endif
+
 CFLAGS_VM_VERSION := \
     $(VERSION_CFLAGS) \
     -DHOTSPOT_VERSION_STRING='"$(VERSION_STRING)"' \
@@ -77,6 +81,7 @@ CFLAGS_VM_VERSION := \
     -DHOTSPOT_BUILD_USER='"$(USERNAME)"' \
     -DHOTSPOT_VM_DISTRO='"$(HOTSPOT_VM_DISTRO)"' \
     -DCPU='"$(OPENJDK_TARGET_CPU_VM_VERSION)"' \
+    $(LIBC_DEFINE) \
     #

 ################################################################################
diff -upr a/make/lib/CoreLibraries.gmk b/make/lib/CoreLibraries.gmk
--- a/make/lib/CoreLibraries.gmk	2019-02-02 23:06:17.772111411 +0100
+++ b/make/lib/CoreLibraries.gmk	2019-02-02 23:52:23.495330899 +0100
@@ -249,6 +249,8 @@ else
   LIBJLI_OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE)/jli
 endif

+LIBJLI_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
+
 LIBJLI_CFLAGS += $(LIBZ_CFLAGS)

 ifneq ($(USE_EXTERNAL_LIBZ), true)
diff -upr a/make/lib/Lib-jdk.hotspot.agent.gmk b/make/lib/Lib-jdk.hotspot.agent.gmk
--- a/make/lib/Lib-jdk.hotspot.agent.gmk	2019-02-02 23:06:17.788777876 +0100
+++ b/make/lib/Lib-jdk.hotspot.agent.gmk	2019-02-02 23:52:23.495330899 +0100
@@ -48,6 +48,15 @@ else ifeq ($(OPENJDK_TARGET_OS), windows
   endif
 endif

+ifeq ($(INCLUDE_SA_ATTACH), true)
+  SA_CFLAGS += -DINCLUDE_SA_ATTACH
+  ifeq ($(OPENJDK_TARGET_OS), linux)
+    SA_LIBS_linux := -lthread_db $(LIBDL)
+  endif
+endif
+
+SA_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
+
 ################################################################################

 $(eval $(call SetupJdkLibrary, BUILD_LIBSA, \
@@ -60,7 +69,7 @@ $(eval $(call SetupJdkLibrary, BUILD_LIB
     CXXFLAGS := $(CXXFLAGS_JDKLIB) $(SA_CFLAGS) $(SA_CXXFLAGS), \
     EXTRA_SRC := $(LIBSA_EXTRA_SRC), \
     LDFLAGS := $(LDFLAGS_JDKLIB) $(SA_LDFLAGS), \
-    LIBS_linux := -lthread_db $(LIBDL), \
+    LIBS_linux := $(SA_LIBS_linux), \
     LIBS_solaris := -ldl -ldemangle -lthread -lproc, \
     LIBS_macosx := -framework Foundation -framework JavaNativeFoundation \
         -framework JavaRuntimeSupport -framework Security -framework CoreFoundation, \
diff -upr a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp	2019-02-02 23:06:17.808777635 +0100
+++ b/src/hotspot/os/linux/os_linux.cpp	2019-02-02 23:52:23.738661291 +0100
@@ -99,7 +99,6 @@
 # include <string.h>
 # include <syscall.h>
 # include <sys/sysinfo.h>
-# include <gnu/libc-version.h>
 # include <sys/ipc.h>
 # include <sys/shm.h>
 # include <link.h>
@@ -145,8 +144,8 @@ pthread_t os::Linux::_main_thread;
 int os::Linux::_page_size = -1;
 bool os::Linux::_supports_fast_thread_cpu_time = false;
 uint32_t os::Linux::_os_version = 0;
-const char * os::Linux::_glibc_version = NULL;
-const char * os::Linux::_libpthread_version = NULL;
+const char * os::Linux::_glibc_version = "unknown";
+const char * os::Linux::_libpthread_version = "unknown";

 static jlong initial_time_count=0;

@@ -517,17 +516,21 @@ void os::Linux::libpthread_init() {
   #error "glibc too old (< 2.3.2)"
 #endif

-  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve glibc version");
-  char *str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBC_VERSION, str, n);
-  os::Linux::set_glibc_version(str);
+  size_t n;
+
+  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBC_VERSION, str, n);
+    os::Linux::set_glibc_version(str);
+  }

   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve pthread version");
-  str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
-  os::Linux::set_libpthread_version(str);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
+    os::Linux::set_libpthread_version(str);
+  }
 }

 /////////////////////////////////////////////////////////////////////////////
@@ -2905,20 +2908,36 @@ void os::Linux::sched_getcpu_init() {
 extern "C" JNIEXPORT void numa_warn(int number, char *where, ...) { }
 extern "C" JNIEXPORT void numa_error(char *where) { }

+static void* dlvsym_if_available(void* handle, const char* name, const char* version) {
+  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);
+  static dlvsym_func_type dlvsym_func;
+  static bool initialized = false;
+
+  if (!initialized) {
+    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, "dlvsym");
+    initialized = true;
+  }
+
+  if (dlvsym_func != NULL) {
+    void *f = dlvsym_func(handle, name, version);
+    if (f != NULL) {
+      return f;
+    }
+  }
+
+  return dlsym(handle, name);
+}
+
 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
 // load symbol from base version instead.
 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
-  void *f = dlvsym(handle, name, "libnuma_1.1");
-  if (f == NULL) {
-    f = dlsym(handle, name);
-  }
-  return f;
+  return dlvsym_if_available(handle, name, "libnuma_1.1");
 }

 // Handle request to load libnuma symbol version 1.2 (API v2) only.
 // Return NULL if the symbol is not defined in this particular version.
 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
-  return dlvsym(handle, name, "libnuma_1.2");
+  return dlvsym_if_available(handle, name, "libnuma_1.2");
 }

 bool os::Linux::libnuma_init() {
@@ -4973,6 +4992,63 @@ void os::Linux::check_signal_handler(int
 extern void report_error(char* file_name, int line_no, char* title,
                          char* format, ...);

+// Some linux distributions (notably: Alpine Linux) include the
+// grsecurity in the kernel by default. Of particular interest from a
+// JVM perspective is PaX (https://pax.grsecurity.net/), which adds
+// some security features related to page attributes. Specifically,
+// the MPROTECT PaX functionality
+// (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
+// code generation by disallowing a (previously) writable page to be
+// marked as executable. This is, of course, exactly what HotSpot does
+// for both JIT compiled method, as well as for stubs, adapters, etc.
+//
+// Instead of crashing "lazily" when trying to make a page executable,
+// this code probes for the presence of PaX and reports the failure
+// eagerly.
+static void check_pax(void) {
+  // Zero doesn't generate code dynamically, so no need to perform the PaX check
+#ifndef ZERO
+  size_t size = os::Linux::page_size();
+
+  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+  if (p == MAP_FAILED) {
+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "failed to allocate memory for PaX check.");
+  }
+
+  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
+  if (res == -1) {
+    vm_exit_during_initialization("Failed to mark memory page as executable",
+                                  "Please check if grsecurity/PaX is enabled in your kernel.\n"
+                                  "\n"
+                                  "For example, you can do this by running (note: you may need root privileges):\n"
+                                  "\n"
+                                  "    sysctl kernel.pax.softmode\n"
+                                  "\n"
+                                  "If PaX is included in the kernel you will see something like this:\n"
+                                  "\n"
+                                  "    kernel.pax.softmode = 0\n"
+                                  "\n"
+                                  "In particular, if the value is 0 (zero), then PaX is enabled.\n"
+                                  "\n"
+                                  "PaX includes security functionality which interferes with the dynamic code\n"
+                                  "generation the JVM relies on. Specifically, the MPROTECT functionality as\n"
+                                  "described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n"
+                                  "with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n"
+                                  "You can do this on a per-executable basis using the paxctl tool, for example:\n"
+                                  "\n"
+                                  "    paxctl -cm bin/java\n"
+                                  "\n"
+                                  "Please note that this modifies the executable binary in-place, so you may want\n"
+                                  "to make a backup of it first. Also note that you have to repeat this for other\n"
+                                  "executables like javac, jar, jcmd, etc.\n"
+                                  );
+
+  }
+
+  ::munmap(p, size);
+#endif
+}
+
 // this is called _before_ most of the global arguments have been parsed
 void os::init(void) {
   char dummy;   // used to get a guess on initial stack address
@@ -5002,6 +5078,8 @@ void os::init(void) {
   Linux::_pthread_setname_np =
     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, "pthread_setname_np");

+  check_pax();
+
   os::Posix::init();
 }

diff -upr a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
--- a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
@@ -204,7 +204,7 @@ inline int g_isnan(double f) { return is
 #elif defined(__APPLE__)
 inline int g_isnan(double f) { return isnan(f); }
 #elif defined(LINUX) || defined(_ALLBSD_SOURCE)
-inline int g_isnan(float  f) { return isnanf(f); }
+inline int g_isnan(float  f) { return isnan(f); }
 inline int g_isnan(double f) { return isnan(f); }
 #else
 #error "missing platform-specific definition here"
diff -upr a/src/java.base/linux/native/libnet/linux_close.c b/src/java.base/linux/native/libnet/linux_close.c
--- a/src/java.base/linux/native/libnet/linux_close.c
+++ b/src/java.base/linux/native/libnet/linux_close.c
@@ -60,7 +60,7 @@ typedef struct {
 /*
  * Signal to unblock thread
  */
-static int sigWakeup = (__SIGRTMAX - 2);
+static int sigWakeup;

 /*
  * fdTable holds one entry per file descriptor, up to a certain
@@ -149,6 +149,7 @@ static void __attribute((constructor)) i
     /*
      * Setup the signal handler
      */
+    sigWakeup = SIGRTMAX - 2;
     sa.sa_handler = sig_wakeup;
     sa.sa_flags   = 0;
     sigemptyset(&sa.sa_mask);
diff -upr a/src/java.base/unix/native/libjava/jdk_util_md.h b/src/java.base/unix/native/libjava/jdk_util_md.h
--- a/src/java.base/unix/native/libjava/jdk_util_md.h
+++ b/src/java.base/unix/native/libjava/jdk_util_md.h
@@ -37,7 +37,7 @@
 #define ISNAND(d) isnan(d)
 #elif defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <math.h>
-#define ISNANF(f) isnanf(f)
+#define ISNANF(f) isnan(f)
 #define ISNAND(d) isnan(d)
 #elif defined(_AIX)
 #include <math.h>
diff -upr a/src/java.base/unix/native/libjli/java_md_solinux.c b/src/java.base/unix/native/libjli/java_md_solinux.c
--- a/src/java.base/unix/native/libjli/java_md_solinux.c
+++ b/src/java.base/unix/native/libjli/java_md_solinux.c
@@ -235,6 +235,39 @@ RequiresSetenv(const char *jvmpath) {
     char *dmllp = NULL;
     char *p; /* a utility pointer */

+#ifdef __linux
+#ifndef LIBC
+#error "LIBC not set"
+#endif
+
+    if (strcmp(LIBC, "musl") == 0) {
+      /*
+       * The musl library loader requires LD_LIBRARY_PATH to be set in
+       * order to correctly resolve the dependency libjava.so has on libjvm.so.
+       *
+       * Specifically, it differs from glibc in the sense that even if
+       * libjvm.so has already been loaded it will not be considered a
+       * candidate for resolving the dependency unless the *full* path
+       * of the already loaded library matches the dependency being loaded.
+       *
+       * libjvm.so is being loaded by the launcher using a long path to
+       * dlopen, not just the basename of the library. Typically this
+       * is something like "../lib/server/libjvm.so". However, if/when
+       * libjvm.so later tries to dlopen libjava.so (which it does in
+       * order to get access to a few functions implemented in
+       * libjava.so) the musl loader will, as part of loading
+       * dependent libraries, try to load libjvm.so using only its
+       * basename "libjvm.so". Since this does not match the longer
+       * path path it was first loaded with, the already loaded
+       * library is not considered a candidate, and the loader will
+       * instead look for libjvm.so elsewhere. If it's not in
+       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so
+       * will therefore fail as well.
+       */
+      return JNI_TRUE;
+    }
+#endif
+
 #ifdef AIX
     /* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. */
     return JNI_TRUE;
diff -upr a/src/java.base/unix/native/libnio/ch/NativeThread.c b/src/java.base/unix/native/libnio/ch/NativeThread.c
--- a/src/java.base/unix/native/libnio/ch/NativeThread.c
+++ b/src/java.base/unix/native/libnio/ch/NativeThread.c
@@ -36,7 +36,7 @@
 #ifdef __linux__
   #include <pthread.h>
   /* Also defined in net/linux_close.c */
-  #define INTERRUPT_SIGNAL (__SIGRTMAX - 2)
+  #define INTERRUPT_SIGNAL (SIGRTMAX - 2)
 #elif _AIX
   #include <pthread.h>
   /* Also defined in net/aix_close.c */
diff -upr a/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c b/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c
--- a/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c	2019-02-02 23:04:27.946771881 +0100
+++ b/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c	2019-02-02 23:52:25.098644853 +0100
@@ -27,9 +27,6 @@
 #include <X11/Xutil.h>
 #include <X11/Xos.h>
 #include <X11/Xatom.h>
-#ifdef __linux__
-#include <execinfo.h>
-#endif

 #include <jvm.h>
 #include <jni.h>
@@ -787,26 +784,6 @@ JNIEXPORT jstring JNICALL Java_sun_awt_X
     return ret;
 }

-#ifdef __linux__
-void print_stack(void)
-{
-  void *array[10];
-  size_t size;
-  char **strings;
-  size_t i;
-
-  size = backtrace (array, 10);
-  strings = backtrace_symbols (array, size);
-
-  fprintf (stderr, "Obtained %zd stack frames.\n", size);
-
-  for (i = 0; i < size; i++)
-     fprintf (stderr, "%s\n", strings[i]);
-
-  free (strings);
-}
-#endif
-
 Window get_xawt_root_shell(JNIEnv *env) {
   static jclass classXRootWindow = NULL;
   static jmethodID methodGetXRootWindow = NULL;
diff -upr a/src/jdk.hotspot.agent/linux/native/libsaproc/LinuxDebuggerLocal.c b/src/jdk.hotspot.agent/linux/native/libsaproc/LinuxDebuggerLocal.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/LinuxDebuggerLocal.c	2019-02-02 23:04:29.946747722 +0100
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/LinuxDebuggerLocal.c	2019-02-02 23:52:25.851969082 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,7 @@

 #include <jni.h>
 #include "libproc.h"
+#include "libproc_impl.h"

 #include <elf.h>
 #include <sys/types.h>
diff -upr a/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.c b/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.c
@@ -26,7 +26,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include <fcntl.h>
+#ifdef INCLUDE_SA_ATTACH
 #include <thread_db.h>
+#else
+#include <dirent.h>
+#endif
 #include "libproc_impl.h"

 #define SA_ALTROOT "SA_ALTROOT"
@@ -117,11 +121,13 @@ init_libproc(bool debug) {
    // init debug mode
    _libsaproc_debug = debug;

+#ifdef INCLUDE_SA_ATTACH
    // initialize the thread_db library
    if (td_init() != TD_OK) {
      print_debug("libthread_db's td_init failed\n");
      return false;
    }
+#endif

    return true;
 }
@@ -275,6 +281,7 @@ thread_info* add_thread_info(struct ps_p
 }


+#ifdef INCLUDE_SA_ATTACH
 // struct used for client data from thread_db callback
 struct thread_db_client_data {
    struct ps_prochandle* ph;
@@ -301,9 +308,12 @@ static int thread_db_callback(const td_t

   return TD_OK;
 }
+#endif // INCLUDE_SA_ATTACH

-// read thread_info using libthread_db
+// read thread_info using libthread_db or by iterating through the entries
+// in /proc/<pid>/task/
 bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb) {
+#ifdef INCLUDE_SA_ATTACH
   struct thread_db_client_data mydata;
   td_thragent_t* thread_agent = NULL;
   if (td_ta_new(ph, &thread_agent) != TD_OK) {
@@ -324,10 +334,33 @@ bool read_thread_info(struct ps_prochand

   // delete thread agent
   td_ta_delete(thread_agent);
+#else
+  DIR *dir = NULL;
+  struct dirent *ent = NULL;
+  char taskpath[80];
+  pid_t pid = ph->pid;
+
+  // Find the lwpids to attach to by traversing the /proc/<pid>/task/ directory.
+  snprintf(taskpath, sizeof (taskpath), "/proc/%ld/task", (unsigned long)pid);
+  if ((dir = opendir(taskpath)) != NULL) {
+    while ((ent = readdir(dir)) != NULL) {
+      unsigned long lwp;
+
+      if ((lwp = strtoul(ent->d_name, NULL, 10)) != 0) {
+        // Create and add the thread info.
+        (*cb)(ph, 0, lwp);
+      }
+    }
+  } else {
+    print_debug("Could not open /proc/%ld/task.\n", (unsigned long)pid);
+    return false;
+  }
+
+  closedir(dir);
+#endif
   return true;
 }

-
 // get number of threads
 int get_num_threads(struct ps_prochandle* ph) {
    return ph->num_threads;
diff -upr a/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.h b/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.h
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.h	2019-02-02 23:04:29.290088988 +0100
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/libproc_impl.h	2019-02-02 23:52:25.818636151 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,9 @@

 #include <unistd.h>
 #include <limits.h>
+
+struct ps_prochandle;
+
 #include "libproc.h"
 #include "symtab.h"

@@ -126,4 +129,32 @@ thread_info* add_thread_info(struct ps_p
 // a test for ELF signature without using libelf
 bool is_elf_file(int fd);

+// ps_getpid() is only defined on Linux to return a thread's process ID
+pid_t ps_getpid(struct ps_prochandle *ph);
+
+// ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
+// of the load object object_name in the target process identified by ph.
+// It returns the symbol's value as an address in the target process in
+// *sym_addr.
+
+ps_err_e ps_pglobal_lookup(struct ps_prochandle *ph, const char *object_name,
+                    const char *sym_name, psaddr_t *sym_addr);
+// read "size" bytes of data from debuggee at address "addr"
+ps_err_e ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
+                   void *buf, size_t size);
+
+// write "size" bytes of data to debuggee at address "addr"
+ps_err_e ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
+                    const void *buf, size_t size);
+
+ps_err_e ps_lsetfpregs(struct ps_prochandle *ph, lwpid_t lid, const prfpregset_t *fpregs);
+
+ps_err_e ps_lsetregs(struct ps_prochandle *ph, lwpid_t lid, const prgregset_t gregset);
+
+ps_err_e  ps_lgetfpregs(struct  ps_prochandle  *ph,  lwpid_t lid, prfpregset_t *fpregs);
+
+ps_err_e ps_lgetregs(struct ps_prochandle *ph, lwpid_t lid, prgregset_t gregset);
+
+// new libthread_db of NPTL seem to require this symbol
+ps_err_e ps_get_thread_area();
 #endif //_LIBPROC_IMPL_H_
diff -upr a/src/jdk.hotspot.agent/linux/native/libsaproc/proc_service.h b/src/jdk.hotspot.agent/linux/native/libsaproc/proc_service.h
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/proc_service.h	2019-02-02 23:04:29.400087660 +0100
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/proc_service.h	2019-02-02 23:52:25.851969082 +0100
@@ -26,7 +26,10 @@
 #define _PROC_SERVICE_H_

 #include <stdio.h>
+#include <sys/procfs.h>
+#ifdef INCLUDE_SA_ATTACH
 #include <thread_db.h>
+#endif
 #include "jni.h"

 // Linux does not have the proc service library, though it does provide the
@@ -44,43 +47,4 @@ typedef enum {
         PS_NOFREGS      /* FPU register set not available for given lwp */
 } ps_err_e;

-// ps_getpid() is only defined on Linux to return a thread's process ID
-JNIEXPORT pid_t JNICALL
-ps_getpid(struct ps_prochandle *ph);
-
-// ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
-// of the load object object_name in the target process identified by ph.
-// It returns the symbol's value as an address in the target process in
-// *sym_addr.
-
-JNIEXPORT ps_err_e JNICALL
-ps_pglobal_lookup(struct ps_prochandle *ph, const char *object_name,
-                    const char *sym_name, psaddr_t *sym_addr);
-
-// read "size" bytes of data from debuggee at address "addr"
-JNIEXPORT ps_err_e JNICALL
-ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
-                   void *buf, size_t size);
-
-// write "size" bytes of data to debuggee at address "addr"
-JNIEXPORT ps_err_e JNICALL
-ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
-                    const void *buf, size_t size);
-
-JNIEXPORT ps_err_e JNICALL
-ps_lsetfpregs(struct ps_prochandle *ph, lwpid_t lid, const prfpregset_t *fpregs);
-
-JNIEXPORT ps_err_e JNICALL
-ps_lsetregs(struct ps_prochandle *ph, lwpid_t lid, const prgregset_t gregset);
-
-JNIEXPORT ps_err_e JNICALL
-ps_lgetfpregs(struct ps_prochandle *ph, lwpid_t lid, prfpregset_t *fpregs);
-
-JNIEXPORT ps_err_e JNICALL
-ps_lgetregs(struct ps_prochandle *ph, lwpid_t lid, prgregset_t gregset);
-
-// new libthread_db of NPTL seem to require this symbol
-JNIEXPORT ps_err_e JNICALL
-ps_get_thread_area();
-
 #endif /* _PROC_SERVICE_H_ */
diff -upr a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
@@ -753,6 +753,10 @@ static bool read_lib_segments(struct ps_
   ELF_PHDR* phbuf;
   ELF_PHDR* lib_php = NULL;

+#ifndef LIBC
+#error "LIBC not set"
+#endif
+
   int page_size = sysconf(_SC_PAGE_SIZE);

   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
@@ -776,8 +780,8 @@ static bool read_lib_segments(struct ps_
       } else {
         // Coredump stores value of p_memsz elf field
         // rounded up to page boundary.
-
-        if ((existing_map->memsz != page_size) &&
+        if ((strcmp(LIBC, "musl")) &&
+            (existing_map->memsz != page_size) &&
             (existing_map->fd != lib_fd) &&
             (ROUNDUP(existing_map->memsz, page_size) != ROUNDUP(lib_php->p_memsz, page_size))) {

diff -upr a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
@@ -218,9 +218,11 @@ static bool ptrace_waitpid(pid_t pid) {
 static bool ptrace_attach(pid_t pid, char* err_buf, size_t err_buf_len) {
   if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {
     char buf[200];
-    char* msg = strerror_r(errno, buf, sizeof(buf));
-    snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, msg);
-    print_debug("%s\n", err_buf);
+    if (strerror_r(errno, buf, sizeof(buf) == 0)) {
+      snprintf(err_buf, err_buf_len,
+               "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, buf);
+      print_debug("%s\n", err_buf);
+    }
     return false;
   } else {
     return ptrace_waitpid(pid);
@@ -407,7 +409,7 @@ Pgrab(pid_t pid, char* err_buf, size_t e
   thr = ph->threads;
   while (thr) {
      // don't attach to the main thread again
-    if (ph->pid != thr->lwp_id && ptrace_attach(thr->lwp_id, err_buf, err_buf_len) != true) {
+     if (pid != thr->lwp_id && ptrace_attach(thr->lwp_id, err_buf, err_buf_len) != true) {
         // even if one attach fails, we get return NULL
         Prelease(ph);
         return NULL;
diff -upr a/src/jdk.jdwp.agent/share/native/libjdwp/util.h b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
--- a/src/jdk.jdwp.agent/share/native/libjdwp/util.h
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
@@ -35,15 +35,15 @@
 #ifdef DEBUG
     /* Just to make sure these interfaces are not used here. */
     #undef free
-    #define free(p) Do not use this interface.
+    #define free do_not_use_this_interface_free
     #undef malloc
-    #define malloc(p) Do not use this interface.
+    #define malloc do_not_use_this_interface_malloc
     #undef calloc
-    #define calloc(p) Do not use this interface.
+    #define calloc do_not_use_this_interface_calloc
     #undef realloc
-    #define realloc(p) Do not use this interface.
+    #define realloc do_not_use_this_interface_realloc
     #undef strdup
-    #define strdup(p) Do not use this interface.
+    #define strdup do_not_use_this_interface_strdup
 #endif

 #include "log_messages.h"
